//-------------------------------------------------------------------------
// HBEndpointCGRAXcel_2x2.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CgraNetReqMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] addr;
  logic [31:0] data;
} CgraNetReqMsg;

// PyMTL BitStruct CgraNetRespMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] addr;
  logic [31:0] data;
} CgraNetRespMsg;

// PyMTL BitStruct CgraXcelReqMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] addr;
  logic [31:0] data;
} CgraXcelReqMsg;

// PyMTL BitStruct CgraXcelRespMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] addr;
  logic [31:0] data;
} CgraXcelRespMsg;

// PyMTL BitStruct CgraSramReqMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] addr;
  logic [31:0] data;
  logic [2:0] opaque;
} CgraSramReqMsg;

// PyMTL BitStruct CgraSramRespMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] addr;
  logic [31:0] data;
  logic [2:0] opaque;
} CgraSramRespMsg;

// PyMTL BitStruct R2C2PEConfigMsg Definition
typedef struct packed {
  logic [1:0] opcode;
  logic [4:0] func;
  logic [2:0] src_opd_a;
  logic [2:0] src_opd_b;
  logic [4:0] dst_compute;
  logic [2:0] src_bypass;
  logic [4:0] dst_bypass;
  logic [2:0] src_altbps;
  logic [4:0] dst_altbps;
  logic [13:0] immediate;
  logic [0:0] x_cord;
} R2C2PEConfigMsg;

// PyMTL BitStruct R2C2MEConfigMsg Definition
typedef struct packed {
  logic [0:0] wen;
  logic [11:0] base_addr;
  logic [11:0] incr_addr;
  logic [11:0] count;
  logic [0:0] x_cord;
} R2C2MEConfigMsg;

// PyMTL BitStruct AluMsg_32 Definition
typedef struct packed {
  logic [31:0] opd_a;
  logic [31:0] opd_b;
} AluMsg_32;

// PyMTL BitStruct mmxbar_req_1_CgraSramReqMsg Definition
typedef struct packed {
  logic [0:0] dst;
  CgraSramReqMsg payload;
} mmxbar_req_1_CgraSramReqMsg;

// PyMTL BitStruct mmxbar_resp_4_CgraSramRespMsg Definition
typedef struct packed {
  logic [1:0] dst;
  CgraSramRespMsg payload;
} mmxbar_resp_4_CgraSramRespMsg;

// PyMTL Component CGRAXcelCtrl Definition
// Full name: CGRAXcelCtrl__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py

module CGRAXcelCtrl__b5592e8a4ff43256
(
  output logic [0:0] cgra_xminion_req_en ,
  input  logic [0:0] cgra_xminion_req_rdy ,
  input  logic [0:0] cgra_xminion_resp_en ,
  output logic [0:0] cgra_xminion_resp_rdy ,
  input  logic [0:0] clk ,
  input  logic [0:0] is_CSR_transaction ,
  input  logic [0:0] is_calc_done ,
  input  logic [0:0] is_go_transaction ,
  input  logic [0:0] is_scratchpad_transaction ,
  output logic [0:0] is_staging ,
  input  logic [0:0] is_write_transaction ,
  output logic [0:0] mmaster_req_en ,
  input  logic [0:0] mmaster_req_rdy ,
  input  logic [0:0] mmaster_resp_en ,
  output logic [0:0] mmaster_resp_rdy ,
  input  logic [0:0] reset ,
  output logic [0:0] stage_val ,
  input  logic [0:0] xminion_req_en ,
  output logic [0:0] xminion_req_rdy ,
  output logic [0:0] xminion_resp_en ,
  input  logic [0:0] xminion_resp_rdy 
);
  localparam logic [0:0] __const__FREEZE  = 1'd0;
  localparam logic [0:0] __const__GO  = 1'd1;
  logic [0:0] is_CSR_signal;
  logic [0:0] is_finish_signal;
  logic [0:0] is_go_signal;
  logic [0:0] next_state;
  logic [0:0] sram_read_val;
  logic [0:0] state;

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:93
  // s.cgra_xminion_req_en //= lambda: s.is_CSR_signal & s.cgra_xminion_req_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_ctrl_cgra_xminion_req_en
    cgra_xminion_req_en = is_CSR_signal & cgra_xminion_req_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:90
  // s.is_staging //= lambda: s.state == FREEZE
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_ctrl_is_staging
    is_staging = state == 1'( __const__FREEZE );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:91
  // s.stage_val //= lambda: s.xminion_req_en & s.is_scratchpad_transaction
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_ctrl_stage_val
    stage_val = xminion_req_en & is_scratchpad_transaction;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:94
  // s.xminion_req_rdy //= lambda: (s.is_CSR_transaction & s.cgra_xminion_req_rdy) | (~s.is_CSR_transaction)
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_ctrl_xminion_req_rdy
    xminion_req_rdy = ( is_CSR_transaction & cgra_xminion_req_rdy ) | ( ~is_CSR_transaction );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:98
  // s.xminion_resp_en //= lambda: (s.sram_read_val | s.cgra_xminion_resp_en) & s.xminion_resp_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_ctrl_xminion_resp_en
    xminion_resp_en = ( sram_read_val | cgra_xminion_resp_en ) & xminion_resp_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:67
  // @update
  // def cgra_xcel_next_state():
  //   s.next_state @= s.state
  //   if s.state == FREEZE:
  //     if s.is_go_signal:
  //       s.next_state @= GO
  //   elif s.state == GO:
  //     if s.is_calc_done:
  //       s.next_state @= FREEZE
  
  always_comb begin : cgra_xcel_next_state
    next_state = state;
    if ( state == 1'( __const__FREEZE ) ) begin
      if ( is_go_signal ) begin
        next_state = 1'( __const__GO );
      end
    end
    else if ( state == 1'( __const__GO ) ) begin
      if ( is_calc_done ) begin
        next_state = 1'( __const__FREEZE );
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:85
  // @update
  // def gen_signals():
  //   s.is_go_signal  @= s.xminion_req_en  & s.is_go_transaction
  //   s.is_CSR_signal @= s.xminion_req_en  & s.is_CSR_transaction
  
  always_comb begin : gen_signals
    is_go_signal = xminion_req_en & is_go_transaction;
    is_CSR_signal = xminion_req_en & is_CSR_transaction;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:60
  // @update_ff
  // def cgra_xcel_fsm():
  //   if s.reset:
  //     s.state <<= FREEZE
  //   else:
  //     s.state <<= s.next_state
  
  always_ff @(posedge clk) begin : cgra_xcel_fsm
    if ( reset ) begin
      state <= 1'( __const__FREEZE );
    end
    else
      state <= next_state;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelCtrl.py:81
  // @update_ff
  // def sram_read_val_reg():
  //   s.sram_read_val <<= s.is_staging & s.stage_val & ~s.is_write_transaction
  
  always_ff @(posedge clk) begin : sram_read_val_reg
    sram_read_val <= ( is_staging & stage_val ) & ( ~is_write_transaction );
  end

  assign mmaster_req_en = 1'd0;
  assign mmaster_resp_rdy = 1'd0;
  assign cgra_xminion_resp_rdy = xminion_resp_rdy;

endmodule


// PyMTL Component StaticCGRACtrl Definition
// Full name: StaticCGRACtrl__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py

module StaticCGRACtrl__b5592e8a4ff43256
(
  output logic [0:0] CSR_wen ,
  output logic [0:0] cfg_init ,
  input  logic [0:0] clk ,
  output logic [0:0] is_calc ,
  input  logic [0:0] is_calc_done ,
  output logic [0:0] is_calc_go ,
  input  logic [0:0] is_calc_go_transaction ,
  output logic [0:0] is_cfg ,
  input  logic [0:0] is_cfg_done ,
  output logic [0:0] is_cfg_go ,
  input  logic [0:0] is_cfg_go_transaction ,
  input  logic [0:0] is_wen ,
  input  logic [0:0] reset ,
  input  logic [0:0] xminion_req_en ,
  output logic [0:0] xminion_req_rdy ,
  output logic [0:0] xminion_resp_en ,
  input  logic [0:0] xminion_resp_rdy 
);
  localparam logic [0:0] __const__FREEZE  = 1'd0;
  localparam logic [0:0] __const__CFG_INIT  = 1'd1;
  localparam logic [2:0] __const__CALC  = 3'd4;
  localparam logic [1:0] __const__CFG  = 2'd2;
  localparam logic [1:0] __const__CFG_FIN  = 2'd3;
  logic [2:0] next_state;
  logic [0:0] reg_xminion_read_req_en;
  logic [2:0] state;

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:111
  // s.CSR_wen //= lambda: s.xminion_req_en & s.is_wen
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_ctrl_CSR_wen
    CSR_wen = xminion_req_en & is_wen;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:110
  // s.cfg_init //= lambda: s.state == CFG_INIT
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_ctrl_cfg_init
    cfg_init = state == 3'( __const__CFG_INIT );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:109
  // s.is_calc //= lambda: s.state == CALC
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_ctrl_is_calc
    is_calc = state == 3'( __const__CALC );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:52
  // s.is_calc_go //= lambda: s.is_calc_go_transaction & s.xminion_req_en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_ctrl_is_calc_go
    is_calc_go = is_calc_go_transaction & xminion_req_en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:108
  // s.is_cfg //= lambda: (s.state == CFG) | (s.state == CFG_FIN)
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_ctrl_is_cfg
    is_cfg = ( state == 3'( __const__CFG ) ) | ( state == 3'( __const__CFG_FIN ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:51
  // s.is_cfg_go  //= lambda: s.is_cfg_go_transaction  & s.xminion_req_en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_ctrl_is_cfg_go
    is_cfg_go = is_cfg_go_transaction & xminion_req_en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:68
  // @update
  // def cgra_next_state():
  //   s.next_state @= s.state
  //   if s.state == FREEZE:
  //     if s.is_cfg_go:
  //       s.next_state @= CFG_INIT
  //     elif s.is_calc_go:
  //       s.next_state @= CALC
  //   elif s.state == CFG_INIT:
  //     s.next_state @= CFG
  //   elif s.state == CFG:
  //     if s.is_cfg_done:
  //       s.next_state @= CFG_FIN
  //   elif s.state == CFG_FIN:
  //     s.next_state @= CALC
  //   elif s.state == CALC:
  //     if s.is_calc_done:
  //       s.next_state @= FREEZE
  
  always_comb begin : cgra_next_state
    next_state = state;
    if ( state == 3'( __const__FREEZE ) ) begin
      if ( is_cfg_go ) begin
        next_state = 3'( __const__CFG_INIT );
      end
      else if ( is_calc_go ) begin
        next_state = 3'( __const__CALC );
      end
    end
    else if ( state == 3'( __const__CFG_INIT ) ) begin
      next_state = 3'( __const__CFG );
    end
    else if ( state == 3'( __const__CFG ) ) begin
      if ( is_cfg_done ) begin
        next_state = 3'( __const__CFG_FIN );
      end
    end
    else if ( state == 3'( __const__CFG_FIN ) ) begin
      next_state = 3'( __const__CALC );
    end
    else if ( state == 3'( __const__CALC ) ) begin
      if ( is_calc_done ) begin
        next_state = 3'( __const__FREEZE );
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:61
  // @update_ff
  // def cgra_state():
  //   if s.reset:
  //     s.state <<= FREEZE
  //   else:
  //     s.state <<= s.next_state
  
  always_ff @(posedge clk) begin : cgra_state
    if ( reset ) begin
      state <= 3'( __const__FREEZE );
    end
    else
      state <= next_state;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRACtrl.py:95
  // @update_ff
  // def register_xminion_read_req_en():
  //   # Only respond to read requests. The response will happen in the
  //   # next cycle following the request.
  //   s.reg_xminion_read_req_en <<= s.xminion_req_en & ~s.is_wen
  
  always_ff @(posedge clk) begin : register_xminion_read_req_en
    reg_xminion_read_req_en <= xminion_req_en & ( ~is_wen );
  end

  assign xminion_req_rdy = 1'd1;
  assign xminion_resp_en = reg_xminion_read_req_en;

endmodule


// PyMTL Component ConfigEngineCtrl Definition
// Full name: ConfigEngineCtrl__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py

module ConfigEngineCtrl__b5592e8a4ff43256
(
  input  logic [0:0] cfg_init ,
  output logic [0:0] cfg_reset ,
  output logic [0:0] cfg_send_en ,
  input  logic [0:0] cfg_send_rdy ,
  input  logic [0:0] clk ,
  output logic [0:0] is_addr_decr ,
  output logic [0:0] is_addr_incr ,
  output logic [0:0] is_done ,
  output logic [0:0] mem_deq_en ,
  input  logic [0:0] mem_deq_rdy ,
  output logic [0:0] mmaster_req_en ,
  input  logic [0:0] mmaster_req_rdy ,
  output logic [1:0] reg_mem_rdata_en ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__count_cfg_init_at_next_remaining_cfgs  = 1'd1;
  localparam logic [0:0] __const__FREEZE  = 1'd0;
  localparam logic [1:0] __const__SEND  = 2'd3;
  localparam logic [0:0] __const__FETCH  = 1'd1;
  localparam logic [0:0] __const__count_words_init_at_next_remaining_words  = 1'd1;
  localparam logic [1:0] __const__WAIT  = 2'd2;
  localparam logic [11:0] __const__start_at_enable_reg_mem_rdata  = 12'd1;
  logic [11:0] count_cfgs;
  logic [11:0] count_words;
  logic [11:0] next_count_cfgs;
  logic [11:0] next_count_words;
  logic [1:0] next_state;
  logic [0:0] reg_is_done;
  logic [1:0] state;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:96
  // @update
  // def CE_next_state():
  //   s.next_state @= s.state
  //   if s.state == FREEZE:
  //     if s.cfg_init:
  //       s.next_state @= FETCH
  //   elif s.state == FETCH:
  //     if s.mmaster_req_en:
  //       s.next_state @= WAIT
  //   elif s.state == WAIT:
  //     if s.mem_deq_en:
  //       if s.count_words == 0:
  //         s.next_state @= SEND
  //       else:
  //         s.next_state @= FETCH
  //   elif s.state == SEND:
  //     if s.cfg_send_en:
  //       if s.count_cfgs == 0:
  //         s.next_state @= FREEZE
  //       else:
  //         s.next_state @= FETCH
  
  always_comb begin : CE_next_state
    next_state = state;
    if ( state == 2'( __const__FREEZE ) ) begin
      if ( cfg_init ) begin
        next_state = 2'( __const__FETCH );
      end
    end
    else if ( state == 2'( __const__FETCH ) ) begin
      if ( mmaster_req_en ) begin
        next_state = 2'( __const__WAIT );
      end
    end
    else if ( state == 2'( __const__WAIT ) ) begin
      if ( mem_deq_en ) begin
        if ( count_words == 12'd0 ) begin
          next_state = 2'( __const__SEND );
        end
        else
          next_state = 2'( __const__FETCH );
      end
    end
    else if ( state == 2'( __const__SEND ) ) begin
      if ( cfg_send_en ) begin
        if ( count_cfgs == 12'd0 ) begin
          next_state = 2'( __const__FREEZE );
        end
        else
          next_state = 2'( __const__FETCH );
      end
    end
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:126
  // s.cfg_send_en //= lambda: ( s.state == SEND ) & s.cfg_send_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__ctrl_cfg_send_en
    cfg_send_en = ( state == 2'( __const__SEND ) ) & cfg_send_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:146
  // s.is_addr_decr //= lambda: ( s.state == WAIT ) & ( s.next_state == SEND )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__ctrl_is_addr_decr
    is_addr_decr = ( state == 2'( __const__WAIT ) ) & ( next_state == 2'( __const__SEND ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:145
  // s.is_addr_incr //= lambda: ( s.state == WAIT ) & ( s.next_state == FETCH )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__ctrl_is_addr_incr
    is_addr_incr = ( state == 2'( __const__WAIT ) ) & ( next_state == 2'( __const__FETCH ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:124
  // s.mem_deq_en //= lambda: ( s.state == WAIT ) & s.mem_deq_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__ctrl_mem_deq_en
    mem_deq_en = ( state == 2'( __const__WAIT ) ) & mem_deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:122
  // s.mmaster_req_en //= lambda: ( s.state == FETCH ) & s.mmaster_req_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__ctrl_mmaster_req_en
    mmaster_req_en = ( state == 2'( __const__FETCH ) ) & mmaster_req_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:150
  // @update
  // def enable_reg_mem_rdata():
  //   for i in range(p.cfg_nwords):
  //     if i == (start - s.count_words):
  //       s.reg_mem_rdata_en[i] @= s.mem_deq_en
  //     else:
  //       s.reg_mem_rdata_en[i] @= 0
  
  always_comb begin : enable_reg_mem_rdata
    for ( int i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( 12'(i) == ( 12'( __const__start_at_enable_reg_mem_rdata ) - count_words ) ) begin
        reg_mem_rdata_en[1'(i)] = mem_deq_en;
      end
      else
        reg_mem_rdata_en[1'(i)] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:63
  // @update
  // def next_remaining_cfgs():
  //   if s.cfg_init:
  //     s.next_count_cfgs @= count_cfg_init
  //   elif s.cfg_send_en:
  //     s.next_count_cfgs @= s.count_cfgs - 1
  //   else:
  //     s.next_count_cfgs @= s.count_cfgs
  
  always_comb begin : next_remaining_cfgs
    if ( cfg_init ) begin
      next_count_cfgs = 12'( __const__count_cfg_init_at_next_remaining_cfgs );
    end
    else if ( cfg_send_en ) begin
      next_count_cfgs = count_cfgs - 12'd1;
    end
    else
      next_count_cfgs = count_cfgs;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:73
  // @update
  // def next_remaining_words():
  //   if ((s.state == FREEZE) | (s.state == SEND)) & (s.next_state == FETCH):
  //     s.next_count_words @= count_words_init
  //   elif s.mem_deq_en:
  //     s.next_count_words @= s.count_words - 1
  //   else:
  //     s.next_count_words @= s.count_words
  
  always_comb begin : next_remaining_words
    if ( ( ( state == 2'( __const__FREEZE ) ) | ( state == 2'( __const__SEND ) ) ) & ( next_state == 2'( __const__FETCH ) ) ) begin
      next_count_words = 12'( __const__count_words_init_at_next_remaining_words );
    end
    else if ( mem_deq_en ) begin
      next_count_words = count_words - 12'd1;
    end
    else
      next_count_words = count_words;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:134
  // @update_ff
  // def CE_ctrl_done():
  //   if s.reset | s.cfg_init:
  //     s.reg_is_done <<= 0
  //   elif ( s.state == SEND ) & ( s.next_state == FREEZE ):
  //     s.reg_is_done <<= 1
  
  always_ff @(posedge clk) begin : CE_ctrl_done
    if ( reset | cfg_init ) begin
      reg_is_done <= 1'd0;
    end
    else if ( ( state == 2'( __const__SEND ) ) & ( next_state == 2'( __const__FREEZE ) ) ) begin
      reg_is_done <= 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:89
  // @update_ff
  // def CE_state():
  //   if s.reset:
  //     s.state <<= FREEZE
  //   else:
  //     s.state <<= s.next_state
  
  always_ff @(posedge clk) begin : CE_state
    if ( reset ) begin
      state <= 2'( __const__FREEZE );
    end
    else
      state <= next_state;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineCtrl.py:53
  // @update_ff
  // def reg_counts():
  //   if s.reset:
  //     s.count_cfgs <<= 0
  //     s.count_words <<= 0
  //   else:
  //     s.count_cfgs <<= s.next_count_cfgs
  //     s.count_words <<= s.next_count_words
  
  always_ff @(posedge clk) begin : reg_counts
    if ( reset ) begin
      count_cfgs <= 12'd0;
      count_words <= 12'd0;
    end
    else begin
      count_cfgs <= next_count_cfgs;
      count_words <= next_count_words;
    end
  end

  assign is_done = reg_is_done;
  assign cfg_reset = cfg_init;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py

module RegEnRst__Type_Bits32__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 32'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component ConfigEngineDpath Definition
// Full name: ConfigEngineDpath__ConfigType_R2C2PEConfigMsg__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py

module ConfigEngineDpath__3b5c60331a151612
(
  input  logic [11:0] cfg_base_addr ,
  input  logic [0:0] cfg_reset ,
  output R2C2PEConfigMsg cfg_send_msg ,
  input  logic [0:0] clk ,
  input  logic [0:0] is_addr_decr ,
  input  logic [0:0] is_addr_incr ,
  input  CgraSramRespMsg mem_deq_ret ,
  output CgraSramReqMsg mmaster_req_msg ,
  input  logic [1:0] reg_mem_rdata_en ,
  input  logic [0:0] reset ,
  input  logic [1:0] y_cord 
);
  logic [63:0] all_words_rdata;
  logic [11:0] end_of_row_cfg_addr;
  logic [11:0] mem_req_addr;
  logic [11:0] mem_req_addr_decr;
  logic [11:0] mem_req_addr_incr;
  logic [11:0] next_mem_req_addr;
  logic [11:0] prev_row_offset;
  //-------------------------------------------------------------
  // Component reg_mem_rdata[0:1]
  //-------------------------------------------------------------

  logic [0:0] reg_mem_rdata__clk [0:1];
  logic [0:0] reg_mem_rdata__en [0:1];
  logic [31:0] reg_mem_rdata__in_ [0:1];
  logic [31:0] reg_mem_rdata__out [0:1];
  logic [0:0] reg_mem_rdata__reset [0:1];

  RegEnRst__Type_Bits32__reset_value_0 reg_mem_rdata__0
  (
    .clk( reg_mem_rdata__clk[0] ),
    .en( reg_mem_rdata__en[0] ),
    .in_( reg_mem_rdata__in_[0] ),
    .out( reg_mem_rdata__out[0] ),
    .reset( reg_mem_rdata__reset[0] )
  );

  RegEnRst__Type_Bits32__reset_value_0 reg_mem_rdata__1
  (
    .clk( reg_mem_rdata__clk[1] ),
    .en( reg_mem_rdata__en[1] ),
    .in_( reg_mem_rdata__in_[1] ),
    .out( reg_mem_rdata__out[1] ),
    .reset( reg_mem_rdata__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component reg_mem_rdata[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:77
  // @update
  // def CE_next_mem_req_addr():
  //   if s.cfg_reset:
  //     s.next_mem_req_addr @= s.end_of_row_cfg_addr
  //   elif s.is_addr_incr:
  //     s.next_mem_req_addr @= s.mem_req_addr + s.mem_req_addr_incr
  //   elif s.is_addr_decr:
  //     s.next_mem_req_addr @= s.mem_req_addr - s.mem_req_addr_decr
  //   else:
  //     s.next_mem_req_addr @= s.mem_req_addr
  
  always_comb begin : CE_next_mem_req_addr
    if ( cfg_reset ) begin
      next_mem_req_addr = end_of_row_cfg_addr;
    end
    else if ( is_addr_incr ) begin
      next_mem_req_addr = mem_req_addr + mem_req_addr_incr;
    end
    else if ( is_addr_decr ) begin
      next_mem_req_addr = mem_req_addr - mem_req_addr_decr;
    end
    else
      next_mem_req_addr = mem_req_addr;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:57
  // s.end_of_row_cfg_addr //= lambda: s.cfg_base_addr + \
  //                                   s.prev_row_offset + \
  //                                   s.end_of_row_offset
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__dpath_end_of_row_cfg_addr
    end_of_row_cfg_addr = ( cfg_base_addr + prev_row_offset ) + 12'd8;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:109
  // s.mmaster_req_msg.opaque //= lambda: zext( s.y_cord, p.opaque_width )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__dpath_mmaster_req_msg_opaque
    mmaster_req_msg.opaque = { { 1 { 1'b0 } }, y_cord };
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:52
  // s.prev_row_offset //= lambda: s.prev_row_factor * zext( s.y_cord, p.addr_width )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_c_0__dpath_prev_row_offset
    prev_row_offset = 12'd16 * { { 10 { 1'b0 } }, y_cord };
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:99
  // @update
  // def join_nwords():
  //   for i in range(p.cfg_nwords):
  //     s.all_words_rdata[i*p.data_width:i*p.data_width+p.data_width] @= s.reg_mem_rdata[i].out
  
  always_comb begin : join_nwords
    for ( int i = 1'd0; i < 2'd2; i += 1'd1 )
      all_words_rdata[6'(i) * 6'd32 +: 32] = reg_mem_rdata__out[1'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:70
  // @update_ff
  // def CE_mem_req_param_addr():
  //   if s.reset:
  //     s.mem_req_addr <<= 0
  //   else:
  //     s.mem_req_addr <<= s.next_mem_req_addr
  
  always_ff @(posedge clk) begin : CE_mem_req_param_addr
    if ( reset ) begin
      mem_req_addr <= 12'd0;
    end
    else
      mem_req_addr <= next_mem_req_addr;
  end

  assign mem_req_addr_incr = 12'd4;
  assign mem_req_addr_decr = 12'd12;
  assign reg_mem_rdata__clk[0] = clk;
  assign reg_mem_rdata__reset[0] = reset;
  assign reg_mem_rdata__clk[1] = clk;
  assign reg_mem_rdata__reset[1] = reset;
  assign reg_mem_rdata__in_[0] = mem_deq_ret.data;
  assign reg_mem_rdata__en[0] = reg_mem_rdata_en[0:0];
  assign reg_mem_rdata__in_[1] = mem_deq_ret.data;
  assign reg_mem_rdata__en[1] = reg_mem_rdata_en[1:1];
  assign mmaster_req_msg.wen = 1'd0;
  assign mmaster_req_msg.addr = mem_req_addr;
  assign mmaster_req_msg.data = 32'd0;
  assign cfg_send_msg.x_cord = all_words_rdata[0:0];
  assign cfg_send_msg.immediate = all_words_rdata[14:1];
  assign cfg_send_msg.dst_altbps = all_words_rdata[19:15];
  assign cfg_send_msg.src_altbps = all_words_rdata[22:20];
  assign cfg_send_msg.dst_bypass = all_words_rdata[27:23];
  assign cfg_send_msg.src_bypass = all_words_rdata[30:28];
  assign cfg_send_msg.dst_compute = all_words_rdata[35:31];
  assign cfg_send_msg.src_opd_b = all_words_rdata[38:36];
  assign cfg_send_msg.src_opd_a = all_words_rdata[41:39];
  assign cfg_send_msg.func = all_words_rdata[46:42];
  assign cfg_send_msg.opcode = all_words_rdata[48:47];

endmodule


// PyMTL Component NormalQueuePow2CtrlRTL Definition
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2CtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] deq_en ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] enq_en ,
  output logic [0:0] enq_rdy ,
  output logic [0:0] raddr ,
  input  logic [0:0] reset ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  logic [0:0] empty;
  logic [0:0] full;
  logic [0:0] r_ptr;
  logic [1:0] r_ptr_with_wrapbit;
  logic [0:0] w_ptr;
  logic [1:0] w_ptr_with_wrapbit;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py:99
  // @update
  // def upblk_empty():
  //   s.empty @= (s.w_ptr_with_wrapbit == s.r_ptr_with_wrapbit)
  
  always_comb begin : upblk_empty
    empty = w_ptr_with_wrapbit == r_ptr_with_wrapbit;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py:95
  // @update
  // def upblk_full():
  //   s.full @= (s.w_ptr == s.r_ptr) & (s.w_ptr_with_wrapbit != s.r_ptr_with_wrapbit)
  
  always_comb begin : upblk_full
    full = ( w_ptr == r_ptr ) & ( w_ptr_with_wrapbit != r_ptr_with_wrapbit );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py:103
  // @update
  // def upblk_output():
  //   s.enq_rdy @= ~ s.full
  //   s.deq_rdy @= ~ s.empty
  //   s.wen     @= (s.enq_en & s.enq_rdy)
  
  always_comb begin : upblk_output
    enq_rdy = ~full;
    deq_rdy = ~empty;
    wen = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py:88
  // @update_ff
  // def upblk_r_ptr():
  //   if s.reset:
  //     s.r_ptr_with_wrapbit <<= 0
  //   elif s.deq_en & s.deq_rdy:
  //     s.r_ptr_with_wrapbit <<= s.r_ptr_with_wrapbit + 1
  
  always_ff @(posedge clk) begin : upblk_r_ptr
    if ( reset ) begin
      r_ptr_with_wrapbit <= 2'd0;
    end
    else if ( deq_en & deq_rdy ) begin
      r_ptr_with_wrapbit <= r_ptr_with_wrapbit + 2'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py:81
  // @update_ff
  // def upblk_w_ptr():
  //   if s.reset:
  //     s.w_ptr_with_wrapbit <<= 0
  //   elif s.enq_en & s.enq_rdy:
  //     s.w_ptr_with_wrapbit <<= s.w_ptr_with_wrapbit + 1
  
  always_ff @(posedge clk) begin : upblk_w_ptr
    if ( reset ) begin
      w_ptr_with_wrapbit <= 2'd0;
    end
    else if ( enq_en & enq_rdy ) begin
      w_ptr_with_wrapbit <= w_ptr_with_wrapbit + 2'd1;
    end
  end

  assign w_ptr = w_ptr_with_wrapbit[0:0];
  assign r_ptr = r_ptr_with_wrapbit[0:0];
  assign waddr = w_ptr;
  assign raddr = r_ptr;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CgraSramRespMsg__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__78ffd70657ac2433
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output CgraSramRespMsg rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  CgraSramRespMsg wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  CgraSramRespMsg regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueuePow2DpathRTL Definition
// Full name: NormalQueuePow2DpathRTL__EntryType_CgraSramRespMsg__num_entries_2
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2DpathRTL__8d92cba355f3d465
(
  input  logic [0:0] clk ,
  output CgraSramRespMsg deq_msg ,
  input  CgraSramRespMsg enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  CgraSramRespMsg queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  CgraSramRespMsg queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__78ffd70657ac2433 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_msg = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueuePow2RTL Definition
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2RTL__EntryType_CgraSramRespMsg__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output CgraSramRespMsg deq__ret  ,
  input logic [0:0] enq__en  ,
  input CgraSramRespMsg enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueuePow2CtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  CgraSramRespMsg dpath__deq_msg;
  CgraSramRespMsg dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueuePow2DpathRTL__8d92cba355f3d465 dpath
  (
    .clk( dpath__clk ),
    .deq_msg( dpath__deq_msg ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_msg;

endmodule


// PyMTL Component ConfigEngine Definition
// Full name: ConfigEngine__ConfigType_R2C2PEConfigMsg__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/ConfigEngine.py

module ConfigEngine__3b5c60331a151612
(
  input  logic [11:0] cfg_base_addr ,
  input  logic [0:0] cfg_init ,
  input  logic [0:0] clk ,
  output logic [0:0] is_done ,
  input  logic [0:0] reset ,
  input  logic [1:0] y_cord ,
  output logic [0:0] cfg_send__en  ,
  output R2C2PEConfigMsg cfg_send__msg  ,
  input logic [0:0] cfg_send__rdy  ,
  output logic [0:0] mem_master__req__en ,
  output CgraSramReqMsg mem_master__req__msg ,
  input logic [0:0] mem_master__req__rdy ,
  input logic [0:0] mem_master__resp__en ,
  input CgraSramRespMsg mem_master__resp__msg ,
  output logic [0:0] mem_master__resp__rdy 
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__cfg_init;
  logic [0:0] ctrl__cfg_reset;
  logic [0:0] ctrl__cfg_send_en;
  logic [0:0] ctrl__cfg_send_rdy;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__is_addr_decr;
  logic [0:0] ctrl__is_addr_incr;
  logic [0:0] ctrl__is_done;
  logic [0:0] ctrl__mem_deq_en;
  logic [0:0] ctrl__mem_deq_rdy;
  logic [0:0] ctrl__mmaster_req_en;
  logic [0:0] ctrl__mmaster_req_rdy;
  logic [1:0] ctrl__reg_mem_rdata_en;
  logic [0:0] ctrl__reset;

  ConfigEngineCtrl__b5592e8a4ff43256 ctrl
  (
    .cfg_init( ctrl__cfg_init ),
    .cfg_reset( ctrl__cfg_reset ),
    .cfg_send_en( ctrl__cfg_send_en ),
    .cfg_send_rdy( ctrl__cfg_send_rdy ),
    .clk( ctrl__clk ),
    .is_addr_decr( ctrl__is_addr_decr ),
    .is_addr_incr( ctrl__is_addr_incr ),
    .is_done( ctrl__is_done ),
    .mem_deq_en( ctrl__mem_deq_en ),
    .mem_deq_rdy( ctrl__mem_deq_rdy ),
    .mmaster_req_en( ctrl__mmaster_req_en ),
    .mmaster_req_rdy( ctrl__mmaster_req_rdy ),
    .reg_mem_rdata_en( ctrl__reg_mem_rdata_en ),
    .reset( ctrl__reset )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [11:0] dpath__cfg_base_addr;
  logic [0:0] dpath__cfg_reset;
  R2C2PEConfigMsg dpath__cfg_send_msg;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__is_addr_decr;
  logic [0:0] dpath__is_addr_incr;
  CgraSramRespMsg dpath__mem_deq_ret;
  CgraSramReqMsg dpath__mmaster_req_msg;
  logic [1:0] dpath__reg_mem_rdata_en;
  logic [0:0] dpath__reset;
  logic [1:0] dpath__y_cord;

  ConfigEngineDpath__3b5c60331a151612 dpath
  (
    .cfg_base_addr( dpath__cfg_base_addr ),
    .cfg_reset( dpath__cfg_reset ),
    .cfg_send_msg( dpath__cfg_send_msg ),
    .clk( dpath__clk ),
    .is_addr_decr( dpath__is_addr_decr ),
    .is_addr_incr( dpath__is_addr_incr ),
    .mem_deq_ret( dpath__mem_deq_ret ),
    .mmaster_req_msg( dpath__mmaster_req_msg ),
    .reg_mem_rdata_en( dpath__reg_mem_rdata_en ),
    .reset( dpath__reset ),
    .y_cord( dpath__y_cord )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_q
  //-------------------------------------------------------------

  logic [0:0] mem_q__clk;
  logic [0:0] mem_q__reset;
  logic [0:0] mem_q__deq__en;
  logic [0:0] mem_q__deq__rdy;
  CgraSramRespMsg mem_q__deq__ret;
  logic [0:0] mem_q__enq__en;
  CgraSramRespMsg mem_q__enq__msg;
  logic [0:0] mem_q__enq__rdy;

  NormalQueuePow2RTL__EntryType_CgraSramRespMsg__num_entries_2 mem_q
  (
    .clk( mem_q__clk ),
    .reset( mem_q__reset ),
    .deq__en( mem_q__deq__en ),
    .deq__rdy( mem_q__deq__rdy ),
    .deq__ret( mem_q__deq__ret ),
    .enq__en( mem_q__enq__en ),
    .enq__msg( mem_q__enq__msg ),
    .enq__rdy( mem_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component mem_q
  //-------------------------------------------------------------

  assign mem_q__clk = clk;
  assign mem_q__reset = reset;
  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign mem_q__enq__en = mem_master__resp__en;
  assign mem_q__enq__msg = mem_master__resp__msg;
  assign mem_master__resp__rdy = mem_q__enq__rdy;
  assign ctrl__cfg_init = cfg_init;
  assign dpath__cfg_base_addr = cfg_base_addr;
  assign is_done = ctrl__is_done;
  assign dpath__y_cord = y_cord;
  assign mem_master__req__en = ctrl__mmaster_req_en;
  assign ctrl__mmaster_req_rdy = mem_master__req__rdy;
  assign mem_master__req__msg = dpath__mmaster_req_msg;
  assign mem_q__deq__en = ctrl__mem_deq_en;
  assign ctrl__mem_deq_rdy = mem_q__deq__rdy;
  assign dpath__mem_deq_ret = mem_q__deq__ret;
  assign cfg_send__en = ctrl__cfg_send_en;
  assign ctrl__cfg_send_rdy = cfg_send__rdy;
  assign cfg_send__msg = dpath__cfg_send_msg;
  assign dpath__cfg_reset = ctrl__cfg_reset;
  assign dpath__is_addr_incr = ctrl__is_addr_incr;
  assign dpath__is_addr_decr = ctrl__is_addr_decr;
  assign dpath__reg_mem_rdata_en = ctrl__reg_mem_rdata_en;

endmodule


// PyMTL Component ConfigEngineDpath Definition
// Full name: ConfigEngineDpath__ConfigType_R2C2MEConfigMsg__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py

module ConfigEngineDpath__8077c4232cf786b0
(
  input  logic [11:0] cfg_base_addr ,
  input  logic [0:0] cfg_reset ,
  output R2C2MEConfigMsg cfg_send_msg ,
  input  logic [0:0] clk ,
  input  logic [0:0] is_addr_decr ,
  input  logic [0:0] is_addr_incr ,
  input  CgraSramRespMsg mem_deq_ret ,
  output CgraSramReqMsg mmaster_req_msg ,
  input  logic [1:0] reg_mem_rdata_en ,
  input  logic [0:0] reset ,
  input  logic [1:0] y_cord 
);
  logic [63:0] all_words_rdata;
  logic [11:0] end_of_row_cfg_addr;
  logic [11:0] mem_req_addr;
  logic [11:0] mem_req_addr_decr;
  logic [11:0] mem_req_addr_incr;
  logic [11:0] next_mem_req_addr;
  logic [11:0] prev_row_offset;
  //-------------------------------------------------------------
  // Component reg_mem_rdata[0:1]
  //-------------------------------------------------------------

  logic [0:0] reg_mem_rdata__clk [0:1];
  logic [0:0] reg_mem_rdata__en [0:1];
  logic [31:0] reg_mem_rdata__in_ [0:1];
  logic [31:0] reg_mem_rdata__out [0:1];
  logic [0:0] reg_mem_rdata__reset [0:1];

  RegEnRst__Type_Bits32__reset_value_0 reg_mem_rdata__0
  (
    .clk( reg_mem_rdata__clk[0] ),
    .en( reg_mem_rdata__en[0] ),
    .in_( reg_mem_rdata__in_[0] ),
    .out( reg_mem_rdata__out[0] ),
    .reset( reg_mem_rdata__reset[0] )
  );

  RegEnRst__Type_Bits32__reset_value_0 reg_mem_rdata__1
  (
    .clk( reg_mem_rdata__clk[1] ),
    .en( reg_mem_rdata__en[1] ),
    .in_( reg_mem_rdata__in_[1] ),
    .out( reg_mem_rdata__out[1] ),
    .reset( reg_mem_rdata__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component reg_mem_rdata[0:1]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:77
  // @update
  // def CE_next_mem_req_addr():
  //   if s.cfg_reset:
  //     s.next_mem_req_addr @= s.end_of_row_cfg_addr
  //   elif s.is_addr_incr:
  //     s.next_mem_req_addr @= s.mem_req_addr + s.mem_req_addr_incr
  //   elif s.is_addr_decr:
  //     s.next_mem_req_addr @= s.mem_req_addr - s.mem_req_addr_decr
  //   else:
  //     s.next_mem_req_addr @= s.mem_req_addr
  
  always_comb begin : CE_next_mem_req_addr
    if ( cfg_reset ) begin
      next_mem_req_addr = end_of_row_cfg_addr;
    end
    else if ( is_addr_incr ) begin
      next_mem_req_addr = mem_req_addr + mem_req_addr_incr;
    end
    else if ( is_addr_decr ) begin
      next_mem_req_addr = mem_req_addr - mem_req_addr_decr;
    end
    else
      next_mem_req_addr = mem_req_addr;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:57
  // s.end_of_row_cfg_addr //= lambda: s.cfg_base_addr + \
  //                                   s.prev_row_offset + \
  //                                   s.end_of_row_offset
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_n_dpath_end_of_row_cfg_addr
    end_of_row_cfg_addr = ( cfg_base_addr + prev_row_offset ) + 12'd8;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:109
  // s.mmaster_req_msg.opaque //= lambda: zext( s.y_cord, p.opaque_width )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_n_dpath_mmaster_req_msg_opaque
    mmaster_req_msg.opaque = { { 1 { 1'b0 } }, y_cord };
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:52
  // s.prev_row_offset //= lambda: s.prev_row_factor * zext( s.y_cord, p.addr_width )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CE_n_dpath_prev_row_offset
    prev_row_offset = 12'd16 * { { 10 { 1'b0 } }, y_cord };
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:99
  // @update
  // def join_nwords():
  //   for i in range(p.cfg_nwords):
  //     s.all_words_rdata[i*p.data_width:i*p.data_width+p.data_width] @= s.reg_mem_rdata[i].out
  
  always_comb begin : join_nwords
    for ( int i = 1'd0; i < 2'd2; i += 1'd1 )
      all_words_rdata[6'(i) * 6'd32 +: 32] = reg_mem_rdata__out[1'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/ConfigEngineDpath.py:70
  // @update_ff
  // def CE_mem_req_param_addr():
  //   if s.reset:
  //     s.mem_req_addr <<= 0
  //   else:
  //     s.mem_req_addr <<= s.next_mem_req_addr
  
  always_ff @(posedge clk) begin : CE_mem_req_param_addr
    if ( reset ) begin
      mem_req_addr <= 12'd0;
    end
    else
      mem_req_addr <= next_mem_req_addr;
  end

  assign mem_req_addr_incr = 12'd4;
  assign mem_req_addr_decr = 12'd12;
  assign reg_mem_rdata__clk[0] = clk;
  assign reg_mem_rdata__reset[0] = reset;
  assign reg_mem_rdata__clk[1] = clk;
  assign reg_mem_rdata__reset[1] = reset;
  assign reg_mem_rdata__in_[0] = mem_deq_ret.data;
  assign reg_mem_rdata__en[0] = reg_mem_rdata_en[0:0];
  assign reg_mem_rdata__in_[1] = mem_deq_ret.data;
  assign reg_mem_rdata__en[1] = reg_mem_rdata_en[1:1];
  assign mmaster_req_msg.wen = 1'd0;
  assign mmaster_req_msg.addr = mem_req_addr;
  assign mmaster_req_msg.data = 32'd0;
  assign cfg_send_msg.x_cord = all_words_rdata[0:0];
  assign cfg_send_msg.count = all_words_rdata[12:1];
  assign cfg_send_msg.incr_addr = all_words_rdata[24:13];
  assign cfg_send_msg.base_addr = all_words_rdata[36:25];
  assign cfg_send_msg.wen = all_words_rdata[37:37];

endmodule


// PyMTL Component ConfigEngine Definition
// Full name: ConfigEngine__ConfigType_R2C2MEConfigMsg__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/ConfigEngine.py

module ConfigEngine__8077c4232cf786b0
(
  input  logic [11:0] cfg_base_addr ,
  input  logic [0:0] cfg_init ,
  input  logic [0:0] clk ,
  output logic [0:0] is_done ,
  input  logic [0:0] reset ,
  input  logic [1:0] y_cord ,
  output logic [0:0] cfg_send__en  ,
  output R2C2MEConfigMsg cfg_send__msg  ,
  input logic [0:0] cfg_send__rdy  ,
  output logic [0:0] mem_master__req__en ,
  output CgraSramReqMsg mem_master__req__msg ,
  input logic [0:0] mem_master__req__rdy ,
  input logic [0:0] mem_master__resp__en ,
  input CgraSramRespMsg mem_master__resp__msg ,
  output logic [0:0] mem_master__resp__rdy 
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__cfg_init;
  logic [0:0] ctrl__cfg_reset;
  logic [0:0] ctrl__cfg_send_en;
  logic [0:0] ctrl__cfg_send_rdy;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__is_addr_decr;
  logic [0:0] ctrl__is_addr_incr;
  logic [0:0] ctrl__is_done;
  logic [0:0] ctrl__mem_deq_en;
  logic [0:0] ctrl__mem_deq_rdy;
  logic [0:0] ctrl__mmaster_req_en;
  logic [0:0] ctrl__mmaster_req_rdy;
  logic [1:0] ctrl__reg_mem_rdata_en;
  logic [0:0] ctrl__reset;

  ConfigEngineCtrl__b5592e8a4ff43256 ctrl
  (
    .cfg_init( ctrl__cfg_init ),
    .cfg_reset( ctrl__cfg_reset ),
    .cfg_send_en( ctrl__cfg_send_en ),
    .cfg_send_rdy( ctrl__cfg_send_rdy ),
    .clk( ctrl__clk ),
    .is_addr_decr( ctrl__is_addr_decr ),
    .is_addr_incr( ctrl__is_addr_incr ),
    .is_done( ctrl__is_done ),
    .mem_deq_en( ctrl__mem_deq_en ),
    .mem_deq_rdy( ctrl__mem_deq_rdy ),
    .mmaster_req_en( ctrl__mmaster_req_en ),
    .mmaster_req_rdy( ctrl__mmaster_req_rdy ),
    .reg_mem_rdata_en( ctrl__reg_mem_rdata_en ),
    .reset( ctrl__reset )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [11:0] dpath__cfg_base_addr;
  logic [0:0] dpath__cfg_reset;
  R2C2MEConfigMsg dpath__cfg_send_msg;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__is_addr_decr;
  logic [0:0] dpath__is_addr_incr;
  CgraSramRespMsg dpath__mem_deq_ret;
  CgraSramReqMsg dpath__mmaster_req_msg;
  logic [1:0] dpath__reg_mem_rdata_en;
  logic [0:0] dpath__reset;
  logic [1:0] dpath__y_cord;

  ConfigEngineDpath__8077c4232cf786b0 dpath
  (
    .cfg_base_addr( dpath__cfg_base_addr ),
    .cfg_reset( dpath__cfg_reset ),
    .cfg_send_msg( dpath__cfg_send_msg ),
    .clk( dpath__clk ),
    .is_addr_decr( dpath__is_addr_decr ),
    .is_addr_incr( dpath__is_addr_incr ),
    .mem_deq_ret( dpath__mem_deq_ret ),
    .mmaster_req_msg( dpath__mmaster_req_msg ),
    .reg_mem_rdata_en( dpath__reg_mem_rdata_en ),
    .reset( dpath__reset ),
    .y_cord( dpath__y_cord )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_q
  //-------------------------------------------------------------

  logic [0:0] mem_q__clk;
  logic [0:0] mem_q__reset;
  logic [0:0] mem_q__deq__en;
  logic [0:0] mem_q__deq__rdy;
  CgraSramRespMsg mem_q__deq__ret;
  logic [0:0] mem_q__enq__en;
  CgraSramRespMsg mem_q__enq__msg;
  logic [0:0] mem_q__enq__rdy;

  NormalQueuePow2RTL__EntryType_CgraSramRespMsg__num_entries_2 mem_q
  (
    .clk( mem_q__clk ),
    .reset( mem_q__reset ),
    .deq__en( mem_q__deq__en ),
    .deq__rdy( mem_q__deq__rdy ),
    .deq__ret( mem_q__deq__ret ),
    .enq__en( mem_q__enq__en ),
    .enq__msg( mem_q__enq__msg ),
    .enq__rdy( mem_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component mem_q
  //-------------------------------------------------------------

  assign mem_q__clk = clk;
  assign mem_q__reset = reset;
  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign mem_q__enq__en = mem_master__resp__en;
  assign mem_q__enq__msg = mem_master__resp__msg;
  assign mem_master__resp__rdy = mem_q__enq__rdy;
  assign ctrl__cfg_init = cfg_init;
  assign dpath__cfg_base_addr = cfg_base_addr;
  assign is_done = ctrl__is_done;
  assign dpath__y_cord = y_cord;
  assign mem_master__req__en = ctrl__mmaster_req_en;
  assign ctrl__mmaster_req_rdy = mem_master__req__rdy;
  assign mem_master__req__msg = dpath__mmaster_req_msg;
  assign mem_q__deq__en = ctrl__mem_deq_en;
  assign ctrl__mem_deq_rdy = mem_q__deq__rdy;
  assign dpath__mem_deq_ret = mem_q__deq__ret;
  assign cfg_send__en = ctrl__cfg_send_en;
  assign ctrl__cfg_send_rdy = cfg_send__rdy;
  assign cfg_send__msg = dpath__cfg_send_msg;
  assign dpath__cfg_reset = ctrl__cfg_reset;
  assign dpath__is_addr_incr = ctrl__is_addr_incr;
  assign dpath__is_addr_decr = ctrl__is_addr_decr;
  assign dpath__reg_mem_rdata_en = ctrl__reg_mem_rdata_en;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py

module RegEnRst__Type_32__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 32'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_R2C2MEConfigMsg__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__bdf7a190bafdf6e6
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output R2C2MEConfigMsg rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  R2C2MEConfigMsg wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  R2C2MEConfigMsg regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueuePow2DpathRTL Definition
// Full name: NormalQueuePow2DpathRTL__EntryType_R2C2MEConfigMsg__num_entries_2
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2DpathRTL__d91f2864cd86419e
(
  input  logic [0:0] clk ,
  output R2C2MEConfigMsg deq_msg ,
  input  R2C2MEConfigMsg enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  R2C2MEConfigMsg queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  R2C2MEConfigMsg queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__bdf7a190bafdf6e6 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_msg = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueuePow2RTL Definition
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2RTL__EntryType_R2C2MEConfigMsg__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output R2C2MEConfigMsg deq__ret  ,
  input logic [0:0] enq__en  ,
  input R2C2MEConfigMsg enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueuePow2CtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  R2C2MEConfigMsg dpath__deq_msg;
  R2C2MEConfigMsg dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueuePow2DpathRTL__d91f2864cd86419e dpath
  (
    .clk( dpath__clk ),
    .deq_msg( dpath__deq_msg ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_msg;

endmodule


// PyMTL Component MemEngineCtrl Definition
// Full name: MemEngineCtrl__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py

module MemEngineCtrl__b5592e8a4ff43256
(
  output logic [0:0] cfg_deq_en ,
  input  logic [0:0] cfg_deq_rdy ,
  output logic [0:0] cfg_send_en ,
  input  logic [0:0] cfg_send_rdy ,
  input  logic [0:0] clk ,
  input  logic [0:0] count_zero ,
  output logic [0:0] deq_en ,
  input  logic [0:0] deq_rdy ,
  input  logic [0:0] is_calc ,
  input  logic [0:0] is_cfg_target_self ,
  input  logic [0:0] is_cfg_write ,
  output logic [0:0] is_done ,
  output logic [0:0] mem_deq_en ,
  input  logic [0:0] mem_deq_rdy ,
  output logic [0:0] mem_req_en ,
  input  logic [0:0] mem_req_rdy ,
  output logic [0:0] req_sent ,
  input  logic [0:0] reset ,
  output logic [0:0] resp_recved ,
  output logic [0:0] self_cfg_deq ,
  output logic [0:0] send_en ,
  input  logic [0:0] send_rdy 
);

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:54
  // s.cfg_deq_en //= lambda: s.self_cfg_deq | ( s.cfg_send_rdy & s.cfg_deq_rdy )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_cfg_deq_en
    cfg_deq_en = self_cfg_deq | ( cfg_send_rdy & cfg_deq_rdy );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:55
  // s.cfg_send_en //= lambda: ~s.is_cfg_target_self & s.cfg_deq_en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_cfg_send_en
    cfg_send_en = ( ~is_cfg_target_self ) & cfg_deq_en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:51
  // s.deq_en //= lambda: s.mem_req_rdy & s.deq_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_deq_en
    deq_en = mem_req_rdy & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:67
  // s.is_done //= lambda: s.is_calc & s.count_zero
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_is_done
    is_done = is_calc & count_zero;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:49
  // s.mem_deq_en //= lambda: s.send_rdy & s.mem_deq_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_mem_deq_en
    mem_deq_en = send_rdy & mem_deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:48
  // s.mem_req_en //= lambda: ( (s.is_cfg_write & s.deq_rdy) | (~s.is_cfg_write & ~s.count_zero) ) & s.mem_req_rdy & s.is_calc
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_mem_req_en
    mem_req_en = ( ( ( is_cfg_write & deq_rdy ) | ( ( ~is_cfg_write ) & ( ~count_zero ) ) ) & mem_req_rdy ) & is_calc;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:63
  // s.req_sent //= lambda: s.mem_req_en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_req_sent
    req_sent = mem_req_en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:65
  // s.resp_recved //= lambda: s.mem_deq_en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_resp_recved
    resp_recved = mem_deq_en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:61
  // s.self_cfg_deq //= lambda: s.cfg_deq_rdy & s.is_cfg_target_self
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_self_cfg_deq
    self_cfg_deq = cfg_deq_rdy & is_cfg_target_self;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineCtrl.py:52
  // s.send_en //= lambda: ~s.is_cfg_write & s.mem_deq_rdy & s.send_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__ctrl_send_en
    send_en = ( ( ~is_cfg_write ) & mem_deq_rdy ) & send_rdy;
  end

endmodule


// PyMTL Component MemEngineDpath Definition
// Full name: MemEngineDpath__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py

module MemEngineDpath__b5592e8a4ff43256
(
  input  R2C2MEConfigMsg cfg_deq_ret ,
  output R2C2MEConfigMsg cfg_send_msg ,
  input  logic [0:0] clk ,
  output logic [0:0] count_zero ,
  input  logic [31:0] deq_ret ,
  output logic [0:0] is_cfg_target_self ,
  output logic [0:0] is_cfg_write ,
  input  CgraSramRespMsg mem_deq_ret ,
  output CgraSramReqMsg mem_req_msg ,
  input  logic [0:0] ns_cord ,
  input  logic [0:0] req_sent ,
  input  logic [0:0] reset ,
  input  logic [0:0] resp_recved ,
  input  logic [0:0] self_cfg_deq ,
  output logic [31:0] send_msg ,
  input  logic [0:0] x_cord 
);
  logic [11:0] cfg_addr;
  logic [11:0] cfg_count;
  logic [11:0] cfg_incr_addr;
  logic [0:0] cfg_wen;
  logic [11:0] next_cfg_addr;
  logic [11:0] next_cfg_count;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:80
  // @update
  // def ME_next_cfg_addr():
  //   if s.req_sent:
  //     s.next_cfg_addr @= s.cfg_addr + s.cfg_incr_addr
  //   else:
  //     s.next_cfg_addr @= s.cfg_addr
  
  always_comb begin : ME_next_cfg_addr
    if ( req_sent ) begin
      next_cfg_addr = cfg_addr + cfg_incr_addr;
    end
    else
      next_cfg_addr = cfg_addr;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:87
  // @update
  // def ME_next_cfg_count():
  //   # if (s.cfg_wen & s.req_sent) | (~s.cfg_wen & s.resp_recved):
  //   if s.req_sent:
  //     s.next_cfg_count @= s.cfg_count - 1
  //   else:
  //     s.next_cfg_count @= s.cfg_count
  
  always_comb begin : ME_next_cfg_count
    if ( req_sent ) begin
      next_cfg_count = cfg_count - 12'd1;
    end
    else
      next_cfg_count = cfg_count;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:106
  // s.cfg_send_msg //= lambda: s.cfg_deq_ret
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__dpath_cfg_send_msg
    cfg_send_msg = cfg_deq_ret;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:112
  // s.count_zero //= lambda: s.cfg_count == 0
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__dpath_count_zero
    count_zero = cfg_count == 12'd0;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:116
  // s.is_cfg_target_self //= lambda: s.cfg_deq_ret.x_cord == s.x_cord
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__dpath_is_cfg_target_self
    is_cfg_target_self = cfg_deq_ret.x_cord == x_cord;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:114
  // s.is_cfg_write //= lambda: s.cfg_wen
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__dpath_is_cfg_write
    is_cfg_write = cfg_wen;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:102
  // s.mem_req_msg.opaque //= lambda: zext( concat( s.ns_cord, s.x_cord ), p.opaque_width )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_ME_r_0__dpath_mem_req_msg_opaque
    mem_req_msg.opaque = { { 1 { 1'b0 } }, { ns_cord, x_cord } };
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:68
  // @update_ff
  // def ME_cfg():
  //   if s.reset:
  //     s.cfg_addr <<= 0
  //     s.cfg_count <<= 0
  //   elif s.self_cfg_deq:
  //     s.cfg_addr <<= s.cfg_deq_ret.base_addr
  //     s.cfg_count <<= s.cfg_deq_ret.count
  //   else:
  //     s.cfg_addr <<= s.next_cfg_addr
  //     s.cfg_count <<= s.next_cfg_count
  
  always_ff @(posedge clk) begin : ME_cfg
    if ( reset ) begin
      cfg_addr <= 12'd0;
      cfg_count <= 12'd0;
    end
    else if ( self_cfg_deq ) begin
      cfg_addr <= cfg_deq_ret.base_addr;
      cfg_count <= cfg_deq_ret.count;
    end
    else begin
      cfg_addr <= next_cfg_addr;
      cfg_count <= next_cfg_count;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/MemEngineDpath.py:59
  // @update_ff
  // def ME_cfg_constant():
  //   if s.reset:
  //     s.cfg_wen <<= 0
  //     s.cfg_incr_addr <<= 0
  //   elif s.self_cfg_deq:
  //     s.cfg_wen <<= s.cfg_deq_ret.wen
  //     s.cfg_incr_addr <<= s.cfg_deq_ret.incr_addr
  
  always_ff @(posedge clk) begin : ME_cfg_constant
    if ( reset ) begin
      cfg_wen <= 1'd0;
      cfg_incr_addr <= 12'd0;
    end
    else if ( self_cfg_deq ) begin
      cfg_wen <= cfg_deq_ret.wen;
      cfg_incr_addr <= cfg_deq_ret.incr_addr;
    end
  end

  assign mem_req_msg.wen = cfg_wen;
  assign mem_req_msg.addr = cfg_addr;
  assign mem_req_msg.data = deq_ret;
  assign send_msg = mem_deq_ret.data;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_Bits32__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__3a42a011005ae1af
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output logic [31:0] rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  logic [31:0] wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  logic [31:0] regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueuePow2DpathRTL Definition
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2DpathRTL__EntryType_Bits32__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [31:0] deq_msg ,
  input  logic [31:0] enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  logic [31:0] queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  logic [31:0] queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__3a42a011005ae1af queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_msg = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueuePow2RTL Definition
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2RTL__EntryType_Bits32__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output logic [31:0] deq__ret  ,
  input logic [0:0] enq__en  ,
  input logic [31:0] enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueuePow2CtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [31:0] dpath__deq_msg;
  logic [31:0] dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueuePow2DpathRTL__EntryType_Bits32__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_msg( dpath__deq_msg ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_msg;

endmodule


// PyMTL Component MemEngine Definition
// Full name: MemEngine__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/MemEngine.py

module MemEngine__b5592e8a4ff43256
(
  input  logic [0:0] clk ,
  input  logic [0:0] is_calc ,
  output logic [0:0] is_done ,
  input  logic [0:0] ns_cord ,
  input  logic [0:0] reset ,
  input  logic [0:0] x_cord ,
  input logic [0:0] cfg_recv__en  ,
  input R2C2MEConfigMsg cfg_recv__msg  ,
  output logic [0:0] cfg_recv__rdy  ,
  output logic [0:0] cfg_send__en  ,
  output R2C2MEConfigMsg cfg_send__msg  ,
  input logic [0:0] cfg_send__rdy  ,
  output logic [0:0] mem_ifc__req__en ,
  output CgraSramReqMsg mem_ifc__req__msg ,
  input logic [0:0] mem_ifc__req__rdy ,
  input logic [0:0] mem_ifc__resp__en ,
  input CgraSramRespMsg mem_ifc__resp__msg ,
  output logic [0:0] mem_ifc__resp__rdy ,
  input logic [0:0] recv__en  ,
  input logic [31:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [31:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  //-------------------------------------------------------------
  // Component cfg_q
  //-------------------------------------------------------------

  logic [0:0] cfg_q__clk;
  logic [0:0] cfg_q__reset;
  logic [0:0] cfg_q__deq__en;
  logic [0:0] cfg_q__deq__rdy;
  R2C2MEConfigMsg cfg_q__deq__ret;
  logic [0:0] cfg_q__enq__en;
  R2C2MEConfigMsg cfg_q__enq__msg;
  logic [0:0] cfg_q__enq__rdy;

  NormalQueuePow2RTL__EntryType_R2C2MEConfigMsg__num_entries_2 cfg_q
  (
    .clk( cfg_q__clk ),
    .reset( cfg_q__reset ),
    .deq__en( cfg_q__deq__en ),
    .deq__rdy( cfg_q__deq__rdy ),
    .deq__ret( cfg_q__deq__ret ),
    .enq__en( cfg_q__enq__en ),
    .enq__msg( cfg_q__enq__msg ),
    .enq__rdy( cfg_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component cfg_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__cfg_deq_en;
  logic [0:0] ctrl__cfg_deq_rdy;
  logic [0:0] ctrl__cfg_send_en;
  logic [0:0] ctrl__cfg_send_rdy;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__count_zero;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__is_calc;
  logic [0:0] ctrl__is_cfg_target_self;
  logic [0:0] ctrl__is_cfg_write;
  logic [0:0] ctrl__is_done;
  logic [0:0] ctrl__mem_deq_en;
  logic [0:0] ctrl__mem_deq_rdy;
  logic [0:0] ctrl__mem_req_en;
  logic [0:0] ctrl__mem_req_rdy;
  logic [0:0] ctrl__req_sent;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__resp_recved;
  logic [0:0] ctrl__self_cfg_deq;
  logic [0:0] ctrl__send_en;
  logic [0:0] ctrl__send_rdy;

  MemEngineCtrl__b5592e8a4ff43256 ctrl
  (
    .cfg_deq_en( ctrl__cfg_deq_en ),
    .cfg_deq_rdy( ctrl__cfg_deq_rdy ),
    .cfg_send_en( ctrl__cfg_send_en ),
    .cfg_send_rdy( ctrl__cfg_send_rdy ),
    .clk( ctrl__clk ),
    .count_zero( ctrl__count_zero ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .is_calc( ctrl__is_calc ),
    .is_cfg_target_self( ctrl__is_cfg_target_self ),
    .is_cfg_write( ctrl__is_cfg_write ),
    .is_done( ctrl__is_done ),
    .mem_deq_en( ctrl__mem_deq_en ),
    .mem_deq_rdy( ctrl__mem_deq_rdy ),
    .mem_req_en( ctrl__mem_req_en ),
    .mem_req_rdy( ctrl__mem_req_rdy ),
    .req_sent( ctrl__req_sent ),
    .reset( ctrl__reset ),
    .resp_recved( ctrl__resp_recved ),
    .self_cfg_deq( ctrl__self_cfg_deq ),
    .send_en( ctrl__send_en ),
    .send_rdy( ctrl__send_rdy )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  R2C2MEConfigMsg dpath__cfg_deq_ret;
  R2C2MEConfigMsg dpath__cfg_send_msg;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__count_zero;
  logic [31:0] dpath__deq_ret;
  logic [0:0] dpath__is_cfg_target_self;
  logic [0:0] dpath__is_cfg_write;
  CgraSramRespMsg dpath__mem_deq_ret;
  CgraSramReqMsg dpath__mem_req_msg;
  logic [0:0] dpath__ns_cord;
  logic [0:0] dpath__req_sent;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__resp_recved;
  logic [0:0] dpath__self_cfg_deq;
  logic [31:0] dpath__send_msg;
  logic [0:0] dpath__x_cord;

  MemEngineDpath__b5592e8a4ff43256 dpath
  (
    .cfg_deq_ret( dpath__cfg_deq_ret ),
    .cfg_send_msg( dpath__cfg_send_msg ),
    .clk( dpath__clk ),
    .count_zero( dpath__count_zero ),
    .deq_ret( dpath__deq_ret ),
    .is_cfg_target_self( dpath__is_cfg_target_self ),
    .is_cfg_write( dpath__is_cfg_write ),
    .mem_deq_ret( dpath__mem_deq_ret ),
    .mem_req_msg( dpath__mem_req_msg ),
    .ns_cord( dpath__ns_cord ),
    .req_sent( dpath__req_sent ),
    .reset( dpath__reset ),
    .resp_recved( dpath__resp_recved ),
    .self_cfg_deq( dpath__self_cfg_deq ),
    .send_msg( dpath__send_msg ),
    .x_cord( dpath__x_cord )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  logic [31:0] in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  logic [31:0] in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  NormalQueuePow2RTL__EntryType_Bits32__num_entries_2 in_q
  (
    .clk( in_q__clk ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_q
  //-------------------------------------------------------------

  logic [0:0] mem_q__clk;
  logic [0:0] mem_q__reset;
  logic [0:0] mem_q__deq__en;
  logic [0:0] mem_q__deq__rdy;
  CgraSramRespMsg mem_q__deq__ret;
  logic [0:0] mem_q__enq__en;
  CgraSramRespMsg mem_q__enq__msg;
  logic [0:0] mem_q__enq__rdy;

  NormalQueuePow2RTL__EntryType_CgraSramRespMsg__num_entries_2 mem_q
  (
    .clk( mem_q__clk ),
    .reset( mem_q__reset ),
    .deq__en( mem_q__deq__en ),
    .deq__rdy( mem_q__deq__rdy ),
    .deq__ret( mem_q__deq__ret ),
    .enq__en( mem_q__enq__en ),
    .enq__msg( mem_q__enq__msg ),
    .enq__rdy( mem_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component mem_q
  //-------------------------------------------------------------

  assign cfg_q__clk = clk;
  assign cfg_q__reset = reset;
  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign mem_q__clk = clk;
  assign mem_q__reset = reset;
  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign cfg_q__enq__en = cfg_recv__en;
  assign cfg_q__enq__msg = cfg_recv__msg;
  assign cfg_recv__rdy = cfg_q__enq__rdy;
  assign in_q__enq__en = recv__en;
  assign in_q__enq__msg = recv__msg;
  assign recv__rdy = in_q__enq__rdy;
  assign mem_q__enq__en = mem_ifc__resp__en;
  assign mem_q__enq__msg = mem_ifc__resp__msg;
  assign mem_ifc__resp__rdy = mem_q__enq__rdy;
  assign cfg_q__deq__en = ctrl__cfg_deq_en;
  assign ctrl__cfg_deq_rdy = cfg_q__deq__rdy;
  assign dpath__cfg_deq_ret = cfg_q__deq__ret;
  assign cfg_send__en = ctrl__cfg_send_en;
  assign ctrl__cfg_send_rdy = cfg_send__rdy;
  assign cfg_send__msg = dpath__cfg_send_msg;
  assign in_q__deq__en = ctrl__deq_en;
  assign ctrl__deq_rdy = in_q__deq__rdy;
  assign dpath__deq_ret = in_q__deq__ret;
  assign send__en = ctrl__send_en;
  assign ctrl__send_rdy = send__rdy;
  assign send__msg = dpath__send_msg;
  assign mem_q__deq__en = ctrl__mem_deq_en;
  assign ctrl__mem_deq_rdy = mem_q__deq__rdy;
  assign dpath__mem_deq_ret = mem_q__deq__ret;
  assign mem_ifc__req__en = ctrl__mem_req_en;
  assign ctrl__mem_req_rdy = mem_ifc__req__rdy;
  assign mem_ifc__req__msg = dpath__mem_req_msg;
  assign is_done = ctrl__is_done;
  assign ctrl__is_calc = is_calc;
  assign dpath__ns_cord = ns_cord;
  assign dpath__x_cord = x_cord;
  assign ctrl__count_zero = dpath__count_zero;
  assign ctrl__is_cfg_write = dpath__is_cfg_write;
  assign ctrl__is_cfg_target_self = dpath__is_cfg_target_self;
  assign dpath__self_cfg_deq = ctrl__self_cfg_deq;
  assign dpath__req_sent = ctrl__req_sent;
  assign dpath__resp_recved = ctrl__resp_recved;

endmodule


// PyMTL Component RecurInitUnit Definition
// At /work/global/pp482/uecgra-src/src/cgra/RecurInitUnit.py

module RecurInitUnit_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] deq_en ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] reset 
);
  logic [0:0] state;
  logic [0:0] state_next;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/RecurInitUnit.py:42
  // @update
  // def up_deq_rdy():
  //   s.deq_rdy @= s.state
  
  always_comb begin : up_deq_rdy
    deq_rdy = state;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/RecurInitUnit.py:33
  // @update
  // def up_state_next():
  //   if s.reset:
  //     s.state_next @= 1
  //   elif s.state == 1:
  //     s.state_next @= ~s.deq_en
  //   else:
  //     s.state_next @= s.state
  
  always_comb begin : up_state_next
    if ( reset ) begin
      state_next = 1'd1;
    end
    else if ( state == 1'd1 ) begin
      state_next = ~deq_en;
    end
    else
      state_next = state;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/RecurInitUnit.py:29
  // @update_ff
  // def up_state():
  //   s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state
    state <= state_next;
  end

endmodule


// PyMTL Component TileStaticCtrl Definition
// Full name: TileStaticCtrl__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py

module TileStaticCtrl__b5592e8a4ff43256
(
  output logic [1:0] acc_mux_sel ,
  output logic [0:0] acc_reg_en ,
  output logic [2:0] altbps_mux_sel ,
  input  logic [31:0] branch_cond ,
  output logic [2:0] bypass_mux_sel ,
  output logic [0:0] cfg_deq_en ,
  input  logic [0:0] cfg_deq_rdy ,
  input  logic [0:0] cfg_init ,
  output logic [0:0] cfg_send_en ,
  input  logic [0:0] cfg_send_rdy ,
  input  R2C2PEConfigMsg cfg_wire ,
  input  logic [0:0] clk ,
  output logic [0:0] deq_en_e ,
  output logic [0:0] deq_en_n ,
  output logic [0:0] deq_en_s ,
  output logic [0:0] deq_en_w ,
  input  logic [0:0] deq_rdy_e ,
  input  logic [0:0] deq_rdy_n ,
  input  logic [0:0] deq_rdy_s ,
  input  logic [0:0] deq_rdy_w ,
  output logic [13:0] imm_partial ,
  output logic [0:0] is_cfg_done ,
  input  logic [0:0] is_cfg_target_self ,
  output logic [4:0] node_cfg ,
  output logic [4:0] node_cfg_func ,
  output logic [0:0] node_recv_en ,
  input  logic [0:0] node_recv_rdy ,
  input  logic [0:0] node_send_en ,
  output logic [0:0] node_send_rdy ,
  output logic [2:0] opd_a_mux_sel ,
  output logic [2:0] opd_b_mux_sel ,
  input  logic [0:0] reset ,
  output logic [0:0] send_en_e ,
  output logic [0:0] send_en_n ,
  output logic [0:0] send_en_s ,
  output logic [0:0] send_en_w ,
  output logic [1:0] send_mux_e_sel ,
  output logic [1:0] send_mux_n_sel ,
  output logic [1:0] send_mux_s_sel ,
  output logic [1:0] send_mux_w_sel ,
  input  logic [0:0] send_rdy_e ,
  input  logic [0:0] send_rdy_n ,
  input  logic [0:0] send_rdy_s ,
  input  logic [0:0] send_rdy_w 
);
  logic [0:0] altbps_deq_rdy;
  logic [0:0] altbps_opd;
  logic [0:0] altbps_send_rdy;
  logic [4:0] altbps_send_rdys;
  logic [0:0] br_deq_rdy;
  logic [4:0] br_dst_false;
  logic [4:0] br_dst_true;
  logic [0:0] br_go_e;
  logic [0:0] br_go_n;
  logic [0:0] br_go_s;
  logic [0:0] br_go_self;
  logic [0:0] br_go_w;
  logic [0:0] br_send_rdy;
  logic [2:0] br_src_bool;
  logic [2:0] br_src_data;
  logic [0:0] branch_taken;
  logic [0:0] bypass_deq_rdy;
  logic [0:0] bypass_opd;
  logic [0:0] bypass_send_rdy;
  logic [4:0] bypass_send_rdys;
  R2C2PEConfigMsg cfg;
  logic [0:0] cfg_en;
  logic [3:0] deq_rdys;
  logic [0:0] is_branch;
  logic [4:0] node_send_rdys;
  logic [0:0] opd_a_deq_rdy;
  logic [0:0] opd_b_deq_rdy;
  logic [0:0] operands_deq_rdy;
  logic [0:0] self_cfg_deq;
  logic [4:0] send_rdys;
  logic [0:0] use_east_q;
  logic [0:0] use_north_q;
  logic [0:0] use_south_q;
  logic [0:0] use_west_q;
  //-------------------------------------------------------------
  // Component riu
  //-------------------------------------------------------------

  logic [0:0] riu__clk;
  logic [0:0] riu__deq_en;
  logic [0:0] riu__deq_rdy;
  logic [0:0] riu__reset;

  RecurInitUnit_noparam riu
  (
    .clk( riu__clk ),
    .deq_en( riu__deq_en ),
    .deq_rdy( riu__deq_rdy ),
    .reset( riu__reset )
  );

  //-------------------------------------------------------------
  // End of component riu
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:159
  // s.cfg_deq_en //= lambda: s.self_cfg_deq | ( s.cfg_send_rdy & s.cfg_deq_rdy )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_PE_rc_0__ctrl_cfg_deq_en
    cfg_deq_en = self_cfg_deq | ( cfg_send_rdy & cfg_deq_rdy );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:160
  // s.cfg_send_en //= lambda: ~s.is_cfg_target_self & s.cfg_deq_en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_PE_rc_0__ctrl_cfg_send_en
    cfg_send_en = ( ~is_cfg_target_self ) & cfg_deq_en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:154
  // s.self_cfg_deq //= lambda: s.is_cfg_target_self & s.cfg_deq_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_PE_rc_0__ctrl_self_cfg_deq
    self_cfg_deq = is_cfg_target_self & cfg_deq_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:597
  // @update
  // def up_acc_mux_sel():
  //   if s.cfg_en:
  //     s.acc_mux_sel @= RegMux.CONST
  // 
  //   # Branch
  //   elif s.is_branch:
  //     s.acc_mux_sel @= 0
  //     if s.cfg.dst_bypass[ TD.SELF ]:
  //       s.acc_mux_sel @= RegMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.SELF ]:
  //       s.acc_mux_sel @= RegMux.BPS_ALT
  //     if s.br_dst_true[ TD.SELF ] | s.br_dst_true[ TD.SELF ]:
  //       s.acc_mux_sel @= RegMux.COMPUTE
  // 
  //   # Other operations
  //   else:
  //     s.acc_mux_sel @= 0
  //     if s.cfg.dst_bypass[ TD.SELF ]:
  //       s.acc_mux_sel @= RegMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.SELF ]:
  //       s.acc_mux_sel @= RegMux.BPS_ALT
  //     if s.cfg.dst_compute[ TD.SELF ]:
  //       s.acc_mux_sel @= RegMux.COMPUTE
  
  always_comb begin : up_acc_mux_sel
    if ( cfg_en ) begin
      acc_mux_sel = 2'd3;
    end
    else if ( is_branch ) begin
      acc_mux_sel = 2'd0;
      if ( cfg.dst_bypass[3'd4] ) begin
        acc_mux_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd4] ) begin
        acc_mux_sel = 2'd2;
      end
      if ( br_dst_true[3'd4] | br_dst_true[3'd4] ) begin
        acc_mux_sel = 2'd0;
      end
    end
    else begin
      acc_mux_sel = 2'd0;
      if ( cfg.dst_bypass[3'd4] ) begin
        acc_mux_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd4] ) begin
        acc_mux_sel = 2'd2;
      end
      if ( cfg.dst_compute[3'd4] ) begin
        acc_mux_sel = 2'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:506
  // @update
  // def up_acc_reg_en():
  //   if s.cfg_en:
  //     # NOTE: THIS IS TEMPORARY
  //     s.acc_reg_en @= 1
  //   elif s.cfg.dst_compute[ TD.SELF ]:
  //     s.acc_reg_en @= s.node_send_en
  //   elif s.cfg.dst_bypass[ TD.SELF ]:
  //     s.acc_reg_en @= s.bypass_deq_rdy
  //   elif s.cfg.dst_altbps[ TD.SELF ]:
  //     s.acc_reg_en @= s.altbps_deq_rdy
  //   else:
  //     s.acc_reg_en @= 0
  
  always_comb begin : up_acc_reg_en
    if ( cfg_en ) begin
      acc_reg_en = 1'd1;
    end
    else if ( cfg.dst_compute[3'd4] ) begin
      acc_reg_en = node_send_en;
    end
    else if ( cfg.dst_bypass[3'd4] ) begin
      acc_reg_en = bypass_deq_rdy;
    end
    else if ( cfg.dst_altbps[3'd4] ) begin
      acc_reg_en = altbps_deq_rdy;
    end
    else
      acc_reg_en = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:329
  // @update
  // def up_altbps_deq_rdy():
  //   if s.altbps_opd:
  //     s.altbps_deq_rdy @= s.operands_deq_rdy
  //   elif s.cfg.src_altbps == CfgMsg.SRC_SELF:
  //     s.altbps_deq_rdy @= 1
  //   else:
  //     s.altbps_deq_rdy @= s.deq_rdys[ s.cfg.src_altbps[0:2] ]
  
  always_comb begin : up_altbps_deq_rdy
    if ( altbps_opd ) begin
      altbps_deq_rdy = operands_deq_rdy;
    end
    else if ( cfg.src_altbps == 3'd4 ) begin
      altbps_deq_rdy = 1'd1;
    end
    else
      altbps_deq_rdy = deq_rdys[cfg.src_altbps[2'd1:2'd0]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:322
  // @update
  // def up_altbps_opd():
  //   s.altbps_opd @= ( s.cfg.src_altbps == s.cfg.src_opd_a ) | \
  //                  ( s.cfg.src_altbps == s.cfg.src_opd_b )
  //   if s.cfg.dst_altbps == CfgMsg.DST_NONE:
  //     s.altbps_opd @= 0
  
  always_comb begin : up_altbps_opd
    altbps_opd = ( cfg.src_altbps == cfg.src_opd_a ) | ( cfg.src_altbps == cfg.src_opd_b );
    if ( cfg.dst_altbps == 5'd0 ) begin
      altbps_opd = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:338
  // @update
  // def up_altbps_send_rdy():
  //   for i in range( 5 ):
  //     if s.cfg.dst_altbps[ i ]:
  //       s.altbps_send_rdys[i] @= s.send_rdys[i]
  //     else:
  //       s.altbps_send_rdys[i] @= 1
  // 
  //   if s.cfg.dst_altbps == CfgMsg.DST_NONE:
  //     s.altbps_send_rdy @= 0
  //   else:
  //     s.altbps_send_rdy @= reduce_and( s.altbps_send_rdys )
  
  always_comb begin : up_altbps_send_rdy
    for ( int i = 1'd0; i < 3'd5; i += 1'd1 )
      if ( cfg.dst_altbps[3'(i)] ) begin
        altbps_send_rdys[3'(i)] = send_rdys[3'(i)];
      end
      else
        altbps_send_rdys[3'(i)] = 1'd1;
    if ( cfg.dst_altbps == 5'd0 ) begin
      altbps_send_rdy = 1'd0;
    end
    else
      altbps_send_rdy = ( & altbps_send_rdys );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:186
  // @update
  // def up_br_deq_rdy():
  //   if s.is_branch:
  //     s.br_deq_rdy @= s.deq_rdys[ s.cfg.src_opd_a[0:2] ] & s.deq_rdys[ s.cfg.src_opd_b[0:2] ]
  //   else:
  //     s.br_deq_rdy @= 0
  
  always_comb begin : up_br_deq_rdy
    if ( is_branch ) begin
      br_deq_rdy = deq_rdys[cfg.src_opd_a[2'd1:2'd0]] & deq_rdys[cfg.src_opd_b[2'd1:2'd0]];
    end
    else
      br_deq_rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:193
  // @update
  // def up_br_dst():
  //   s.br_go_n    @= s.br_dst_true [ TD.NORTH ] &  s.branch_taken | \
  //                   s.br_dst_false[ TD.NORTH ] & ~s.branch_taken
  //   s.br_go_s    @= s.br_dst_true [ TD.SOUTH ] &  s.branch_taken | \
  //                   s.br_dst_false[ TD.SOUTH ] & ~s.branch_taken
  //   s.br_go_w    @= s.br_dst_true [ TD.WEST  ] &  s.branch_taken | \
  //                   s.br_dst_false[ TD.WEST  ] & ~s.branch_taken
  //   s.br_go_e    @= s.br_dst_true [ TD.EAST  ] &  s.branch_taken | \
  //                   s.br_dst_false[ TD.EAST  ] & ~s.branch_taken
  //   s.br_go_self @= s.br_dst_true [ TD.SELF  ] &  s.branch_taken | \
  //                   s.br_dst_false[ TD.SELF  ] & ~s.branch_taken
  
  always_comb begin : up_br_dst
    br_go_n = ( br_dst_true[3'd0] & branch_taken ) | ( br_dst_false[3'd0] & ( ~branch_taken ) );
    br_go_s = ( br_dst_true[3'd1] & branch_taken ) | ( br_dst_false[3'd1] & ( ~branch_taken ) );
    br_go_w = ( br_dst_true[3'd2] & branch_taken ) | ( br_dst_false[3'd2] & ( ~branch_taken ) );
    br_go_e = ( br_dst_true[3'd3] & branch_taken ) | ( br_dst_false[3'd3] & ( ~branch_taken ) );
    br_go_self = ( br_dst_true[3'd4] & branch_taken ) | ( br_dst_false[3'd4] & ( ~branch_taken ) );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:207
  // @update
  // def up_br_send_rdy():
  //   if s.is_branch:
  //     # Branch taken
  //     if s.branch_taken:
  //       if s.br_dst_true == CfgMsg.DST_NORTH:
  //         s.br_send_rdy @= s.send_rdy_n
  //       elif s.br_dst_true == CfgMsg.DST_SOUTH:
  //         s.br_send_rdy @= s.send_rdy_s
  //       elif s.br_dst_true == CfgMsg.DST_WEST:
  //         s.br_send_rdy @= s.send_rdy_w
  //       elif s.br_dst_true == CfgMsg.DST_EAST:
  //         s.br_send_rdy @= s.send_rdy_e
  //       else:
  //         s.br_send_rdy @= 1
  // 
  //     # Branch not taken
  //     else:
  //       if s.br_dst_false == CfgMsg.DST_NORTH:
  //         s.br_send_rdy @= s.send_rdy_n
  //       elif s.br_dst_false == CfgMsg.DST_SOUTH:
  //         s.br_send_rdy @= s.send_rdy_s
  //       elif s.br_dst_false == CfgMsg.DST_WEST:
  //         s.br_send_rdy @= s.send_rdy_w
  //       elif s.br_dst_false == CfgMsg.DST_EAST:
  //         s.br_send_rdy @= s.send_rdy_e
  //       else:
  //         s.br_send_rdy @= 1
  //   else:
  //     s.br_send_rdy @= 0
  
  always_comb begin : up_br_send_rdy
    if ( is_branch ) begin
      if ( branch_taken ) begin
        if ( br_dst_true == 5'd1 ) begin
          br_send_rdy = send_rdy_n;
        end
        else if ( br_dst_true == 5'd2 ) begin
          br_send_rdy = send_rdy_s;
        end
        else if ( br_dst_true == 5'd4 ) begin
          br_send_rdy = send_rdy_w;
        end
        else if ( br_dst_true == 5'd8 ) begin
          br_send_rdy = send_rdy_e;
        end
        else
          br_send_rdy = 1'd1;
      end
      else if ( br_dst_false == 5'd1 ) begin
        br_send_rdy = send_rdy_n;
      end
      else if ( br_dst_false == 5'd2 ) begin
        br_send_rdy = send_rdy_s;
      end
      else if ( br_dst_false == 5'd4 ) begin
        br_send_rdy = send_rdy_w;
      end
      else if ( br_dst_false == 5'd8 ) begin
        br_send_rdy = send_rdy_e;
      end
      else
        br_send_rdy = 1'd1;
    end
    else
      br_send_rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:182
  // @update
  // def up_branch_taken():
  //   s.branch_taken @= s.branch_cond > 0
  
  always_comb begin : up_branch_taken
    branch_taken = branch_cond > 32'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:300
  // @update
  // def up_bypass_deq_rdy():
  //   if s.bypass_opd:
  //     s.bypass_deq_rdy @= s.operands_deq_rdy
  //   elif s.cfg.src_bypass == CfgMsg.SRC_SELF:
  //     s.bypass_deq_rdy @= 1
  //   else:
  //     s.bypass_deq_rdy @= s.deq_rdys[ s.cfg.src_bypass[0:2] ]
  
  always_comb begin : up_bypass_deq_rdy
    if ( bypass_opd ) begin
      bypass_deq_rdy = operands_deq_rdy;
    end
    else if ( cfg.src_bypass == 3'd4 ) begin
      bypass_deq_rdy = 1'd1;
    end
    else
      bypass_deq_rdy = deq_rdys[cfg.src_bypass[2'd1:2'd0]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:293
  // @update
  // def up_bypass_opd():
  //   s.bypass_opd @= ( s.cfg.src_bypass == s.cfg.src_opd_a ) | \
  //                  ( s.cfg.src_bypass == s.cfg.src_opd_b )
  //   if s.cfg.dst_bypass == CfgMsg.DST_NONE:
  //     s.bypass_opd @= 0
  
  always_comb begin : up_bypass_opd
    bypass_opd = ( cfg.src_bypass == cfg.src_opd_a ) | ( cfg.src_bypass == cfg.src_opd_b );
    if ( cfg.dst_bypass == 5'd0 ) begin
      bypass_opd = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:309
  // @update
  // def up_bypass_send_rdy():
  //   for i in range( 5 ):
  //     if s.cfg.dst_bypass[ i ]:
  //       s.bypass_send_rdys[i] @= s.send_rdys[i]
  //     else:
  //       s.bypass_send_rdys[i] @= 1
  // 
  //   if s.cfg.dst_bypass == CfgMsg.DST_NONE:
  //     s.bypass_send_rdy @= 0
  //   else:
  //     s.bypass_send_rdy @= reduce_and( s.bypass_send_rdys )
  
  always_comb begin : up_bypass_send_rdy
    for ( int i = 1'd0; i < 3'd5; i += 1'd1 )
      if ( cfg.dst_bypass[3'(i)] ) begin
        bypass_send_rdys[3'(i)] = send_rdys[3'(i)];
      end
      else
        bypass_send_rdys[3'(i)] = 1'd1;
    if ( cfg.dst_bypass == 5'd0 ) begin
      bypass_send_rdy = 1'd0;
    end
    else
      bypass_send_rdy = ( & bypass_send_rdys );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:460
  // @update
  // def up_deq_en_e():
  //   # Kills enable signal during configuration
  //   if s.cfg_en:
  //     s.deq_en_e @= 0
  //   # Bypass operand
  //   elif s.bypass_opd & ( s.cfg.src_bypass == CfgMsg.SRC_EAST ):
  //     s.deq_en_e @= s.bypass_deq_rdy & s.bypass_send_rdy & s.node_recv_rdy
  // 
  //   # Bypass non-operand
  //   elif s.cfg.src_bypass == CfgMsg.SRC_EAST:
  //     s.deq_en_e @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //   # Alternative bypass operand
  //   elif s.altbps_opd & ( s.cfg.src_altbps == CfgMsg.SRC_EAST ):
  //     s.deq_en_e @= s.altbps_deq_rdy & s.altbps_send_rdy & s.node_recv_rdy
  // 
  //   # Alternative bypass non-operand
  //   elif s.cfg.src_altbps == CfgMsg.SRC_EAST:
  //     s.deq_en_e @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //   # Operand without bypassing
  //   elif s.use_east_q:
  //     # For phi node only either of src needs to be ready
  //     if s.cfg.func == CfgMsg.PHI:
  //       s.deq_en_e @= s.deq_rdy_e
  //     else:
  //       s.deq_en_e @= s.operands_deq_rdy & s.node_recv_rdy
  // 
  //   # Not selected
  //   else:
  //     s.deq_en_e @= 0
  
  always_comb begin : up_deq_en_e
    if ( cfg_en ) begin
      deq_en_e = 1'd0;
    end
    else if ( bypass_opd & ( cfg.src_bypass == 3'd3 ) ) begin
      deq_en_e = ( bypass_deq_rdy & bypass_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_bypass == 3'd3 ) begin
      deq_en_e = bypass_deq_rdy & bypass_send_rdy;
    end
    else if ( altbps_opd & ( cfg.src_altbps == 3'd3 ) ) begin
      deq_en_e = ( altbps_deq_rdy & altbps_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_altbps == 3'd3 ) begin
      deq_en_e = altbps_deq_rdy & altbps_send_rdy;
    end
    else if ( use_east_q ) begin
      if ( cfg.func == 5'd30 ) begin
        deq_en_e = deq_rdy_e;
      end
      else
        deq_en_e = operands_deq_rdy & node_recv_rdy;
    end
    else
      deq_en_e = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:360
  // @update
  // def up_deq_en_n():
  //   # Kills enable signal during configuration
  //   if s.cfg_en:
  //     s.deq_en_n @= 0
  // 
  //   # Bypass operand
  //   elif s.bypass_opd & ( s.cfg.src_bypass == CfgMsg.SRC_NORTH ):
  //     s.deq_en_n @= s.bypass_deq_rdy & s.bypass_send_rdy & s.node_recv_rdy
  // 
  //   # Bypass non-operand
  //   elif s.cfg.src_bypass == CfgMsg.SRC_NORTH:
  //     s.deq_en_n @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //   # Alternative bypass operand
  //   elif s.altbps_opd & ( s.cfg.src_altbps == CfgMsg.SRC_NORTH ) :
  //     s.deq_en_n @= s.altbps_deq_rdy & s.altbps_send_rdy & s.node_recv_rdy
  // 
  //   # Alternative bypass non-operand
  //   elif s.cfg.src_altbps == CfgMsg.SRC_NORTH:
  //     s.deq_en_n @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //   # Operand without bypassing
  //   elif s.use_north_q:
  //     # For phi node only either of src needs to be ready
  //     if s.cfg.func == CfgMsg.PHI:
  //       s.deq_en_n @= s.deq_rdy_n
  //     else:
  //       s.deq_en_n @= s.operands_deq_rdy & s.node_recv_rdy
  // 
  //   # Not selected
  //   else:
  //     s.deq_en_n @= 0
  
  always_comb begin : up_deq_en_n
    if ( cfg_en ) begin
      deq_en_n = 1'd0;
    end
    else if ( bypass_opd & ( cfg.src_bypass == 3'd0 ) ) begin
      deq_en_n = ( bypass_deq_rdy & bypass_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_bypass == 3'd0 ) begin
      deq_en_n = bypass_deq_rdy & bypass_send_rdy;
    end
    else if ( altbps_opd & ( cfg.src_altbps == 3'd0 ) ) begin
      deq_en_n = ( altbps_deq_rdy & altbps_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_altbps == 3'd0 ) begin
      deq_en_n = altbps_deq_rdy & altbps_send_rdy;
    end
    else if ( use_north_q ) begin
      if ( cfg.func == 5'd30 ) begin
        deq_en_n = deq_rdy_n;
      end
      else
        deq_en_n = operands_deq_rdy & node_recv_rdy;
    end
    else
      deq_en_n = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:394
  // @update
  // def up_deq_en_s():
  //   # Kills enable signal during configuration
  //   if s.cfg_en:
  //     s.deq_en_s @= 0
  //   # Bypass operand
  //   elif s.bypass_opd & ( s.cfg.src_bypass == CfgMsg.SRC_SOUTH ):
  //     s.deq_en_s @= s.bypass_deq_rdy & s.bypass_send_rdy & s.node_recv_rdy
  // 
  //   # Bypass non-operand
  //   elif s.cfg.src_bypass == CfgMsg.SRC_SOUTH:
  //     s.deq_en_s @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //   # Alternative bypass operand
  //   elif s.altbps_opd & ( s.cfg.src_altbps == CfgMsg.SRC_SOUTH ):
  //     s.deq_en_s @= s.altbps_deq_rdy & s.altbps_send_rdy & s.node_recv_rdy
  // 
  //   # Alternative bypass non-operand
  //   elif s.cfg.src_altbps == CfgMsg.SRC_SOUTH:
  //     s.deq_en_s @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //   # Operand without bypassing
  //   elif s.use_south_q:
  //     # For phi node only either of src needs to be ready
  //     if s.cfg.func == CfgMsg.PHI:
  //       s.deq_en_s @= s.deq_rdy_s
  //     else:
  //       s.deq_en_s @= s.operands_deq_rdy & s.node_recv_rdy
  // 
  //   # Not selected
  //   else:
  //     s.deq_en_s @= 0
  
  always_comb begin : up_deq_en_s
    if ( cfg_en ) begin
      deq_en_s = 1'd0;
    end
    else if ( bypass_opd & ( cfg.src_bypass == 3'd1 ) ) begin
      deq_en_s = ( bypass_deq_rdy & bypass_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_bypass == 3'd1 ) begin
      deq_en_s = bypass_deq_rdy & bypass_send_rdy;
    end
    else if ( altbps_opd & ( cfg.src_altbps == 3'd1 ) ) begin
      deq_en_s = ( altbps_deq_rdy & altbps_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_altbps == 3'd1 ) begin
      deq_en_s = altbps_deq_rdy & altbps_send_rdy;
    end
    else if ( use_south_q ) begin
      if ( cfg.func == 5'd30 ) begin
        deq_en_s = deq_rdy_s;
      end
      else
        deq_en_s = operands_deq_rdy & node_recv_rdy;
    end
    else
      deq_en_s = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:427
  // @update
  // def up_deq_en_w():
  //   # Kills enable signal during configuration
  //   if s.cfg_en:
  //     s.deq_en_w @= 0
  //   # Bypass operand
  //   elif s.bypass_opd & ( s.cfg.src_bypass == CfgMsg.SRC_WEST ):
  //     s.deq_en_w @= s.bypass_deq_rdy & s.bypass_send_rdy & s.node_recv_rdy
  // 
  //   # Bypass non-operand
  //   elif s.cfg.src_bypass == CfgMsg.SRC_WEST:
  //     s.deq_en_w @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //   # Alternative bypass operand
  //   elif s.altbps_opd & ( s.cfg.src_altbps == CfgMsg.SRC_WEST ):
  //     s.deq_en_w @= s.altbps_deq_rdy & s.altbps_send_rdy & s.node_recv_rdy
  // 
  //   # Alternative bypass non-operand
  //   elif s.cfg.src_altbps == CfgMsg.SRC_WEST:
  //     s.deq_en_w @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //   # Operand without bypassing
  //   elif s.use_west_q:
  //     # For phi node only either of src needs to be ready
  //     if s.cfg.func == CfgMsg.PHI:
  //       s.deq_en_w @= s.deq_rdy_w
  //     else:
  //       s.deq_en_w @= s.operands_deq_rdy & s.node_recv_rdy
  // 
  //   # Not selected
  //   else:
  //     s.deq_en_w @= 0
  
  always_comb begin : up_deq_en_w
    if ( cfg_en ) begin
      deq_en_w = 1'd0;
    end
    else if ( bypass_opd & ( cfg.src_bypass == 3'd2 ) ) begin
      deq_en_w = ( bypass_deq_rdy & bypass_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_bypass == 3'd2 ) begin
      deq_en_w = bypass_deq_rdy & bypass_send_rdy;
    end
    else if ( altbps_opd & ( cfg.src_altbps == 3'd2 ) ) begin
      deq_en_w = ( altbps_deq_rdy & altbps_send_rdy ) & node_recv_rdy;
    end
    else if ( cfg.src_altbps == 3'd2 ) begin
      deq_en_w = altbps_deq_rdy & altbps_send_rdy;
    end
    else if ( use_west_q ) begin
      if ( cfg.func == 5'd30 ) begin
        deq_en_w = deq_rdy_w;
      end
      else
        deq_en_w = operands_deq_rdy & node_recv_rdy;
    end
    else
      deq_en_w = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:178
  // @update
  // def up_is_branch():
  //   s.is_branch @= ( s.cfg.opcode == CfgMsg.OP_B_TYPE )
  
  always_comb begin : up_is_branch
    is_branch = cfg.opcode == 2'd1;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:240
  // @update
  // def up_node_cfg():
  //   s.node_cfg @= s.cfg.func
  //   if s.is_branch:
  //     s.node_cfg @= CfgMsg.CP0
  //   elif s.cfg.func == CfgMsg.PHI:
  //     if s.opd_a_deq_rdy:
  //       s.node_cfg @= CfgMsg.CP0
  //     elif s.opd_b_deq_rdy:
  //       s.node_cfg @= CfgMsg.CP1
  
  always_comb begin : up_node_cfg
    node_cfg = cfg.func;
    if ( is_branch ) begin
      node_cfg = 5'd0;
    end
    else if ( cfg.func == 5'd30 ) begin
      if ( opd_a_deq_rdy ) begin
        node_cfg = 5'd0;
      end
      else if ( opd_b_deq_rdy ) begin
        node_cfg = 5'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:252
  // @update
  // def up_node_cfg_func():
  //   s.node_cfg_func @= s.cfg.func
  
  always_comb begin : up_node_cfg_func
    node_cfg_func = cfg.func;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:524
  // @update
  // def up_node_recv_en():
  //   if s.cfg_en:
  //     s.node_recv_en @= 0
  //   elif s.cfg.func == CfgMsg.NOP:
  //     s.node_recv_en @= 0
  //   else:
  //     # For PHI node only one operand needs to be ready
  //     if s.cfg.func == CfgMsg.PHI:
  //       if ~s.bypass_opd & ~s.altbps_opd:
  //         s.node_recv_en @= ( s.opd_a_deq_rdy | s.opd_b_deq_rdy ) & s.node_recv_rdy
  //       elif s.bypass_opd:
  //         s.node_recv_en @= ( s.opd_a_deq_rdy | s.opd_b_deq_rdy ) & s.bypass_deq_rdy & s.node_recv_rdy
  //       elif s.altbps_opd:
  //         s.node_recv_en @= ( s.opd_a_deq_rdy | s.opd_b_deq_rdy ) & s.altbps_deq_rdy & s.node_recv_rdy
  //       else: # s.bypass_opd & s.altbps_opd
  //         s.node_recv_en @= ( s.opd_a_deq_rdy | s.opd_b_deq_rdy ) & s.bypass_deq_rdy & s.altbps_deq_rdy & s.node_recv_rdy
  // 
  //     elif s.bypass_opd:
  //       s.node_recv_en @= s.operands_deq_rdy & s.bypass_deq_rdy & s.node_recv_rdy
  //     elif s.altbps_opd:
  //       s.node_recv_en @= s.operands_deq_rdy & s.altbps_deq_rdy & s.node_recv_rdy
  //     else:
  //       s.node_recv_en @= s.operands_deq_rdy & s.node_recv_rdy
  
  always_comb begin : up_node_recv_en
    if ( cfg_en ) begin
      node_recv_en = 1'd0;
    end
    else if ( cfg.func == 5'd31 ) begin
      node_recv_en = 1'd0;
    end
    else if ( cfg.func == 5'd30 ) begin
      if ( ( ~bypass_opd ) & ( ~altbps_opd ) ) begin
        node_recv_en = ( opd_a_deq_rdy | opd_b_deq_rdy ) & node_recv_rdy;
      end
      else if ( bypass_opd ) begin
        node_recv_en = ( ( opd_a_deq_rdy | opd_b_deq_rdy ) & bypass_deq_rdy ) & node_recv_rdy;
      end
      else if ( altbps_opd ) begin
        node_recv_en = ( ( opd_a_deq_rdy | opd_b_deq_rdy ) & altbps_deq_rdy ) & node_recv_rdy;
      end
      else
        node_recv_en = ( ( ( opd_a_deq_rdy | opd_b_deq_rdy ) & bypass_deq_rdy ) & altbps_deq_rdy ) & node_recv_rdy;
    end
    else if ( bypass_opd ) begin
      node_recv_en = ( operands_deq_rdy & bypass_deq_rdy ) & node_recv_rdy;
    end
    else if ( altbps_opd ) begin
      node_recv_en = ( operands_deq_rdy & altbps_deq_rdy ) & node_recv_rdy;
    end
    else
      node_recv_en = operands_deq_rdy & node_recv_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:554
  // @update
  // def up_node_send_rdy():
  //   for i in range( 5 ):
  //     if s.cfg.dst_compute[i]:
  //       s.node_send_rdys[i] @= s.send_rdys[i]
  //     else:
  //       s.node_send_rdys[i] @= 1
  // 
  //   if s.is_branch:
  //     if s.bypass_opd:
  //       s.node_send_rdy @= s.br_send_rdy & s.bypass_send_rdy
  //     elif s.altbps_opd:
  //       s.node_send_rdy @= s.br_send_rdy & s.altbps_send_rdy
  //     else:
  //       s.node_send_rdy @= s.br_send_rdy
  // 
  //   elif s.cfg.dst_compute == CfgMsg.DST_NONE:
  //     s.node_send_rdy @= 0
  // 
  //   else:
  //     # FIXME: This part is tricky and may not be correct.
  //     if s.bypass_opd & s.altbps_opd:
  //       s.node_send_rdy @= reduce_and( s.node_send_rdys ) & s.bypass_send_rdy & s.altbps_send_rdy
  //     elif s.bypass_opd:
  //       s.node_send_rdy @= reduce_and( s.node_send_rdys ) & s.bypass_send_rdy
  //     elif s.altbps_opd:
  //       s.node_send_rdy @= reduce_and( s.node_send_rdys ) & s.altbps_send_rdy
  // 
  //     # FIXME: Why do I AND the bypass_send_rdy here?
  //     elif s.cfg.dst_bypass != CfgMsg.DST_NONE:
  //       s.node_send_rdy @= reduce_and( s.node_send_rdys ) # & s.bypass_send_rdy
  //     elif s.cfg.dst_altbps != CfgMsg.DST_NONE:
  //       s.node_send_rdy @= reduce_and( s.node_send_rdys ) # & s.altbps_send_rdy
  // 
  //     else:
  //       s.node_send_rdy @= reduce_and( s.node_send_rdys )
  
  always_comb begin : up_node_send_rdy
    for ( int i = 1'd0; i < 3'd5; i += 1'd1 )
      if ( cfg.dst_compute[3'(i)] ) begin
        node_send_rdys[3'(i)] = send_rdys[3'(i)];
      end
      else
        node_send_rdys[3'(i)] = 1'd1;
    if ( is_branch ) begin
      if ( bypass_opd ) begin
        node_send_rdy = br_send_rdy & bypass_send_rdy;
      end
      else if ( altbps_opd ) begin
        node_send_rdy = br_send_rdy & altbps_send_rdy;
      end
      else
        node_send_rdy = br_send_rdy;
    end
    else if ( cfg.dst_compute == 5'd0 ) begin
      node_send_rdy = 1'd0;
    end
    else if ( bypass_opd & altbps_opd ) begin
      node_send_rdy = ( ( & node_send_rdys ) & bypass_send_rdy ) & altbps_send_rdy;
    end
    else if ( bypass_opd ) begin
      node_send_rdy = ( & node_send_rdys ) & bypass_send_rdy;
    end
    else if ( altbps_opd ) begin
      node_send_rdy = ( & node_send_rdys ) & altbps_send_rdy;
    end
    else if ( cfg.dst_bypass != 5'd0 ) begin
      node_send_rdy = ( & node_send_rdys );
    end
    else if ( cfg.dst_altbps != 5'd0 ) begin
      node_send_rdy = ( & node_send_rdys );
    end
    else
      node_send_rdy = ( & node_send_rdys );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:271
  // @update
  // def up_opd_a_deq_rdy():
  //   if s.cfg.src_opd_a == CfgMsg.SRC_SELF:
  //     s.opd_a_deq_rdy @= s.riu.deq_rdy if s.cfg.func == CfgMsg.PHI else 1
  //   else:
  //     s.opd_a_deq_rdy @= s.deq_rdys[ s.cfg.src_opd_a[0:2] ]
  
  always_comb begin : up_opd_a_deq_rdy
    if ( cfg.src_opd_a == 3'd4 ) begin
      opd_a_deq_rdy = ( cfg.func == 5'd30 ) ? riu__deq_rdy : 1'd1;
    end
    else
      opd_a_deq_rdy = deq_rdys[cfg.src_opd_a[2'd1:2'd0]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:278
  // @update
  // def up_opd_b_deq_rdy():
  //   if s.cfg.src_opd_b == CfgMsg.SRC_SELF:
  //     s.opd_b_deq_rdy @= s.riu.deq_rdy if s.cfg.func == CfgMsg.PHI else 1
  //   else:
  //     s.opd_b_deq_rdy @= s.deq_rdys[ s.cfg.src_opd_b[0:2] ]
  
  always_comb begin : up_opd_b_deq_rdy
    if ( cfg.src_opd_b == 3'd4 ) begin
      opd_b_deq_rdy = ( cfg.func == 5'd30 ) ? riu__deq_rdy : 1'd1;
    end
    else
      opd_b_deq_rdy = deq_rdys[cfg.src_opd_b[2'd1:2'd0]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:285
  // @update
  // def up_opeands_rdy():
  //   s.operands_deq_rdy @= s.opd_a_deq_rdy & s.opd_b_deq_rdy
  
  always_comb begin : up_opeands_rdy
    operands_deq_rdy = opd_a_deq_rdy & opd_b_deq_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:355
  // @update
  // def up_riu_deq_en():
  //   s.riu.deq_en @= ( s.cfg.func == CfgMsg.PHI ) & s.node_recv_rdy & \
  //                  s.riu.deq_rdy & ~s.cfg_en & ~s.is_branch
  
  always_comb begin : up_riu_deq_en
    riu__deq_en = ( ( ( ( cfg.func == 5'd30 ) & node_recv_rdy ) & riu__deq_rdy ) & ( ~cfg_en ) ) & ( ~is_branch );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:788
  // @update
  // def up_send_en_e():
  //   # Kills enable signal during configuration
  //   s.send_en_e @= 0
  //   if ~s.cfg_en:
  //     # Bypass
  //     if s.bypass_opd & s.cfg.dst_bypass[ TD.EAST ]:
  //       s.send_en_e @= s.node_send_en
  //     elif s.cfg.dst_bypass[ TD.EAST ]:
  //       s.send_en_e @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //     # Alternative bypass
  //     if s.altbps_opd & s.cfg.dst_altbps[ TD.EAST ]:
  //       s.send_en_e @= s.node_send_en
  //     elif s.cfg.dst_altbps[ TD.EAST ]:
  //       s.send_en_e @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //     # Branch
  //     if s.is_branch:
  //       if ( ( s.branch_cond != 0 ) & ( s.br_dst_true [ TD.EAST ] ) ) | \
  //          ( ( s.branch_cond == 0 ) & ( s.br_dst_false[ TD.EAST ] ) ):
  //         s.send_en_e @= s.node_send_en & s.br_go_e
  //     # Other
  //     elif s.cfg.dst_compute[ TD.EAST ]:
  //         s.send_en_e @= s.node_send_en
  
  always_comb begin : up_send_en_e
    send_en_e = 1'd0;
    if ( ~cfg_en ) begin
      if ( bypass_opd & cfg.dst_bypass[3'd3] ) begin
        send_en_e = node_send_en;
      end
      else if ( cfg.dst_bypass[3'd3] ) begin
        send_en_e = bypass_deq_rdy & bypass_send_rdy;
      end
      if ( altbps_opd & cfg.dst_altbps[3'd3] ) begin
        send_en_e = node_send_en;
      end
      else if ( cfg.dst_altbps[3'd3] ) begin
        send_en_e = altbps_deq_rdy & altbps_send_rdy;
      end
      if ( is_branch ) begin
        if ( ( ( branch_cond != 32'd0 ) & br_dst_true[3'd3] ) | ( ( branch_cond == 32'd0 ) & br_dst_false[3'd3] ) ) begin
          send_en_e = node_send_en & br_go_e;
        end
      end
      else if ( cfg.dst_compute[3'd3] ) begin
        send_en_e = node_send_en;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:710
  // @update
  // def up_send_en_n():
  //   # Kills enable signal during configuration
  //   s.send_en_n @= 0
  //   if ~s.cfg_en:
  //     # Bypass
  //     if s.bypass_opd & s.cfg.dst_bypass[ TD.NORTH ]:
  //       s.send_en_n @= s.node_send_en
  //     elif s.cfg.dst_bypass[ TD.NORTH ]:
  //       s.send_en_n @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //     # Alternative bypass
  //     if s.altbps_opd & s.cfg.dst_altbps[ TD.NORTH ]:
  //       s.send_en_n @= s.node_send_en
  //     elif s.cfg.dst_altbps[ TD.NORTH ]:
  //       s.send_en_n @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //     # Branch
  //     if s.is_branch:
  //       if ( ( s.branch_cond != 0 ) & ( s.br_dst_true [ TD.NORTH ] ) ) | \
  //          ( ( s.branch_cond == 0 ) & ( s.br_dst_false[ TD.NORTH ] ) ):
  //         s.send_en_n @= s.node_send_en & s.br_go_n
  //     # Other
  //     elif s.cfg.dst_compute[ TD.NORTH ]:
  //         s.send_en_n @= s.node_send_en
  
  always_comb begin : up_send_en_n
    send_en_n = 1'd0;
    if ( ~cfg_en ) begin
      if ( bypass_opd & cfg.dst_bypass[3'd0] ) begin
        send_en_n = node_send_en;
      end
      else if ( cfg.dst_bypass[3'd0] ) begin
        send_en_n = bypass_deq_rdy & bypass_send_rdy;
      end
      if ( altbps_opd & cfg.dst_altbps[3'd0] ) begin
        send_en_n = node_send_en;
      end
      else if ( cfg.dst_altbps[3'd0] ) begin
        send_en_n = altbps_deq_rdy & altbps_send_rdy;
      end
      if ( is_branch ) begin
        if ( ( ( branch_cond != 32'd0 ) & br_dst_true[3'd0] ) | ( ( branch_cond == 32'd0 ) & br_dst_false[3'd0] ) ) begin
          send_en_n = node_send_en & br_go_n;
        end
      end
      else if ( cfg.dst_compute[3'd0] ) begin
        send_en_n = node_send_en;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:736
  // @update
  // def up_send_en_s():
  //   # Kills enable signal during configuration
  //   s.send_en_s @= 0
  //   if ~s.cfg_en:
  //     # Bypass
  //     if s.bypass_opd & s.cfg.dst_bypass[ TD.SOUTH ]:
  //       s.send_en_s @= s.node_send_en
  //     elif s.cfg.dst_bypass[ TD.SOUTH ]:
  //       s.send_en_s @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //     # Alternative bypass
  //     if s.altbps_opd & s.cfg.dst_altbps[ TD.SOUTH ]:
  //       s.send_en_s @= s.node_send_en
  //     elif s.cfg.dst_altbps[ TD.SOUTH ]:
  //       s.send_en_s @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //     # Branch
  //     if s.is_branch:
  //       if ( ( s.branch_cond != 0 ) & ( s.br_dst_true [ TD.SOUTH ] ) ) | \
  //          ( ( s.branch_cond == 0 ) & ( s.br_dst_false[ TD.SOUTH ] ) ):
  //         s.send_en_s @= s.node_send_en & s.br_go_s
  //     # Other
  //     elif s.cfg.dst_compute[ TD.SOUTH ]:
  //         s.send_en_s @= s.node_send_en
  
  always_comb begin : up_send_en_s
    send_en_s = 1'd0;
    if ( ~cfg_en ) begin
      if ( bypass_opd & cfg.dst_bypass[3'd1] ) begin
        send_en_s = node_send_en;
      end
      else if ( cfg.dst_bypass[3'd1] ) begin
        send_en_s = bypass_deq_rdy & bypass_send_rdy;
      end
      if ( altbps_opd & cfg.dst_altbps[3'd1] ) begin
        send_en_s = node_send_en;
      end
      else if ( cfg.dst_altbps[3'd1] ) begin
        send_en_s = altbps_deq_rdy & altbps_send_rdy;
      end
      if ( is_branch ) begin
        if ( ( ( branch_cond != 32'd0 ) & br_dst_true[3'd1] ) | ( ( branch_cond == 32'd0 ) & br_dst_false[3'd1] ) ) begin
          send_en_s = node_send_en & br_go_s;
        end
      end
      else if ( cfg.dst_compute[3'd1] ) begin
        send_en_s = node_send_en;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:762
  // @update
  // def up_send_en_w():
  //   # Kills enable signal during configuration
  //   s.send_en_w @= 0
  //   if ~s.cfg_en:
  //     # Bypass
  //     if s.bypass_opd & s.cfg.dst_bypass[ TD.WEST ]:
  //       s.send_en_w @= s.node_send_en
  //     elif s.cfg.dst_bypass[ TD.WEST ]:
  //       s.send_en_w @= s.bypass_deq_rdy & s.bypass_send_rdy
  // 
  //     # Alternative bypass
  //     if s.altbps_opd & s.cfg.dst_altbps[ TD.WEST ]:
  //       s.send_en_w @= s.node_send_en
  //     elif s.cfg.dst_altbps[ TD.WEST ]:
  //       s.send_en_w @= s.altbps_deq_rdy & s.altbps_send_rdy
  // 
  //     # Branch
  //     if s.is_branch:
  //       if ( ( s.branch_cond != 0 ) & ( s.br_dst_true [ TD.WEST ] ) ) | \
  //          ( ( s.branch_cond == 0 ) & ( s.br_dst_false[ TD.WEST ] ) ):
  //         s.send_en_w @= s.node_send_en & s.br_go_w
  //     # Other
  //     elif s.cfg.dst_compute[ TD.WEST ]:
  //         s.send_en_w @= s.node_send_en
  
  always_comb begin : up_send_en_w
    send_en_w = 1'd0;
    if ( ~cfg_en ) begin
      if ( bypass_opd & cfg.dst_bypass[3'd2] ) begin
        send_en_w = node_send_en;
      end
      else if ( cfg.dst_bypass[3'd2] ) begin
        send_en_w = bypass_deq_rdy & bypass_send_rdy;
      end
      if ( altbps_opd & cfg.dst_altbps[3'd2] ) begin
        send_en_w = node_send_en;
      end
      else if ( cfg.dst_altbps[3'd2] ) begin
        send_en_w = altbps_deq_rdy & altbps_send_rdy;
      end
      if ( is_branch ) begin
        if ( ( ( branch_cond != 32'd0 ) & br_dst_true[3'd2] ) | ( ( branch_cond == 32'd0 ) & br_dst_false[3'd2] ) ) begin
          send_en_w = node_send_en & br_go_w;
        end
      end
      else if ( cfg.dst_compute[3'd2] ) begin
        send_en_w = node_send_en;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:685
  // @update
  // def up_send_mux_e_sel():
  //   # Branch
  //   if s.is_branch:
  //     s.send_mux_e_sel @= 0
  //     if s.cfg.dst_bypass[ TD.EAST ]:
  //       s.send_mux_e_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.EAST ]:
  //       s.send_mux_e_sel @= OutputMux.BPS_ALT
  //     if s.br_dst_true[ TD.EAST ] | s.br_dst_true[ TD.EAST ]:
  //       s.send_mux_e_sel @= OutputMux.COMPUTE
  //   # Other
  //   else:
  //     s.send_mux_e_sel @= 0
  //     if s.cfg.dst_bypass[ TD.EAST ]:
  //       s.send_mux_e_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.EAST ]:
  //       s.send_mux_e_sel @= OutputMux.BPS_ALT
  //     if s.cfg.dst_compute[ TD.EAST ]:
  //       s.send_mux_e_sel @= OutputMux.COMPUTE
  
  always_comb begin : up_send_mux_e_sel
    if ( is_branch ) begin
      send_mux_e_sel = 2'd0;
      if ( cfg.dst_bypass[3'd3] ) begin
        send_mux_e_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd3] ) begin
        send_mux_e_sel = 2'd2;
      end
      if ( br_dst_true[3'd3] | br_dst_true[3'd3] ) begin
        send_mux_e_sel = 2'd0;
      end
    end
    else begin
      send_mux_e_sel = 2'd0;
      if ( cfg.dst_bypass[3'd3] ) begin
        send_mux_e_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd3] ) begin
        send_mux_e_sel = 2'd2;
      end
      if ( cfg.dst_compute[3'd3] ) begin
        send_mux_e_sel = 2'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:622
  // @update
  // def up_send_mux_n_sel():
  //   # Branch
  //   if s.is_branch:
  //     s.send_mux_n_sel @= 0
  //     if s.cfg.dst_bypass[ TD.NORTH ]:
  //       s.send_mux_n_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.NORTH ]:
  //       s.send_mux_n_sel @= OutputMux.BPS_ALT
  //     if s.br_dst_true[ TD.NORTH ] | s.br_dst_true[ TD.NORTH ]:
  //       s.send_mux_n_sel @= OutputMux.COMPUTE
  //   # Other
  //   else:
  //     s.send_mux_n_sel @= 0
  //     if s.cfg.dst_bypass[ TD.NORTH ]:
  //       s.send_mux_n_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.NORTH ]:
  //       s.send_mux_n_sel @= OutputMux.BPS_ALT
  //     if s.cfg.dst_compute[ TD.NORTH ]:
  //       s.send_mux_n_sel @= OutputMux.COMPUTE
  
  always_comb begin : up_send_mux_n_sel
    if ( is_branch ) begin
      send_mux_n_sel = 2'd0;
      if ( cfg.dst_bypass[3'd0] ) begin
        send_mux_n_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd0] ) begin
        send_mux_n_sel = 2'd2;
      end
      if ( br_dst_true[3'd0] | br_dst_true[3'd0] ) begin
        send_mux_n_sel = 2'd0;
      end
    end
    else begin
      send_mux_n_sel = 2'd0;
      if ( cfg.dst_bypass[3'd0] ) begin
        send_mux_n_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd0] ) begin
        send_mux_n_sel = 2'd2;
      end
      if ( cfg.dst_compute[3'd0] ) begin
        send_mux_n_sel = 2'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:643
  // @update
  // def up_send_mux_s_sel():
  //   # Branch
  //   if s.is_branch:
  //     s.send_mux_s_sel @= 0
  //     if s.cfg.dst_bypass[ TD.SOUTH ]:
  //       s.send_mux_s_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.SOUTH ]:
  //       s.send_mux_s_sel @= OutputMux.BPS_ALT
  //     if s.br_dst_true[ TD.SOUTH ] | s.br_dst_true[ TD.SOUTH ]:
  //       s.send_mux_s_sel @= OutputMux.COMPUTE
  //   # Other
  //   else:
  //     s.send_mux_s_sel @= 0
  //     if s.cfg.dst_bypass[ TD.SOUTH ]:
  //       s.send_mux_s_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.SOUTH ]:
  //       s.send_mux_s_sel @= OutputMux.BPS_ALT
  //     if s.cfg.dst_compute[ TD.SOUTH ]:
  //       s.send_mux_s_sel @= OutputMux.COMPUTE
  
  always_comb begin : up_send_mux_s_sel
    if ( is_branch ) begin
      send_mux_s_sel = 2'd0;
      if ( cfg.dst_bypass[3'd1] ) begin
        send_mux_s_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd1] ) begin
        send_mux_s_sel = 2'd2;
      end
      if ( br_dst_true[3'd1] | br_dst_true[3'd1] ) begin
        send_mux_s_sel = 2'd0;
      end
    end
    else begin
      send_mux_s_sel = 2'd0;
      if ( cfg.dst_bypass[3'd1] ) begin
        send_mux_s_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd1] ) begin
        send_mux_s_sel = 2'd2;
      end
      if ( cfg.dst_compute[3'd1] ) begin
        send_mux_s_sel = 2'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:664
  // @update
  // def up_send_mux_w_sel():
  //   # Branch
  //   if s.is_branch:
  //     s.send_mux_w_sel @= 0
  //     if s.cfg.dst_bypass[ TD.WEST ]:
  //       s.send_mux_w_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.WEST ]:
  //       s.send_mux_w_sel @= OutputMux.BPS_ALT
  //     if s.br_dst_true[ TD.WEST ] | s.br_dst_true[ TD.WEST ]:
  //       s.send_mux_w_sel @= OutputMux.COMPUTE
  //   # Other
  //   else:
  //     s.send_mux_w_sel @= 0
  //     if s.cfg.dst_bypass[ TD.WEST ]:
  //       s.send_mux_w_sel @= OutputMux.BYPASS
  //     if s.cfg.dst_altbps[ TD.WEST ]:
  //       s.send_mux_w_sel @= OutputMux.BPS_ALT
  //     if s.cfg.dst_compute[ TD.WEST ]:
  //       s.send_mux_w_sel @= OutputMux.COMPUTE
  
  always_comb begin : up_send_mux_w_sel
    if ( is_branch ) begin
      send_mux_w_sel = 2'd0;
      if ( cfg.dst_bypass[3'd2] ) begin
        send_mux_w_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd2] ) begin
        send_mux_w_sel = 2'd2;
      end
      if ( br_dst_true[3'd2] | br_dst_true[3'd2] ) begin
        send_mux_w_sel = 2'd0;
      end
    end
    else begin
      send_mux_w_sel = 2'd0;
      if ( cfg.dst_bypass[3'd2] ) begin
        send_mux_w_sel = 2'd1;
      end
      if ( cfg.dst_altbps[3'd2] ) begin
        send_mux_w_sel = 2'd2;
      end
      if ( cfg.dst_compute[3'd2] ) begin
        send_mux_w_sel = 2'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:260
  // @update
  // def up_use_logic():
  //   s.use_north_q @= ( s.cfg.src_opd_a  == CfgMsg.SRC_NORTH ) | \
  //                    ( s.cfg.src_opd_b  == CfgMsg.SRC_NORTH )
  //   s.use_south_q @= ( s.cfg.src_opd_a  == CfgMsg.SRC_SOUTH ) | \
  //                    ( s.cfg.src_opd_b  == CfgMsg.SRC_SOUTH )
  //   s.use_west_q  @= ( s.cfg.src_opd_a  == CfgMsg.SRC_WEST  ) | \
  //                    ( s.cfg.src_opd_b  == CfgMsg.SRC_WEST  )
  //   s.use_east_q  @= ( s.cfg.src_opd_a  == CfgMsg.SRC_EAST  ) | \
  //                    ( s.cfg.src_opd_b  == CfgMsg.SRC_EAST  )
  
  always_comb begin : up_use_logic
    use_north_q = ( cfg.src_opd_a == 3'd0 ) | ( cfg.src_opd_b == 3'd0 );
    use_south_q = ( cfg.src_opd_a == 3'd1 ) | ( cfg.src_opd_b == 3'd1 );
    use_west_q = ( cfg.src_opd_a == 3'd2 ) | ( cfg.src_opd_b == 3'd2 );
    use_east_q = ( cfg.src_opd_a == 3'd3 ) | ( cfg.src_opd_b == 3'd3 );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:162
  // @update_ff
  // def register_cfg():
  //   if s.reset | s.cfg_init:
  //     s.cfg <<= p.pe_cfg_type()
  //   elif s.cfg_en:
  //     s.cfg <<= s.cfg_wire
  
  always_ff @(posedge clk) begin : register_cfg
    if ( reset | cfg_init ) begin
      cfg <= { 2'd0, 5'd0, 3'd0, 3'd0, 5'd0, 3'd0, 5'd0, 3'd0, 5'd0, 14'd0, 1'd0 };
    end
    else if ( cfg_en ) begin
      cfg <= cfg_wire;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticCtrl.py:169
  // @update_ff
  // def register_is_PE_cfg_done():
  //   if s.reset | s.cfg_init:
  //     s.is_cfg_done <<= 0
  //   elif s.self_cfg_deq:
  //     s.is_cfg_done <<= 1
  
  always_ff @(posedge clk) begin : register_is_PE_cfg_done
    if ( reset | cfg_init ) begin
      is_cfg_done <= 1'd0;
    end
    else if ( self_cfg_deq ) begin
      is_cfg_done <= 1'd1;
    end
  end

  assign riu__clk = clk;
  assign riu__reset = reset;
  assign deq_rdys[0:0] = deq_rdy_n;
  assign deq_rdys[1:1] = deq_rdy_s;
  assign deq_rdys[2:2] = deq_rdy_w;
  assign deq_rdys[3:3] = deq_rdy_e;
  assign send_rdys[0:0] = send_rdy_n;
  assign send_rdys[1:1] = send_rdy_s;
  assign send_rdys[2:2] = send_rdy_w;
  assign send_rdys[3:3] = send_rdy_e;
  assign send_rdys[4:4] = 1'd1;
  assign br_src_data = cfg.src_opd_a;
  assign br_src_bool = cfg.src_opd_b;
  assign br_dst_true = cfg.dst_compute;
  assign br_dst_false = cfg.func;
  assign cfg_en = self_cfg_deq;
  assign imm_partial = cfg.immediate;
  assign opd_a_mux_sel = cfg.src_opd_a;
  assign opd_b_mux_sel = cfg.src_opd_b;
  assign bypass_mux_sel = cfg.src_bypass;
  assign altbps_mux_sel = cfg.src_altbps;

endmodule


// PyMTL Component Mux Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py

module Mux__Type_Bits32__ninputs_4
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:3],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py

module RegEn__Type_Bits32
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py

module Mux__Type_Bits32__ninputs_5
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:4],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component Alu Definition
// At /work/global/pp482/uecgra-src/src/cgra/Alu.py

module Alu__Type_Bits32
(
  input  logic [0:0] clk ,
  input  logic [4:0] fn ,
  input  logic [31:0] in0 ,
  input  logic [31:0] in1 ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__shamt_at_comb_logic  = 3'd5;
  logic [0:0] a_eq_b;
  logic [0:0] a_gt_b;
  logic [31:0] add_a_wire;
  logic [31:0] add_b_wire;
  logic [31:0] and_a_wire;
  logic [31:0] and_b_wire;
  logic [31:0] cp0_wire;
  logic [31:0] cp1_wire;
  logic [31:0] eq_a_wire;
  logic [31:0] eq_b_wire;
  logic [31:0] gt_a_wire;
  logic [31:0] gt_b_wire;
  logic [31:0] or_a_wire;
  logic [31:0] or_b_wire;
  logic [31:0] sll_a_wire;
  logic [31:0] sll_b_wire;
  logic [31:0] srl_a_wire;
  logic [31:0] srl_b_wire;
  logic [31:0] sub_a_wire;
  logic [31:0] sub_b_wire;
  logic [31:0] xor_a_wire;
  logic [31:0] xor_b_wire;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Alu.py:111
  // @update
  // def comb_logic():
  //   if   s.fn == AluOp.CP0: s.out @= s.cp0_wire                                    # COPY OP0
  //   elif s.fn == AluOp.CP1: s.out @= s.cp1_wire                                    # COPY OP1
  //   elif s.fn == AluOp.ADD: s.out @= s.add_a_wire + s.add_b_wire                   # ADD
  //   elif s.fn == AluOp.SUB: s.out @= s.sub_a_wire - s.sub_b_wire                   # SUB
  //   elif s.fn == AluOp.SLL: s.out @= s.sll_a_wire << s.sll_b_wire[0:shamt]         # SLL
  //   elif s.fn == AluOp.SRL: s.out @= s.srl_a_wire >> s.srl_b_wire[0:shamt]         # SRL
  //   elif s.fn == AluOp.AND: s.out @= s.and_a_wire & s.and_b_wire                   # AND
  //   elif s.fn == AluOp.OR : s.out @= s.or_a_wire  | s.or_b_wire                    # OR
  //   elif s.fn == AluOp.XOR: s.out @= s.xor_a_wire ^ s.xor_b_wire                   # XOR
  //   elif s.fn == AluOp.EQ : s.out @= 1 if  s.a_eq_b else 0                         # EQ
  //   elif s.fn == AluOp.NE : s.out @= 1 if ~s.a_eq_b else 0                         # NE
  //   elif s.fn == AluOp.GT : s.out @= 1 if  s.a_gt_b else 0                         # GT
  //   elif s.fn == AluOp.GEQ: s.out @= 1 if  s.a_gt_b |  s.a_eq_b else 0             # GEQ
  //   elif s.fn == AluOp.LT : s.out @= 1 if ~s.a_gt_b & ~s.a_eq_b else 0             # GEQ
  //   elif s.fn == AluOp.LEQ: s.out @= 1 if ~s.a_gt_b             else 0             # GEQ
  //   else:                   s.out @= 0                                             # NOP
  
  always_comb begin : comb_logic
    if ( fn == 5'd0 ) begin
      out = cp0_wire;
    end
    else if ( fn == 5'd1 ) begin
      out = cp1_wire;
    end
    else if ( fn == 5'd2 ) begin
      out = add_a_wire + add_b_wire;
    end
    else if ( fn == 5'd3 ) begin
      out = sub_a_wire - sub_b_wire;
    end
    else if ( fn == 5'd4 ) begin
      out = sll_a_wire << sll_b_wire[5'd4:5'd0];
    end
    else if ( fn == 5'd5 ) begin
      out = srl_a_wire >> srl_b_wire[5'd4:5'd0];
    end
    else if ( fn == 5'd6 ) begin
      out = and_a_wire & and_b_wire;
    end
    else if ( fn == 5'd7 ) begin
      out = or_a_wire | or_b_wire;
    end
    else if ( fn == 5'd8 ) begin
      out = xor_a_wire ^ xor_b_wire;
    end
    else if ( fn == 5'd9 ) begin
      out = a_eq_b ? 32'd1 : 32'd0;
    end
    else if ( fn == 5'd10 ) begin
      out = ( ~a_eq_b ) ? 32'd1 : 32'd0;
    end
    else if ( fn == 5'd11 ) begin
      out = a_gt_b ? 32'd1 : 32'd0;
    end
    else if ( fn == 5'd12 ) begin
      out = ( a_gt_b | a_eq_b ) ? 32'd1 : 32'd0;
    end
    else if ( fn == 5'd13 ) begin
      out = ( ( ~a_gt_b ) & ( ~a_eq_b ) ) ? 32'd1 : 32'd0;
    end
    else if ( fn == 5'd14 ) begin
      out = ( ~a_gt_b ) ? 32'd1 : 32'd0;
    end
    else
      out = 32'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Alu.py:64
  // @update
  // def up_data_gating():
  //   s.cp0_wire   @= s.in0 if s.fn == AluOp.CP0 else 0
  //   s.cp1_wire   @= s.in1 if s.fn == AluOp.CP1 else 0
  // 
  //   s.add_a_wire @= s.in0 if s.fn == AluOp.ADD else 0
  //   s.add_b_wire @= s.in1 if s.fn == AluOp.ADD else 0
  // 
  //   s.sub_a_wire @= s.in0 if s.fn == AluOp.SUB else 0
  //   s.sub_b_wire @= s.in1 if s.fn == AluOp.SUB else 0
  // 
  //   s.sll_a_wire @= s.in0 if s.fn == AluOp.SLL else 0
  //   s.sll_b_wire @= s.in1 if s.fn == AluOp.SLL else 0
  // 
  //   s.srl_a_wire @= s.in0 if s.fn == AluOp.SRL else 0
  //   s.srl_b_wire @= s.in1 if s.fn == AluOp.SRL else 0
  // 
  //   s.and_a_wire @= s.in0 if s.fn == AluOp.AND else 0
  //   s.and_b_wire @= s.in1 if s.fn == AluOp.AND else 0
  // 
  //   s.or_a_wire  @= s.in0 if s.fn == AluOp.OR  else 0
  //   s.or_b_wire  @= s.in1 if s.fn == AluOp.OR  else 0
  // 
  //   s.xor_a_wire @= s.in0 if s.fn == AluOp.XOR else 0
  //   s.xor_b_wire @= s.in1 if s.fn == AluOp.XOR else 0
  // 
  //   if ( s.fn == AluOp.EQ  ) | ( s.fn == AluOp.NE ) | \
  //      ( s.fn == AluOp.GEQ ) | ( s.fn == AluOp.LT ):
  //     s.eq_a_wire @= s.in0
  //     s.eq_b_wire @= s.in1
  //   else:
  //     s.eq_a_wire @= 0
  //     s.eq_b_wire @= 0
  // 
  //   if ( s.fn == AluOp.GT ) | ( s.fn == AluOp.GEQ ) | \
  //      ( s.fn == AluOp.LT ) | ( s.fn == AluOp.LEQ ):
  //     s.gt_a_wire @= s.in0
  //     s.gt_b_wire @= s.in1
  //   else:
  //     s.gt_a_wire @= 0
  //     s.gt_b_wire @= 0
  
  always_comb begin : up_data_gating
    cp0_wire = ( fn == 5'd0 ) ? in0 : 32'd0;
    cp1_wire = ( fn == 5'd1 ) ? in1 : 32'd0;
    add_a_wire = ( fn == 5'd2 ) ? in0 : 32'd0;
    add_b_wire = ( fn == 5'd2 ) ? in1 : 32'd0;
    sub_a_wire = ( fn == 5'd3 ) ? in0 : 32'd0;
    sub_b_wire = ( fn == 5'd3 ) ? in1 : 32'd0;
    sll_a_wire = ( fn == 5'd4 ) ? in0 : 32'd0;
    sll_b_wire = ( fn == 5'd4 ) ? in1 : 32'd0;
    srl_a_wire = ( fn == 5'd5 ) ? in0 : 32'd0;
    srl_b_wire = ( fn == 5'd5 ) ? in1 : 32'd0;
    and_a_wire = ( fn == 5'd6 ) ? in0 : 32'd0;
    and_b_wire = ( fn == 5'd6 ) ? in1 : 32'd0;
    or_a_wire = ( fn == 5'd7 ) ? in0 : 32'd0;
    or_b_wire = ( fn == 5'd7 ) ? in1 : 32'd0;
    xor_a_wire = ( fn == 5'd8 ) ? in0 : 32'd0;
    xor_b_wire = ( fn == 5'd8 ) ? in1 : 32'd0;
    if ( ( ( ( fn == 5'd9 ) | ( fn == 5'd10 ) ) | ( fn == 5'd12 ) ) | ( fn == 5'd13 ) ) begin
      eq_a_wire = in0;
      eq_b_wire = in1;
    end
    else begin
      eq_a_wire = 32'd0;
      eq_b_wire = 32'd0;
    end
    if ( ( ( ( fn == 5'd11 ) | ( fn == 5'd12 ) ) | ( fn == 5'd13 ) ) | ( fn == 5'd14 ) ) begin
      gt_a_wire = in0;
      gt_b_wire = in1;
    end
    else begin
      gt_a_wire = 32'd0;
      gt_b_wire = 32'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Alu.py:106
  // @update
  // def up_eq_gt_wire():
  //   s.a_eq_b @= s.eq_a_wire == s.eq_b_wire
  //   s.a_gt_b @= s.gt_a_wire > s.gt_b_wire
  
  always_comb begin : up_eq_gt_wire
    a_eq_b = eq_a_wire == eq_b_wire;
    a_gt_b = gt_a_wire > gt_b_wire;
  end

endmodule


// PyMTL Component Mul Definition
// At /work/global/pp482/uecgra-src/src/cgra/Mul.py

module Mul__OpdType_Bits32
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input AluMsg_32 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [31:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  logic [31:0] opd_a_wire;
  logic [31:0] opd_b_wire;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Mul.py:46
  // @update
  // def up_mul_send():
  //   s.send.msg @= s.opd_a_wire * s.opd_b_wire
  //   s.recv.rdy @= s.send.rdy
  //   s.send.en  @= s.recv.en
  
  always_comb begin : up_mul_send
    send__msg = opd_a_wire * opd_b_wire;
    recv__rdy = send__rdy;
    send__en = recv__en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Mul.py:37
  // @update
  // def up_opd_wires():
  //   if s.send.en:
  //     s.opd_a_wire @= s.recv.msg.opd_a
  //     s.opd_b_wire @= s.recv.msg.opd_b
  //   else:
  //     s.opd_a_wire @= 0
  //     s.opd_b_wire @= 0
  
  always_comb begin : up_opd_wires
    if ( send__en ) begin
      opd_a_wire = recv__msg.opd_a;
      opd_b_wire = recv__msg.opd_b;
    end
    else begin
      opd_a_wire = 32'd0;
      opd_b_wire = 32'd0;
    end
  end

endmodule


// PyMTL Component Node Definition
// At /work/global/pp482/uecgra-src/src/cgra/Node.py

module Node__Type_Bits32__mul_ncycles_0
(
  input  logic [4:0] cfg ,
  input  logic [4:0] cfg_func ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input AluMsg_32 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [31:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [0:0] __const__IDLE_at_up_en_msg  = 1'd0;
  localparam logic [0:0] __const__IDLE_at_up_rdy  = 1'd0;
  localparam logic [0:0] __const__IDLE_at_up_state  = 1'd0;
  localparam logic [0:0] __const__IDLE_at_up_state_next  = 1'd0;
  localparam logic [0:0] __const__MUL_at_up_state_next  = 1'd1;
  logic [31:0] alu_opd_a;
  logic [31:0] alu_opd_b;
  logic [31:0] mul_opd_a;
  logic [31:0] mul_opd_b;
  logic [0:0] state;
  logic [0:0] state_next;
  //-------------------------------------------------------------
  // Component alu
  //-------------------------------------------------------------

  logic [0:0] alu__clk;
  logic [4:0] alu__fn;
  logic [31:0] alu__in0;
  logic [31:0] alu__in1;
  logic [31:0] alu__out;
  logic [0:0] alu__reset;

  Alu__Type_Bits32 alu
  (
    .clk( alu__clk ),
    .fn( alu__fn ),
    .in0( alu__in0 ),
    .in1( alu__in1 ),
    .out( alu__out ),
    .reset( alu__reset )
  );

  //-------------------------------------------------------------
  // End of component alu
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mul
  //-------------------------------------------------------------

  logic [0:0] mul__clk;
  logic [0:0] mul__reset;
  logic [0:0] mul__recv__en;
  AluMsg_32 mul__recv__msg;
  logic [0:0] mul__recv__rdy;
  logic [0:0] mul__send__en;
  logic [31:0] mul__send__msg;
  logic [0:0] mul__send__rdy;

  Mul__OpdType_Bits32 mul
  (
    .clk( mul__clk ),
    .reset( mul__reset ),
    .recv__en( mul__recv__en ),
    .recv__msg( mul__recv__msg ),
    .recv__rdy( mul__recv__rdy ),
    .send__en( mul__send__en ),
    .send__msg( mul__send__msg ),
    .send__rdy( mul__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component mul
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Node.py:63
  // @update
  // def up_data_gating():
  //   if s.cfg_func == NodeConfig.NOP:
  //     s.mul_opd_a @= 0
  //     s.mul_opd_b @= 0
  //     s.alu_opd_a @= 0
  //     s.alu_opd_b @= 0
  //   elif s.cfg_func == NodeConfig.MUL:
  //     s.mul_opd_a @= s.recv.msg.opd_a
  //     s.mul_opd_b @= s.recv.msg.opd_b
  //     s.alu_opd_a @= 0
  //     s.alu_opd_b @= 0
  //   else:
  //     s.mul_opd_a @= 0
  //     s.mul_opd_b @= 0
  //     s.alu_opd_a @= s.recv.msg.opd_a
  //     s.alu_opd_b @= s.recv.msg.opd_b
  
  always_comb begin : up_data_gating
    if ( cfg_func == 5'd31 ) begin
      mul_opd_a = 32'd0;
      mul_opd_b = 32'd0;
      alu_opd_a = 32'd0;
      alu_opd_b = 32'd0;
    end
    else if ( cfg_func == 5'd15 ) begin
      mul_opd_a = recv__msg.opd_a;
      mul_opd_b = recv__msg.opd_b;
      alu_opd_a = 32'd0;
      alu_opd_b = 32'd0;
    end
    else begin
      mul_opd_a = 32'd0;
      mul_opd_b = 32'd0;
      alu_opd_a = recv__msg.opd_a;
      alu_opd_b = recv__msg.opd_b;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Node.py:82
  // @update
  // def up_en_msg():
  //   if s.state == IDLE:
  //     # If configured to use multiplier
  //     if s.cfg == NodeConfig.MUL:
  //       s.mul.recv.en @= s.recv.en
  //       s.send.en     @= s.mul.send.en
  //       s.send.msg    @= s.mul.send.msg
  // 
  //     # If configured to do nothing
  //     elif s.cfg == NodeConfig.NOP:
  //       s.mul.recv.en @= 0
  //       s.send.en     @= 0
  //       s.send.msg    @= 0
  // 
  //     # If configured to use ALU
  //     else:
  //       s.mul.recv.en @= 0
  //       s.send.en     @= s.recv.en
  //       s.send.msg    @= s.alu.out
  // 
  //   else: # MUL
  //     s.mul.recv.en @= s.recv.en
  //     s.send.en     @= s.mul.send.en
  //     s.send.msg    @= s.mul.send.msg
  
  always_comb begin : up_en_msg
    if ( state == 1'( __const__IDLE_at_up_en_msg ) ) begin
      if ( cfg == 5'd15 ) begin
        mul__recv__en = recv__en;
        send__en = mul__send__en;
        send__msg = mul__send__msg;
      end
      else if ( cfg == 5'd31 ) begin
        mul__recv__en = 1'd0;
        send__en = 1'd0;
        send__msg = 32'd0;
      end
      else begin
        mul__recv__en = 1'd0;
        send__en = recv__en;
        send__msg = alu__out;
      end
    end
    else begin
      mul__recv__en = recv__en;
      send__en = mul__send__en;
      send__msg = mul__send__msg;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Node.py:108
  // @update
  // def up_rdy():
  //   if s.state == IDLE:
  //     # If configured to use multiplier
  //     if s.cfg == NodeConfig.MUL:
  //       s.mul.send.rdy @= s.send.rdy
  //       s.recv.rdy     @= s.mul.recv.rdy
  // 
  //     elif s.cfg == NodeConfig.NOP:
  //       s.mul.send.rdy @= 0
  //       s.recv.rdy     @= 0
  // 
  //     # If configured to use ALU
  //     else:
  //       s.mul.send.rdy @= 0
  //       s.recv.rdy     @= s.send.rdy
  // 
  //   else: # MUL
  //     s.mul.send.rdy @= s.send.rdy
  //     s.recv.rdy     @= s.mul.recv.rdy & ( s.cfg == NodeConfig.MUL )
  
  always_comb begin : up_rdy
    if ( state == 1'( __const__IDLE_at_up_rdy ) ) begin
      if ( cfg == 5'd15 ) begin
        mul__send__rdy = send__rdy;
        recv__rdy = mul__recv__rdy;
      end
      else if ( cfg == 5'd31 ) begin
        mul__send__rdy = 1'd0;
        recv__rdy = 1'd0;
      end
      else begin
        mul__send__rdy = 1'd0;
        recv__rdy = send__rdy;
      end
    end
    else begin
      mul__send__rdy = send__rdy;
      recv__rdy = mul__recv__rdy & ( cfg == 5'd15 );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Node.py:142
  // @update
  // def up_state_next():
  //   if s.state == IDLE:
  //     s.state_next @= IDLE
  //     if s.recv.en & ~s.send.en:
  //       s.state_next @= MUL
  //   else: # MUL
  //     s.state_next @= MUL
  //     if ~s.recv.en & s.send.en:
  //       s.state_next @= IDLE
  
  always_comb begin : up_state_next
    if ( state == 1'( __const__IDLE_at_up_state_next ) ) begin
      state_next = 1'( __const__IDLE_at_up_state_next );
      if ( recv__en & ( ~send__en ) ) begin
        state_next = 1'( __const__MUL_at_up_state_next );
      end
    end
    else begin
      state_next = 1'( __const__MUL_at_up_state_next );
      if ( ( ~recv__en ) & send__en ) begin
        state_next = 1'( __const__IDLE_at_up_state_next );
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/Node.py:131
  // @update_ff
  // def up_state():
  //   if s.reset:
  //     s.state <<= IDLE
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      state <= 1'( __const__IDLE_at_up_state );
    end
    else
      state <= state_next;
  end

  assign alu__clk = clk;
  assign alu__reset = reset;
  assign mul__clk = clk;
  assign mul__reset = reset;
  assign alu__fn = cfg;
  assign alu__in0 = alu_opd_a;
  assign alu__in1 = alu_opd_b;
  assign mul__recv__msg.opd_a = mul_opd_a;
  assign mul__recv__msg.opd_b = mul_opd_b;

endmodule


// PyMTL Component Mux Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py

module Mux__Type_Bits32__ninputs_3
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:2],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component TileStaticDpath Definition
// Full name: TileStaticDpath__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/TileStaticDpath.py

module TileStaticDpath__b5592e8a4ff43256
(
  input  logic [1:0] acc_mux_sel ,
  input  logic [0:0] acc_reg_en ,
  input  logic [2:0] altbps_mux_sel ,
  output logic [31:0] branch_cond ,
  input  logic [2:0] bypass_mux_sel ,
  input  R2C2PEConfigMsg cfg_deq_ret ,
  output R2C2PEConfigMsg cfg_send_msg ,
  input  logic [0:0] clk ,
  input  logic [31:0] deq_msg_e ,
  input  logic [31:0] deq_msg_n ,
  input  logic [31:0] deq_msg_s ,
  input  logic [31:0] deq_msg_w ,
  input  logic [13:0] imm_partial ,
  output logic [0:0] is_cfg_target_self ,
  input  logic [4:0] node_cfg ,
  input  logic [4:0] node_cfg_func ,
  input  logic [0:0] node_recv_en ,
  output logic [0:0] node_recv_rdy ,
  output logic [0:0] node_send_en ,
  input  logic [0:0] node_send_rdy ,
  input  logic [2:0] opd_a_mux_sel ,
  input  logic [2:0] opd_b_mux_sel ,
  input  logic [0:0] reset ,
  output logic [31:0] send_msg_e ,
  output logic [31:0] send_msg_n ,
  output logic [31:0] send_msg_s ,
  output logic [31:0] send_msg_w ,
  input  logic [1:0] send_mux_e_sel ,
  input  logic [1:0] send_mux_n_sel ,
  input  logic [1:0] send_mux_s_sel ,
  input  logic [1:0] send_mux_w_sel ,
  input  logic [0:0] x_cord 
);
  logic [31:0] altbps_wire;
  logic [31:0] bypass_wire;
  logic [31:0] opd_a_wire;
  logic [31:0] opd_b_wire;
  //-------------------------------------------------------------
  // Component acc_mux
  //-------------------------------------------------------------

  logic [0:0] acc_mux__clk;
  logic [31:0] acc_mux__in_ [0:3];
  logic [31:0] acc_mux__out;
  logic [0:0] acc_mux__reset;
  logic [1:0] acc_mux__sel;

  Mux__Type_Bits32__ninputs_4 acc_mux
  (
    .clk( acc_mux__clk ),
    .in_( acc_mux__in_ ),
    .out( acc_mux__out ),
    .reset( acc_mux__reset ),
    .sel( acc_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component acc_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component acc_reg
  //-------------------------------------------------------------

  logic [0:0] acc_reg__clk;
  logic [0:0] acc_reg__en;
  logic [31:0] acc_reg__in_;
  logic [31:0] acc_reg__out;
  logic [0:0] acc_reg__reset;

  RegEn__Type_Bits32 acc_reg
  (
    .clk( acc_reg__clk ),
    .en( acc_reg__en ),
    .in_( acc_reg__in_ ),
    .out( acc_reg__out ),
    .reset( acc_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component acc_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component altbps_mux
  //-------------------------------------------------------------

  logic [0:0] altbps_mux__clk;
  logic [31:0] altbps_mux__in_ [0:4];
  logic [31:0] altbps_mux__out;
  logic [0:0] altbps_mux__reset;
  logic [2:0] altbps_mux__sel;

  Mux__Type_Bits32__ninputs_5 altbps_mux
  (
    .clk( altbps_mux__clk ),
    .in_( altbps_mux__in_ ),
    .out( altbps_mux__out ),
    .reset( altbps_mux__reset ),
    .sel( altbps_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component altbps_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component bypass_mux
  //-------------------------------------------------------------

  logic [0:0] bypass_mux__clk;
  logic [31:0] bypass_mux__in_ [0:4];
  logic [31:0] bypass_mux__out;
  logic [0:0] bypass_mux__reset;
  logic [2:0] bypass_mux__sel;

  Mux__Type_Bits32__ninputs_5 bypass_mux
  (
    .clk( bypass_mux__clk ),
    .in_( bypass_mux__in_ ),
    .out( bypass_mux__out ),
    .reset( bypass_mux__reset ),
    .sel( bypass_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component bypass_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component node
  //-------------------------------------------------------------

  logic [4:0] node__cfg;
  logic [4:0] node__cfg_func;
  logic [0:0] node__clk;
  logic [0:0] node__reset;
  logic [0:0] node__recv__en;
  AluMsg_32 node__recv__msg;
  logic [0:0] node__recv__rdy;
  logic [0:0] node__send__en;
  logic [31:0] node__send__msg;
  logic [0:0] node__send__rdy;

  Node__Type_Bits32__mul_ncycles_0 node
  (
    .cfg( node__cfg ),
    .cfg_func( node__cfg_func ),
    .clk( node__clk ),
    .reset( node__reset ),
    .recv__en( node__recv__en ),
    .recv__msg( node__recv__msg ),
    .recv__rdy( node__recv__rdy ),
    .send__en( node__send__en ),
    .send__msg( node__send__msg ),
    .send__rdy( node__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component node
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opd_a_mux
  //-------------------------------------------------------------

  logic [0:0] opd_a_mux__clk;
  logic [31:0] opd_a_mux__in_ [0:4];
  logic [31:0] opd_a_mux__out;
  logic [0:0] opd_a_mux__reset;
  logic [2:0] opd_a_mux__sel;

  Mux__Type_Bits32__ninputs_5 opd_a_mux
  (
    .clk( opd_a_mux__clk ),
    .in_( opd_a_mux__in_ ),
    .out( opd_a_mux__out ),
    .reset( opd_a_mux__reset ),
    .sel( opd_a_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component opd_a_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opd_b_mux
  //-------------------------------------------------------------

  logic [0:0] opd_b_mux__clk;
  logic [31:0] opd_b_mux__in_ [0:4];
  logic [31:0] opd_b_mux__out;
  logic [0:0] opd_b_mux__reset;
  logic [2:0] opd_b_mux__sel;

  Mux__Type_Bits32__ninputs_5 opd_b_mux
  (
    .clk( opd_b_mux__clk ),
    .in_( opd_b_mux__in_ ),
    .out( opd_b_mux__out ),
    .reset( opd_b_mux__reset ),
    .sel( opd_b_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component opd_b_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_mux_e
  //-------------------------------------------------------------

  logic [0:0] send_mux_e__clk;
  logic [31:0] send_mux_e__in_ [0:2];
  logic [31:0] send_mux_e__out;
  logic [0:0] send_mux_e__reset;
  logic [1:0] send_mux_e__sel;

  Mux__Type_Bits32__ninputs_3 send_mux_e
  (
    .clk( send_mux_e__clk ),
    .in_( send_mux_e__in_ ),
    .out( send_mux_e__out ),
    .reset( send_mux_e__reset ),
    .sel( send_mux_e__sel )
  );

  //-------------------------------------------------------------
  // End of component send_mux_e
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_mux_n
  //-------------------------------------------------------------

  logic [0:0] send_mux_n__clk;
  logic [31:0] send_mux_n__in_ [0:2];
  logic [31:0] send_mux_n__out;
  logic [0:0] send_mux_n__reset;
  logic [1:0] send_mux_n__sel;

  Mux__Type_Bits32__ninputs_3 send_mux_n
  (
    .clk( send_mux_n__clk ),
    .in_( send_mux_n__in_ ),
    .out( send_mux_n__out ),
    .reset( send_mux_n__reset ),
    .sel( send_mux_n__sel )
  );

  //-------------------------------------------------------------
  // End of component send_mux_n
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_mux_s
  //-------------------------------------------------------------

  logic [0:0] send_mux_s__clk;
  logic [31:0] send_mux_s__in_ [0:2];
  logic [31:0] send_mux_s__out;
  logic [0:0] send_mux_s__reset;
  logic [1:0] send_mux_s__sel;

  Mux__Type_Bits32__ninputs_3 send_mux_s
  (
    .clk( send_mux_s__clk ),
    .in_( send_mux_s__in_ ),
    .out( send_mux_s__out ),
    .reset( send_mux_s__reset ),
    .sel( send_mux_s__sel )
  );

  //-------------------------------------------------------------
  // End of component send_mux_s
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component send_mux_w
  //-------------------------------------------------------------

  logic [0:0] send_mux_w__clk;
  logic [31:0] send_mux_w__in_ [0:2];
  logic [31:0] send_mux_w__out;
  logic [0:0] send_mux_w__reset;
  logic [1:0] send_mux_w__sel;

  Mux__Type_Bits32__ninputs_3 send_mux_w
  (
    .clk( send_mux_w__clk ),
    .in_( send_mux_w__in_ ),
    .out( send_mux_w__out ),
    .reset( send_mux_w__reset ),
    .sel( send_mux_w__sel )
  );

  //-------------------------------------------------------------
  // End of component send_mux_w
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticDpath.py:136
  // s.acc_mux.in_[RegMux.CONST  ] //= lambda: sext( s.imm_partial, p.data_width )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_PE_rc_0__dpath_acc_mux_in__3_
    acc_mux__in_[2'd3] = { { 18 { imm_partial[13] } }, imm_partial };
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/TileStaticDpath.py:171
  // s.is_cfg_target_self //= lambda: s.cfg_deq_ret.x_cord == s.x_cord
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_PE_rc_0__dpath_is_cfg_target_self
    is_cfg_target_self = cfg_deq_ret.x_cord == x_cord;
  end

  assign acc_reg__clk = clk;
  assign acc_reg__reset = reset;
  assign acc_reg__en = acc_reg_en;
  assign opd_a_mux__clk = clk;
  assign opd_a_mux__reset = reset;
  assign opd_a_mux__sel = opd_a_mux_sel;
  assign opd_a_mux__in_[0] = deq_msg_n;
  assign opd_a_mux__in_[1] = deq_msg_s;
  assign opd_a_mux__in_[2] = deq_msg_w;
  assign opd_a_mux__in_[3] = deq_msg_e;
  assign opd_a_mux__in_[4] = acc_reg__out;
  assign opd_a_wire = opd_a_mux__out;
  assign opd_b_mux__clk = clk;
  assign opd_b_mux__reset = reset;
  assign opd_b_mux__sel = opd_b_mux_sel;
  assign opd_b_mux__in_[0] = deq_msg_n;
  assign opd_b_mux__in_[1] = deq_msg_s;
  assign opd_b_mux__in_[2] = deq_msg_w;
  assign opd_b_mux__in_[3] = deq_msg_e;
  assign opd_b_mux__in_[4] = acc_reg__out;
  assign opd_b_wire = opd_b_mux__out;
  assign branch_cond = opd_b_mux__out;
  assign bypass_mux__clk = clk;
  assign bypass_mux__reset = reset;
  assign bypass_mux__sel = bypass_mux_sel;
  assign bypass_mux__in_[0] = deq_msg_n;
  assign bypass_mux__in_[1] = deq_msg_s;
  assign bypass_mux__in_[2] = deq_msg_w;
  assign bypass_mux__in_[3] = deq_msg_e;
  assign bypass_mux__in_[4] = acc_reg__out;
  assign bypass_wire = bypass_mux__out;
  assign altbps_mux__clk = clk;
  assign altbps_mux__reset = reset;
  assign altbps_mux__sel = altbps_mux_sel;
  assign altbps_mux__in_[0] = deq_msg_n;
  assign altbps_mux__in_[1] = deq_msg_s;
  assign altbps_mux__in_[2] = deq_msg_w;
  assign altbps_mux__in_[3] = deq_msg_e;
  assign altbps_mux__in_[4] = acc_reg__out;
  assign altbps_wire = altbps_mux__out;
  assign node__clk = clk;
  assign node__reset = reset;
  assign node__cfg = node_cfg;
  assign node__cfg_func = node_cfg_func;
  assign node__recv__msg.opd_a = opd_a_wire;
  assign node__recv__msg.opd_b = opd_b_wire;
  assign node__recv__en = node_recv_en;
  assign node_recv_rdy = node__recv__rdy;
  assign node_send_en = node__send__en;
  assign node__send__rdy = node_send_rdy;
  assign acc_mux__clk = clk;
  assign acc_mux__reset = reset;
  assign acc_mux__sel = acc_mux_sel;
  assign acc_mux__in_[0] = node__send__msg;
  assign acc_mux__in_[1] = bypass_wire;
  assign acc_mux__in_[2] = altbps_wire;
  assign acc_reg__in_ = acc_mux__out;
  assign send_mux_n__clk = clk;
  assign send_mux_n__reset = reset;
  assign send_mux_n__sel = send_mux_n_sel;
  assign send_mux_n__in_[0] = node__send__msg;
  assign send_mux_n__in_[1] = bypass_wire;
  assign send_mux_n__in_[2] = altbps_wire;
  assign send_msg_n = send_mux_n__out;
  assign send_mux_s__clk = clk;
  assign send_mux_s__reset = reset;
  assign send_mux_s__sel = send_mux_s_sel;
  assign send_mux_s__in_[0] = node__send__msg;
  assign send_mux_s__in_[1] = bypass_wire;
  assign send_mux_s__in_[2] = altbps_wire;
  assign send_msg_s = send_mux_s__out;
  assign send_mux_w__clk = clk;
  assign send_mux_w__reset = reset;
  assign send_mux_w__sel = send_mux_w_sel;
  assign send_mux_w__in_[0] = node__send__msg;
  assign send_mux_w__in_[1] = bypass_wire;
  assign send_mux_w__in_[2] = altbps_wire;
  assign send_msg_w = send_mux_w__out;
  assign send_mux_e__clk = clk;
  assign send_mux_e__reset = reset;
  assign send_mux_e__sel = send_mux_e_sel;
  assign send_mux_e__in_[0] = node__send__msg;
  assign send_mux_e__in_[1] = bypass_wire;
  assign send_mux_e__in_[2] = altbps_wire;
  assign send_msg_e = send_mux_e__out;
  assign cfg_send_msg = cfg_deq_ret;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_R2C2PEConfigMsg__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__917f79746fbe7c14
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output R2C2PEConfigMsg rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  R2C2PEConfigMsg wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  R2C2PEConfigMsg regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueuePow2DpathRTL Definition
// Full name: NormalQueuePow2DpathRTL__EntryType_R2C2PEConfigMsg__num_entries_2
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2DpathRTL__3438cae2f42355e2
(
  input  logic [0:0] clk ,
  output R2C2PEConfigMsg deq_msg ,
  input  R2C2PEConfigMsg enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  R2C2PEConfigMsg queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  R2C2PEConfigMsg queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__917f79746fbe7c14 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_msg = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueuePow2RTL Definition
// At /work/global/pp482/uecgra-src/src/fifos/NormalQueuePow2RTL.py

module NormalQueuePow2RTL__EntryType_R2C2PEConfigMsg__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output R2C2PEConfigMsg deq__ret  ,
  input logic [0:0] enq__en  ,
  input R2C2PEConfigMsg enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueuePow2CtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  R2C2PEConfigMsg dpath__deq_msg;
  R2C2PEConfigMsg dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueuePow2DpathRTL__3438cae2f42355e2 dpath
  (
    .clk( dpath__clk ),
    .deq_msg( dpath__deq_msg ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_msg;

endmodule


// PyMTL Component TileStatic Definition
// Full name: TileStatic__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/TileStatic.py

module TileStatic__b5592e8a4ff43256
(
  input  logic [0:0] cfg_init ,
  input  logic [0:0] clk ,
  output logic [0:0] is_cfg_done ,
  input  logic [0:0] reset ,
  input  logic [0:0] x_cord ,
  input  logic [0:0] y_cord ,
  input logic [0:0] cfg_recv__en  ,
  input R2C2PEConfigMsg cfg_recv__msg  ,
  output logic [0:0] cfg_recv__rdy  ,
  output logic [0:0] cfg_send__en  ,
  output R2C2PEConfigMsg cfg_send__msg  ,
  input logic [0:0] cfg_send__rdy  ,
  input logic [0:0] recv__en [0:3] ,
  input logic [31:0] recv__msg [0:3] ,
  output logic [0:0] recv__rdy [0:3] ,
  output logic [0:0] send__en [0:3] ,
  output logic [31:0] send__msg [0:3] ,
  input logic [0:0] send__rdy [0:3] 
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [1:0] ctrl__acc_mux_sel;
  logic [0:0] ctrl__acc_reg_en;
  logic [2:0] ctrl__altbps_mux_sel;
  logic [31:0] ctrl__branch_cond;
  logic [2:0] ctrl__bypass_mux_sel;
  logic [0:0] ctrl__cfg_deq_en;
  logic [0:0] ctrl__cfg_deq_rdy;
  logic [0:0] ctrl__cfg_init;
  logic [0:0] ctrl__cfg_send_en;
  logic [0:0] ctrl__cfg_send_rdy;
  R2C2PEConfigMsg ctrl__cfg_wire;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_en_e;
  logic [0:0] ctrl__deq_en_n;
  logic [0:0] ctrl__deq_en_s;
  logic [0:0] ctrl__deq_en_w;
  logic [0:0] ctrl__deq_rdy_e;
  logic [0:0] ctrl__deq_rdy_n;
  logic [0:0] ctrl__deq_rdy_s;
  logic [0:0] ctrl__deq_rdy_w;
  logic [13:0] ctrl__imm_partial;
  logic [0:0] ctrl__is_cfg_done;
  logic [0:0] ctrl__is_cfg_target_self;
  logic [4:0] ctrl__node_cfg;
  logic [4:0] ctrl__node_cfg_func;
  logic [0:0] ctrl__node_recv_en;
  logic [0:0] ctrl__node_recv_rdy;
  logic [0:0] ctrl__node_send_en;
  logic [0:0] ctrl__node_send_rdy;
  logic [2:0] ctrl__opd_a_mux_sel;
  logic [2:0] ctrl__opd_b_mux_sel;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__send_en_e;
  logic [0:0] ctrl__send_en_n;
  logic [0:0] ctrl__send_en_s;
  logic [0:0] ctrl__send_en_w;
  logic [1:0] ctrl__send_mux_e_sel;
  logic [1:0] ctrl__send_mux_n_sel;
  logic [1:0] ctrl__send_mux_s_sel;
  logic [1:0] ctrl__send_mux_w_sel;
  logic [0:0] ctrl__send_rdy_e;
  logic [0:0] ctrl__send_rdy_n;
  logic [0:0] ctrl__send_rdy_s;
  logic [0:0] ctrl__send_rdy_w;

  TileStaticCtrl__b5592e8a4ff43256 ctrl
  (
    .acc_mux_sel( ctrl__acc_mux_sel ),
    .acc_reg_en( ctrl__acc_reg_en ),
    .altbps_mux_sel( ctrl__altbps_mux_sel ),
    .branch_cond( ctrl__branch_cond ),
    .bypass_mux_sel( ctrl__bypass_mux_sel ),
    .cfg_deq_en( ctrl__cfg_deq_en ),
    .cfg_deq_rdy( ctrl__cfg_deq_rdy ),
    .cfg_init( ctrl__cfg_init ),
    .cfg_send_en( ctrl__cfg_send_en ),
    .cfg_send_rdy( ctrl__cfg_send_rdy ),
    .cfg_wire( ctrl__cfg_wire ),
    .clk( ctrl__clk ),
    .deq_en_e( ctrl__deq_en_e ),
    .deq_en_n( ctrl__deq_en_n ),
    .deq_en_s( ctrl__deq_en_s ),
    .deq_en_w( ctrl__deq_en_w ),
    .deq_rdy_e( ctrl__deq_rdy_e ),
    .deq_rdy_n( ctrl__deq_rdy_n ),
    .deq_rdy_s( ctrl__deq_rdy_s ),
    .deq_rdy_w( ctrl__deq_rdy_w ),
    .imm_partial( ctrl__imm_partial ),
    .is_cfg_done( ctrl__is_cfg_done ),
    .is_cfg_target_self( ctrl__is_cfg_target_self ),
    .node_cfg( ctrl__node_cfg ),
    .node_cfg_func( ctrl__node_cfg_func ),
    .node_recv_en( ctrl__node_recv_en ),
    .node_recv_rdy( ctrl__node_recv_rdy ),
    .node_send_en( ctrl__node_send_en ),
    .node_send_rdy( ctrl__node_send_rdy ),
    .opd_a_mux_sel( ctrl__opd_a_mux_sel ),
    .opd_b_mux_sel( ctrl__opd_b_mux_sel ),
    .reset( ctrl__reset ),
    .send_en_e( ctrl__send_en_e ),
    .send_en_n( ctrl__send_en_n ),
    .send_en_s( ctrl__send_en_s ),
    .send_en_w( ctrl__send_en_w ),
    .send_mux_e_sel( ctrl__send_mux_e_sel ),
    .send_mux_n_sel( ctrl__send_mux_n_sel ),
    .send_mux_s_sel( ctrl__send_mux_s_sel ),
    .send_mux_w_sel( ctrl__send_mux_w_sel ),
    .send_rdy_e( ctrl__send_rdy_e ),
    .send_rdy_n( ctrl__send_rdy_n ),
    .send_rdy_s( ctrl__send_rdy_s ),
    .send_rdy_w( ctrl__send_rdy_w )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [1:0] dpath__acc_mux_sel;
  logic [0:0] dpath__acc_reg_en;
  logic [2:0] dpath__altbps_mux_sel;
  logic [31:0] dpath__branch_cond;
  logic [2:0] dpath__bypass_mux_sel;
  R2C2PEConfigMsg dpath__cfg_deq_ret;
  R2C2PEConfigMsg dpath__cfg_send_msg;
  logic [0:0] dpath__clk;
  logic [31:0] dpath__deq_msg_e;
  logic [31:0] dpath__deq_msg_n;
  logic [31:0] dpath__deq_msg_s;
  logic [31:0] dpath__deq_msg_w;
  logic [13:0] dpath__imm_partial;
  logic [0:0] dpath__is_cfg_target_self;
  logic [4:0] dpath__node_cfg;
  logic [4:0] dpath__node_cfg_func;
  logic [0:0] dpath__node_recv_en;
  logic [0:0] dpath__node_recv_rdy;
  logic [0:0] dpath__node_send_en;
  logic [0:0] dpath__node_send_rdy;
  logic [2:0] dpath__opd_a_mux_sel;
  logic [2:0] dpath__opd_b_mux_sel;
  logic [0:0] dpath__reset;
  logic [31:0] dpath__send_msg_e;
  logic [31:0] dpath__send_msg_n;
  logic [31:0] dpath__send_msg_s;
  logic [31:0] dpath__send_msg_w;
  logic [1:0] dpath__send_mux_e_sel;
  logic [1:0] dpath__send_mux_n_sel;
  logic [1:0] dpath__send_mux_s_sel;
  logic [1:0] dpath__send_mux_w_sel;
  logic [0:0] dpath__x_cord;

  TileStaticDpath__b5592e8a4ff43256 dpath
  (
    .acc_mux_sel( dpath__acc_mux_sel ),
    .acc_reg_en( dpath__acc_reg_en ),
    .altbps_mux_sel( dpath__altbps_mux_sel ),
    .branch_cond( dpath__branch_cond ),
    .bypass_mux_sel( dpath__bypass_mux_sel ),
    .cfg_deq_ret( dpath__cfg_deq_ret ),
    .cfg_send_msg( dpath__cfg_send_msg ),
    .clk( dpath__clk ),
    .deq_msg_e( dpath__deq_msg_e ),
    .deq_msg_n( dpath__deq_msg_n ),
    .deq_msg_s( dpath__deq_msg_s ),
    .deq_msg_w( dpath__deq_msg_w ),
    .imm_partial( dpath__imm_partial ),
    .is_cfg_target_self( dpath__is_cfg_target_self ),
    .node_cfg( dpath__node_cfg ),
    .node_cfg_func( dpath__node_cfg_func ),
    .node_recv_en( dpath__node_recv_en ),
    .node_recv_rdy( dpath__node_recv_rdy ),
    .node_send_en( dpath__node_send_en ),
    .node_send_rdy( dpath__node_send_rdy ),
    .opd_a_mux_sel( dpath__opd_a_mux_sel ),
    .opd_b_mux_sel( dpath__opd_b_mux_sel ),
    .reset( dpath__reset ),
    .send_msg_e( dpath__send_msg_e ),
    .send_msg_n( dpath__send_msg_n ),
    .send_msg_s( dpath__send_msg_s ),
    .send_msg_w( dpath__send_msg_w ),
    .send_mux_e_sel( dpath__send_mux_e_sel ),
    .send_mux_n_sel( dpath__send_mux_n_sel ),
    .send_mux_s_sel( dpath__send_mux_s_sel ),
    .send_mux_w_sel( dpath__send_mux_w_sel ),
    .x_cord( dpath__x_cord )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q_cfg
  //-------------------------------------------------------------

  logic [0:0] in_q_cfg__clk;
  logic [0:0] in_q_cfg__reset;
  logic [0:0] in_q_cfg__deq__en;
  logic [0:0] in_q_cfg__deq__rdy;
  R2C2PEConfigMsg in_q_cfg__deq__ret;
  logic [0:0] in_q_cfg__enq__en;
  R2C2PEConfigMsg in_q_cfg__enq__msg;
  logic [0:0] in_q_cfg__enq__rdy;

  NormalQueuePow2RTL__EntryType_R2C2PEConfigMsg__num_entries_2 in_q_cfg
  (
    .clk( in_q_cfg__clk ),
    .reset( in_q_cfg__reset ),
    .deq__en( in_q_cfg__deq__en ),
    .deq__rdy( in_q_cfg__deq__rdy ),
    .deq__ret( in_q_cfg__deq__ret ),
    .enq__en( in_q_cfg__enq__en ),
    .enq__msg( in_q_cfg__enq__msg ),
    .enq__rdy( in_q_cfg__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q_cfg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q_e
  //-------------------------------------------------------------

  logic [0:0] in_q_e__clk;
  logic [0:0] in_q_e__reset;
  logic [0:0] in_q_e__deq__en;
  logic [0:0] in_q_e__deq__rdy;
  logic [31:0] in_q_e__deq__ret;
  logic [0:0] in_q_e__enq__en;
  logic [31:0] in_q_e__enq__msg;
  logic [0:0] in_q_e__enq__rdy;

  NormalQueuePow2RTL__EntryType_Bits32__num_entries_2 in_q_e
  (
    .clk( in_q_e__clk ),
    .reset( in_q_e__reset ),
    .deq__en( in_q_e__deq__en ),
    .deq__rdy( in_q_e__deq__rdy ),
    .deq__ret( in_q_e__deq__ret ),
    .enq__en( in_q_e__enq__en ),
    .enq__msg( in_q_e__enq__msg ),
    .enq__rdy( in_q_e__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q_e
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q_n
  //-------------------------------------------------------------

  logic [0:0] in_q_n__clk;
  logic [0:0] in_q_n__reset;
  logic [0:0] in_q_n__deq__en;
  logic [0:0] in_q_n__deq__rdy;
  logic [31:0] in_q_n__deq__ret;
  logic [0:0] in_q_n__enq__en;
  logic [31:0] in_q_n__enq__msg;
  logic [0:0] in_q_n__enq__rdy;

  NormalQueuePow2RTL__EntryType_Bits32__num_entries_2 in_q_n
  (
    .clk( in_q_n__clk ),
    .reset( in_q_n__reset ),
    .deq__en( in_q_n__deq__en ),
    .deq__rdy( in_q_n__deq__rdy ),
    .deq__ret( in_q_n__deq__ret ),
    .enq__en( in_q_n__enq__en ),
    .enq__msg( in_q_n__enq__msg ),
    .enq__rdy( in_q_n__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q_n
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q_s
  //-------------------------------------------------------------

  logic [0:0] in_q_s__clk;
  logic [0:0] in_q_s__reset;
  logic [0:0] in_q_s__deq__en;
  logic [0:0] in_q_s__deq__rdy;
  logic [31:0] in_q_s__deq__ret;
  logic [0:0] in_q_s__enq__en;
  logic [31:0] in_q_s__enq__msg;
  logic [0:0] in_q_s__enq__rdy;

  NormalQueuePow2RTL__EntryType_Bits32__num_entries_2 in_q_s
  (
    .clk( in_q_s__clk ),
    .reset( in_q_s__reset ),
    .deq__en( in_q_s__deq__en ),
    .deq__rdy( in_q_s__deq__rdy ),
    .deq__ret( in_q_s__deq__ret ),
    .enq__en( in_q_s__enq__en ),
    .enq__msg( in_q_s__enq__msg ),
    .enq__rdy( in_q_s__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q_s
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q_w
  //-------------------------------------------------------------

  logic [0:0] in_q_w__clk;
  logic [0:0] in_q_w__reset;
  logic [0:0] in_q_w__deq__en;
  logic [0:0] in_q_w__deq__rdy;
  logic [31:0] in_q_w__deq__ret;
  logic [0:0] in_q_w__enq__en;
  logic [31:0] in_q_w__enq__msg;
  logic [0:0] in_q_w__enq__rdy;

  NormalQueuePow2RTL__EntryType_Bits32__num_entries_2 in_q_w
  (
    .clk( in_q_w__clk ),
    .reset( in_q_w__reset ),
    .deq__en( in_q_w__deq__en ),
    .deq__rdy( in_q_w__deq__rdy ),
    .deq__ret( in_q_w__deq__ret ),
    .enq__en( in_q_w__enq__en ),
    .enq__msg( in_q_w__enq__msg ),
    .enq__rdy( in_q_w__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q_w
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign in_q_n__clk = clk;
  assign in_q_n__reset = reset;
  assign in_q_s__clk = clk;
  assign in_q_s__reset = reset;
  assign in_q_w__clk = clk;
  assign in_q_w__reset = reset;
  assign in_q_e__clk = clk;
  assign in_q_e__reset = reset;
  assign in_q_n__enq__en = recv__en[0];
  assign in_q_n__enq__msg = recv__msg[0];
  assign recv__rdy[0] = in_q_n__enq__rdy;
  assign in_q_s__enq__en = recv__en[1];
  assign in_q_s__enq__msg = recv__msg[1];
  assign recv__rdy[1] = in_q_s__enq__rdy;
  assign in_q_w__enq__en = recv__en[2];
  assign in_q_w__enq__msg = recv__msg[2];
  assign recv__rdy[2] = in_q_w__enq__rdy;
  assign in_q_e__enq__en = recv__en[3];
  assign in_q_e__enq__msg = recv__msg[3];
  assign recv__rdy[3] = in_q_e__enq__rdy;
  assign in_q_cfg__clk = clk;
  assign in_q_cfg__reset = reset;
  assign in_q_cfg__enq__en = cfg_recv__en;
  assign in_q_cfg__enq__msg = cfg_recv__msg;
  assign cfg_recv__rdy = in_q_cfg__enq__rdy;
  assign ctrl__branch_cond = dpath__branch_cond;
  assign dpath__acc_reg_en = ctrl__acc_reg_en;
  assign dpath__node_cfg = ctrl__node_cfg;
  assign dpath__node_cfg_func = ctrl__node_cfg_func;
  assign dpath__node_recv_en = ctrl__node_recv_en;
  assign ctrl__node_recv_rdy = dpath__node_recv_rdy;
  assign ctrl__node_send_en = dpath__node_send_en;
  assign dpath__node_send_rdy = ctrl__node_send_rdy;
  assign dpath__opd_a_mux_sel = ctrl__opd_a_mux_sel;
  assign dpath__opd_b_mux_sel = ctrl__opd_b_mux_sel;
  assign dpath__bypass_mux_sel = ctrl__bypass_mux_sel;
  assign dpath__altbps_mux_sel = ctrl__altbps_mux_sel;
  assign dpath__acc_mux_sel = ctrl__acc_mux_sel;
  assign dpath__send_mux_n_sel = ctrl__send_mux_n_sel;
  assign dpath__send_mux_s_sel = ctrl__send_mux_s_sel;
  assign dpath__send_mux_w_sel = ctrl__send_mux_w_sel;
  assign dpath__send_mux_e_sel = ctrl__send_mux_e_sel;
  assign ctrl__is_cfg_target_self = dpath__is_cfg_target_self;
  assign dpath__imm_partial = ctrl__imm_partial;
  assign in_q_n__deq__en = ctrl__deq_en_n;
  assign ctrl__deq_rdy_n = in_q_n__deq__rdy;
  assign dpath__deq_msg_n = in_q_n__deq__ret;
  assign in_q_s__deq__en = ctrl__deq_en_s;
  assign ctrl__deq_rdy_s = in_q_s__deq__rdy;
  assign dpath__deq_msg_s = in_q_s__deq__ret;
  assign in_q_w__deq__en = ctrl__deq_en_w;
  assign ctrl__deq_rdy_w = in_q_w__deq__rdy;
  assign dpath__deq_msg_w = in_q_w__deq__ret;
  assign in_q_e__deq__en = ctrl__deq_en_e;
  assign ctrl__deq_rdy_e = in_q_e__deq__rdy;
  assign dpath__deq_msg_e = in_q_e__deq__ret;
  assign in_q_cfg__deq__en = ctrl__cfg_deq_en;
  assign ctrl__cfg_deq_rdy = in_q_cfg__deq__rdy;
  assign ctrl__cfg_wire = in_q_cfg__deq__ret;
  assign dpath__cfg_deq_ret = in_q_cfg__deq__ret;
  assign send__en[0] = ctrl__send_en_n;
  assign ctrl__send_rdy_n = send__rdy[0];
  assign send__msg[0] = dpath__send_msg_n;
  assign send__en[1] = ctrl__send_en_s;
  assign ctrl__send_rdy_s = send__rdy[1];
  assign send__msg[1] = dpath__send_msg_s;
  assign send__en[2] = ctrl__send_en_w;
  assign ctrl__send_rdy_w = send__rdy[2];
  assign send__msg[2] = dpath__send_msg_w;
  assign send__en[3] = ctrl__send_en_e;
  assign ctrl__send_rdy_e = send__rdy[3];
  assign send__msg[3] = dpath__send_msg_e;
  assign cfg_send__en = ctrl__cfg_send_en;
  assign ctrl__cfg_send_rdy = cfg_send__rdy;
  assign cfg_send__msg = dpath__cfg_send_msg;
  assign dpath__x_cord = x_cord;
  assign is_cfg_done = ctrl__is_cfg_done;
  assign ctrl__cfg_init = cfg_init;

endmodule


// PyMTL Component TieOffRecv Definition
// At /work/global/pp482/uecgra-src/src/misc/TieOffRecv.py

module TieOffRecv__Type_R2C2MEConfigMsg
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input R2C2MEConfigMsg recv__msg  ,
  output logic [0:0] recv__rdy  
);

  assign recv__rdy = 1'd0;

endmodule


// PyMTL Component MemMasterIfcMux Definition
// Full name: MemMasterIfcMux__ninputs_2__MasterIfcType_MemMasterIfcRTL__MinionIfcType_MemMinionIfcRTL__ReqType_CgraSramReqMsg__RespType_CgraSramRespMsg
// At /work/global/pp482/uecgra-src/src/misc/MemMasterIfcMux.py

module MemMasterIfcMux__6e15b16bb85ce62f
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel ,
  input logic [0:0] in___req__en [0:1],
  input CgraSramReqMsg in___req__msg [0:1],
  output logic [0:0] in___req__rdy [0:1],
  output logic [0:0] in___resp__en [0:1],
  output CgraSramRespMsg in___resp__msg [0:1],
  input logic [0:0] in___resp__rdy [0:1],
  output logic [0:0] out__req__en ,
  output CgraSramReqMsg out__req__msg ,
  input logic [0:0] out__req__rdy ,
  input logic [0:0] out__resp__en ,
  input CgraSramRespMsg out__resp__msg ,
  output logic [0:0] out__resp__rdy 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/misc/MemMasterIfcMux.py:27
  // @update
  // def mem_master_ifc_mux_upblk():
  //   s.out.req.en          @= s.in_[s.sel].req.en
  //   s.out.req.msg         @= s.in_[s.sel].req.msg
  //   s.in_[s.sel].req.rdy  @= s.out.req.rdy
  //   s.out.resp.rdy        @= s.in_[s.sel].resp.rdy
  //   s.in_[s.sel].resp.en  @= s.out.resp.en
  //   s.in_[s.sel].resp.msg @= s.out.resp.msg
  
  always_comb begin : mem_master_ifc_mux_upblk
    out__req__en = in___req__en[sel];
    out__req__msg = in___req__msg[sel];
    in___req__rdy[sel] = out__req__rdy;
    out__resp__rdy = in___resp__rdy[sel];
    in___resp__en[sel] = out__resp__en;
    in___resp__msg[sel] = out__resp__msg;
  end

endmodule


// PyMTL Component TieOffRecv Definition
// At /work/global/pp482/uecgra-src/src/misc/TieOffRecv.py

module TieOffRecv__Type_R2C2PEConfigMsg
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input R2C2PEConfigMsg recv__msg  ,
  output logic [0:0] recv__rdy  
);

  assign recv__rdy = 1'd0;

endmodule


// PyMTL Component TieOffSendRecv Definition
// At /work/global/pp482/uecgra-src/src/misc/TieOffSendRecv.py

module TieOffSendRecv__Type_Bits32
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input logic [31:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [31:0] send__msg  ,
  input logic [0:0] send__rdy  
);

  assign send__msg = 32'd0;
  assign send__en = 1'd0;
  assign recv__rdy = 1'd0;

endmodule


// PyMTL Component StaticCGRADpath Definition
// Full name: StaticCGRADpath__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py

module StaticCGRADpath__b5592e8a4ff43256
(
  input  logic [0:0] CSR_wen ,
  input  logic [0:0] cfg_init ,
  input  logic [0:0] clk ,
  input  logic [0:0] is_calc ,
  output logic [0:0] is_calc_done ,
  input  logic [0:0] is_calc_go ,
  output logic [0:0] is_calc_go_transaction ,
  input  logic [0:0] is_cfg ,
  output logic [0:0] is_cfg_done ,
  input  logic [0:0] is_cfg_go ,
  output logic [0:0] is_cfg_go_transaction ,
  output logic [0:0] is_wen ,
  input  logic [0:0] reset ,
  input  CgraXcelReqMsg xminion_req_msg ,
  output CgraXcelRespMsg xminion_resp_msg ,
  output logic [0:0] spad_masters__req__en [0:3],
  output CgraSramReqMsg spad_masters__req__msg [0:3],
  input logic [0:0] spad_masters__req__rdy [0:3],
  input logic [0:0] spad_masters__resp__en [0:3],
  input CgraSramRespMsg spad_masters__resp__msg [0:3],
  output logic [0:0] spad_masters__resp__rdy [0:3]
);
  localparam logic [1:0] __const__i_at__lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_in_3_  = 2'd3;
  localparam logic [2:0] __const__i_at__lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_in_4_  = 3'd4;
  localparam logic [2:0] __const__num_CSRs_width_at__lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_xminion_resp_msg_data  = 3'd4;
  logic [15:0] CSR_wen_bits;
  logic [15:0] CSRs_en;
  logic [31:0] CSRs_in [0:15];
  logic [3:0] all_CE_done;
  logic [3:0] all_ME_done;
  logic [3:0] all_PE_cfg_done;
  logic [11:0] reg_CSR_raddr;
  //-------------------------------------------------------------
  // Component CE_c[0:1]
  //-------------------------------------------------------------

  logic [11:0] CE_c__cfg_base_addr [0:1];
  logic [0:0] CE_c__cfg_init [0:1];
  logic [0:0] CE_c__clk [0:1];
  logic [0:0] CE_c__is_done [0:1];
  logic [0:0] CE_c__reset [0:1];
  logic [1:0] CE_c__y_cord [0:1];
  logic [0:0] CE_c__cfg_send__en [0:1];
  R2C2PEConfigMsg CE_c__cfg_send__msg [0:1];
  logic [0:0] CE_c__cfg_send__rdy [0:1];
  logic [0:0] CE_c__mem_master__req__en [0:1];
  CgraSramReqMsg CE_c__mem_master__req__msg [0:1];
  logic [0:0] CE_c__mem_master__req__rdy [0:1];
  logic [0:0] CE_c__mem_master__resp__en [0:1];
  CgraSramRespMsg CE_c__mem_master__resp__msg [0:1];
  logic [0:0] CE_c__mem_master__resp__rdy [0:1];

  ConfigEngine__3b5c60331a151612 CE_c__0
  (
    .cfg_base_addr( CE_c__cfg_base_addr[0] ),
    .cfg_init( CE_c__cfg_init[0] ),
    .clk( CE_c__clk[0] ),
    .is_done( CE_c__is_done[0] ),
    .reset( CE_c__reset[0] ),
    .y_cord( CE_c__y_cord[0] ),
    .cfg_send__en( CE_c__cfg_send__en[0] ),
    .cfg_send__msg( CE_c__cfg_send__msg[0] ),
    .cfg_send__rdy( CE_c__cfg_send__rdy[0] ),
    .mem_master__req__en( CE_c__mem_master__req__en[0] ),
    .mem_master__req__msg( CE_c__mem_master__req__msg[0] ),
    .mem_master__req__rdy( CE_c__mem_master__req__rdy[0] ),
    .mem_master__resp__en( CE_c__mem_master__resp__en[0] ),
    .mem_master__resp__msg( CE_c__mem_master__resp__msg[0] ),
    .mem_master__resp__rdy( CE_c__mem_master__resp__rdy[0] )
  );

  ConfigEngine__3b5c60331a151612 CE_c__1
  (
    .cfg_base_addr( CE_c__cfg_base_addr[1] ),
    .cfg_init( CE_c__cfg_init[1] ),
    .clk( CE_c__clk[1] ),
    .is_done( CE_c__is_done[1] ),
    .reset( CE_c__reset[1] ),
    .y_cord( CE_c__y_cord[1] ),
    .cfg_send__en( CE_c__cfg_send__en[1] ),
    .cfg_send__msg( CE_c__cfg_send__msg[1] ),
    .cfg_send__rdy( CE_c__cfg_send__rdy[1] ),
    .mem_master__req__en( CE_c__mem_master__req__en[1] ),
    .mem_master__req__msg( CE_c__mem_master__req__msg[1] ),
    .mem_master__req__rdy( CE_c__mem_master__req__rdy[1] ),
    .mem_master__resp__en( CE_c__mem_master__resp__en[1] ),
    .mem_master__resp__msg( CE_c__mem_master__resp__msg[1] ),
    .mem_master__resp__rdy( CE_c__mem_master__resp__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component CE_c[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component CE_n
  //-------------------------------------------------------------

  logic [11:0] CE_n__cfg_base_addr;
  logic [0:0] CE_n__cfg_init;
  logic [0:0] CE_n__clk;
  logic [0:0] CE_n__is_done;
  logic [0:0] CE_n__reset;
  logic [1:0] CE_n__y_cord;
  logic [0:0] CE_n__cfg_send__en;
  R2C2MEConfigMsg CE_n__cfg_send__msg;
  logic [0:0] CE_n__cfg_send__rdy;
  logic [0:0] CE_n__mem_master__req__en;
  CgraSramReqMsg CE_n__mem_master__req__msg;
  logic [0:0] CE_n__mem_master__req__rdy;
  logic [0:0] CE_n__mem_master__resp__en;
  CgraSramRespMsg CE_n__mem_master__resp__msg;
  logic [0:0] CE_n__mem_master__resp__rdy;

  ConfigEngine__8077c4232cf786b0 CE_n
  (
    .cfg_base_addr( CE_n__cfg_base_addr ),
    .cfg_init( CE_n__cfg_init ),
    .clk( CE_n__clk ),
    .is_done( CE_n__is_done ),
    .reset( CE_n__reset ),
    .y_cord( CE_n__y_cord ),
    .cfg_send__en( CE_n__cfg_send__en ),
    .cfg_send__msg( CE_n__cfg_send__msg ),
    .cfg_send__rdy( CE_n__cfg_send__rdy ),
    .mem_master__req__en( CE_n__mem_master__req__en ),
    .mem_master__req__msg( CE_n__mem_master__req__msg ),
    .mem_master__req__rdy( CE_n__mem_master__req__rdy ),
    .mem_master__resp__en( CE_n__mem_master__resp__en ),
    .mem_master__resp__msg( CE_n__mem_master__resp__msg ),
    .mem_master__resp__rdy( CE_n__mem_master__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component CE_n
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component CE_s
  //-------------------------------------------------------------

  logic [11:0] CE_s__cfg_base_addr;
  logic [0:0] CE_s__cfg_init;
  logic [0:0] CE_s__clk;
  logic [0:0] CE_s__is_done;
  logic [0:0] CE_s__reset;
  logic [1:0] CE_s__y_cord;
  logic [0:0] CE_s__cfg_send__en;
  R2C2MEConfigMsg CE_s__cfg_send__msg;
  logic [0:0] CE_s__cfg_send__rdy;
  logic [0:0] CE_s__mem_master__req__en;
  CgraSramReqMsg CE_s__mem_master__req__msg;
  logic [0:0] CE_s__mem_master__req__rdy;
  logic [0:0] CE_s__mem_master__resp__en;
  CgraSramRespMsg CE_s__mem_master__resp__msg;
  logic [0:0] CE_s__mem_master__resp__rdy;

  ConfigEngine__8077c4232cf786b0 CE_s
  (
    .cfg_base_addr( CE_s__cfg_base_addr ),
    .cfg_init( CE_s__cfg_init ),
    .clk( CE_s__clk ),
    .is_done( CE_s__is_done ),
    .reset( CE_s__reset ),
    .y_cord( CE_s__y_cord ),
    .cfg_send__en( CE_s__cfg_send__en ),
    .cfg_send__msg( CE_s__cfg_send__msg ),
    .cfg_send__rdy( CE_s__cfg_send__rdy ),
    .mem_master__req__en( CE_s__mem_master__req__en ),
    .mem_master__req__msg( CE_s__mem_master__req__msg ),
    .mem_master__req__rdy( CE_s__mem_master__req__rdy ),
    .mem_master__resp__en( CE_s__mem_master__resp__en ),
    .mem_master__resp__msg( CE_s__mem_master__resp__msg ),
    .mem_master__resp__rdy( CE_s__mem_master__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component CE_s
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component CSRs[0:15]
  //-------------------------------------------------------------

  logic [0:0] CSRs__clk [0:15];
  logic [0:0] CSRs__en [0:15];
  logic [31:0] CSRs__in_ [0:15];
  logic [31:0] CSRs__out [0:15];
  logic [0:0] CSRs__reset [0:15];

  RegEnRst__Type_32__reset_value_0 CSRs__0
  (
    .clk( CSRs__clk[0] ),
    .en( CSRs__en[0] ),
    .in_( CSRs__in_[0] ),
    .out( CSRs__out[0] ),
    .reset( CSRs__reset[0] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__1
  (
    .clk( CSRs__clk[1] ),
    .en( CSRs__en[1] ),
    .in_( CSRs__in_[1] ),
    .out( CSRs__out[1] ),
    .reset( CSRs__reset[1] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__2
  (
    .clk( CSRs__clk[2] ),
    .en( CSRs__en[2] ),
    .in_( CSRs__in_[2] ),
    .out( CSRs__out[2] ),
    .reset( CSRs__reset[2] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__3
  (
    .clk( CSRs__clk[3] ),
    .en( CSRs__en[3] ),
    .in_( CSRs__in_[3] ),
    .out( CSRs__out[3] ),
    .reset( CSRs__reset[3] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__4
  (
    .clk( CSRs__clk[4] ),
    .en( CSRs__en[4] ),
    .in_( CSRs__in_[4] ),
    .out( CSRs__out[4] ),
    .reset( CSRs__reset[4] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__5
  (
    .clk( CSRs__clk[5] ),
    .en( CSRs__en[5] ),
    .in_( CSRs__in_[5] ),
    .out( CSRs__out[5] ),
    .reset( CSRs__reset[5] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__6
  (
    .clk( CSRs__clk[6] ),
    .en( CSRs__en[6] ),
    .in_( CSRs__in_[6] ),
    .out( CSRs__out[6] ),
    .reset( CSRs__reset[6] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__7
  (
    .clk( CSRs__clk[7] ),
    .en( CSRs__en[7] ),
    .in_( CSRs__in_[7] ),
    .out( CSRs__out[7] ),
    .reset( CSRs__reset[7] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__8
  (
    .clk( CSRs__clk[8] ),
    .en( CSRs__en[8] ),
    .in_( CSRs__in_[8] ),
    .out( CSRs__out[8] ),
    .reset( CSRs__reset[8] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__9
  (
    .clk( CSRs__clk[9] ),
    .en( CSRs__en[9] ),
    .in_( CSRs__in_[9] ),
    .out( CSRs__out[9] ),
    .reset( CSRs__reset[9] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__10
  (
    .clk( CSRs__clk[10] ),
    .en( CSRs__en[10] ),
    .in_( CSRs__in_[10] ),
    .out( CSRs__out[10] ),
    .reset( CSRs__reset[10] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__11
  (
    .clk( CSRs__clk[11] ),
    .en( CSRs__en[11] ),
    .in_( CSRs__in_[11] ),
    .out( CSRs__out[11] ),
    .reset( CSRs__reset[11] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__12
  (
    .clk( CSRs__clk[12] ),
    .en( CSRs__en[12] ),
    .in_( CSRs__in_[12] ),
    .out( CSRs__out[12] ),
    .reset( CSRs__reset[12] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__13
  (
    .clk( CSRs__clk[13] ),
    .en( CSRs__en[13] ),
    .in_( CSRs__in_[13] ),
    .out( CSRs__out[13] ),
    .reset( CSRs__reset[13] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__14
  (
    .clk( CSRs__clk[14] ),
    .en( CSRs__en[14] ),
    .in_( CSRs__in_[14] ),
    .out( CSRs__out[14] ),
    .reset( CSRs__reset[14] )
  );

  RegEnRst__Type_32__reset_value_0 CSRs__15
  (
    .clk( CSRs__clk[15] ),
    .en( CSRs__en[15] ),
    .in_( CSRs__in_[15] ),
    .out( CSRs__out[15] ),
    .reset( CSRs__reset[15] )
  );

  //-------------------------------------------------------------
  // End of component CSRs[0:15]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ME_r[0:3]
  //-------------------------------------------------------------

  logic [0:0] ME_r__clk [0:3];
  logic [0:0] ME_r__is_calc [0:3];
  logic [0:0] ME_r__is_done [0:3];
  logic [0:0] ME_r__ns_cord [0:3];
  logic [0:0] ME_r__reset [0:3];
  logic [0:0] ME_r__x_cord [0:3];
  logic [0:0] ME_r__cfg_recv__en [0:3];
  R2C2MEConfigMsg ME_r__cfg_recv__msg [0:3];
  logic [0:0] ME_r__cfg_recv__rdy [0:3];
  logic [0:0] ME_r__cfg_send__en [0:3];
  R2C2MEConfigMsg ME_r__cfg_send__msg [0:3];
  logic [0:0] ME_r__cfg_send__rdy [0:3];
  logic [0:0] ME_r__mem_ifc__req__en [0:3];
  CgraSramReqMsg ME_r__mem_ifc__req__msg [0:3];
  logic [0:0] ME_r__mem_ifc__req__rdy [0:3];
  logic [0:0] ME_r__mem_ifc__resp__en [0:3];
  CgraSramRespMsg ME_r__mem_ifc__resp__msg [0:3];
  logic [0:0] ME_r__mem_ifc__resp__rdy [0:3];
  logic [0:0] ME_r__recv__en [0:3];
  logic [31:0] ME_r__recv__msg [0:3];
  logic [0:0] ME_r__recv__rdy [0:3];
  logic [0:0] ME_r__send__en [0:3];
  logic [31:0] ME_r__send__msg [0:3];
  logic [0:0] ME_r__send__rdy [0:3];

  MemEngine__b5592e8a4ff43256 ME_r__0
  (
    .clk( ME_r__clk[0] ),
    .is_calc( ME_r__is_calc[0] ),
    .is_done( ME_r__is_done[0] ),
    .ns_cord( ME_r__ns_cord[0] ),
    .reset( ME_r__reset[0] ),
    .x_cord( ME_r__x_cord[0] ),
    .cfg_recv__en( ME_r__cfg_recv__en[0] ),
    .cfg_recv__msg( ME_r__cfg_recv__msg[0] ),
    .cfg_recv__rdy( ME_r__cfg_recv__rdy[0] ),
    .cfg_send__en( ME_r__cfg_send__en[0] ),
    .cfg_send__msg( ME_r__cfg_send__msg[0] ),
    .cfg_send__rdy( ME_r__cfg_send__rdy[0] ),
    .mem_ifc__req__en( ME_r__mem_ifc__req__en[0] ),
    .mem_ifc__req__msg( ME_r__mem_ifc__req__msg[0] ),
    .mem_ifc__req__rdy( ME_r__mem_ifc__req__rdy[0] ),
    .mem_ifc__resp__en( ME_r__mem_ifc__resp__en[0] ),
    .mem_ifc__resp__msg( ME_r__mem_ifc__resp__msg[0] ),
    .mem_ifc__resp__rdy( ME_r__mem_ifc__resp__rdy[0] ),
    .recv__en( ME_r__recv__en[0] ),
    .recv__msg( ME_r__recv__msg[0] ),
    .recv__rdy( ME_r__recv__rdy[0] ),
    .send__en( ME_r__send__en[0] ),
    .send__msg( ME_r__send__msg[0] ),
    .send__rdy( ME_r__send__rdy[0] )
  );

  MemEngine__b5592e8a4ff43256 ME_r__1
  (
    .clk( ME_r__clk[1] ),
    .is_calc( ME_r__is_calc[1] ),
    .is_done( ME_r__is_done[1] ),
    .ns_cord( ME_r__ns_cord[1] ),
    .reset( ME_r__reset[1] ),
    .x_cord( ME_r__x_cord[1] ),
    .cfg_recv__en( ME_r__cfg_recv__en[1] ),
    .cfg_recv__msg( ME_r__cfg_recv__msg[1] ),
    .cfg_recv__rdy( ME_r__cfg_recv__rdy[1] ),
    .cfg_send__en( ME_r__cfg_send__en[1] ),
    .cfg_send__msg( ME_r__cfg_send__msg[1] ),
    .cfg_send__rdy( ME_r__cfg_send__rdy[1] ),
    .mem_ifc__req__en( ME_r__mem_ifc__req__en[1] ),
    .mem_ifc__req__msg( ME_r__mem_ifc__req__msg[1] ),
    .mem_ifc__req__rdy( ME_r__mem_ifc__req__rdy[1] ),
    .mem_ifc__resp__en( ME_r__mem_ifc__resp__en[1] ),
    .mem_ifc__resp__msg( ME_r__mem_ifc__resp__msg[1] ),
    .mem_ifc__resp__rdy( ME_r__mem_ifc__resp__rdy[1] ),
    .recv__en( ME_r__recv__en[1] ),
    .recv__msg( ME_r__recv__msg[1] ),
    .recv__rdy( ME_r__recv__rdy[1] ),
    .send__en( ME_r__send__en[1] ),
    .send__msg( ME_r__send__msg[1] ),
    .send__rdy( ME_r__send__rdy[1] )
  );

  MemEngine__b5592e8a4ff43256 ME_r__2
  (
    .clk( ME_r__clk[2] ),
    .is_calc( ME_r__is_calc[2] ),
    .is_done( ME_r__is_done[2] ),
    .ns_cord( ME_r__ns_cord[2] ),
    .reset( ME_r__reset[2] ),
    .x_cord( ME_r__x_cord[2] ),
    .cfg_recv__en( ME_r__cfg_recv__en[2] ),
    .cfg_recv__msg( ME_r__cfg_recv__msg[2] ),
    .cfg_recv__rdy( ME_r__cfg_recv__rdy[2] ),
    .cfg_send__en( ME_r__cfg_send__en[2] ),
    .cfg_send__msg( ME_r__cfg_send__msg[2] ),
    .cfg_send__rdy( ME_r__cfg_send__rdy[2] ),
    .mem_ifc__req__en( ME_r__mem_ifc__req__en[2] ),
    .mem_ifc__req__msg( ME_r__mem_ifc__req__msg[2] ),
    .mem_ifc__req__rdy( ME_r__mem_ifc__req__rdy[2] ),
    .mem_ifc__resp__en( ME_r__mem_ifc__resp__en[2] ),
    .mem_ifc__resp__msg( ME_r__mem_ifc__resp__msg[2] ),
    .mem_ifc__resp__rdy( ME_r__mem_ifc__resp__rdy[2] ),
    .recv__en( ME_r__recv__en[2] ),
    .recv__msg( ME_r__recv__msg[2] ),
    .recv__rdy( ME_r__recv__rdy[2] ),
    .send__en( ME_r__send__en[2] ),
    .send__msg( ME_r__send__msg[2] ),
    .send__rdy( ME_r__send__rdy[2] )
  );

  MemEngine__b5592e8a4ff43256 ME_r__3
  (
    .clk( ME_r__clk[3] ),
    .is_calc( ME_r__is_calc[3] ),
    .is_done( ME_r__is_done[3] ),
    .ns_cord( ME_r__ns_cord[3] ),
    .reset( ME_r__reset[3] ),
    .x_cord( ME_r__x_cord[3] ),
    .cfg_recv__en( ME_r__cfg_recv__en[3] ),
    .cfg_recv__msg( ME_r__cfg_recv__msg[3] ),
    .cfg_recv__rdy( ME_r__cfg_recv__rdy[3] ),
    .cfg_send__en( ME_r__cfg_send__en[3] ),
    .cfg_send__msg( ME_r__cfg_send__msg[3] ),
    .cfg_send__rdy( ME_r__cfg_send__rdy[3] ),
    .mem_ifc__req__en( ME_r__mem_ifc__req__en[3] ),
    .mem_ifc__req__msg( ME_r__mem_ifc__req__msg[3] ),
    .mem_ifc__req__rdy( ME_r__mem_ifc__req__rdy[3] ),
    .mem_ifc__resp__en( ME_r__mem_ifc__resp__en[3] ),
    .mem_ifc__resp__msg( ME_r__mem_ifc__resp__msg[3] ),
    .mem_ifc__resp__rdy( ME_r__mem_ifc__resp__rdy[3] ),
    .recv__en( ME_r__recv__en[3] ),
    .recv__msg( ME_r__recv__msg[3] ),
    .recv__rdy( ME_r__recv__rdy[3] ),
    .send__en( ME_r__send__en[3] ),
    .send__msg( ME_r__send__msg[3] ),
    .send__rdy( ME_r__send__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component ME_r[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component PE_rc[0:3]
  //-------------------------------------------------------------

  logic [0:0] PE_rc__cfg_init [0:3];
  logic [0:0] PE_rc__clk [0:3];
  logic [0:0] PE_rc__is_cfg_done [0:3];
  logic [0:0] PE_rc__reset [0:3];
  logic [0:0] PE_rc__x_cord [0:3];
  logic [0:0] PE_rc__y_cord [0:3];
  logic [0:0] PE_rc__cfg_recv__en [0:3];
  R2C2PEConfigMsg PE_rc__cfg_recv__msg [0:3];
  logic [0:0] PE_rc__cfg_recv__rdy [0:3];
  logic [0:0] PE_rc__cfg_send__en [0:3];
  R2C2PEConfigMsg PE_rc__cfg_send__msg [0:3];
  logic [0:0] PE_rc__cfg_send__rdy [0:3];
  logic [0:0] PE_rc__recv__en [0:3][0:3];
  logic [31:0] PE_rc__recv__msg [0:3][0:3];
  logic [0:0] PE_rc__recv__rdy [0:3][0:3];
  logic [0:0] PE_rc__send__en [0:3][0:3];
  logic [31:0] PE_rc__send__msg [0:3][0:3];
  logic [0:0] PE_rc__send__rdy [0:3][0:3];

  TileStatic__b5592e8a4ff43256 PE_rc__0
  (
    .cfg_init( PE_rc__cfg_init[0] ),
    .clk( PE_rc__clk[0] ),
    .is_cfg_done( PE_rc__is_cfg_done[0] ),
    .reset( PE_rc__reset[0] ),
    .x_cord( PE_rc__x_cord[0] ),
    .y_cord( PE_rc__y_cord[0] ),
    .cfg_recv__en( PE_rc__cfg_recv__en[0] ),
    .cfg_recv__msg( PE_rc__cfg_recv__msg[0] ),
    .cfg_recv__rdy( PE_rc__cfg_recv__rdy[0] ),
    .cfg_send__en( PE_rc__cfg_send__en[0] ),
    .cfg_send__msg( PE_rc__cfg_send__msg[0] ),
    .cfg_send__rdy( PE_rc__cfg_send__rdy[0] ),
    .recv__en( PE_rc__recv__en[0] ),
    .recv__msg( PE_rc__recv__msg[0] ),
    .recv__rdy( PE_rc__recv__rdy[0] ),
    .send__en( PE_rc__send__en[0] ),
    .send__msg( PE_rc__send__msg[0] ),
    .send__rdy( PE_rc__send__rdy[0] )
  );

  TileStatic__b5592e8a4ff43256 PE_rc__1
  (
    .cfg_init( PE_rc__cfg_init[1] ),
    .clk( PE_rc__clk[1] ),
    .is_cfg_done( PE_rc__is_cfg_done[1] ),
    .reset( PE_rc__reset[1] ),
    .x_cord( PE_rc__x_cord[1] ),
    .y_cord( PE_rc__y_cord[1] ),
    .cfg_recv__en( PE_rc__cfg_recv__en[1] ),
    .cfg_recv__msg( PE_rc__cfg_recv__msg[1] ),
    .cfg_recv__rdy( PE_rc__cfg_recv__rdy[1] ),
    .cfg_send__en( PE_rc__cfg_send__en[1] ),
    .cfg_send__msg( PE_rc__cfg_send__msg[1] ),
    .cfg_send__rdy( PE_rc__cfg_send__rdy[1] ),
    .recv__en( PE_rc__recv__en[1] ),
    .recv__msg( PE_rc__recv__msg[1] ),
    .recv__rdy( PE_rc__recv__rdy[1] ),
    .send__en( PE_rc__send__en[1] ),
    .send__msg( PE_rc__send__msg[1] ),
    .send__rdy( PE_rc__send__rdy[1] )
  );

  TileStatic__b5592e8a4ff43256 PE_rc__2
  (
    .cfg_init( PE_rc__cfg_init[2] ),
    .clk( PE_rc__clk[2] ),
    .is_cfg_done( PE_rc__is_cfg_done[2] ),
    .reset( PE_rc__reset[2] ),
    .x_cord( PE_rc__x_cord[2] ),
    .y_cord( PE_rc__y_cord[2] ),
    .cfg_recv__en( PE_rc__cfg_recv__en[2] ),
    .cfg_recv__msg( PE_rc__cfg_recv__msg[2] ),
    .cfg_recv__rdy( PE_rc__cfg_recv__rdy[2] ),
    .cfg_send__en( PE_rc__cfg_send__en[2] ),
    .cfg_send__msg( PE_rc__cfg_send__msg[2] ),
    .cfg_send__rdy( PE_rc__cfg_send__rdy[2] ),
    .recv__en( PE_rc__recv__en[2] ),
    .recv__msg( PE_rc__recv__msg[2] ),
    .recv__rdy( PE_rc__recv__rdy[2] ),
    .send__en( PE_rc__send__en[2] ),
    .send__msg( PE_rc__send__msg[2] ),
    .send__rdy( PE_rc__send__rdy[2] )
  );

  TileStatic__b5592e8a4ff43256 PE_rc__3
  (
    .cfg_init( PE_rc__cfg_init[3] ),
    .clk( PE_rc__clk[3] ),
    .is_cfg_done( PE_rc__is_cfg_done[3] ),
    .reset( PE_rc__reset[3] ),
    .x_cord( PE_rc__x_cord[3] ),
    .y_cord( PE_rc__y_cord[3] ),
    .cfg_recv__en( PE_rc__cfg_recv__en[3] ),
    .cfg_recv__msg( PE_rc__cfg_recv__msg[3] ),
    .cfg_recv__rdy( PE_rc__cfg_recv__rdy[3] ),
    .cfg_send__en( PE_rc__cfg_send__en[3] ),
    .cfg_send__msg( PE_rc__cfg_send__msg[3] ),
    .cfg_send__rdy( PE_rc__cfg_send__rdy[3] ),
    .recv__en( PE_rc__recv__en[3] ),
    .recv__msg( PE_rc__recv__msg[3] ),
    .recv__rdy( PE_rc__recv__rdy[3] ),
    .send__en( PE_rc__send__en[3] ),
    .send__msg( PE_rc__send__msg[3] ),
    .send__rdy( PE_rc__send__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component PE_rc[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component me_n_cfg_tieoff
  //-------------------------------------------------------------

  logic [0:0] me_n_cfg_tieoff__clk;
  logic [0:0] me_n_cfg_tieoff__reset;
  logic [0:0] me_n_cfg_tieoff__recv__en;
  R2C2MEConfigMsg me_n_cfg_tieoff__recv__msg;
  logic [0:0] me_n_cfg_tieoff__recv__rdy;

  TieOffRecv__Type_R2C2MEConfigMsg me_n_cfg_tieoff
  (
    .clk( me_n_cfg_tieoff__clk ),
    .reset( me_n_cfg_tieoff__reset ),
    .recv__en( me_n_cfg_tieoff__recv__en ),
    .recv__msg( me_n_cfg_tieoff__recv__msg ),
    .recv__rdy( me_n_cfg_tieoff__recv__rdy )
  );

  //-------------------------------------------------------------
  // End of component me_n_cfg_tieoff
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component me_s_cfg_tieoff
  //-------------------------------------------------------------

  logic [0:0] me_s_cfg_tieoff__clk;
  logic [0:0] me_s_cfg_tieoff__reset;
  logic [0:0] me_s_cfg_tieoff__recv__en;
  R2C2MEConfigMsg me_s_cfg_tieoff__recv__msg;
  logic [0:0] me_s_cfg_tieoff__recv__rdy;

  TieOffRecv__Type_R2C2MEConfigMsg me_s_cfg_tieoff
  (
    .clk( me_s_cfg_tieoff__clk ),
    .reset( me_s_cfg_tieoff__reset ),
    .recv__en( me_s_cfg_tieoff__recv__en ),
    .recv__msg( me_s_cfg_tieoff__recv__msg ),
    .recv__rdy( me_s_cfg_tieoff__recv__rdy )
  );

  //-------------------------------------------------------------
  // End of component me_s_cfg_tieoff
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_muxes[0:3]
  //-------------------------------------------------------------

  logic [0:0] mem_muxes__clk [0:3];
  logic [0:0] mem_muxes__reset [0:3];
  logic [0:0] mem_muxes__sel [0:3];
  logic [0:0] mem_muxes__in___req__en [0:3][0:1];
  CgraSramReqMsg mem_muxes__in___req__msg [0:3][0:1];
  logic [0:0] mem_muxes__in___req__rdy [0:3][0:1];
  logic [0:0] mem_muxes__in___resp__en [0:3][0:1];
  CgraSramRespMsg mem_muxes__in___resp__msg [0:3][0:1];
  logic [0:0] mem_muxes__in___resp__rdy [0:3][0:1];
  logic [0:0] mem_muxes__out__req__en [0:3];
  CgraSramReqMsg mem_muxes__out__req__msg [0:3];
  logic [0:0] mem_muxes__out__req__rdy [0:3];
  logic [0:0] mem_muxes__out__resp__en [0:3];
  CgraSramRespMsg mem_muxes__out__resp__msg [0:3];
  logic [0:0] mem_muxes__out__resp__rdy [0:3];

  MemMasterIfcMux__6e15b16bb85ce62f mem_muxes__0
  (
    .clk( mem_muxes__clk[0] ),
    .reset( mem_muxes__reset[0] ),
    .sel( mem_muxes__sel[0] ),
    .in___req__en( mem_muxes__in___req__en[0] ),
    .in___req__msg( mem_muxes__in___req__msg[0] ),
    .in___req__rdy( mem_muxes__in___req__rdy[0] ),
    .in___resp__en( mem_muxes__in___resp__en[0] ),
    .in___resp__msg( mem_muxes__in___resp__msg[0] ),
    .in___resp__rdy( mem_muxes__in___resp__rdy[0] ),
    .out__req__en( mem_muxes__out__req__en[0] ),
    .out__req__msg( mem_muxes__out__req__msg[0] ),
    .out__req__rdy( mem_muxes__out__req__rdy[0] ),
    .out__resp__en( mem_muxes__out__resp__en[0] ),
    .out__resp__msg( mem_muxes__out__resp__msg[0] ),
    .out__resp__rdy( mem_muxes__out__resp__rdy[0] )
  );

  MemMasterIfcMux__6e15b16bb85ce62f mem_muxes__1
  (
    .clk( mem_muxes__clk[1] ),
    .reset( mem_muxes__reset[1] ),
    .sel( mem_muxes__sel[1] ),
    .in___req__en( mem_muxes__in___req__en[1] ),
    .in___req__msg( mem_muxes__in___req__msg[1] ),
    .in___req__rdy( mem_muxes__in___req__rdy[1] ),
    .in___resp__en( mem_muxes__in___resp__en[1] ),
    .in___resp__msg( mem_muxes__in___resp__msg[1] ),
    .in___resp__rdy( mem_muxes__in___resp__rdy[1] ),
    .out__req__en( mem_muxes__out__req__en[1] ),
    .out__req__msg( mem_muxes__out__req__msg[1] ),
    .out__req__rdy( mem_muxes__out__req__rdy[1] ),
    .out__resp__en( mem_muxes__out__resp__en[1] ),
    .out__resp__msg( mem_muxes__out__resp__msg[1] ),
    .out__resp__rdy( mem_muxes__out__resp__rdy[1] )
  );

  MemMasterIfcMux__6e15b16bb85ce62f mem_muxes__2
  (
    .clk( mem_muxes__clk[2] ),
    .reset( mem_muxes__reset[2] ),
    .sel( mem_muxes__sel[2] ),
    .in___req__en( mem_muxes__in___req__en[2] ),
    .in___req__msg( mem_muxes__in___req__msg[2] ),
    .in___req__rdy( mem_muxes__in___req__rdy[2] ),
    .in___resp__en( mem_muxes__in___resp__en[2] ),
    .in___resp__msg( mem_muxes__in___resp__msg[2] ),
    .in___resp__rdy( mem_muxes__in___resp__rdy[2] ),
    .out__req__en( mem_muxes__out__req__en[2] ),
    .out__req__msg( mem_muxes__out__req__msg[2] ),
    .out__req__rdy( mem_muxes__out__req__rdy[2] ),
    .out__resp__en( mem_muxes__out__resp__en[2] ),
    .out__resp__msg( mem_muxes__out__resp__msg[2] ),
    .out__resp__rdy( mem_muxes__out__resp__rdy[2] )
  );

  MemMasterIfcMux__6e15b16bb85ce62f mem_muxes__3
  (
    .clk( mem_muxes__clk[3] ),
    .reset( mem_muxes__reset[3] ),
    .sel( mem_muxes__sel[3] ),
    .in___req__en( mem_muxes__in___req__en[3] ),
    .in___req__msg( mem_muxes__in___req__msg[3] ),
    .in___req__rdy( mem_muxes__in___req__rdy[3] ),
    .in___resp__en( mem_muxes__in___resp__en[3] ),
    .in___resp__msg( mem_muxes__in___resp__msg[3] ),
    .in___resp__rdy( mem_muxes__in___resp__rdy[3] ),
    .out__req__en( mem_muxes__out__req__en[3] ),
    .out__req__msg( mem_muxes__out__req__msg[3] ),
    .out__req__rdy( mem_muxes__out__req__rdy[3] ),
    .out__resp__en( mem_muxes__out__resp__en[3] ),
    .out__resp__msg( mem_muxes__out__resp__msg[3] ),
    .out__resp__rdy( mem_muxes__out__resp__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component mem_muxes[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pe_cfg_tieoff[0:1]
  //-------------------------------------------------------------

  logic [0:0] pe_cfg_tieoff__clk [0:1];
  logic [0:0] pe_cfg_tieoff__reset [0:1];
  logic [0:0] pe_cfg_tieoff__recv__en [0:1];
  R2C2PEConfigMsg pe_cfg_tieoff__recv__msg [0:1];
  logic [0:0] pe_cfg_tieoff__recv__rdy [0:1];

  TieOffRecv__Type_R2C2PEConfigMsg pe_cfg_tieoff__0
  (
    .clk( pe_cfg_tieoff__clk[0] ),
    .reset( pe_cfg_tieoff__reset[0] ),
    .recv__en( pe_cfg_tieoff__recv__en[0] ),
    .recv__msg( pe_cfg_tieoff__recv__msg[0] ),
    .recv__rdy( pe_cfg_tieoff__recv__rdy[0] )
  );

  TieOffRecv__Type_R2C2PEConfigMsg pe_cfg_tieoff__1
  (
    .clk( pe_cfg_tieoff__clk[1] ),
    .reset( pe_cfg_tieoff__reset[1] ),
    .recv__en( pe_cfg_tieoff__recv__en[1] ),
    .recv__msg( pe_cfg_tieoff__recv__msg[1] ),
    .recv__rdy( pe_cfg_tieoff__recv__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component pe_cfg_tieoff[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pe_e_tieoff[0:1]
  //-------------------------------------------------------------

  logic [0:0] pe_e_tieoff__clk [0:1];
  logic [0:0] pe_e_tieoff__reset [0:1];
  logic [0:0] pe_e_tieoff__recv__en [0:1];
  logic [31:0] pe_e_tieoff__recv__msg [0:1];
  logic [0:0] pe_e_tieoff__recv__rdy [0:1];
  logic [0:0] pe_e_tieoff__send__en [0:1];
  logic [31:0] pe_e_tieoff__send__msg [0:1];
  logic [0:0] pe_e_tieoff__send__rdy [0:1];

  TieOffSendRecv__Type_Bits32 pe_e_tieoff__0
  (
    .clk( pe_e_tieoff__clk[0] ),
    .reset( pe_e_tieoff__reset[0] ),
    .recv__en( pe_e_tieoff__recv__en[0] ),
    .recv__msg( pe_e_tieoff__recv__msg[0] ),
    .recv__rdy( pe_e_tieoff__recv__rdy[0] ),
    .send__en( pe_e_tieoff__send__en[0] ),
    .send__msg( pe_e_tieoff__send__msg[0] ),
    .send__rdy( pe_e_tieoff__send__rdy[0] )
  );

  TieOffSendRecv__Type_Bits32 pe_e_tieoff__1
  (
    .clk( pe_e_tieoff__clk[1] ),
    .reset( pe_e_tieoff__reset[1] ),
    .recv__en( pe_e_tieoff__recv__en[1] ),
    .recv__msg( pe_e_tieoff__recv__msg[1] ),
    .recv__rdy( pe_e_tieoff__recv__rdy[1] ),
    .send__en( pe_e_tieoff__send__en[1] ),
    .send__msg( pe_e_tieoff__send__msg[1] ),
    .send__rdy( pe_e_tieoff__send__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component pe_e_tieoff[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pe_w_tieoff[0:1]
  //-------------------------------------------------------------

  logic [0:0] pe_w_tieoff__clk [0:1];
  logic [0:0] pe_w_tieoff__reset [0:1];
  logic [0:0] pe_w_tieoff__recv__en [0:1];
  logic [31:0] pe_w_tieoff__recv__msg [0:1];
  logic [0:0] pe_w_tieoff__recv__rdy [0:1];
  logic [0:0] pe_w_tieoff__send__en [0:1];
  logic [31:0] pe_w_tieoff__send__msg [0:1];
  logic [0:0] pe_w_tieoff__send__rdy [0:1];

  TieOffSendRecv__Type_Bits32 pe_w_tieoff__0
  (
    .clk( pe_w_tieoff__clk[0] ),
    .reset( pe_w_tieoff__reset[0] ),
    .recv__en( pe_w_tieoff__recv__en[0] ),
    .recv__msg( pe_w_tieoff__recv__msg[0] ),
    .recv__rdy( pe_w_tieoff__recv__rdy[0] ),
    .send__en( pe_w_tieoff__send__en[0] ),
    .send__msg( pe_w_tieoff__send__msg[0] ),
    .send__rdy( pe_w_tieoff__send__rdy[0] )
  );

  TieOffSendRecv__Type_Bits32 pe_w_tieoff__1
  (
    .clk( pe_w_tieoff__clk[1] ),
    .reset( pe_w_tieoff__reset[1] ),
    .recv__en( pe_w_tieoff__recv__en[1] ),
    .recv__msg( pe_w_tieoff__recv__msg[1] ),
    .recv__rdy( pe_w_tieoff__recv__rdy[1] ),
    .send__en( pe_w_tieoff__send__en[1] ),
    .send__msg( pe_w_tieoff__send__msg[1] ),
    .send__rdy( pe_w_tieoff__send__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component pe_w_tieoff[0:1]
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:117
  // s.CSRs_en[i] //= lambda: s.is_cfg_done | s.is_cfg_go | s.is_calc_go
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_en_3_4_
    CSRs_en[4'd3:4'd3] = ( is_cfg_done | is_cfg_go ) | is_calc_go;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:119
  // s.CSRs_en[i] //= lambda: s.is_calc_done | s.is_cfg_go | s.is_calc_go
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_en_4_5_
    CSRs_en[4'd4:4'd4] = ( is_calc_done | is_cfg_go ) | is_calc_go;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:125
  // s.CSRs_in[i] //= lambda: 1 if s.is_cfg_done else \
  //                          0 if (s.is_cfg_go | s.is_calc_go) else \
  //                          s.CSRs[i].out
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_in_3_
    CSRs_in[4'd3] = is_cfg_done ? 32'd1 : ( is_cfg_go | is_calc_go ) ? 32'd0 : CSRs__out[4'( __const__i_at__lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_in_3_ )];
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:129
  // s.CSRs_in[i] //= lambda: 1 if s.is_calc_done else \
  //                          0 if (s.is_cfg_go | s.is_calc_go) else \
  //                          s.CSRs[i].out
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_in_4_
    CSRs_in[4'd4] = is_calc_done ? 32'd1 : ( is_cfg_go | is_calc_go ) ? 32'd0 : CSRs__out[4'( __const__i_at__lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_CSRs_in_4_ )];
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:291
  // s.is_calc_done           //= lambda: reduce_and( s.all_ME_done )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_is_calc_done
    is_calc_done = ( & all_ME_done );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:289
  // s.is_calc_go_transaction //= lambda: s.xminion_req_msg.addr == 1
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_is_calc_go_transaction
    is_calc_go_transaction = xminion_req_msg.addr == 12'd1;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:290
  // s.is_cfg_done            //= lambda: reduce_and( s.all_CE_done ) & reduce_and( s.all_PE_cfg_done )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_is_cfg_done
    is_cfg_done = ( & all_CE_done ) & ( & all_PE_cfg_done );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:288
  // s.is_cfg_go_transaction  //= lambda: s.xminion_req_msg.addr == 0
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_is_cfg_go_transaction
    is_cfg_go_transaction = xminion_req_msg.addr == 12'd0;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:262
  // s.xminion_resp_msg.data //= lambda: s.CSRs[ s.reg_CSR_raddr[0:num_CSRs_width] ].out
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_cgra_dpath_xminion_resp_msg_data
    xminion_resp_msg.data = CSRs__out[reg_CSR_raddr[4'd3:4'd0]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:135
  // @update
  // def req_bits():
  //   for i in range( p.num_CSRs ):
  //     if s.xminion_req_msg.addr == i:
  //       s.CSR_wen_bits[i] @= s.CSR_wen
  //     else:
  //       s.CSR_wen_bits[i] @= 0
  
  always_comb begin : req_bits
    for ( int i = 1'd0; i < 5'd16; i += 1'd1 )
      if ( xminion_req_msg.addr == 12'(i) ) begin
        CSR_wen_bits[4'(i)] = CSR_wen;
      end
      else
        CSR_wen_bits[4'(i)] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/StaticCGRADpath.py:146
  // @update_ff
  // def register_CSR_raddr():
  //   s.reg_CSR_raddr <<= s.xminion_req_msg.addr
  
  always_ff @(posedge clk) begin : register_CSR_raddr
    reg_CSR_raddr <= xminion_req_msg.addr;
  end

  assign pe_e_tieoff__clk[0] = clk;
  assign pe_e_tieoff__reset[0] = reset;
  assign pe_e_tieoff__clk[1] = clk;
  assign pe_e_tieoff__reset[1] = reset;
  assign pe_w_tieoff__clk[0] = clk;
  assign pe_w_tieoff__reset[0] = reset;
  assign pe_w_tieoff__clk[1] = clk;
  assign pe_w_tieoff__reset[1] = reset;
  assign me_n_cfg_tieoff__clk = clk;
  assign me_n_cfg_tieoff__reset = reset;
  assign me_s_cfg_tieoff__clk = clk;
  assign me_s_cfg_tieoff__reset = reset;
  assign pe_cfg_tieoff__clk[0] = clk;
  assign pe_cfg_tieoff__reset[0] = reset;
  assign pe_cfg_tieoff__clk[1] = clk;
  assign pe_cfg_tieoff__reset[1] = reset;
  assign ME_r__clk[0] = clk;
  assign ME_r__reset[0] = reset;
  assign ME_r__clk[1] = clk;
  assign ME_r__reset[1] = reset;
  assign ME_r__clk[2] = clk;
  assign ME_r__reset[2] = reset;
  assign ME_r__clk[3] = clk;
  assign ME_r__reset[3] = reset;
  assign CE_n__clk = clk;
  assign CE_n__reset = reset;
  assign CE_s__clk = clk;
  assign CE_s__reset = reset;
  assign CE_c__clk[0] = clk;
  assign CE_c__reset[0] = reset;
  assign CE_c__clk[1] = clk;
  assign CE_c__reset[1] = reset;
  assign PE_rc__clk[0] = clk;
  assign PE_rc__reset[0] = reset;
  assign PE_rc__clk[1] = clk;
  assign PE_rc__reset[1] = reset;
  assign PE_rc__clk[2] = clk;
  assign PE_rc__reset[2] = reset;
  assign PE_rc__clk[3] = clk;
  assign PE_rc__reset[3] = reset;
  assign mem_muxes__clk[0] = clk;
  assign mem_muxes__reset[0] = reset;
  assign mem_muxes__clk[1] = clk;
  assign mem_muxes__reset[1] = reset;
  assign mem_muxes__clk[2] = clk;
  assign mem_muxes__reset[2] = reset;
  assign mem_muxes__clk[3] = clk;
  assign mem_muxes__reset[3] = reset;
  assign CSRs__clk[0] = clk;
  assign CSRs__reset[0] = reset;
  assign CSRs__clk[1] = clk;
  assign CSRs__reset[1] = reset;
  assign CSRs__clk[2] = clk;
  assign CSRs__reset[2] = reset;
  assign CSRs__clk[3] = clk;
  assign CSRs__reset[3] = reset;
  assign CSRs__clk[4] = clk;
  assign CSRs__reset[4] = reset;
  assign CSRs__clk[5] = clk;
  assign CSRs__reset[5] = reset;
  assign CSRs__clk[6] = clk;
  assign CSRs__reset[6] = reset;
  assign CSRs__clk[7] = clk;
  assign CSRs__reset[7] = reset;
  assign CSRs__clk[8] = clk;
  assign CSRs__reset[8] = reset;
  assign CSRs__clk[9] = clk;
  assign CSRs__reset[9] = reset;
  assign CSRs__clk[10] = clk;
  assign CSRs__reset[10] = reset;
  assign CSRs__clk[11] = clk;
  assign CSRs__reset[11] = reset;
  assign CSRs__clk[12] = clk;
  assign CSRs__reset[12] = reset;
  assign CSRs__clk[13] = clk;
  assign CSRs__reset[13] = reset;
  assign CSRs__clk[14] = clk;
  assign CSRs__reset[14] = reset;
  assign CSRs__clk[15] = clk;
  assign CSRs__reset[15] = reset;
  assign CSRs__en[0] = CSRs_en[0:0];
  assign CSRs__in_[0] = CSRs_in[0];
  assign CSRs__en[1] = CSRs_en[1:1];
  assign CSRs__in_[1] = CSRs_in[1];
  assign CSRs__en[2] = CSRs_en[2:2];
  assign CSRs__in_[2] = CSRs_in[2];
  assign CSRs__en[3] = CSRs_en[3:3];
  assign CSRs__in_[3] = CSRs_in[3];
  assign CSRs__en[4] = CSRs_en[4:4];
  assign CSRs__in_[4] = CSRs_in[4];
  assign CSRs__en[5] = CSRs_en[5:5];
  assign CSRs__in_[5] = CSRs_in[5];
  assign CSRs__en[6] = CSRs_en[6:6];
  assign CSRs__in_[6] = CSRs_in[6];
  assign CSRs__en[7] = CSRs_en[7:7];
  assign CSRs__in_[7] = CSRs_in[7];
  assign CSRs__en[8] = CSRs_en[8:8];
  assign CSRs__in_[8] = CSRs_in[8];
  assign CSRs__en[9] = CSRs_en[9:9];
  assign CSRs__in_[9] = CSRs_in[9];
  assign CSRs__en[10] = CSRs_en[10:10];
  assign CSRs__in_[10] = CSRs_in[10];
  assign CSRs__en[11] = CSRs_en[11:11];
  assign CSRs__in_[11] = CSRs_in[11];
  assign CSRs__en[12] = CSRs_en[12:12];
  assign CSRs__in_[12] = CSRs_in[12];
  assign CSRs__en[13] = CSRs_en[13:13];
  assign CSRs__in_[13] = CSRs_in[13];
  assign CSRs__en[14] = CSRs_en[14:14];
  assign CSRs__in_[14] = CSRs_in[14];
  assign CSRs__en[15] = CSRs_en[15:15];
  assign CSRs__in_[15] = CSRs_in[15];
  assign CSRs_en[0:0] = CSR_wen_bits[0:0];
  assign CSRs_en[1:1] = CSR_wen_bits[1:1];
  assign CSRs_en[2:2] = CSR_wen_bits[2:2];
  assign CSRs_en[5:5] = CSR_wen_bits[5:5];
  assign CSRs_en[6:6] = CSR_wen_bits[6:6];
  assign CSRs_en[7:7] = CSR_wen_bits[7:7];
  assign CSRs_en[8:8] = CSR_wen_bits[8:8];
  assign CSRs_en[9:9] = CSR_wen_bits[9:9];
  assign CSRs_en[10:10] = CSR_wen_bits[10:10];
  assign CSRs_en[11:11] = CSR_wen_bits[11:11];
  assign CSRs_en[12:12] = CSR_wen_bits[12:12];
  assign CSRs_en[13:13] = CSR_wen_bits[13:13];
  assign CSRs_en[14:14] = CSR_wen_bits[14:14];
  assign CSRs_en[15:15] = CSR_wen_bits[15:15];
  assign CSRs_in[0] = xminion_req_msg.data;
  assign CSRs_in[1] = xminion_req_msg.data;
  assign CSRs_in[2] = xminion_req_msg.data;
  assign CSRs_in[5] = xminion_req_msg.data;
  assign CSRs_in[6] = xminion_req_msg.data;
  assign CSRs_in[7] = xminion_req_msg.data;
  assign CSRs_in[8] = xminion_req_msg.data;
  assign CSRs_in[9] = xminion_req_msg.data;
  assign CSRs_in[10] = xminion_req_msg.data;
  assign CSRs_in[11] = xminion_req_msg.data;
  assign CSRs_in[12] = xminion_req_msg.data;
  assign CSRs_in[13] = xminion_req_msg.data;
  assign CSRs_in[14] = xminion_req_msg.data;
  assign CSRs_in[15] = xminion_req_msg.data;
  assign CE_n__cfg_init = cfg_init;
  assign CE_n__cfg_base_addr = CSRs__out[2][11:0];
  assign CE_n__y_cord = 2'd3;
  assign CE_s__cfg_init = cfg_init;
  assign CE_s__cfg_base_addr = CSRs__out[2][11:0];
  assign CE_s__y_cord = 2'd0;
  assign CE_c__cfg_init[0] = cfg_init;
  assign CE_c__cfg_base_addr[0] = CSRs__out[2][11:0];
  assign CE_c__y_cord[0] = 2'd1;
  assign CE_c__cfg_init[1] = cfg_init;
  assign CE_c__cfg_base_addr[1] = CSRs__out[2][11:0];
  assign CE_c__y_cord[1] = 2'd2;
  assign ME_r__is_calc[2] = is_calc;
  assign ME_r__is_calc[0] = is_calc;
  assign ME_r__cfg_recv__en[2] = CE_n__cfg_send__en;
  assign ME_r__cfg_recv__msg[2] = CE_n__cfg_send__msg;
  assign CE_n__cfg_send__rdy = ME_r__cfg_recv__rdy[2];
  assign ME_r__cfg_recv__en[0] = CE_s__cfg_send__en;
  assign ME_r__cfg_recv__msg[0] = CE_s__cfg_send__msg;
  assign CE_s__cfg_send__rdy = ME_r__cfg_recv__rdy[0];
  assign ME_r__cfg_recv__en[3] = ME_r__cfg_send__en[2];
  assign ME_r__cfg_recv__msg[3] = ME_r__cfg_send__msg[2];
  assign ME_r__cfg_send__rdy[2] = ME_r__cfg_recv__rdy[3];
  assign ME_r__cfg_recv__en[1] = ME_r__cfg_send__en[0];
  assign ME_r__cfg_recv__msg[1] = ME_r__cfg_send__msg[0];
  assign ME_r__cfg_send__rdy[0] = ME_r__cfg_recv__rdy[1];
  assign ME_r__is_calc[3] = is_calc;
  assign ME_r__is_calc[1] = is_calc;
  assign me_n_cfg_tieoff__recv__en = ME_r__cfg_send__en[3];
  assign me_n_cfg_tieoff__recv__msg = ME_r__cfg_send__msg[3];
  assign ME_r__cfg_send__rdy[3] = me_n_cfg_tieoff__recv__rdy;
  assign me_s_cfg_tieoff__recv__en = ME_r__cfg_send__en[1];
  assign me_s_cfg_tieoff__recv__msg = ME_r__cfg_send__msg[1];
  assign ME_r__cfg_send__rdy[1] = me_s_cfg_tieoff__recv__rdy;
  assign PE_rc__cfg_recv__en[0] = CE_c__cfg_send__en[0];
  assign PE_rc__cfg_recv__msg[0] = CE_c__cfg_send__msg[0];
  assign CE_c__cfg_send__rdy[0] = PE_rc__cfg_recv__rdy[0];
  assign PE_rc__cfg_recv__en[1] = PE_rc__cfg_send__en[0];
  assign PE_rc__cfg_recv__msg[1] = PE_rc__cfg_send__msg[0];
  assign PE_rc__cfg_send__rdy[0] = PE_rc__cfg_recv__rdy[1];
  assign pe_cfg_tieoff__recv__en[0] = PE_rc__cfg_send__en[1];
  assign pe_cfg_tieoff__recv__msg[0] = PE_rc__cfg_send__msg[1];
  assign PE_rc__cfg_send__rdy[1] = pe_cfg_tieoff__recv__rdy[0];
  assign PE_rc__cfg_recv__en[2] = CE_c__cfg_send__en[1];
  assign PE_rc__cfg_recv__msg[2] = CE_c__cfg_send__msg[1];
  assign CE_c__cfg_send__rdy[1] = PE_rc__cfg_recv__rdy[2];
  assign PE_rc__cfg_recv__en[3] = PE_rc__cfg_send__en[2];
  assign PE_rc__cfg_recv__msg[3] = PE_rc__cfg_send__msg[2];
  assign PE_rc__cfg_send__rdy[2] = PE_rc__cfg_recv__rdy[3];
  assign pe_cfg_tieoff__recv__en[1] = PE_rc__cfg_send__en[3];
  assign pe_cfg_tieoff__recv__msg[1] = PE_rc__cfg_send__msg[3];
  assign PE_rc__cfg_send__rdy[3] = pe_cfg_tieoff__recv__rdy[1];
  assign mem_muxes__in___req__en[0][0] = ME_r__mem_ifc__req__en[0];
  assign mem_muxes__in___req__msg[0][0] = ME_r__mem_ifc__req__msg[0];
  assign ME_r__mem_ifc__req__rdy[0] = mem_muxes__in___req__rdy[0][0];
  assign ME_r__mem_ifc__resp__en[0] = mem_muxes__in___resp__en[0][0];
  assign ME_r__mem_ifc__resp__msg[0] = mem_muxes__in___resp__msg[0][0];
  assign mem_muxes__in___resp__rdy[0][0] = ME_r__mem_ifc__resp__rdy[0];
  assign mem_muxes__in___req__en[0][1] = CE_s__mem_master__req__en;
  assign mem_muxes__in___req__msg[0][1] = CE_s__mem_master__req__msg;
  assign CE_s__mem_master__req__rdy = mem_muxes__in___req__rdy[0][1];
  assign CE_s__mem_master__resp__en = mem_muxes__in___resp__en[0][1];
  assign CE_s__mem_master__resp__msg = mem_muxes__in___resp__msg[0][1];
  assign mem_muxes__in___resp__rdy[0][1] = CE_s__mem_master__resp__rdy;
  assign mem_muxes__sel[0] = is_cfg;
  assign spad_masters__req__en[0] = mem_muxes__out__req__en[0];
  assign spad_masters__req__msg[0] = mem_muxes__out__req__msg[0];
  assign mem_muxes__out__req__rdy[0] = spad_masters__req__rdy[0];
  assign mem_muxes__out__resp__en[0] = spad_masters__resp__en[0];
  assign mem_muxes__out__resp__msg[0] = spad_masters__resp__msg[0];
  assign spad_masters__resp__rdy[0] = mem_muxes__out__resp__rdy[0];
  assign mem_muxes__in___req__en[1][0] = ME_r__mem_ifc__req__en[1];
  assign mem_muxes__in___req__msg[1][0] = ME_r__mem_ifc__req__msg[1];
  assign ME_r__mem_ifc__req__rdy[1] = mem_muxes__in___req__rdy[1][0];
  assign ME_r__mem_ifc__resp__en[1] = mem_muxes__in___resp__en[1][0];
  assign ME_r__mem_ifc__resp__msg[1] = mem_muxes__in___resp__msg[1][0];
  assign mem_muxes__in___resp__rdy[1][0] = ME_r__mem_ifc__resp__rdy[1];
  assign mem_muxes__in___req__en[1][1] = CE_c__mem_master__req__en[0];
  assign mem_muxes__in___req__msg[1][1] = CE_c__mem_master__req__msg[0];
  assign CE_c__mem_master__req__rdy[0] = mem_muxes__in___req__rdy[1][1];
  assign CE_c__mem_master__resp__en[0] = mem_muxes__in___resp__en[1][1];
  assign CE_c__mem_master__resp__msg[0] = mem_muxes__in___resp__msg[1][1];
  assign mem_muxes__in___resp__rdy[1][1] = CE_c__mem_master__resp__rdy[0];
  assign mem_muxes__sel[1] = is_cfg;
  assign spad_masters__req__en[1] = mem_muxes__out__req__en[1];
  assign spad_masters__req__msg[1] = mem_muxes__out__req__msg[1];
  assign mem_muxes__out__req__rdy[1] = spad_masters__req__rdy[1];
  assign mem_muxes__out__resp__en[1] = spad_masters__resp__en[1];
  assign mem_muxes__out__resp__msg[1] = spad_masters__resp__msg[1];
  assign spad_masters__resp__rdy[1] = mem_muxes__out__resp__rdy[1];
  assign mem_muxes__in___req__en[2][0] = ME_r__mem_ifc__req__en[2];
  assign mem_muxes__in___req__msg[2][0] = ME_r__mem_ifc__req__msg[2];
  assign ME_r__mem_ifc__req__rdy[2] = mem_muxes__in___req__rdy[2][0];
  assign ME_r__mem_ifc__resp__en[2] = mem_muxes__in___resp__en[2][0];
  assign ME_r__mem_ifc__resp__msg[2] = mem_muxes__in___resp__msg[2][0];
  assign mem_muxes__in___resp__rdy[2][0] = ME_r__mem_ifc__resp__rdy[2];
  assign mem_muxes__in___req__en[2][1] = CE_c__mem_master__req__en[1];
  assign mem_muxes__in___req__msg[2][1] = CE_c__mem_master__req__msg[1];
  assign CE_c__mem_master__req__rdy[1] = mem_muxes__in___req__rdy[2][1];
  assign CE_c__mem_master__resp__en[1] = mem_muxes__in___resp__en[2][1];
  assign CE_c__mem_master__resp__msg[1] = mem_muxes__in___resp__msg[2][1];
  assign mem_muxes__in___resp__rdy[2][1] = CE_c__mem_master__resp__rdy[1];
  assign mem_muxes__sel[2] = is_cfg;
  assign spad_masters__req__en[2] = mem_muxes__out__req__en[2];
  assign spad_masters__req__msg[2] = mem_muxes__out__req__msg[2];
  assign mem_muxes__out__req__rdy[2] = spad_masters__req__rdy[2];
  assign mem_muxes__out__resp__en[2] = spad_masters__resp__en[2];
  assign mem_muxes__out__resp__msg[2] = spad_masters__resp__msg[2];
  assign spad_masters__resp__rdy[2] = mem_muxes__out__resp__rdy[2];
  assign mem_muxes__in___req__en[3][0] = ME_r__mem_ifc__req__en[3];
  assign mem_muxes__in___req__msg[3][0] = ME_r__mem_ifc__req__msg[3];
  assign ME_r__mem_ifc__req__rdy[3] = mem_muxes__in___req__rdy[3][0];
  assign ME_r__mem_ifc__resp__en[3] = mem_muxes__in___resp__en[3][0];
  assign ME_r__mem_ifc__resp__msg[3] = mem_muxes__in___resp__msg[3][0];
  assign mem_muxes__in___resp__rdy[3][0] = ME_r__mem_ifc__resp__rdy[3];
  assign mem_muxes__in___req__en[3][1] = CE_n__mem_master__req__en;
  assign mem_muxes__in___req__msg[3][1] = CE_n__mem_master__req__msg;
  assign CE_n__mem_master__req__rdy = mem_muxes__in___req__rdy[3][1];
  assign CE_n__mem_master__resp__en = mem_muxes__in___resp__en[3][1];
  assign CE_n__mem_master__resp__msg = mem_muxes__in___resp__msg[3][1];
  assign mem_muxes__in___resp__rdy[3][1] = CE_n__mem_master__resp__rdy;
  assign mem_muxes__sel[3] = is_cfg;
  assign spad_masters__req__en[3] = mem_muxes__out__req__en[3];
  assign spad_masters__req__msg[3] = mem_muxes__out__req__msg[3];
  assign mem_muxes__out__req__rdy[3] = spad_masters__req__rdy[3];
  assign mem_muxes__out__resp__en[3] = spad_masters__resp__en[3];
  assign mem_muxes__out__resp__msg[3] = spad_masters__resp__msg[3];
  assign spad_masters__resp__rdy[3] = mem_muxes__out__resp__rdy[3];
  assign ME_r__ns_cord[2] = 1'd1;
  assign ME_r__x_cord[2] = 1'd0;
  assign ME_r__ns_cord[0] = 1'd0;
  assign ME_r__x_cord[0] = 1'd0;
  assign ME_r__ns_cord[3] = 1'd1;
  assign ME_r__x_cord[3] = 1'd1;
  assign ME_r__ns_cord[1] = 1'd0;
  assign ME_r__x_cord[1] = 1'd1;
  assign PE_rc__y_cord[0] = 1'd0;
  assign PE_rc__x_cord[0] = 1'd0;
  assign PE_rc__recv__en[0][0] = PE_rc__send__en[2][1];
  assign PE_rc__recv__msg[0][0] = PE_rc__send__msg[2][1];
  assign PE_rc__send__rdy[2][1] = PE_rc__recv__rdy[0][0];
  assign PE_rc__recv__en[2][1] = PE_rc__send__en[0][0];
  assign PE_rc__recv__msg[2][1] = PE_rc__send__msg[0][0];
  assign PE_rc__send__rdy[0][0] = PE_rc__recv__rdy[2][1];
  assign PE_rc__recv__en[0][1] = ME_r__send__en[0];
  assign PE_rc__recv__msg[0][1] = ME_r__send__msg[0];
  assign ME_r__send__rdy[0] = PE_rc__recv__rdy[0][1];
  assign ME_r__recv__en[0] = PE_rc__send__en[0][1];
  assign ME_r__recv__msg[0] = PE_rc__send__msg[0][1];
  assign PE_rc__send__rdy[0][1] = ME_r__recv__rdy[0];
  assign PE_rc__recv__en[0][3] = PE_rc__send__en[1][2];
  assign PE_rc__recv__msg[0][3] = PE_rc__send__msg[1][2];
  assign PE_rc__send__rdy[1][2] = PE_rc__recv__rdy[0][3];
  assign PE_rc__recv__en[1][2] = PE_rc__send__en[0][3];
  assign PE_rc__recv__msg[1][2] = PE_rc__send__msg[0][3];
  assign PE_rc__send__rdy[0][3] = PE_rc__recv__rdy[1][2];
  assign PE_rc__recv__en[0][2] = pe_w_tieoff__send__en[0];
  assign PE_rc__recv__msg[0][2] = pe_w_tieoff__send__msg[0];
  assign pe_w_tieoff__send__rdy[0] = PE_rc__recv__rdy[0][2];
  assign pe_w_tieoff__recv__en[0] = PE_rc__send__en[0][2];
  assign pe_w_tieoff__recv__msg[0] = PE_rc__send__msg[0][2];
  assign PE_rc__send__rdy[0][2] = pe_w_tieoff__recv__rdy[0];
  assign PE_rc__y_cord[1] = 1'd0;
  assign PE_rc__x_cord[1] = 1'd1;
  assign PE_rc__recv__en[1][0] = PE_rc__send__en[3][1];
  assign PE_rc__recv__msg[1][0] = PE_rc__send__msg[3][1];
  assign PE_rc__send__rdy[3][1] = PE_rc__recv__rdy[1][0];
  assign PE_rc__recv__en[3][1] = PE_rc__send__en[1][0];
  assign PE_rc__recv__msg[3][1] = PE_rc__send__msg[1][0];
  assign PE_rc__send__rdy[1][0] = PE_rc__recv__rdy[3][1];
  assign PE_rc__recv__en[1][1] = ME_r__send__en[1];
  assign PE_rc__recv__msg[1][1] = ME_r__send__msg[1];
  assign ME_r__send__rdy[1] = PE_rc__recv__rdy[1][1];
  assign ME_r__recv__en[1] = PE_rc__send__en[1][1];
  assign ME_r__recv__msg[1] = PE_rc__send__msg[1][1];
  assign PE_rc__send__rdy[1][1] = ME_r__recv__rdy[1];
  assign PE_rc__recv__en[1][3] = pe_e_tieoff__send__en[0];
  assign PE_rc__recv__msg[1][3] = pe_e_tieoff__send__msg[0];
  assign pe_e_tieoff__send__rdy[0] = PE_rc__recv__rdy[1][3];
  assign pe_e_tieoff__recv__en[0] = PE_rc__send__en[1][3];
  assign pe_e_tieoff__recv__msg[0] = PE_rc__send__msg[1][3];
  assign PE_rc__send__rdy[1][3] = pe_e_tieoff__recv__rdy[0];
  assign PE_rc__y_cord[2] = 1'd1;
  assign PE_rc__x_cord[2] = 1'd0;
  assign PE_rc__recv__en[2][0] = ME_r__send__en[2];
  assign PE_rc__recv__msg[2][0] = ME_r__send__msg[2];
  assign ME_r__send__rdy[2] = PE_rc__recv__rdy[2][0];
  assign ME_r__recv__en[2] = PE_rc__send__en[2][0];
  assign ME_r__recv__msg[2] = PE_rc__send__msg[2][0];
  assign PE_rc__send__rdy[2][0] = ME_r__recv__rdy[2];
  assign PE_rc__recv__en[2][3] = PE_rc__send__en[3][2];
  assign PE_rc__recv__msg[2][3] = PE_rc__send__msg[3][2];
  assign PE_rc__send__rdy[3][2] = PE_rc__recv__rdy[2][3];
  assign PE_rc__recv__en[3][2] = PE_rc__send__en[2][3];
  assign PE_rc__recv__msg[3][2] = PE_rc__send__msg[2][3];
  assign PE_rc__send__rdy[2][3] = PE_rc__recv__rdy[3][2];
  assign PE_rc__recv__en[2][2] = pe_w_tieoff__send__en[1];
  assign PE_rc__recv__msg[2][2] = pe_w_tieoff__send__msg[1];
  assign pe_w_tieoff__send__rdy[1] = PE_rc__recv__rdy[2][2];
  assign pe_w_tieoff__recv__en[1] = PE_rc__send__en[2][2];
  assign pe_w_tieoff__recv__msg[1] = PE_rc__send__msg[2][2];
  assign PE_rc__send__rdy[2][2] = pe_w_tieoff__recv__rdy[1];
  assign PE_rc__y_cord[3] = 1'd1;
  assign PE_rc__x_cord[3] = 1'd1;
  assign PE_rc__recv__en[3][0] = ME_r__send__en[3];
  assign PE_rc__recv__msg[3][0] = ME_r__send__msg[3];
  assign ME_r__send__rdy[3] = PE_rc__recv__rdy[3][0];
  assign ME_r__recv__en[3] = PE_rc__send__en[3][0];
  assign ME_r__recv__msg[3] = PE_rc__send__msg[3][0];
  assign PE_rc__send__rdy[3][0] = ME_r__recv__rdy[3];
  assign PE_rc__recv__en[3][3] = pe_e_tieoff__send__en[1];
  assign PE_rc__recv__msg[3][3] = pe_e_tieoff__send__msg[1];
  assign pe_e_tieoff__send__rdy[1] = PE_rc__recv__rdy[3][3];
  assign pe_e_tieoff__recv__en[1] = PE_rc__send__en[3][3];
  assign pe_e_tieoff__recv__msg[1] = PE_rc__send__msg[3][3];
  assign PE_rc__send__rdy[3][3] = pe_e_tieoff__recv__rdy[1];
  assign PE_rc__cfg_init[0] = cfg_init;
  assign PE_rc__cfg_init[1] = cfg_init;
  assign PE_rc__cfg_init[2] = cfg_init;
  assign PE_rc__cfg_init[3] = cfg_init;
  assign xminion_resp_msg.wen = 1'd0;
  assign xminion_resp_msg.addr = reg_CSR_raddr;
  assign all_CE_done[0:0] = CE_n__is_done;
  assign all_CE_done[3:3] = CE_s__is_done;
  assign all_CE_done[1:1] = CE_c__is_done[0];
  assign all_CE_done[2:2] = CE_c__is_done[1];
  assign all_PE_cfg_done[0:0] = PE_rc__is_cfg_done[0];
  assign all_PE_cfg_done[1:1] = PE_rc__is_cfg_done[1];
  assign all_PE_cfg_done[2:2] = PE_rc__is_cfg_done[2];
  assign all_PE_cfg_done[3:3] = PE_rc__is_cfg_done[3];
  assign all_ME_done[0:0] = ME_r__is_done[0];
  assign all_ME_done[1:1] = ME_r__is_done[1];
  assign all_ME_done[2:2] = ME_r__is_done[2];
  assign all_ME_done[3:3] = ME_r__is_done[3];
  assign is_wen = xminion_req_msg.wen;

endmodule


// PyMTL Component StaticCGRA Definition
// Full name: StaticCGRA__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/StaticCGRA.py

module StaticCGRA__b5592e8a4ff43256
(
  input  logic [0:0] clk ,
  output logic [0:0] is_calc_done ,
  input  logic [0:0] reset ,
  output logic [0:0] spad_masters__req__en [0:3],
  output CgraSramReqMsg spad_masters__req__msg [0:3],
  input logic [0:0] spad_masters__req__rdy [0:3],
  input logic [0:0] spad_masters__resp__en [0:3],
  input CgraSramRespMsg spad_masters__resp__msg [0:3],
  output logic [0:0] spad_masters__resp__rdy [0:3],
  input logic [0:0] xcel_minion__req__en ,
  input CgraXcelReqMsg xcel_minion__req__msg ,
  output logic [0:0] xcel_minion__req__rdy ,
  output logic [0:0] xcel_minion__resp__en ,
  output CgraXcelRespMsg xcel_minion__resp__msg ,
  input logic [0:0] xcel_minion__resp__rdy 
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__CSR_wen;
  logic [0:0] ctrl__cfg_init;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__is_calc;
  logic [0:0] ctrl__is_calc_done;
  logic [0:0] ctrl__is_calc_go;
  logic [0:0] ctrl__is_calc_go_transaction;
  logic [0:0] ctrl__is_cfg;
  logic [0:0] ctrl__is_cfg_done;
  logic [0:0] ctrl__is_cfg_go;
  logic [0:0] ctrl__is_cfg_go_transaction;
  logic [0:0] ctrl__is_wen;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__xminion_req_en;
  logic [0:0] ctrl__xminion_req_rdy;
  logic [0:0] ctrl__xminion_resp_en;
  logic [0:0] ctrl__xminion_resp_rdy;

  StaticCGRACtrl__b5592e8a4ff43256 ctrl
  (
    .CSR_wen( ctrl__CSR_wen ),
    .cfg_init( ctrl__cfg_init ),
    .clk( ctrl__clk ),
    .is_calc( ctrl__is_calc ),
    .is_calc_done( ctrl__is_calc_done ),
    .is_calc_go( ctrl__is_calc_go ),
    .is_calc_go_transaction( ctrl__is_calc_go_transaction ),
    .is_cfg( ctrl__is_cfg ),
    .is_cfg_done( ctrl__is_cfg_done ),
    .is_cfg_go( ctrl__is_cfg_go ),
    .is_cfg_go_transaction( ctrl__is_cfg_go_transaction ),
    .is_wen( ctrl__is_wen ),
    .reset( ctrl__reset ),
    .xminion_req_en( ctrl__xminion_req_en ),
    .xminion_req_rdy( ctrl__xminion_req_rdy ),
    .xminion_resp_en( ctrl__xminion_resp_en ),
    .xminion_resp_rdy( ctrl__xminion_resp_rdy )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__CSR_wen;
  logic [0:0] dpath__cfg_init;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__is_calc;
  logic [0:0] dpath__is_calc_done;
  logic [0:0] dpath__is_calc_go;
  logic [0:0] dpath__is_calc_go_transaction;
  logic [0:0] dpath__is_cfg;
  logic [0:0] dpath__is_cfg_done;
  logic [0:0] dpath__is_cfg_go;
  logic [0:0] dpath__is_cfg_go_transaction;
  logic [0:0] dpath__is_wen;
  logic [0:0] dpath__reset;
  CgraXcelReqMsg dpath__xminion_req_msg;
  CgraXcelRespMsg dpath__xminion_resp_msg;
  logic [0:0] dpath__spad_masters__req__en [0:3];
  CgraSramReqMsg dpath__spad_masters__req__msg [0:3];
  logic [0:0] dpath__spad_masters__req__rdy [0:3];
  logic [0:0] dpath__spad_masters__resp__en [0:3];
  CgraSramRespMsg dpath__spad_masters__resp__msg [0:3];
  logic [0:0] dpath__spad_masters__resp__rdy [0:3];

  StaticCGRADpath__b5592e8a4ff43256 dpath
  (
    .CSR_wen( dpath__CSR_wen ),
    .cfg_init( dpath__cfg_init ),
    .clk( dpath__clk ),
    .is_calc( dpath__is_calc ),
    .is_calc_done( dpath__is_calc_done ),
    .is_calc_go( dpath__is_calc_go ),
    .is_calc_go_transaction( dpath__is_calc_go_transaction ),
    .is_cfg( dpath__is_cfg ),
    .is_cfg_done( dpath__is_cfg_done ),
    .is_cfg_go( dpath__is_cfg_go ),
    .is_cfg_go_transaction( dpath__is_cfg_go_transaction ),
    .is_wen( dpath__is_wen ),
    .reset( dpath__reset ),
    .xminion_req_msg( dpath__xminion_req_msg ),
    .xminion_resp_msg( dpath__xminion_resp_msg ),
    .spad_masters__req__en( dpath__spad_masters__req__en ),
    .spad_masters__req__msg( dpath__spad_masters__req__msg ),
    .spad_masters__req__rdy( dpath__spad_masters__req__rdy ),
    .spad_masters__resp__en( dpath__spad_masters__resp__en ),
    .spad_masters__resp__msg( dpath__spad_masters__resp__msg ),
    .spad_masters__resp__rdy( dpath__spad_masters__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__xminion_req_en = xcel_minion__req__en;
  assign xcel_minion__req__rdy = ctrl__xminion_req_rdy;
  assign dpath__xminion_req_msg = xcel_minion__req__msg;
  assign xcel_minion__resp__en = ctrl__xminion_resp_en;
  assign ctrl__xminion_resp_rdy = xcel_minion__resp__rdy;
  assign xcel_minion__resp__msg = dpath__xminion_resp_msg;
  assign spad_masters__req__en[0] = dpath__spad_masters__req__en[0];
  assign spad_masters__req__msg[0] = dpath__spad_masters__req__msg[0];
  assign dpath__spad_masters__req__rdy[0] = spad_masters__req__rdy[0];
  assign dpath__spad_masters__resp__en[0] = spad_masters__resp__en[0];
  assign dpath__spad_masters__resp__msg[0] = spad_masters__resp__msg[0];
  assign spad_masters__resp__rdy[0] = dpath__spad_masters__resp__rdy[0];
  assign spad_masters__req__en[1] = dpath__spad_masters__req__en[1];
  assign spad_masters__req__msg[1] = dpath__spad_masters__req__msg[1];
  assign dpath__spad_masters__req__rdy[1] = spad_masters__req__rdy[1];
  assign dpath__spad_masters__resp__en[1] = spad_masters__resp__en[1];
  assign dpath__spad_masters__resp__msg[1] = spad_masters__resp__msg[1];
  assign spad_masters__resp__rdy[1] = dpath__spad_masters__resp__rdy[1];
  assign spad_masters__req__en[2] = dpath__spad_masters__req__en[2];
  assign spad_masters__req__msg[2] = dpath__spad_masters__req__msg[2];
  assign dpath__spad_masters__req__rdy[2] = spad_masters__req__rdy[2];
  assign dpath__spad_masters__resp__en[2] = spad_masters__resp__en[2];
  assign dpath__spad_masters__resp__msg[2] = spad_masters__resp__msg[2];
  assign spad_masters__resp__rdy[2] = dpath__spad_masters__resp__rdy[2];
  assign spad_masters__req__en[3] = dpath__spad_masters__req__en[3];
  assign spad_masters__req__msg[3] = dpath__spad_masters__req__msg[3];
  assign dpath__spad_masters__req__rdy[3] = spad_masters__req__rdy[3];
  assign dpath__spad_masters__resp__en[3] = spad_masters__resp__en[3];
  assign dpath__spad_masters__resp__msg[3] = spad_masters__resp__msg[3];
  assign spad_masters__resp__rdy[3] = dpath__spad_masters__resp__rdy[3];
  assign ctrl__is_cfg_go_transaction = dpath__is_cfg_go_transaction;
  assign ctrl__is_calc_go_transaction = dpath__is_calc_go_transaction;
  assign ctrl__is_cfg_done = dpath__is_cfg_done;
  assign ctrl__is_calc_done = dpath__is_calc_done;
  assign ctrl__is_wen = dpath__is_wen;
  assign dpath__is_cfg = ctrl__is_cfg;
  assign dpath__is_calc = ctrl__is_calc;
  assign dpath__cfg_init = ctrl__cfg_init;
  assign dpath__CSR_wen = ctrl__CSR_wen;
  assign is_calc_done = dpath__is_calc_done;

endmodule


// PyMTL Component MemMasterToSramAdapter Definition
// Full name: MemMasterToSramAdapter__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__data_width_32__num_entries_1024__mask_size_0
// At /work/global/pp482/uecgra-src/src/misc/MemMasterToSramAdapter.py

module MemMasterToSramAdapter__20779eae7290b15a
(
  input  logic [0:0] clk ,
  output logic [9:0] idx ,
  input  logic [31:0] rdata ,
  input  logic [0:0] reset ,
  output logic [0:0] type_ ,
  output logic [0:0] val ,
  output logic [31:0] wdata ,
  input logic [0:0] minion__req__en ,
  input CgraSramReqMsg minion__req__msg ,
  output logic [0:0] minion__req__rdy ,
  output logic [0:0] minion__resp__en ,
  output CgraSramRespMsg minion__resp__msg ,
  input logic [0:0] minion__resp__rdy 
);
  logic [11:0] reg_req_addr;
  logic [2:0] reg_req_opaque;
  logic [0:0] reg_req_wen;
  logic [0:0] resp_val;

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/misc/MemMasterToSramAdapter.py:52
  // s.minion.resp.en  //= lambda: s.minion.resp.rdy & s.resp_val
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_scratchpad_adapters_0__minion_resp_en
    minion__resp__en = minion__resp__rdy & resp_val;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/misc/MemMasterToSramAdapter.py:45
  // s.val   //= lambda: s.minion.req.en & s.minion.req.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_scratchpad_adapters_0__val
    val = minion__req__en & minion__req__rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/misc/MemMasterToSramAdapter.py:64
  // @update_ff
  // def register_req():
  //   s.reg_req_wen <<= s.minion.req.msg.wen
  //   s.reg_req_addr <<= s.minion.req.msg.addr
  //   s.reg_req_opaque <<= s.minion.req.msg.opaque
  
  always_ff @(posedge clk) begin : register_req
    reg_req_wen <= minion__req__msg.wen;
    reg_req_addr <= minion__req__msg.addr;
    reg_req_opaque <= minion__req__msg.opaque;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/misc/MemMasterToSramAdapter.py:59
  // @update_ff
  // def resp_val_upblk():
  //   # Read response will come out in the next cycle
  //   s.resp_val <<= s.val
  
  always_ff @(posedge clk) begin : resp_val_upblk
    resp_val <= val;
  end

  assign minion__req__rdy = 1'd1;
  assign type_ = minion__req__msg.wen;
  assign idx = minion__req__msg.addr[11:2];
  assign wdata = minion__req__msg.data;
  assign minion__resp__msg.wen = reg_req_wen;
  assign minion__resp__msg.addr = reg_req_addr;
  assign minion__resp__msg.opaque = reg_req_opaque;
  assign minion__resp__msg.data = rdata;

endmodule


// PyMTL Component SramGenericPRTL Definition
// At /work/global/pp482/uecgra-src/src/sram/SramGenericPRTL.py

module SramGenericPRTL__data_nbits_32__num_entries_1024
(
  input  logic [9:0] A1 ,
  input  logic [0:0] CE1 ,
  input  logic [0:0] CSB1 ,
  input  logic [31:0] I1 ,
  output logic [31:0] O1 ,
  input  logic [0:0] OEB1 ,
  input  logic [0:0] WEB1 ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset 
);
  logic [31:0] dout;
  logic [31:0] ram [0:1023];

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/sram/SramGenericPRTL.py:46
  // @update
  // def comb_logic():
  //   if ~s.OEB1:
  //     s.O1 @= s.dout
  //   else:
  //     s.O1 @= 0
  
  always_comb begin : comb_logic
    if ( ~OEB1 ) begin
      O1 = dout;
    end
    else
      O1 = 32'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/sram/SramGenericPRTL.py:39
  // @update_ff
  // def read_logic():
  //   if ~s.CSB1 & s.WEB1:
  //     s.dout <<= s.ram[ s.A1 ]
  //   else:
  //     s.dout <<= 0
  
  always_ff @(posedge clk) begin : read_logic
    if ( ( ~CSB1 ) & WEB1 ) begin
      dout <= ram[A1];
    end
    else
      dout <= 32'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/sram/SramGenericPRTL.py:55
  // @update_ff
  // def write_logic():
  //   if (~s.CSB1) & (~s.WEB1):
  //     s.ram[s.A1] <<= s.I1
  
  always_ff @(posedge clk) begin : write_logic
    if ( ( ~CSB1 ) & ( ~WEB1 ) ) begin
      ram[A1] <= I1;
    end
  end

endmodule


// PyMTL Component SramRTL Definition
// At /work/global/pp482/uecgra-src/src/sram/SramRTL.py

module SramRTL__data_nbits_32__num_entries_1024__mask_size_0
(
  input  logic [0:0] clk ,
  input  logic [9:0] port0_idx ,
  output logic [31:0] port0_rdata ,
  input  logic [0:0] port0_type ,
  input  logic [0:0] port0_val ,
  input  logic [31:0] port0_wdata ,
  input  logic [0:0] reset 
);
  logic [0:0] port0_type_bar;
  logic [0:0] port0_val_bar;
  //-------------------------------------------------------------
  // Component sram
  //-------------------------------------------------------------

  logic [9:0] sram__A1;
  logic [0:0] sram__CE1;
  logic [0:0] sram__CSB1;
  logic [31:0] sram__I1;
  logic [31:0] sram__O1;
  logic [0:0] sram__OEB1;
  logic [0:0] sram__WEB1;
  logic [0:0] sram__clk;
  logic [0:0] sram__reset;

  SramGenericPRTL__data_nbits_32__num_entries_1024 sram
  (
    .A1( sram__A1 ),
    .CE1( sram__CE1 ),
    .CSB1( sram__CSB1 ),
    .I1( sram__I1 ),
    .O1( sram__O1 ),
    .OEB1( sram__OEB1 ),
    .WEB1( sram__WEB1 ),
    .clk( sram__clk ),
    .reset( sram__reset )
  );

  //-------------------------------------------------------------
  // End of component sram
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/sram/SramPRTL.py:84
  // s.port0_type_bar //= lambda: ~s.port0_type
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_scratchpads_0__port0_type_bar
    port0_type_bar = ~port0_type;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/sram/SramPRTL.py:58
  // s.port0_val_bar  //= lambda: ~s.port0_val
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_scratchpads_0__port0_val_bar
    port0_val_bar = ~port0_val;
  end

  assign sram__clk = clk;
  assign sram__reset = reset;
  assign sram__CE1 = clk;
  assign sram__CSB1 = port0_val_bar;
  assign sram__OEB1 = 1'd0;
  assign sram__WEB1 = port0_type_bar;
  assign sram__A1 = port0_idx;
  assign sram__I1 = port0_wdata;
  assign port0_rdata = sram__O1;

endmodule


// PyMTL Component DstLogicSingleResp Definition
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py

module DstLogicSingleResp__Req_CgraSramReqMsg__SrcT_Bits2__DstT_Bits1
(
  input  logic [0:0] clk ,
  input  CgraSramReqMsg in_req ,
  input  logic [1:0] in_src_id ,
  output logic [0:0] out_dst ,
  input  logic [0:0] reset 
);

  assign out_dst = 1'd0;

endmodule


// PyMTL Component Table Definition
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py

module Table__EntryType_Bits3__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] alloc__en  ,
  input logic [2:0] alloc__msg  ,
  output logic [0:0] alloc__rdy  ,
  output logic [0:0] alloc__ret  ,
  input logic [0:0] dealloc__en  ,
  input logic [0:0] dealloc__msg  ,
  output logic [0:0] dealloc__rdy  ,
  output logic [2:0] dealloc__ret  
);
  localparam logic [1:0] __const__num_entries_at_up_entry_r_valid_r  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_avail_idx_next  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_avail_idx_r  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_alloc_rdy  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_dealloc_rdy  = 2'd2;
  logic [0:0] avail_idx_next;
  logic [0:0] avail_idx_r;
  logic [2:0] entry_r [0:1];
  logic [0:0] valid_r [0:1];

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py:89
  // s.dealloc.ret //= lambda: s.entry_r[ s.dealloc.msg ] if s.valid_r[ s.dealloc.msg ] else EntryType(-1)
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_0__opq_table_dealloc_ret
    dealloc__ret = valid_r[dealloc__msg] ? entry_r[dealloc__msg] : 3'd7;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py:72
  // @update
  // def up_alloc_rdy():
  //   s.alloc.rdy @= 0
  //   for i in range( num_entries ):
  //     if ~s.valid_r[i]:
  //       s.alloc.rdy @= 1
  
  always_comb begin : up_alloc_rdy
    alloc__rdy = 1'd0;
    for ( int i = 1'd0; i < 2'( __const__num_entries_at_up_alloc_rdy ); i += 1'd1 )
      if ( ~valid_r[1'(i)] ) begin
        alloc__rdy = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py:51
  // @update
  // def up_avail_idx_next():
  //   s.avail_idx_next @= 0
  //   for i in range( num_entries ):
  //     if ~s.valid_r[i] & \
  //        ~( s.alloc.en & ( s.avail_idx_r == i ) ) | \
  //        s.dealloc.en & ( s.dealloc.msg == i ):
  //       s.avail_idx_next @= i
  
  always_comb begin : up_avail_idx_next
    avail_idx_next = 1'd0;
    for ( int i = 1'd0; i < 2'( __const__num_entries_at_up_avail_idx_next ); i += 1'd1 )
      if ( ( ( ~valid_r[1'(i)] ) & ( ~( alloc__en & ( avail_idx_r == 1'(i) ) ) ) ) | ( dealloc__en & ( dealloc__msg == 1'(i) ) ) ) begin
        avail_idx_next = 1'(i);
      end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py:79
  // @update
  // def up_dealloc_rdy():
  //   s.dealloc.rdy @= 0
  //   for i in range( num_entries ):
  //     if s.valid_r[i]:
  //       s.dealloc.rdy @= 1
  
  always_comb begin : up_dealloc_rdy
    dealloc__rdy = 1'd0;
    for ( int i = 1'd0; i < 2'( __const__num_entries_at_up_dealloc_rdy ); i += 1'd1 )
      if ( valid_r[1'(i)] ) begin
        dealloc__rdy = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py:60
  // @update_ff
  // def up_avail_idx_r():
  //   if s.reset:
  //     s.avail_idx_r <<= IdxType(num_entries-1)
  //   else:
  //     s.avail_idx_r <<= s.avail_idx_next
  
  always_ff @(posedge clk) begin : up_avail_idx_r
    if ( reset ) begin
      avail_idx_r <= 1'd1;
    end
    else
      avail_idx_r <= avail_idx_next;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/Table.py:37
  // @update_ff
  // def up_entry_r_valid_r():
  //   if s.reset:
  //     # s.valid_r <<= BitsN(0)
  //     for i in range( num_entries ):
  //       s.valid_r[i] <<= 0
  //   else:
  //     if s.alloc.en:
  //       s.entry_r[ s.avail_idx_r ] <<= s.alloc.msg
  //       s.valid_r[ s.avail_idx_r ] <<= 1
  // 
  //     if s.dealloc.en:
  //       s.valid_r[ s.dealloc.msg ] <<= 0
  
  always_ff @(posedge clk) begin : up_entry_r_valid_r
    if ( reset ) begin
      for ( int i = 1'd0; i < 2'( __const__num_entries_at_up_entry_r_valid_r ); i += 1'd1 )
        valid_r[1'(i)] <= 1'd0;
    end
    else begin
      if ( alloc__en ) begin
        entry_r[avail_idx_r] <= alloc__msg;
        valid_r[avail_idx_r] <= 1'd1;
      end
      if ( dealloc__en ) begin
        valid_r[dealloc__msg] <= 1'd0;
      end
    end
  end

  assign alloc__ret = avail_idx_r;

endmodule


// PyMTL Component ReqAdapter Definition
// Full name: ReqAdapter__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__id_0__num_requesters_4__num_responders_1__max_req_in_flight_2__DstLogicT_DstLogicSingleResp
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py

module ReqAdapter__8171e7eaa19befb7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master__req__en ,
  output mmxbar_req_1_CgraSramReqMsg master__req__msg ,
  input logic [0:0] master__req__rdy ,
  input logic [0:0] master__resp__en ,
  input mmxbar_resp_4_CgraSramRespMsg master__resp__msg ,
  output logic [0:0] master__resp__rdy ,
  input logic [0:0] minion__req__en ,
  input CgraSramReqMsg minion__req__msg ,
  output logic [0:0] minion__req__rdy ,
  output logic [0:0] minion__resp__en ,
  output CgraSramRespMsg minion__resp__msg ,
  input logic [0:0] minion__resp__rdy 
);
  localparam logic [0:0] __const__id_at_up_master_req_msg  = 1'd0;
  //-------------------------------------------------------------
  // Component dst_logic
  //-------------------------------------------------------------

  logic [0:0] dst_logic__clk;
  CgraSramReqMsg dst_logic__in_req;
  logic [1:0] dst_logic__in_src_id;
  logic [0:0] dst_logic__out_dst;
  logic [0:0] dst_logic__reset;

  DstLogicSingleResp__Req_CgraSramReqMsg__SrcT_Bits2__DstT_Bits1 dst_logic
  (
    .clk( dst_logic__clk ),
    .in_req( dst_logic__in_req ),
    .in_src_id( dst_logic__in_src_id ),
    .out_dst( dst_logic__out_dst ),
    .reset( dst_logic__reset )
  );

  //-------------------------------------------------------------
  // End of component dst_logic
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opq_table
  //-------------------------------------------------------------

  logic [0:0] opq_table__clk;
  logic [0:0] opq_table__reset;
  logic [0:0] opq_table__alloc__en;
  logic [2:0] opq_table__alloc__msg;
  logic [0:0] opq_table__alloc__rdy;
  logic [0:0] opq_table__alloc__ret;
  logic [0:0] opq_table__dealloc__en;
  logic [0:0] opq_table__dealloc__msg;
  logic [0:0] opq_table__dealloc__rdy;
  logic [2:0] opq_table__dealloc__ret;

  Table__EntryType_Bits3__num_entries_2 opq_table
  (
    .clk( opq_table__clk ),
    .reset( opq_table__reset ),
    .alloc__en( opq_table__alloc__en ),
    .alloc__msg( opq_table__alloc__msg ),
    .alloc__rdy( opq_table__alloc__rdy ),
    .alloc__ret( opq_table__alloc__ret ),
    .dealloc__en( opq_table__dealloc__en ),
    .dealloc__msg( opq_table__dealloc__msg ),
    .dealloc__rdy( opq_table__dealloc__rdy ),
    .dealloc__ret( opq_table__dealloc__ret )
  );

  //-------------------------------------------------------------
  // End of component opq_table
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:91
  // s.master.req.en   //= lambda: s.minion.req.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_0__master_req_en
    master__req__en = minion__req__en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:92
  // s.master.resp.rdy //= lambda: s.minion.resp.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_0__master_resp_rdy
    master__resp__rdy = minion__resp__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:88
  // s.minion.req.rdy //= lambda: s.opq_table.alloc.rdy & s.master.req.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_0__minion_req_rdy
    minion__req__rdy = opq_table__alloc__rdy & master__req__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:89
  // s.minion.resp.en //= lambda: s.master.resp.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_0__minion_resp_en
    minion__resp__en = master__resp__en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:94
  // @update
  // def up_master_req_msg():
  //   s.master.req.msg.dst @= s.dst_logic.out_dst
  //   s.master.req.msg.payload @= s.minion.req.msg
  //   s.master.req.msg.payload.opaque[ sl_src ] @= id
  //   s.master.req.msg.payload.opaque[ sl_idx ] @= s.opq_table.alloc.ret
  
  always_comb begin : up_master_req_msg
    master__req__msg.dst = dst_logic__out_dst;
    master__req__msg.payload = minion__req__msg;
    master__req__msg.payload.opaque[2'd1:2'd0] = 2'( __const__id_at_up_master_req_msg );
    master__req__msg.payload.opaque[2'd2:2'd2] = opq_table__alloc__ret;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:101
  // @update
  // def up_minion_resp_msg():
  //   s.minion.resp.msg @= s.master.resp.msg.payload
  //   s.minion.resp.msg.opaque @= s.opq_table.dealloc.ret
  
  always_comb begin : up_minion_resp_msg
    minion__resp__msg = master__resp__msg.payload;
    minion__resp__msg.opaque = opq_table__dealloc__ret;
  end

  assign opq_table__clk = clk;
  assign opq_table__reset = reset;
  assign opq_table__alloc__en = minion__req__en;
  assign opq_table__alloc__msg = minion__req__msg.opaque;
  assign opq_table__dealloc__en = master__resp__en;
  assign opq_table__dealloc__msg = master__resp__msg.payload.opaque[2:2];
  assign dst_logic__clk = clk;
  assign dst_logic__reset = reset;
  assign dst_logic__in_req = minion__req__msg;
  assign dst_logic__in_src_id = 2'd0;

endmodule


// PyMTL Component ReqAdapter Definition
// Full name: ReqAdapter__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__id_1__num_requesters_4__num_responders_1__max_req_in_flight_2__DstLogicT_DstLogicSingleResp
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py

module ReqAdapter__f237a5ca74f516bf
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master__req__en ,
  output mmxbar_req_1_CgraSramReqMsg master__req__msg ,
  input logic [0:0] master__req__rdy ,
  input logic [0:0] master__resp__en ,
  input mmxbar_resp_4_CgraSramRespMsg master__resp__msg ,
  output logic [0:0] master__resp__rdy ,
  input logic [0:0] minion__req__en ,
  input CgraSramReqMsg minion__req__msg ,
  output logic [0:0] minion__req__rdy ,
  output logic [0:0] minion__resp__en ,
  output CgraSramRespMsg minion__resp__msg ,
  input logic [0:0] minion__resp__rdy 
);
  localparam logic [0:0] __const__id_at_up_master_req_msg  = 1'd1;
  //-------------------------------------------------------------
  // Component dst_logic
  //-------------------------------------------------------------

  logic [0:0] dst_logic__clk;
  CgraSramReqMsg dst_logic__in_req;
  logic [1:0] dst_logic__in_src_id;
  logic [0:0] dst_logic__out_dst;
  logic [0:0] dst_logic__reset;

  DstLogicSingleResp__Req_CgraSramReqMsg__SrcT_Bits2__DstT_Bits1 dst_logic
  (
    .clk( dst_logic__clk ),
    .in_req( dst_logic__in_req ),
    .in_src_id( dst_logic__in_src_id ),
    .out_dst( dst_logic__out_dst ),
    .reset( dst_logic__reset )
  );

  //-------------------------------------------------------------
  // End of component dst_logic
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opq_table
  //-------------------------------------------------------------

  logic [0:0] opq_table__clk;
  logic [0:0] opq_table__reset;
  logic [0:0] opq_table__alloc__en;
  logic [2:0] opq_table__alloc__msg;
  logic [0:0] opq_table__alloc__rdy;
  logic [0:0] opq_table__alloc__ret;
  logic [0:0] opq_table__dealloc__en;
  logic [0:0] opq_table__dealloc__msg;
  logic [0:0] opq_table__dealloc__rdy;
  logic [2:0] opq_table__dealloc__ret;

  Table__EntryType_Bits3__num_entries_2 opq_table
  (
    .clk( opq_table__clk ),
    .reset( opq_table__reset ),
    .alloc__en( opq_table__alloc__en ),
    .alloc__msg( opq_table__alloc__msg ),
    .alloc__rdy( opq_table__alloc__rdy ),
    .alloc__ret( opq_table__alloc__ret ),
    .dealloc__en( opq_table__dealloc__en ),
    .dealloc__msg( opq_table__dealloc__msg ),
    .dealloc__rdy( opq_table__dealloc__rdy ),
    .dealloc__ret( opq_table__dealloc__ret )
  );

  //-------------------------------------------------------------
  // End of component opq_table
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:91
  // s.master.req.en   //= lambda: s.minion.req.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_1__master_req_en
    master__req__en = minion__req__en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:92
  // s.master.resp.rdy //= lambda: s.minion.resp.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_1__master_resp_rdy
    master__resp__rdy = minion__resp__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:88
  // s.minion.req.rdy //= lambda: s.opq_table.alloc.rdy & s.master.req.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_1__minion_req_rdy
    minion__req__rdy = opq_table__alloc__rdy & master__req__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:89
  // s.minion.resp.en //= lambda: s.master.resp.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_1__minion_resp_en
    minion__resp__en = master__resp__en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:94
  // @update
  // def up_master_req_msg():
  //   s.master.req.msg.dst @= s.dst_logic.out_dst
  //   s.master.req.msg.payload @= s.minion.req.msg
  //   s.master.req.msg.payload.opaque[ sl_src ] @= id
  //   s.master.req.msg.payload.opaque[ sl_idx ] @= s.opq_table.alloc.ret
  
  always_comb begin : up_master_req_msg
    master__req__msg.dst = dst_logic__out_dst;
    master__req__msg.payload = minion__req__msg;
    master__req__msg.payload.opaque[2'd1:2'd0] = 2'( __const__id_at_up_master_req_msg );
    master__req__msg.payload.opaque[2'd2:2'd2] = opq_table__alloc__ret;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:101
  // @update
  // def up_minion_resp_msg():
  //   s.minion.resp.msg @= s.master.resp.msg.payload
  //   s.minion.resp.msg.opaque @= s.opq_table.dealloc.ret
  
  always_comb begin : up_minion_resp_msg
    minion__resp__msg = master__resp__msg.payload;
    minion__resp__msg.opaque = opq_table__dealloc__ret;
  end

  assign opq_table__clk = clk;
  assign opq_table__reset = reset;
  assign opq_table__alloc__en = minion__req__en;
  assign opq_table__alloc__msg = minion__req__msg.opaque;
  assign opq_table__dealloc__en = master__resp__en;
  assign opq_table__dealloc__msg = master__resp__msg.payload.opaque[2:2];
  assign dst_logic__clk = clk;
  assign dst_logic__reset = reset;
  assign dst_logic__in_req = minion__req__msg;
  assign dst_logic__in_src_id = 2'd1;

endmodule


// PyMTL Component ReqAdapter Definition
// Full name: ReqAdapter__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__id_2__num_requesters_4__num_responders_1__max_req_in_flight_2__DstLogicT_DstLogicSingleResp
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py

module ReqAdapter__1b4b26a38c16ecd6
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master__req__en ,
  output mmxbar_req_1_CgraSramReqMsg master__req__msg ,
  input logic [0:0] master__req__rdy ,
  input logic [0:0] master__resp__en ,
  input mmxbar_resp_4_CgraSramRespMsg master__resp__msg ,
  output logic [0:0] master__resp__rdy ,
  input logic [0:0] minion__req__en ,
  input CgraSramReqMsg minion__req__msg ,
  output logic [0:0] minion__req__rdy ,
  output logic [0:0] minion__resp__en ,
  output CgraSramRespMsg minion__resp__msg ,
  input logic [0:0] minion__resp__rdy 
);
  localparam logic [1:0] __const__id_at_up_master_req_msg  = 2'd2;
  //-------------------------------------------------------------
  // Component dst_logic
  //-------------------------------------------------------------

  logic [0:0] dst_logic__clk;
  CgraSramReqMsg dst_logic__in_req;
  logic [1:0] dst_logic__in_src_id;
  logic [0:0] dst_logic__out_dst;
  logic [0:0] dst_logic__reset;

  DstLogicSingleResp__Req_CgraSramReqMsg__SrcT_Bits2__DstT_Bits1 dst_logic
  (
    .clk( dst_logic__clk ),
    .in_req( dst_logic__in_req ),
    .in_src_id( dst_logic__in_src_id ),
    .out_dst( dst_logic__out_dst ),
    .reset( dst_logic__reset )
  );

  //-------------------------------------------------------------
  // End of component dst_logic
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opq_table
  //-------------------------------------------------------------

  logic [0:0] opq_table__clk;
  logic [0:0] opq_table__reset;
  logic [0:0] opq_table__alloc__en;
  logic [2:0] opq_table__alloc__msg;
  logic [0:0] opq_table__alloc__rdy;
  logic [0:0] opq_table__alloc__ret;
  logic [0:0] opq_table__dealloc__en;
  logic [0:0] opq_table__dealloc__msg;
  logic [0:0] opq_table__dealloc__rdy;
  logic [2:0] opq_table__dealloc__ret;

  Table__EntryType_Bits3__num_entries_2 opq_table
  (
    .clk( opq_table__clk ),
    .reset( opq_table__reset ),
    .alloc__en( opq_table__alloc__en ),
    .alloc__msg( opq_table__alloc__msg ),
    .alloc__rdy( opq_table__alloc__rdy ),
    .alloc__ret( opq_table__alloc__ret ),
    .dealloc__en( opq_table__dealloc__en ),
    .dealloc__msg( opq_table__dealloc__msg ),
    .dealloc__rdy( opq_table__dealloc__rdy ),
    .dealloc__ret( opq_table__dealloc__ret )
  );

  //-------------------------------------------------------------
  // End of component opq_table
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:91
  // s.master.req.en   //= lambda: s.minion.req.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_2__master_req_en
    master__req__en = minion__req__en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:92
  // s.master.resp.rdy //= lambda: s.minion.resp.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_2__master_resp_rdy
    master__resp__rdy = minion__resp__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:88
  // s.minion.req.rdy //= lambda: s.opq_table.alloc.rdy & s.master.req.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_2__minion_req_rdy
    minion__req__rdy = opq_table__alloc__rdy & master__req__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:89
  // s.minion.resp.en //= lambda: s.master.resp.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_2__minion_resp_en
    minion__resp__en = master__resp__en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:94
  // @update
  // def up_master_req_msg():
  //   s.master.req.msg.dst @= s.dst_logic.out_dst
  //   s.master.req.msg.payload @= s.minion.req.msg
  //   s.master.req.msg.payload.opaque[ sl_src ] @= id
  //   s.master.req.msg.payload.opaque[ sl_idx ] @= s.opq_table.alloc.ret
  
  always_comb begin : up_master_req_msg
    master__req__msg.dst = dst_logic__out_dst;
    master__req__msg.payload = minion__req__msg;
    master__req__msg.payload.opaque[2'd1:2'd0] = 2'( __const__id_at_up_master_req_msg );
    master__req__msg.payload.opaque[2'd2:2'd2] = opq_table__alloc__ret;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:101
  // @update
  // def up_minion_resp_msg():
  //   s.minion.resp.msg @= s.master.resp.msg.payload
  //   s.minion.resp.msg.opaque @= s.opq_table.dealloc.ret
  
  always_comb begin : up_minion_resp_msg
    minion__resp__msg = master__resp__msg.payload;
    minion__resp__msg.opaque = opq_table__dealloc__ret;
  end

  assign opq_table__clk = clk;
  assign opq_table__reset = reset;
  assign opq_table__alloc__en = minion__req__en;
  assign opq_table__alloc__msg = minion__req__msg.opaque;
  assign opq_table__dealloc__en = master__resp__en;
  assign opq_table__dealloc__msg = master__resp__msg.payload.opaque[2:2];
  assign dst_logic__clk = clk;
  assign dst_logic__reset = reset;
  assign dst_logic__in_req = minion__req__msg;
  assign dst_logic__in_src_id = 2'd2;

endmodule


// PyMTL Component ReqAdapter Definition
// Full name: ReqAdapter__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__id_3__num_requesters_4__num_responders_1__max_req_in_flight_2__DstLogicT_DstLogicSingleResp
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py

module ReqAdapter__676d2b176ec992bb
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master__req__en ,
  output mmxbar_req_1_CgraSramReqMsg master__req__msg ,
  input logic [0:0] master__req__rdy ,
  input logic [0:0] master__resp__en ,
  input mmxbar_resp_4_CgraSramRespMsg master__resp__msg ,
  output logic [0:0] master__resp__rdy ,
  input logic [0:0] minion__req__en ,
  input CgraSramReqMsg minion__req__msg ,
  output logic [0:0] minion__req__rdy ,
  output logic [0:0] minion__resp__en ,
  output CgraSramRespMsg minion__resp__msg ,
  input logic [0:0] minion__resp__rdy 
);
  localparam logic [1:0] __const__id_at_up_master_req_msg  = 2'd3;
  //-------------------------------------------------------------
  // Component dst_logic
  //-------------------------------------------------------------

  logic [0:0] dst_logic__clk;
  CgraSramReqMsg dst_logic__in_req;
  logic [1:0] dst_logic__in_src_id;
  logic [0:0] dst_logic__out_dst;
  logic [0:0] dst_logic__reset;

  DstLogicSingleResp__Req_CgraSramReqMsg__SrcT_Bits2__DstT_Bits1 dst_logic
  (
    .clk( dst_logic__clk ),
    .in_req( dst_logic__in_req ),
    .in_src_id( dst_logic__in_src_id ),
    .out_dst( dst_logic__out_dst ),
    .reset( dst_logic__reset )
  );

  //-------------------------------------------------------------
  // End of component dst_logic
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opq_table
  //-------------------------------------------------------------

  logic [0:0] opq_table__clk;
  logic [0:0] opq_table__reset;
  logic [0:0] opq_table__alloc__en;
  logic [2:0] opq_table__alloc__msg;
  logic [0:0] opq_table__alloc__rdy;
  logic [0:0] opq_table__alloc__ret;
  logic [0:0] opq_table__dealloc__en;
  logic [0:0] opq_table__dealloc__msg;
  logic [0:0] opq_table__dealloc__rdy;
  logic [2:0] opq_table__dealloc__ret;

  Table__EntryType_Bits3__num_entries_2 opq_table
  (
    .clk( opq_table__clk ),
    .reset( opq_table__reset ),
    .alloc__en( opq_table__alloc__en ),
    .alloc__msg( opq_table__alloc__msg ),
    .alloc__rdy( opq_table__alloc__rdy ),
    .alloc__ret( opq_table__alloc__ret ),
    .dealloc__en( opq_table__dealloc__en ),
    .dealloc__msg( opq_table__dealloc__msg ),
    .dealloc__rdy( opq_table__dealloc__rdy ),
    .dealloc__ret( opq_table__dealloc__ret )
  );

  //-------------------------------------------------------------
  // End of component opq_table
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:91
  // s.master.req.en   //= lambda: s.minion.req.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_3__master_req_en
    master__req__en = minion__req__en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:92
  // s.master.resp.rdy //= lambda: s.minion.resp.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_3__master_resp_rdy
    master__resp__rdy = minion__resp__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:88
  // s.minion.req.rdy //= lambda: s.opq_table.alloc.rdy & s.master.req.rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_3__minion_req_rdy
    minion__req__rdy = opq_table__alloc__rdy & master__req__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:89
  // s.minion.resp.en //= lambda: s.master.resp.en
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_adapter_3__minion_resp_en
    minion__resp__en = master__resp__en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:94
  // @update
  // def up_master_req_msg():
  //   s.master.req.msg.dst @= s.dst_logic.out_dst
  //   s.master.req.msg.payload @= s.minion.req.msg
  //   s.master.req.msg.payload.opaque[ sl_src ] @= id
  //   s.master.req.msg.payload.opaque[ sl_idx ] @= s.opq_table.alloc.ret
  
  always_comb begin : up_master_req_msg
    master__req__msg.dst = dst_logic__out_dst;
    master__req__msg.payload = minion__req__msg;
    master__req__msg.payload.opaque[2'd1:2'd0] = 2'( __const__id_at_up_master_req_msg );
    master__req__msg.payload.opaque[2'd2:2'd2] = opq_table__alloc__ret;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:101
  // @update
  // def up_minion_resp_msg():
  //   s.minion.resp.msg @= s.master.resp.msg.payload
  //   s.minion.resp.msg.opaque @= s.opq_table.dealloc.ret
  
  always_comb begin : up_minion_resp_msg
    minion__resp__msg = master__resp__msg.payload;
    minion__resp__msg.opaque = opq_table__dealloc__ret;
  end

  assign opq_table__clk = clk;
  assign opq_table__reset = reset;
  assign opq_table__alloc__en = minion__req__en;
  assign opq_table__alloc__msg = minion__req__msg.opaque;
  assign opq_table__dealloc__en = master__resp__en;
  assign opq_table__dealloc__msg = master__resp__msg.payload.opaque[2:2];
  assign dst_logic__clk = clk;
  assign dst_logic__reset = reset;
  assign dst_logic__in_req = minion__req__msg;
  assign dst_logic__in_src_id = 2'd3;

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] deq_en ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] enq_en ,
  output logic [0:0] enq_rdy ,
  output logic [0:0] raddr ,
  input  logic [0:0] reset ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  logic [0:0] deq_xfer;
  logic [0:0] enq_xfer;
  logic [0:0] head;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py:85
  // s.deq_rdy //= lambda: ~s.reset & ( s.count > CountType(0) )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_net_input_units_0__queue_ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( count > 2'd0 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py:88
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_net_input_units_0__queue_ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py:84
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_net_input_units_0__queue_ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < 2'd2 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py:87
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_DUT_cgra_xcel_dpath_xbar_req_net_input_units_0__queue_ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py:90
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < 1'd1 ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < 1'd1 ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_mmxbar_req_1_CgraSramReqMsg__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__18426cfd02008ff7
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output mmxbar_req_1_CgraSramReqMsg rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  mmxbar_req_1_CgraSramReqMsg wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  mmxbar_req_1_CgraSramReqMsg regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_mmxbar_req_1_CgraSramReqMsg__num_entries_2
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__b6434a2c060e87ad
(
  input  logic [0:0] clk ,
  output mmxbar_req_1_CgraSramReqMsg deq_ret ,
  input  mmxbar_req_1_CgraSramReqMsg enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  mmxbar_req_1_CgraSramReqMsg queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  mmxbar_req_1_CgraSramReqMsg queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__18426cfd02008ff7 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_mmxbar_req_1_CgraSramReqMsg__num_entries_2
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__b6434a2c060e87ad
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output mmxbar_req_1_CgraSramReqMsg deq__ret  ,
  input logic [0:0] enq__en  ,
  input mmxbar_req_1_CgraSramReqMsg enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  mmxbar_req_1_CgraSramReqMsg dpath__deq_ret;
  mmxbar_req_1_CgraSramReqMsg dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__b6434a2c060e87ad dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_mmxbar_req_1_CgraSramReqMsg__QueueType_NormalQueueRTL
// At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/InputUnitRTL.py

module InputUnitRTL__ee053f62ae490832
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output mmxbar_req_1_CgraSramReqMsg give__ret  ,
  input logic [0:0] recv__en  ,
  input mmxbar_req_1_CgraSramReqMsg recv__msg  ,
  output logic [0:0] recv__rdy  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  logic [0:0] queue__deq__en;
  logic [0:0] queue__deq__rdy;
  mmxbar_req_1_CgraSramReqMsg queue__deq__ret;
  logic [0:0] queue__enq__en;
  mmxbar_req_1_CgraSramReqMsg queue__enq__msg;
  logic [0:0] queue__enq__rdy;

  NormalQueueRTL__b6434a2c060e87ad queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .deq__en( queue__deq__en ),
    .deq__rdy( queue__deq__rdy ),
    .deq__ret( queue__deq__ret ),
    .enq__en( queue__enq__en ),
    .enq__msg( queue__enq__msg ),
    .enq__rdy( queue__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__enq__en = recv__en;
  assign queue__enq__msg = recv__msg;
  assign recv__rdy = queue__enq__rdy;
  assign queue__deq__en = give__en;
  assign give__rdy = queue__deq__rdy;
  assign give__ret = queue__deq__ret;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_mmxbar_req_1_CgraSramReqMsg__QueueType_None
// At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/OutputUnitRTL.py

module OutputUnitRTL__19b97aab68ccee36
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input mmxbar_req_1_CgraSramReqMsg get__ret  ,
  output logic [0:0] send__en  ,
  output mmxbar_req_1_CgraSramReqMsg send__msg  ,
  input logic [0:0] send__rdy  
);
  logic [0:0] __tmpvar__up_get_send_both_rdy;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/OutputUnitRTL.py:51
  // @update
  // def up_get_send():
  //   both_rdy = s.get.rdy & s.send.rdy
  //   s.get.en  @= both_rdy
  //   s.send.en @= both_rdy
  
  always_comb begin : up_get_send
    __tmpvar__up_get_send_both_rdy = get__rdy & send__rdy;
    get__en = __tmpvar__up_get_send_both_rdy;
    send__en = __tmpvar__up_get_send_both_rdy;
  end

  assign send__msg = get__ret;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_mmxbar_req_1_CgraSramReqMsg__num_outports_1
// At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__40e2c4fa5b678b08
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input mmxbar_req_1_CgraSramReqMsg get__ret  ,
  input logic [0:0] give__en [0:0] ,
  output logic [0:0] give__rdy [0:0] ,
  output mmxbar_req_1_CgraSramReqMsg give__ret [0:0] 
);
  localparam logic [0:0] __const__num_outports_at_up_ru_routing  = 1'd1;
  logic [0:0] give_ens;
  logic [0:0] out_dir;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_give_en():
  //   s.get.en @= s.give_ens > BitsN(0)
  
  always_comb begin : up_ru_give_en
    get__en = give_ens > 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= DirT( s.get.ret.dst )
  // 
  //   for i in range( num_outports ):
  //     s.give[i].rdy @= b1(0)
  // 
  //   if s.get.rdy:
  //     s.give[ s.out_dir ].rdy @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = 1'( get__ret.dst );
    for ( int i = 1'd0; i < 1'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      give__rdy[1'(i)] = 1'd0;
    if ( get__rdy ) begin
      give__rdy[out_dir] = 1'd1;
    end
  end

  assign give__ret[0] = get__ret;
  assign give_ens[0:0] = give__en[0];

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py

module RegEnRst__Type_Bits4__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py

module RoundRobinArbiterEn__nreqs_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [3:0] grants ,
  input  logic [3:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd8;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd4;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd8;
  logic [7:0] grants_int;
  logic [8:0] kills;
  logic [0:0] priority_en;
  logic [7:0] priority_int;
  logic [7:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [3:0] priority_reg__in_;
  logic [3:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits4__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py:172
  // @update
  // def comb_grants():
  // 
  //   # Assign the output ports
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[2'(i)] = grants_int[3'(i)] | grants_int[3'( __const__nreqs_at_comb_grants ) + 3'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py:222
  // @update
  // def comb_grants_int():
  // 
  //   for i in range( nreqsX2 ):
  // 
  //     # Set internal grants
  // 
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  // 
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        grants_int[3'(i)] = reqs_int[3'(i)];
      end
      else
        grants_int[3'(i)] = ( ~kills[4'(i)] ) & reqs_int[3'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py:203
  // @update
  // def comb_kills():
  // 
  //   # Set kill signals
  // 
  //   s.kills[0] @= 1
  // 
  //   for i in range( nreqsX2 ):
  // 
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  // 
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[3'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[3'(i)] );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py:183
  // @update
  // def comb_priority_en():
  // 
  //   # Set the priority enable
  //   s.priority_en @= ( s.grants != Type(0) ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 4'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py:193
  // @update
  // def comb_priority_int():
  // 
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[3'd3:3'd0] = priority_reg__out;
    priority_int[3'd7:3'( __const__nreqs_at_comb_priority_int )] = 4'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arbiters.py:162
  // @update
  // def comb_reqs_int():
  // 
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[3'd3:3'd0] = reqs;
    reqs_int[3'd7:3'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[3:1] = grants[2:0];
  assign priority_reg__in_[0:0] = grants[3:3];

endmodule


// PyMTL Component Encoder Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/Encoder.py

module Encoder__in_nbits_4__out_nbits_2
(
  input  logic [0:0] clk ,
  input  logic [3:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/Encoder.py:31
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 2'd0;
    for ( int i = 1'd0; i < 3'd4; i += 1'd1 )
      if ( in_[2'(i)] ) begin
        out = 2'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py

module Mux__Type_mmxbar_req_1_CgraSramReqMsg__ninputs_4
(
  input  logic [0:0] clk ,
  input  mmxbar_req_1_CgraSramReqMsg in_ [0:3],
  output mmxbar_req_1_CgraSramReqMsg out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SwitchUnitRTL Definition
// Full name: SwitchUnitRTL__PacketType_mmxbar_req_1_CgraSramReqMsg__num_inports_4
// At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/SwitchUnitRTL.py

module SwitchUnitRTL__c8b0a610d732275b
(
  input  logic [0:0] clk ,
  output logic [0:0] out_ocp ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en [0:3] ,
  input logic [0:0] get__rdy [0:3] ,
  input mmxbar_req_1_CgraSramReqMsg get__ret [0:3] ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output mmxbar_req_1_CgraSramReqMsg give__ret  
);
  localparam logic [2:0] __const__num_inports_at_up_get_en  = 3'd4;
  logic [0:0] get_en [0:3];
  logic [0:0] get_rdy [0:3];
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [3:0] arbiter__grants;
  logic [3:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_4 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [3:0] encoder__in_;
  logic [1:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_4__out_nbits_2 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  mmxbar_req_1_CgraSramReqMsg mux__in_ [0:3];
  mmxbar_req_1_CgraSramReqMsg mux__out;
  logic [0:0] mux__reset;
  logic [1:0] mux__sel;

  Mux__Type_mmxbar_req_1_CgraSramReqMsg__ninputs_4 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/SwitchUnitRTL.py:61
  // @update
  // def up_get_en():
  //   for i in range( num_inports ):
  //     s.get_en[i] @= s.give.en & ( s.mux.sel == i )
  
  always_comb begin : up_get_en
    for ( int i = 1'd0; i < 3'( __const__num_inports_at_up_get_en ); i += 1'd1 )
      get_en[2'(i)] = give__en & ( mux__sel == 2'(i) );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/SwitchUnitRTL.py:57
  // @update
  // def up_give():
  //   s.give.rdy @= s.arbiter.grants > 0
  
  always_comb begin : up_give
    give__rdy = arbiter__grants > 4'd0;
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign give__ret = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = get__rdy[0];
  assign mux__in_[0] = get__ret[0];
  assign get__en[0] = get_en[0];
  assign get_rdy[0] = get__rdy[0];
  assign arbiter__reqs[1:1] = get__rdy[1];
  assign mux__in_[1] = get__ret[1];
  assign get__en[1] = get_en[1];
  assign get_rdy[1] = get__rdy[1];
  assign arbiter__reqs[2:2] = get__rdy[2];
  assign mux__in_[2] = get__ret[2];
  assign get__en[2] = get_en[2];
  assign get_rdy[2] = get__rdy[2];
  assign arbiter__reqs[3:3] = get__rdy[3];
  assign mux__in_[3] = get__ret[3];
  assign get__en[3] = get_en[3];
  assign get_rdy[3] = get__rdy[3];

endmodule


// PyMTL Component XbarRTL Definition
// Full name: XbarRTL__PacketType_mmxbar_req_1_CgraSramReqMsg__num_inports_4__num_outports_1__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRTL.py

module XbarRTL__9b27802f6735c6ad
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:3] ,
  input mmxbar_req_1_CgraSramReqMsg recv__msg [0:3] ,
  output logic [0:0] recv__rdy [0:3] ,
  output logic [0:0] send__en [0:0] ,
  output mmxbar_req_1_CgraSramReqMsg send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] 
);
  //-------------------------------------------------------------
  // Component input_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:3];
  logic [0:0] input_units__reset [0:3];
  logic [0:0] input_units__give__en [0:3];
  logic [0:0] input_units__give__rdy [0:3];
  mmxbar_req_1_CgraSramReqMsg input_units__give__ret [0:3];
  logic [0:0] input_units__recv__en [0:3];
  mmxbar_req_1_CgraSramReqMsg input_units__recv__msg [0:3];
  logic [0:0] input_units__recv__rdy [0:3];

  InputUnitRTL__ee053f62ae490832 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .give__en( input_units__give__en[0] ),
    .give__rdy( input_units__give__rdy[0] ),
    .give__ret( input_units__give__ret[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] )
  );

  InputUnitRTL__ee053f62ae490832 input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .give__en( input_units__give__en[1] ),
    .give__rdy( input_units__give__rdy[1] ),
    .give__ret( input_units__give__ret[1] ),
    .recv__en( input_units__recv__en[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] )
  );

  InputUnitRTL__ee053f62ae490832 input_units__2
  (
    .clk( input_units__clk[2] ),
    .reset( input_units__reset[2] ),
    .give__en( input_units__give__en[2] ),
    .give__rdy( input_units__give__rdy[2] ),
    .give__ret( input_units__give__ret[2] ),
    .recv__en( input_units__recv__en[2] ),
    .recv__msg( input_units__recv__msg[2] ),
    .recv__rdy( input_units__recv__rdy[2] )
  );

  InputUnitRTL__ee053f62ae490832 input_units__3
  (
    .clk( input_units__clk[3] ),
    .reset( input_units__reset[3] ),
    .give__en( input_units__give__en[3] ),
    .give__rdy( input_units__give__rdy[3] ),
    .give__ret( input_units__give__ret[3] ),
    .recv__en( input_units__recv__en[3] ),
    .recv__msg( input_units__recv__msg[3] ),
    .recv__rdy( input_units__recv__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:0];
  logic [0:0] output_units__reset [0:0];
  logic [0:0] output_units__get__en [0:0];
  logic [0:0] output_units__get__rdy [0:0];
  mmxbar_req_1_CgraSramReqMsg output_units__get__ret [0:0];
  logic [0:0] output_units__send__en [0:0];
  mmxbar_req_1_CgraSramReqMsg output_units__send__msg [0:0];
  logic [0:0] output_units__send__rdy [0:0];

  OutputUnitRTL__19b97aab68ccee36 output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .get__en( output_units__get__en[0] ),
    .get__rdy( output_units__get__rdy[0] ),
    .get__ret( output_units__get__ret[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:3];
  logic [0:0] route_units__reset [0:3];
  logic [0:0] route_units__get__en [0:3];
  logic [0:0] route_units__get__rdy [0:3];
  mmxbar_req_1_CgraSramReqMsg route_units__get__ret [0:3];
  logic [0:0] route_units__give__en [0:3][0:0];
  logic [0:0] route_units__give__rdy [0:3][0:0];
  mmxbar_req_1_CgraSramReqMsg route_units__give__ret [0:3][0:0];

  XbarRouteUnitRTL__40e2c4fa5b678b08 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .get__en( route_units__get__en[0] ),
    .get__rdy( route_units__get__rdy[0] ),
    .get__ret( route_units__get__ret[0] ),
    .give__en( route_units__give__en[0] ),
    .give__rdy( route_units__give__rdy[0] ),
    .give__ret( route_units__give__ret[0] )
  );

  XbarRouteUnitRTL__40e2c4fa5b678b08 route_units__1
  (
    .clk( route_units__clk[1] ),
    .reset( route_units__reset[1] ),
    .get__en( route_units__get__en[1] ),
    .get__rdy( route_units__get__rdy[1] ),
    .get__ret( route_units__get__ret[1] ),
    .give__en( route_units__give__en[1] ),
    .give__rdy( route_units__give__rdy[1] ),
    .give__ret( route_units__give__ret[1] )
  );

  XbarRouteUnitRTL__40e2c4fa5b678b08 route_units__2
  (
    .clk( route_units__clk[2] ),
    .reset( route_units__reset[2] ),
    .get__en( route_units__get__en[2] ),
    .get__rdy( route_units__get__rdy[2] ),
    .get__ret( route_units__get__ret[2] ),
    .give__en( route_units__give__en[2] ),
    .give__rdy( route_units__give__rdy[2] ),
    .give__ret( route_units__give__ret[2] )
  );

  XbarRouteUnitRTL__40e2c4fa5b678b08 route_units__3
  (
    .clk( route_units__clk[3] ),
    .reset( route_units__reset[3] ),
    .get__en( route_units__get__en[3] ),
    .get__rdy( route_units__get__rdy[3] ),
    .get__ret( route_units__get__ret[3] ),
    .give__en( route_units__give__en[3] ),
    .give__rdy( route_units__give__rdy[3] ),
    .give__ret( route_units__give__ret[3] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:0];
  logic [0:0] switch_units__out_ocp [0:0];
  logic [0:0] switch_units__reset [0:0];
  logic [0:0] switch_units__get__en [0:0][0:3];
  logic [0:0] switch_units__get__rdy [0:0][0:3];
  mmxbar_req_1_CgraSramReqMsg switch_units__get__ret [0:0][0:3];
  logic [0:0] switch_units__give__en [0:0];
  logic [0:0] switch_units__give__rdy [0:0];
  mmxbar_req_1_CgraSramReqMsg switch_units__give__ret [0:0];

  SwitchUnitRTL__c8b0a610d732275b switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .out_ocp( switch_units__out_ocp[0] ),
    .reset( switch_units__reset[0] ),
    .get__en( switch_units__get__en[0] ),
    .get__rdy( switch_units__get__rdy[0] ),
    .get__ret( switch_units__get__ret[0] ),
    .give__en( switch_units__give__en[0] ),
    .give__rdy( switch_units__give__rdy[0] ),
    .give__ret( switch_units__give__ret[0] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:0]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign input_units__clk[2] = clk;
  assign input_units__reset[2] = reset;
  assign input_units__clk[3] = clk;
  assign input_units__reset[3] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign route_units__clk[2] = clk;
  assign route_units__reset[2] = reset;
  assign route_units__clk[3] = clk;
  assign route_units__reset[3] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__give__en[0] = route_units__get__en[0];
  assign route_units__get__rdy[0] = input_units__give__rdy[0];
  assign route_units__get__ret[0] = input_units__give__ret[0];
  assign input_units__recv__en[1] = recv__en[1];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__give__en[1] = route_units__get__en[1];
  assign route_units__get__rdy[1] = input_units__give__rdy[1];
  assign route_units__get__ret[1] = input_units__give__ret[1];
  assign input_units__recv__en[2] = recv__en[2];
  assign input_units__recv__msg[2] = recv__msg[2];
  assign recv__rdy[2] = input_units__recv__rdy[2];
  assign input_units__give__en[2] = route_units__get__en[2];
  assign route_units__get__rdy[2] = input_units__give__rdy[2];
  assign route_units__get__ret[2] = input_units__give__ret[2];
  assign input_units__recv__en[3] = recv__en[3];
  assign input_units__recv__msg[3] = recv__msg[3];
  assign recv__rdy[3] = input_units__recv__rdy[3];
  assign input_units__give__en[3] = route_units__get__en[3];
  assign route_units__get__rdy[3] = input_units__give__rdy[3];
  assign route_units__get__ret[3] = input_units__give__ret[3];
  assign route_units__give__en[0][0] = switch_units__get__en[0][0];
  assign switch_units__get__rdy[0][0] = route_units__give__rdy[0][0];
  assign switch_units__get__ret[0][0] = route_units__give__ret[0][0];
  assign route_units__give__en[1][0] = switch_units__get__en[0][1];
  assign switch_units__get__rdy[0][1] = route_units__give__rdy[1][0];
  assign switch_units__get__ret[0][1] = route_units__give__ret[1][0];
  assign route_units__give__en[2][0] = switch_units__get__en[0][2];
  assign switch_units__get__rdy[0][2] = route_units__give__rdy[2][0];
  assign switch_units__get__ret[0][2] = route_units__give__ret[2][0];
  assign route_units__give__en[3][0] = switch_units__get__en[0][3];
  assign switch_units__get__rdy[0][3] = route_units__give__rdy[3][0];
  assign switch_units__get__ret[0][3] = route_units__give__ret[3][0];
  assign switch_units__give__en[0] = output_units__get__en[0];
  assign output_units__get__rdy[0] = switch_units__give__rdy[0];
  assign output_units__get__ret[0] = switch_units__give__ret[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];

endmodule


// PyMTL Component RespAdapter Definition
// Full name: RespAdapter__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__id_0__num_requesters_4__num_responders_1
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py

module RespAdapter__779677536fb59106
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master__req__en ,
  output CgraSramReqMsg master__req__msg ,
  input logic [0:0] master__req__rdy ,
  input logic [0:0] master__resp__en ,
  input CgraSramRespMsg master__resp__msg ,
  output logic [0:0] master__resp__rdy ,
  input logic [0:0] minion__req__en ,
  input mmxbar_req_1_CgraSramReqMsg minion__req__msg ,
  output logic [0:0] minion__req__rdy ,
  output logic [0:0] minion__resp__en ,
  output mmxbar_resp_4_CgraSramRespMsg minion__resp__msg ,
  input logic [0:0] minion__resp__rdy 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:153
  // @update
  // def up_master_req_msg():
  //   s.master.req.msg @= s.minion.req.msg.payload
  
  always_comb begin : up_master_req_msg
    master__req__msg = minion__req__msg.payload;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/adapters.py:157
  // @update
  // def up_minion_resp_msg():
  //   s.minion.resp.msg.dst @= s.master.resp.msg.opaque[ sl_src ]
  //   s.minion.resp.msg.payload @= s.master.resp.msg
  
  always_comb begin : up_minion_resp_msg
    minion__resp__msg.dst = master__resp__msg.opaque[2'd1:2'd0];
    minion__resp__msg.payload = master__resp__msg;
  end

  assign minion__req__rdy = master__req__rdy;
  assign minion__resp__en = master__resp__en;
  assign master__req__en = minion__req__en;
  assign master__resp__rdy = minion__resp__rdy;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_mmxbar_resp_4_CgraSramRespMsg__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__1bff04de699373ab
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output mmxbar_resp_4_CgraSramRespMsg rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  mmxbar_resp_4_CgraSramRespMsg wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  mmxbar_resp_4_CgraSramRespMsg regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_mmxbar_resp_4_CgraSramRespMsg__num_entries_2
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__182e271c65059661
(
  input  logic [0:0] clk ,
  output mmxbar_resp_4_CgraSramRespMsg deq_ret ,
  input  mmxbar_resp_4_CgraSramRespMsg enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  mmxbar_resp_4_CgraSramRespMsg queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  mmxbar_resp_4_CgraSramRespMsg queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__1bff04de699373ab queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_mmxbar_resp_4_CgraSramRespMsg__num_entries_2
// At /work/global/pp482/clean/pymtl-v3/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__182e271c65059661
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output mmxbar_resp_4_CgraSramRespMsg deq__ret  ,
  input logic [0:0] enq__en  ,
  input mmxbar_resp_4_CgraSramRespMsg enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  mmxbar_resp_4_CgraSramRespMsg dpath__deq_ret;
  mmxbar_resp_4_CgraSramRespMsg dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__182e271c65059661 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_mmxbar_resp_4_CgraSramRespMsg__QueueType_NormalQueueRTL
// At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/InputUnitRTL.py

module InputUnitRTL__3804ff93b1466a81
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output mmxbar_resp_4_CgraSramRespMsg give__ret  ,
  input logic [0:0] recv__en  ,
  input mmxbar_resp_4_CgraSramRespMsg recv__msg  ,
  output logic [0:0] recv__rdy  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  logic [0:0] queue__deq__en;
  logic [0:0] queue__deq__rdy;
  mmxbar_resp_4_CgraSramRespMsg queue__deq__ret;
  logic [0:0] queue__enq__en;
  mmxbar_resp_4_CgraSramRespMsg queue__enq__msg;
  logic [0:0] queue__enq__rdy;

  NormalQueueRTL__182e271c65059661 queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .deq__en( queue__deq__en ),
    .deq__rdy( queue__deq__rdy ),
    .deq__ret( queue__deq__ret ),
    .enq__en( queue__enq__en ),
    .enq__msg( queue__enq__msg ),
    .enq__rdy( queue__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__enq__en = recv__en;
  assign queue__enq__msg = recv__msg;
  assign recv__rdy = queue__enq__rdy;
  assign queue__deq__en = give__en;
  assign give__rdy = queue__deq__rdy;
  assign give__ret = queue__deq__ret;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_mmxbar_resp_4_CgraSramRespMsg__QueueType_None
// At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/OutputUnitRTL.py

module OutputUnitRTL__2da1a5c1e1900e3d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input mmxbar_resp_4_CgraSramRespMsg get__ret  ,
  output logic [0:0] send__en  ,
  output mmxbar_resp_4_CgraSramRespMsg send__msg  ,
  input logic [0:0] send__rdy  
);
  logic [0:0] __tmpvar__up_get_send_both_rdy;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/OutputUnitRTL.py:51
  // @update
  // def up_get_send():
  //   both_rdy = s.get.rdy & s.send.rdy
  //   s.get.en  @= both_rdy
  //   s.send.en @= both_rdy
  
  always_comb begin : up_get_send
    __tmpvar__up_get_send_both_rdy = get__rdy & send__rdy;
    get__en = __tmpvar__up_get_send_both_rdy;
    send__en = __tmpvar__up_get_send_both_rdy;
  end

  assign send__msg = get__ret;

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_mmxbar_resp_4_CgraSramRespMsg__num_outports_4
// At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__0d167c8138ef96a2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input mmxbar_resp_4_CgraSramRespMsg get__ret  ,
  input logic [0:0] give__en [0:3] ,
  output logic [0:0] give__rdy [0:3] ,
  output mmxbar_resp_4_CgraSramRespMsg give__ret [0:3] 
);
  localparam logic [2:0] __const__num_outports_at_up_ru_routing  = 3'd4;
  logic [3:0] give_ens;
  logic [1:0] out_dir;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_give_en():
  //   s.get.en @= s.give_ens > BitsN(0)
  
  always_comb begin : up_ru_give_en
    get__en = give_ens > 4'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= DirT( s.get.ret.dst )
  // 
  //   for i in range( num_outports ):
  //     s.give[i].rdy @= b1(0)
  // 
  //   if s.get.rdy:
  //     s.give[ s.out_dir ].rdy @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = 2'( get__ret.dst );
    for ( int i = 1'd0; i < 3'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      give__rdy[2'(i)] = 1'd0;
    if ( get__rdy ) begin
      give__rdy[out_dir] = 1'd1;
    end
  end

  assign give__ret[0] = get__ret;
  assign give_ens[0:0] = give__en[0];
  assign give__ret[1] = get__ret;
  assign give_ens[1:1] = give__en[1];
  assign give__ret[2] = get__ret;
  assign give_ens[2:2] = give__en[2];
  assign give__ret[3] = get__ret;
  assign give_ens[3:3] = give__en[3];

endmodule


// PyMTL Component SwitchUnitNullRTL Definition
// Full name: SwitchUnitNullRTL__Type_mmxbar_resp_4_CgraSramRespMsg__num_inports_1
// At /work/global/pp482/clean/pymtl3-ip/pymtl3-net/router/SwitchUnitNullRTL.py

module SwitchUnitNullRTL__02774b84caacc2ea
(
  input  logic [0:0] clk ,
  input  logic [0:0] hold [0:0],
  input  logic [0:0] reset ,
  output logic [0:0] get__en [0:0] ,
  input logic [0:0] get__rdy [0:0] ,
  input mmxbar_resp_4_CgraSramRespMsg get__ret [0:0] ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output mmxbar_resp_4_CgraSramRespMsg give__ret  
);

  assign get__en[0] = give__en;
  assign give__rdy = get__rdy[0];
  assign give__ret = get__ret[0];

endmodule


// PyMTL Component XbarRTL Definition
// Full name: XbarRTL__PacketType_mmxbar_resp_4_CgraSramRespMsg__num_inports_1__num_outports_4__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /work/global/pp482/uecgra-src/src/pymtl3_net/xbar/XbarRTL.py

module XbarRTL__c3da19f3d421b06c
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:0] ,
  input mmxbar_resp_4_CgraSramRespMsg recv__msg [0:0] ,
  output logic [0:0] recv__rdy [0:0] ,
  output logic [0:0] send__en [0:3] ,
  output mmxbar_resp_4_CgraSramRespMsg send__msg [0:3] ,
  input logic [0:0] send__rdy [0:3] 
);
  //-------------------------------------------------------------
  // Component input_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:0];
  logic [0:0] input_units__reset [0:0];
  logic [0:0] input_units__give__en [0:0];
  logic [0:0] input_units__give__rdy [0:0];
  mmxbar_resp_4_CgraSramRespMsg input_units__give__ret [0:0];
  logic [0:0] input_units__recv__en [0:0];
  mmxbar_resp_4_CgraSramRespMsg input_units__recv__msg [0:0];
  logic [0:0] input_units__recv__rdy [0:0];

  InputUnitRTL__3804ff93b1466a81 input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .give__en( input_units__give__en[0] ),
    .give__rdy( input_units__give__rdy[0] ),
    .give__ret( input_units__give__ret[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:3];
  logic [0:0] output_units__reset [0:3];
  logic [0:0] output_units__get__en [0:3];
  logic [0:0] output_units__get__rdy [0:3];
  mmxbar_resp_4_CgraSramRespMsg output_units__get__ret [0:3];
  logic [0:0] output_units__send__en [0:3];
  mmxbar_resp_4_CgraSramRespMsg output_units__send__msg [0:3];
  logic [0:0] output_units__send__rdy [0:3];

  OutputUnitRTL__2da1a5c1e1900e3d output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .get__en( output_units__get__en[0] ),
    .get__rdy( output_units__get__rdy[0] ),
    .get__ret( output_units__get__ret[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] )
  );

  OutputUnitRTL__2da1a5c1e1900e3d output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .get__en( output_units__get__en[1] ),
    .get__rdy( output_units__get__rdy[1] ),
    .get__ret( output_units__get__ret[1] ),
    .send__en( output_units__send__en[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__rdy( output_units__send__rdy[1] )
  );

  OutputUnitRTL__2da1a5c1e1900e3d output_units__2
  (
    .clk( output_units__clk[2] ),
    .reset( output_units__reset[2] ),
    .get__en( output_units__get__en[2] ),
    .get__rdy( output_units__get__rdy[2] ),
    .get__ret( output_units__get__ret[2] ),
    .send__en( output_units__send__en[2] ),
    .send__msg( output_units__send__msg[2] ),
    .send__rdy( output_units__send__rdy[2] )
  );

  OutputUnitRTL__2da1a5c1e1900e3d output_units__3
  (
    .clk( output_units__clk[3] ),
    .reset( output_units__reset[3] ),
    .get__en( output_units__get__en[3] ),
    .get__rdy( output_units__get__rdy[3] ),
    .get__ret( output_units__get__ret[3] ),
    .send__en( output_units__send__en[3] ),
    .send__msg( output_units__send__msg[3] ),
    .send__rdy( output_units__send__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:0];
  logic [0:0] route_units__reset [0:0];
  logic [0:0] route_units__get__en [0:0];
  logic [0:0] route_units__get__rdy [0:0];
  mmxbar_resp_4_CgraSramRespMsg route_units__get__ret [0:0];
  logic [0:0] route_units__give__en [0:0][0:3];
  logic [0:0] route_units__give__rdy [0:0][0:3];
  mmxbar_resp_4_CgraSramRespMsg route_units__give__ret [0:0][0:3];

  XbarRouteUnitRTL__0d167c8138ef96a2 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .get__en( route_units__get__en[0] ),
    .get__rdy( route_units__get__rdy[0] ),
    .get__ret( route_units__get__ret[0] ),
    .give__en( route_units__give__en[0] ),
    .give__rdy( route_units__give__rdy[0] ),
    .give__ret( route_units__give__ret[0] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:3]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:3];
  logic [0:0] switch_units__hold [0:3][0:0];
  logic [0:0] switch_units__reset [0:3];
  logic [0:0] switch_units__get__en [0:3][0:0];
  logic [0:0] switch_units__get__rdy [0:3][0:0];
  mmxbar_resp_4_CgraSramRespMsg switch_units__get__ret [0:3][0:0];
  logic [0:0] switch_units__give__en [0:3];
  logic [0:0] switch_units__give__rdy [0:3];
  mmxbar_resp_4_CgraSramRespMsg switch_units__give__ret [0:3];

  SwitchUnitNullRTL__02774b84caacc2ea switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .hold( switch_units__hold[0] ),
    .reset( switch_units__reset[0] ),
    .get__en( switch_units__get__en[0] ),
    .get__rdy( switch_units__get__rdy[0] ),
    .get__ret( switch_units__get__ret[0] ),
    .give__en( switch_units__give__en[0] ),
    .give__rdy( switch_units__give__rdy[0] ),
    .give__ret( switch_units__give__ret[0] )
  );

  SwitchUnitNullRTL__02774b84caacc2ea switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .hold( switch_units__hold[1] ),
    .reset( switch_units__reset[1] ),
    .get__en( switch_units__get__en[1] ),
    .get__rdy( switch_units__get__rdy[1] ),
    .get__ret( switch_units__get__ret[1] ),
    .give__en( switch_units__give__en[1] ),
    .give__rdy( switch_units__give__rdy[1] ),
    .give__ret( switch_units__give__ret[1] )
  );

  SwitchUnitNullRTL__02774b84caacc2ea switch_units__2
  (
    .clk( switch_units__clk[2] ),
    .hold( switch_units__hold[2] ),
    .reset( switch_units__reset[2] ),
    .get__en( switch_units__get__en[2] ),
    .get__rdy( switch_units__get__rdy[2] ),
    .get__ret( switch_units__get__ret[2] ),
    .give__en( switch_units__give__en[2] ),
    .give__rdy( switch_units__give__rdy[2] ),
    .give__ret( switch_units__give__ret[2] )
  );

  SwitchUnitNullRTL__02774b84caacc2ea switch_units__3
  (
    .clk( switch_units__clk[3] ),
    .hold( switch_units__hold[3] ),
    .reset( switch_units__reset[3] ),
    .get__en( switch_units__get__en[3] ),
    .get__rdy( switch_units__get__rdy[3] ),
    .get__ret( switch_units__get__ret[3] ),
    .give__en( switch_units__give__en[3] ),
    .give__rdy( switch_units__give__rdy[3] ),
    .give__ret( switch_units__give__ret[3] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:3]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign switch_units__clk[2] = clk;
  assign switch_units__reset[2] = reset;
  assign switch_units__clk[3] = clk;
  assign switch_units__reset[3] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign output_units__clk[2] = clk;
  assign output_units__reset[2] = reset;
  assign output_units__clk[3] = clk;
  assign output_units__reset[3] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__give__en[0] = route_units__get__en[0];
  assign route_units__get__rdy[0] = input_units__give__rdy[0];
  assign route_units__get__ret[0] = input_units__give__ret[0];
  assign route_units__give__en[0][0] = switch_units__get__en[0][0];
  assign switch_units__get__rdy[0][0] = route_units__give__rdy[0][0];
  assign switch_units__get__ret[0][0] = route_units__give__ret[0][0];
  assign route_units__give__en[0][1] = switch_units__get__en[1][0];
  assign switch_units__get__rdy[1][0] = route_units__give__rdy[0][1];
  assign switch_units__get__ret[1][0] = route_units__give__ret[0][1];
  assign route_units__give__en[0][2] = switch_units__get__en[2][0];
  assign switch_units__get__rdy[2][0] = route_units__give__rdy[0][2];
  assign switch_units__get__ret[2][0] = route_units__give__ret[0][2];
  assign route_units__give__en[0][3] = switch_units__get__en[3][0];
  assign switch_units__get__rdy[3][0] = route_units__give__rdy[0][3];
  assign switch_units__get__ret[3][0] = route_units__give__ret[0][3];
  assign switch_units__give__en[0] = output_units__get__en[0];
  assign output_units__get__rdy[0] = switch_units__give__rdy[0];
  assign output_units__get__ret[0] = switch_units__give__ret[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign switch_units__give__en[1] = output_units__get__en[1];
  assign output_units__get__rdy[1] = switch_units__give__rdy[1];
  assign output_units__get__ret[1] = switch_units__give__ret[1];
  assign send__en[1] = output_units__send__en[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__rdy[1] = send__rdy[1];
  assign switch_units__give__en[2] = output_units__get__en[2];
  assign output_units__get__rdy[2] = switch_units__give__rdy[2];
  assign output_units__get__ret[2] = switch_units__give__ret[2];
  assign send__en[2] = output_units__send__en[2];
  assign send__msg[2] = output_units__send__msg[2];
  assign output_units__send__rdy[2] = send__rdy[2];
  assign switch_units__give__en[3] = output_units__get__en[3];
  assign output_units__get__rdy[3] = switch_units__give__rdy[3];
  assign output_units__get__ret[3] = switch_units__give__ret[3];
  assign send__en[3] = output_units__send__en[3];
  assign send__msg[3] = output_units__send__msg[3];
  assign output_units__send__rdy[3] = send__rdy[3];

endmodule


// PyMTL Component MasterMinionXbarGeneric Definition
// Full name: MasterMinionXbarGeneric__Req_CgraSramReqMsg__Resp_CgraSramRespMsg__num_requesters_4__num_responders_1__max_req_in_flight_2__DstLogicT_DstLogicSingleResp
// At /work/global/pp482/uecgra-src/src/pymtl3_net/mmxbar/MasterMinionXbarGeneric.py

module MasterMinionXbarGeneric__5dddf022121cf371
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master__req__en [0:0],
  output CgraSramReqMsg master__req__msg [0:0],
  input logic [0:0] master__req__rdy [0:0],
  input logic [0:0] master__resp__en [0:0],
  input CgraSramRespMsg master__resp__msg [0:0],
  output logic [0:0] master__resp__rdy [0:0],
  input logic [0:0] minion__req__en [0:3],
  input CgraSramReqMsg minion__req__msg [0:3],
  output logic [0:0] minion__req__rdy [0:3],
  output logic [0:0] minion__resp__en [0:3],
  output CgraSramRespMsg minion__resp__msg [0:3],
  input logic [0:0] minion__resp__rdy [0:3]
);
  //-------------------------------------------------------------
  // Component req_adapter[0:3]
  //-------------------------------------------------------------

  logic [0:0] req_adapter__clk [0:3];
  logic [0:0] req_adapter__reset [0:3];
  logic [0:0] req_adapter__master__req__en [0:3];
  mmxbar_req_1_CgraSramReqMsg req_adapter__master__req__msg [0:3];
  logic [0:0] req_adapter__master__req__rdy [0:3];
  logic [0:0] req_adapter__master__resp__en [0:3];
  mmxbar_resp_4_CgraSramRespMsg req_adapter__master__resp__msg [0:3];
  logic [0:0] req_adapter__master__resp__rdy [0:3];
  logic [0:0] req_adapter__minion__req__en [0:3];
  CgraSramReqMsg req_adapter__minion__req__msg [0:3];
  logic [0:0] req_adapter__minion__req__rdy [0:3];
  logic [0:0] req_adapter__minion__resp__en [0:3];
  CgraSramRespMsg req_adapter__minion__resp__msg [0:3];
  logic [0:0] req_adapter__minion__resp__rdy [0:3];

  ReqAdapter__8171e7eaa19befb7 req_adapter__0
  (
    .clk( req_adapter__clk[0] ),
    .reset( req_adapter__reset[0] ),
    .master__req__en( req_adapter__master__req__en[0] ),
    .master__req__msg( req_adapter__master__req__msg[0] ),
    .master__req__rdy( req_adapter__master__req__rdy[0] ),
    .master__resp__en( req_adapter__master__resp__en[0] ),
    .master__resp__msg( req_adapter__master__resp__msg[0] ),
    .master__resp__rdy( req_adapter__master__resp__rdy[0] ),
    .minion__req__en( req_adapter__minion__req__en[0] ),
    .minion__req__msg( req_adapter__minion__req__msg[0] ),
    .minion__req__rdy( req_adapter__minion__req__rdy[0] ),
    .minion__resp__en( req_adapter__minion__resp__en[0] ),
    .minion__resp__msg( req_adapter__minion__resp__msg[0] ),
    .minion__resp__rdy( req_adapter__minion__resp__rdy[0] )
  );

  ReqAdapter__f237a5ca74f516bf req_adapter__1
  (
    .clk( req_adapter__clk[1] ),
    .reset( req_adapter__reset[1] ),
    .master__req__en( req_adapter__master__req__en[1] ),
    .master__req__msg( req_adapter__master__req__msg[1] ),
    .master__req__rdy( req_adapter__master__req__rdy[1] ),
    .master__resp__en( req_adapter__master__resp__en[1] ),
    .master__resp__msg( req_adapter__master__resp__msg[1] ),
    .master__resp__rdy( req_adapter__master__resp__rdy[1] ),
    .minion__req__en( req_adapter__minion__req__en[1] ),
    .minion__req__msg( req_adapter__minion__req__msg[1] ),
    .minion__req__rdy( req_adapter__minion__req__rdy[1] ),
    .minion__resp__en( req_adapter__minion__resp__en[1] ),
    .minion__resp__msg( req_adapter__minion__resp__msg[1] ),
    .minion__resp__rdy( req_adapter__minion__resp__rdy[1] )
  );

  ReqAdapter__1b4b26a38c16ecd6 req_adapter__2
  (
    .clk( req_adapter__clk[2] ),
    .reset( req_adapter__reset[2] ),
    .master__req__en( req_adapter__master__req__en[2] ),
    .master__req__msg( req_adapter__master__req__msg[2] ),
    .master__req__rdy( req_adapter__master__req__rdy[2] ),
    .master__resp__en( req_adapter__master__resp__en[2] ),
    .master__resp__msg( req_adapter__master__resp__msg[2] ),
    .master__resp__rdy( req_adapter__master__resp__rdy[2] ),
    .minion__req__en( req_adapter__minion__req__en[2] ),
    .minion__req__msg( req_adapter__minion__req__msg[2] ),
    .minion__req__rdy( req_adapter__minion__req__rdy[2] ),
    .minion__resp__en( req_adapter__minion__resp__en[2] ),
    .minion__resp__msg( req_adapter__minion__resp__msg[2] ),
    .minion__resp__rdy( req_adapter__minion__resp__rdy[2] )
  );

  ReqAdapter__676d2b176ec992bb req_adapter__3
  (
    .clk( req_adapter__clk[3] ),
    .reset( req_adapter__reset[3] ),
    .master__req__en( req_adapter__master__req__en[3] ),
    .master__req__msg( req_adapter__master__req__msg[3] ),
    .master__req__rdy( req_adapter__master__req__rdy[3] ),
    .master__resp__en( req_adapter__master__resp__en[3] ),
    .master__resp__msg( req_adapter__master__resp__msg[3] ),
    .master__resp__rdy( req_adapter__master__resp__rdy[3] ),
    .minion__req__en( req_adapter__minion__req__en[3] ),
    .minion__req__msg( req_adapter__minion__req__msg[3] ),
    .minion__req__rdy( req_adapter__minion__req__rdy[3] ),
    .minion__resp__en( req_adapter__minion__resp__en[3] ),
    .minion__resp__msg( req_adapter__minion__resp__msg[3] ),
    .minion__resp__rdy( req_adapter__minion__resp__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component req_adapter[0:3]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req_net
  //-------------------------------------------------------------

  logic [0:0] req_net__clk;
  logic [0:0] req_net__reset;
  logic [0:0] req_net__recv__en [0:3];
  mmxbar_req_1_CgraSramReqMsg req_net__recv__msg [0:3];
  logic [0:0] req_net__recv__rdy [0:3];
  logic [0:0] req_net__send__en [0:0];
  mmxbar_req_1_CgraSramReqMsg req_net__send__msg [0:0];
  logic [0:0] req_net__send__rdy [0:0];

  XbarRTL__9b27802f6735c6ad req_net
  (
    .clk( req_net__clk ),
    .reset( req_net__reset ),
    .recv__en( req_net__recv__en ),
    .recv__msg( req_net__recv__msg ),
    .recv__rdy( req_net__recv__rdy ),
    .send__en( req_net__send__en ),
    .send__msg( req_net__send__msg ),
    .send__rdy( req_net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component req_net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component resp_adapter[0:0]
  //-------------------------------------------------------------

  logic [0:0] resp_adapter__clk [0:0];
  logic [0:0] resp_adapter__reset [0:0];
  logic [0:0] resp_adapter__master__req__en [0:0];
  CgraSramReqMsg resp_adapter__master__req__msg [0:0];
  logic [0:0] resp_adapter__master__req__rdy [0:0];
  logic [0:0] resp_adapter__master__resp__en [0:0];
  CgraSramRespMsg resp_adapter__master__resp__msg [0:0];
  logic [0:0] resp_adapter__master__resp__rdy [0:0];
  logic [0:0] resp_adapter__minion__req__en [0:0];
  mmxbar_req_1_CgraSramReqMsg resp_adapter__minion__req__msg [0:0];
  logic [0:0] resp_adapter__minion__req__rdy [0:0];
  logic [0:0] resp_adapter__minion__resp__en [0:0];
  mmxbar_resp_4_CgraSramRespMsg resp_adapter__minion__resp__msg [0:0];
  logic [0:0] resp_adapter__minion__resp__rdy [0:0];

  RespAdapter__779677536fb59106 resp_adapter__0
  (
    .clk( resp_adapter__clk[0] ),
    .reset( resp_adapter__reset[0] ),
    .master__req__en( resp_adapter__master__req__en[0] ),
    .master__req__msg( resp_adapter__master__req__msg[0] ),
    .master__req__rdy( resp_adapter__master__req__rdy[0] ),
    .master__resp__en( resp_adapter__master__resp__en[0] ),
    .master__resp__msg( resp_adapter__master__resp__msg[0] ),
    .master__resp__rdy( resp_adapter__master__resp__rdy[0] ),
    .minion__req__en( resp_adapter__minion__req__en[0] ),
    .minion__req__msg( resp_adapter__minion__req__msg[0] ),
    .minion__req__rdy( resp_adapter__minion__req__rdy[0] ),
    .minion__resp__en( resp_adapter__minion__resp__en[0] ),
    .minion__resp__msg( resp_adapter__minion__resp__msg[0] ),
    .minion__resp__rdy( resp_adapter__minion__resp__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component resp_adapter[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component resp_net
  //-------------------------------------------------------------

  logic [0:0] resp_net__clk;
  logic [0:0] resp_net__reset;
  logic [0:0] resp_net__recv__en [0:0];
  mmxbar_resp_4_CgraSramRespMsg resp_net__recv__msg [0:0];
  logic [0:0] resp_net__recv__rdy [0:0];
  logic [0:0] resp_net__send__en [0:3];
  mmxbar_resp_4_CgraSramRespMsg resp_net__send__msg [0:3];
  logic [0:0] resp_net__send__rdy [0:3];

  XbarRTL__c3da19f3d421b06c resp_net
  (
    .clk( resp_net__clk ),
    .reset( resp_net__reset ),
    .recv__en( resp_net__recv__en ),
    .recv__msg( resp_net__recv__msg ),
    .recv__rdy( resp_net__recv__rdy ),
    .send__en( resp_net__send__en ),
    .send__msg( resp_net__send__msg ),
    .send__rdy( resp_net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component resp_net
  //-------------------------------------------------------------

  assign req_net__clk = clk;
  assign req_net__reset = reset;
  assign resp_net__clk = clk;
  assign resp_net__reset = reset;
  assign req_adapter__clk[0] = clk;
  assign req_adapter__reset[0] = reset;
  assign req_adapter__clk[1] = clk;
  assign req_adapter__reset[1] = reset;
  assign req_adapter__clk[2] = clk;
  assign req_adapter__reset[2] = reset;
  assign req_adapter__clk[3] = clk;
  assign req_adapter__reset[3] = reset;
  assign resp_adapter__clk[0] = clk;
  assign resp_adapter__reset[0] = reset;
  assign req_adapter__minion__req__en[0] = minion__req__en[0];
  assign req_adapter__minion__req__msg[0] = minion__req__msg[0];
  assign minion__req__rdy[0] = req_adapter__minion__req__rdy[0];
  assign minion__resp__en[0] = req_adapter__minion__resp__en[0];
  assign minion__resp__msg[0] = req_adapter__minion__resp__msg[0];
  assign req_adapter__minion__resp__rdy[0] = minion__resp__rdy[0];
  assign req_net__recv__en[0] = req_adapter__master__req__en[0];
  assign req_net__recv__msg[0] = req_adapter__master__req__msg[0];
  assign req_adapter__master__req__rdy[0] = req_net__recv__rdy[0];
  assign req_adapter__master__resp__en[0] = resp_net__send__en[0];
  assign req_adapter__master__resp__msg[0] = resp_net__send__msg[0];
  assign resp_net__send__rdy[0] = req_adapter__master__resp__rdy[0];
  assign req_adapter__minion__req__en[1] = minion__req__en[1];
  assign req_adapter__minion__req__msg[1] = minion__req__msg[1];
  assign minion__req__rdy[1] = req_adapter__minion__req__rdy[1];
  assign minion__resp__en[1] = req_adapter__minion__resp__en[1];
  assign minion__resp__msg[1] = req_adapter__minion__resp__msg[1];
  assign req_adapter__minion__resp__rdy[1] = minion__resp__rdy[1];
  assign req_net__recv__en[1] = req_adapter__master__req__en[1];
  assign req_net__recv__msg[1] = req_adapter__master__req__msg[1];
  assign req_adapter__master__req__rdy[1] = req_net__recv__rdy[1];
  assign req_adapter__master__resp__en[1] = resp_net__send__en[1];
  assign req_adapter__master__resp__msg[1] = resp_net__send__msg[1];
  assign resp_net__send__rdy[1] = req_adapter__master__resp__rdy[1];
  assign req_adapter__minion__req__en[2] = minion__req__en[2];
  assign req_adapter__minion__req__msg[2] = minion__req__msg[2];
  assign minion__req__rdy[2] = req_adapter__minion__req__rdy[2];
  assign minion__resp__en[2] = req_adapter__minion__resp__en[2];
  assign minion__resp__msg[2] = req_adapter__minion__resp__msg[2];
  assign req_adapter__minion__resp__rdy[2] = minion__resp__rdy[2];
  assign req_net__recv__en[2] = req_adapter__master__req__en[2];
  assign req_net__recv__msg[2] = req_adapter__master__req__msg[2];
  assign req_adapter__master__req__rdy[2] = req_net__recv__rdy[2];
  assign req_adapter__master__resp__en[2] = resp_net__send__en[2];
  assign req_adapter__master__resp__msg[2] = resp_net__send__msg[2];
  assign resp_net__send__rdy[2] = req_adapter__master__resp__rdy[2];
  assign req_adapter__minion__req__en[3] = minion__req__en[3];
  assign req_adapter__minion__req__msg[3] = minion__req__msg[3];
  assign minion__req__rdy[3] = req_adapter__minion__req__rdy[3];
  assign minion__resp__en[3] = req_adapter__minion__resp__en[3];
  assign minion__resp__msg[3] = req_adapter__minion__resp__msg[3];
  assign req_adapter__minion__resp__rdy[3] = minion__resp__rdy[3];
  assign req_net__recv__en[3] = req_adapter__master__req__en[3];
  assign req_net__recv__msg[3] = req_adapter__master__req__msg[3];
  assign req_adapter__master__req__rdy[3] = req_net__recv__rdy[3];
  assign req_adapter__master__resp__en[3] = resp_net__send__en[3];
  assign req_adapter__master__resp__msg[3] = resp_net__send__msg[3];
  assign resp_net__send__rdy[3] = req_adapter__master__resp__rdy[3];
  assign resp_adapter__minion__req__en[0] = req_net__send__en[0];
  assign resp_adapter__minion__req__msg[0] = req_net__send__msg[0];
  assign req_net__send__rdy[0] = resp_adapter__minion__req__rdy[0];
  assign resp_net__recv__en[0] = resp_adapter__minion__resp__en[0];
  assign resp_net__recv__msg[0] = resp_adapter__minion__resp__msg[0];
  assign resp_adapter__minion__resp__rdy[0] = resp_net__recv__rdy[0];
  assign master__req__en[0] = resp_adapter__master__req__en[0];
  assign master__req__msg[0] = resp_adapter__master__req__msg[0];
  assign resp_adapter__master__req__rdy[0] = master__req__rdy[0];
  assign resp_adapter__master__resp__en[0] = master__resp__en[0];
  assign resp_adapter__master__resp__msg[0] = master__resp__msg[0];
  assign master__resp__rdy[0] = resp_adapter__master__resp__rdy[0];

endmodule


// PyMTL Component CGRAXcelDpath Definition
// Full name: CGRAXcelDpath__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelDpath.py

module CGRAXcelDpath__b5592e8a4ff43256
(
  input  logic [0:0] cgra_xminion_req_en ,
  output logic [0:0] cgra_xminion_req_rdy ,
  output logic [0:0] cgra_xminion_resp_en ,
  input  logic [0:0] cgra_xminion_resp_rdy ,
  input  logic [0:0] clk ,
  output logic [0:0] is_CSR_transaction ,
  output logic [0:0] is_calc_done ,
  output logic [0:0] is_go_transaction ,
  output logic [0:0] is_scratchpad_transaction ,
  input  logic [0:0] is_staging ,
  output logic [0:0] is_write_transaction ,
  output CgraNetReqMsg mmaster_req_msg ,
  input  CgraNetRespMsg mmaster_resp_msg ,
  input  logic [0:0] reset ,
  input  logic [0:0] stage_val ,
  input  CgraXcelReqMsg xminion_req_msg ,
  output CgraXcelRespMsg xminion_resp_msg 
);
  localparam logic [1:0] __const__lower_idx_at_xcel_scratchpad_muxing  = 2'd2;
  localparam logic [3:0] __const__upper_idx_at_xcel_scratchpad_muxing  = 4'd12;
  logic [0:0] is_scratchpad_transaction_r;
  logic [0:0] is_staging_r;
  logic [11:0] reg_req_addr;
  logic [0:0] reg_req_wen;
  //-------------------------------------------------------------
  // Component cgra
  //-------------------------------------------------------------

  logic [0:0] cgra__clk;
  logic [0:0] cgra__is_calc_done;
  logic [0:0] cgra__reset;
  logic [0:0] cgra__spad_masters__req__en [0:3];
  CgraSramReqMsg cgra__spad_masters__req__msg [0:3];
  logic [0:0] cgra__spad_masters__req__rdy [0:3];
  logic [0:0] cgra__spad_masters__resp__en [0:3];
  CgraSramRespMsg cgra__spad_masters__resp__msg [0:3];
  logic [0:0] cgra__spad_masters__resp__rdy [0:3];
  logic [0:0] cgra__xcel_minion__req__en;
  CgraXcelReqMsg cgra__xcel_minion__req__msg;
  logic [0:0] cgra__xcel_minion__req__rdy;
  logic [0:0] cgra__xcel_minion__resp__en;
  CgraXcelRespMsg cgra__xcel_minion__resp__msg;
  logic [0:0] cgra__xcel_minion__resp__rdy;

  StaticCGRA__b5592e8a4ff43256 cgra
  (
    .clk( cgra__clk ),
    .is_calc_done( cgra__is_calc_done ),
    .reset( cgra__reset ),
    .spad_masters__req__en( cgra__spad_masters__req__en ),
    .spad_masters__req__msg( cgra__spad_masters__req__msg ),
    .spad_masters__req__rdy( cgra__spad_masters__req__rdy ),
    .spad_masters__resp__en( cgra__spad_masters__resp__en ),
    .spad_masters__resp__msg( cgra__spad_masters__resp__msg ),
    .spad_masters__resp__rdy( cgra__spad_masters__resp__rdy ),
    .xcel_minion__req__en( cgra__xcel_minion__req__en ),
    .xcel_minion__req__msg( cgra__xcel_minion__req__msg ),
    .xcel_minion__req__rdy( cgra__xcel_minion__req__rdy ),
    .xcel_minion__resp__en( cgra__xcel_minion__resp__en ),
    .xcel_minion__resp__msg( cgra__xcel_minion__resp__msg ),
    .xcel_minion__resp__rdy( cgra__xcel_minion__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component cgra
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component scratchpad_adapters[0:0]
  //-------------------------------------------------------------

  logic [0:0] scratchpad_adapters__clk [0:0];
  logic [9:0] scratchpad_adapters__idx [0:0];
  logic [31:0] scratchpad_adapters__rdata [0:0];
  logic [0:0] scratchpad_adapters__reset [0:0];
  logic [0:0] scratchpad_adapters__type_ [0:0];
  logic [0:0] scratchpad_adapters__val [0:0];
  logic [31:0] scratchpad_adapters__wdata [0:0];
  logic [0:0] scratchpad_adapters__minion__req__en [0:0];
  CgraSramReqMsg scratchpad_adapters__minion__req__msg [0:0];
  logic [0:0] scratchpad_adapters__minion__req__rdy [0:0];
  logic [0:0] scratchpad_adapters__minion__resp__en [0:0];
  CgraSramRespMsg scratchpad_adapters__minion__resp__msg [0:0];
  logic [0:0] scratchpad_adapters__minion__resp__rdy [0:0];

  MemMasterToSramAdapter__20779eae7290b15a scratchpad_adapters__0
  (
    .clk( scratchpad_adapters__clk[0] ),
    .idx( scratchpad_adapters__idx[0] ),
    .rdata( scratchpad_adapters__rdata[0] ),
    .reset( scratchpad_adapters__reset[0] ),
    .type_( scratchpad_adapters__type_[0] ),
    .val( scratchpad_adapters__val[0] ),
    .wdata( scratchpad_adapters__wdata[0] ),
    .minion__req__en( scratchpad_adapters__minion__req__en[0] ),
    .minion__req__msg( scratchpad_adapters__minion__req__msg[0] ),
    .minion__req__rdy( scratchpad_adapters__minion__req__rdy[0] ),
    .minion__resp__en( scratchpad_adapters__minion__resp__en[0] ),
    .minion__resp__msg( scratchpad_adapters__minion__resp__msg[0] ),
    .minion__resp__rdy( scratchpad_adapters__minion__resp__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component scratchpad_adapters[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component scratchpads[0:0]
  //-------------------------------------------------------------

  logic [0:0] scratchpads__clk [0:0];
  logic [9:0] scratchpads__port0_idx [0:0];
  logic [31:0] scratchpads__port0_rdata [0:0];
  logic [0:0] scratchpads__port0_type [0:0];
  logic [0:0] scratchpads__port0_val [0:0];
  logic [31:0] scratchpads__port0_wdata [0:0];
  logic [0:0] scratchpads__reset [0:0];

  SramRTL__data_nbits_32__num_entries_1024__mask_size_0 scratchpads__0
  (
    .clk( scratchpads__clk[0] ),
    .port0_idx( scratchpads__port0_idx[0] ),
    .port0_rdata( scratchpads__port0_rdata[0] ),
    .port0_type( scratchpads__port0_type[0] ),
    .port0_val( scratchpads__port0_val[0] ),
    .port0_wdata( scratchpads__port0_wdata[0] ),
    .reset( scratchpads__reset[0] )
  );

  //-------------------------------------------------------------
  // End of component scratchpads[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component xbar
  //-------------------------------------------------------------

  logic [0:0] xbar__clk;
  logic [0:0] xbar__reset;
  logic [0:0] xbar__master__req__en [0:0];
  CgraSramReqMsg xbar__master__req__msg [0:0];
  logic [0:0] xbar__master__req__rdy [0:0];
  logic [0:0] xbar__master__resp__en [0:0];
  CgraSramRespMsg xbar__master__resp__msg [0:0];
  logic [0:0] xbar__master__resp__rdy [0:0];
  logic [0:0] xbar__minion__req__en [0:3];
  CgraSramReqMsg xbar__minion__req__msg [0:3];
  logic [0:0] xbar__minion__req__rdy [0:3];
  logic [0:0] xbar__minion__resp__en [0:3];
  CgraSramRespMsg xbar__minion__resp__msg [0:3];
  logic [0:0] xbar__minion__resp__rdy [0:3];

  MasterMinionXbarGeneric__5dddf022121cf371 xbar
  (
    .clk( xbar__clk ),
    .reset( xbar__reset ),
    .master__req__en( xbar__master__req__en ),
    .master__req__msg( xbar__master__req__msg ),
    .master__req__rdy( xbar__master__req__rdy ),
    .master__resp__en( xbar__master__resp__en ),
    .master__resp__msg( xbar__master__resp__msg ),
    .master__resp__rdy( xbar__master__resp__rdy ),
    .minion__req__en( xbar__minion__req__en ),
    .minion__req__msg( xbar__minion__req__msg ),
    .minion__req__rdy( xbar__minion__req__rdy ),
    .minion__resp__en( xbar__minion__resp__en ),
    .minion__resp__msg( xbar__minion__resp__msg ),
    .minion__resp__rdy( xbar__minion__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component xbar
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelDpath.py:120
  // @update
  // def cgra_xminion_resp_msg():
  //   if s.is_staging_r & s.is_scratchpad_transaction_r:
  //     s.xminion_resp_msg.wen @= s.reg_req_wen
  //     s.xminion_resp_msg.addr @= s.reg_req_addr
  //     s.xminion_resp_msg.data @= s.scratchpads[0].port0_rdata
  //   else:
  //     s.xminion_resp_msg @= s.cgra.xcel_minion.resp.msg
  
  always_comb begin : cgra_xminion_resp_msg
    if ( is_staging_r & is_scratchpad_transaction_r ) begin
      xminion_resp_msg.wen = reg_req_wen;
      xminion_resp_msg.addr = reg_req_addr;
      xminion_resp_msg.data = scratchpads__port0_rdata[1'd0];
    end
    else
      xminion_resp_msg = cgra__xcel_minion__resp__msg;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelDpath.py:156
  // @update
  // def gen_is_transactions():
  //   s.is_go_transaction         @= s.xminion_req_msg.wen & \
  //                                ( s.xminion_req_msg.addr == 0 ) & \
  //                                ( s.xminion_req_msg.data != 0 )
  //   s.is_CSR_transaction        @= s.xminion_req_msg.addr < 0x040
  //   s.is_scratchpad_transaction @= ( s.xminion_req_msg.addr >= 0x040 ) & \
  //                                  ( s.xminion_req_msg.addr <  0xFFF )
  //   s.is_write_transaction      @= s.xminion_req_msg.wen
  
  always_comb begin : gen_is_transactions
    is_go_transaction = ( xminion_req_msg.wen & ( xminion_req_msg.addr == 12'd0 ) ) & ( xminion_req_msg.data != 32'd0 );
    is_CSR_transaction = xminion_req_msg.addr < 12'd64;
    is_scratchpad_transaction = ( xminion_req_msg.addr >= 12'd64 ) & ( xminion_req_msg.addr < 12'd4095 );
    is_write_transaction = xminion_req_msg.wen;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelDpath.py:137
  // @update
  // def xcel_scratchpad_muxing():
  //   if s.is_staging:
  //     # The scratchpad should be interfaced to the xcel minion
  //     # to be staged with bitstream and data.
  //     for i in range( p.nspads ):
  //       s.scratchpads[i].port0_val   @= s.stage_val
  //       s.scratchpads[i].port0_type  @= s.xminion_req_msg.wen
  //       s.scratchpads[i].port0_idx   @= s.xminion_req_msg.addr[lower_idx:upper_idx]
  //       s.scratchpads[i].port0_wdata @= s.xminion_req_msg.data
  //   else:
  //     # Otherwise the scratchpad should be interfaced to the memory
  //     # masters exposed by the PE array.
  //     for i in range( p.nspads ):
  //       s.scratchpads[i].port0_val   @= s.scratchpad_adapters[i].val
  //       s.scratchpads[i].port0_type  @= s.scratchpad_adapters[i].type_
  //       s.scratchpads[i].port0_idx   @= s.scratchpad_adapters[i].idx
  //       s.scratchpads[i].port0_wdata @= s.scratchpad_adapters[i].wdata
  
  always_comb begin : xcel_scratchpad_muxing
    if ( is_staging ) begin
      for ( int i = 1'd0; i < 1'd1; i += 1'd1 ) begin
        scratchpads__port0_val[1'(i)] = stage_val;
        scratchpads__port0_type[1'(i)] = xminion_req_msg.wen;
        scratchpads__port0_idx[1'(i)] = xminion_req_msg.addr[4'd11:4'( __const__lower_idx_at_xcel_scratchpad_muxing )];
        scratchpads__port0_wdata[1'(i)] = xminion_req_msg.data;
      end
    end
    else
      for ( int i = 1'd0; i < 1'd1; i += 1'd1 ) begin
        scratchpads__port0_val[1'(i)] = scratchpad_adapters__val[1'(i)];
        scratchpads__port0_type[1'(i)] = scratchpad_adapters__type_[1'(i)];
        scratchpads__port0_idx[1'(i)] = scratchpad_adapters__idx[1'(i)];
        scratchpads__port0_wdata[1'(i)] = scratchpad_adapters__wdata[1'(i)];
      end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelDpath.py:99
  // @update_ff
  // def register_request():
  //   s.reg_req_wen <<= s.xminion_req_msg.wen
  //   s.reg_req_addr <<= s.xminion_req_msg.addr
  
  always_ff @(posedge clk) begin : register_request
    reg_req_wen <= xminion_req_msg.wen;
    reg_req_addr <= xminion_req_msg.addr;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/cgra/CGRAXcelDpath.py:115
  // @update_ff
  // def xcel_dpath_reg():
  //   s.is_staging_r <<= s.is_staging
  //   s.is_scratchpad_transaction_r <<= s.is_scratchpad_transaction
  
  always_ff @(posedge clk) begin : xcel_dpath_reg
    is_staging_r <= is_staging;
    is_scratchpad_transaction_r <= is_scratchpad_transaction;
  end

  assign cgra__clk = clk;
  assign cgra__reset = reset;
  assign xbar__clk = clk;
  assign xbar__reset = reset;
  assign scratchpad_adapters__clk[0] = clk;
  assign scratchpad_adapters__reset[0] = reset;
  assign scratchpads__clk[0] = clk;
  assign scratchpads__reset[0] = reset;
  assign xbar__minion__req__en[0] = cgra__spad_masters__req__en[0];
  assign xbar__minion__req__msg[0] = cgra__spad_masters__req__msg[0];
  assign cgra__spad_masters__req__rdy[0] = xbar__minion__req__rdy[0];
  assign cgra__spad_masters__resp__en[0] = xbar__minion__resp__en[0];
  assign cgra__spad_masters__resp__msg[0] = xbar__minion__resp__msg[0];
  assign xbar__minion__resp__rdy[0] = cgra__spad_masters__resp__rdy[0];
  assign xbar__minion__req__en[1] = cgra__spad_masters__req__en[1];
  assign xbar__minion__req__msg[1] = cgra__spad_masters__req__msg[1];
  assign cgra__spad_masters__req__rdy[1] = xbar__minion__req__rdy[1];
  assign cgra__spad_masters__resp__en[1] = xbar__minion__resp__en[1];
  assign cgra__spad_masters__resp__msg[1] = xbar__minion__resp__msg[1];
  assign xbar__minion__resp__rdy[1] = cgra__spad_masters__resp__rdy[1];
  assign xbar__minion__req__en[2] = cgra__spad_masters__req__en[2];
  assign xbar__minion__req__msg[2] = cgra__spad_masters__req__msg[2];
  assign cgra__spad_masters__req__rdy[2] = xbar__minion__req__rdy[2];
  assign cgra__spad_masters__resp__en[2] = xbar__minion__resp__en[2];
  assign cgra__spad_masters__resp__msg[2] = xbar__minion__resp__msg[2];
  assign xbar__minion__resp__rdy[2] = cgra__spad_masters__resp__rdy[2];
  assign xbar__minion__req__en[3] = cgra__spad_masters__req__en[3];
  assign xbar__minion__req__msg[3] = cgra__spad_masters__req__msg[3];
  assign cgra__spad_masters__req__rdy[3] = xbar__minion__req__rdy[3];
  assign cgra__spad_masters__resp__en[3] = xbar__minion__resp__en[3];
  assign cgra__spad_masters__resp__msg[3] = xbar__minion__resp__msg[3];
  assign xbar__minion__resp__rdy[3] = cgra__spad_masters__resp__rdy[3];
  assign scratchpad_adapters__minion__req__en[0] = xbar__master__req__en[0];
  assign scratchpad_adapters__minion__req__msg[0] = xbar__master__req__msg[0];
  assign xbar__master__req__rdy[0] = scratchpad_adapters__minion__req__rdy[0];
  assign xbar__master__resp__en[0] = scratchpad_adapters__minion__resp__en[0];
  assign xbar__master__resp__msg[0] = scratchpad_adapters__minion__resp__msg[0];
  assign scratchpad_adapters__minion__resp__rdy[0] = xbar__master__resp__rdy[0];
  assign is_calc_done = cgra__is_calc_done;
  assign mmaster_req_msg = { 1'd0, 12'd0, 32'd0 };
  assign cgra__xcel_minion__req__en = cgra_xminion_req_en;
  assign cgra_xminion_req_rdy = cgra__xcel_minion__req__rdy;
  assign cgra_xminion_resp_en = cgra__xcel_minion__resp__en;
  assign cgra__xcel_minion__resp__rdy = cgra_xminion_resp_rdy;
  assign cgra__xcel_minion__req__msg = xminion_req_msg;
  assign scratchpad_adapters__rdata[0] = scratchpads__port0_rdata[0];

endmodule


// PyMTL Component CGRAXcel Definition
// Full name: CGRAXcel__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/cgra/CGRAXcel.py

module CGRAXcel__b5592e8a4ff43256
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] mem_master__req__en ,
  output CgraNetReqMsg mem_master__req__msg ,
  input logic [0:0] mem_master__req__rdy ,
  input logic [0:0] mem_master__resp__en ,
  input CgraNetRespMsg mem_master__resp__msg ,
  output logic [0:0] mem_master__resp__rdy ,
  input logic [0:0] xcel_minion__req__en ,
  input CgraXcelReqMsg xcel_minion__req__msg ,
  output logic [0:0] xcel_minion__req__rdy ,
  output logic [0:0] xcel_minion__resp__en ,
  output CgraXcelRespMsg xcel_minion__resp__msg ,
  input logic [0:0] xcel_minion__resp__rdy 
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__cgra_xminion_req_en;
  logic [0:0] ctrl__cgra_xminion_req_rdy;
  logic [0:0] ctrl__cgra_xminion_resp_en;
  logic [0:0] ctrl__cgra_xminion_resp_rdy;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__is_CSR_transaction;
  logic [0:0] ctrl__is_calc_done;
  logic [0:0] ctrl__is_go_transaction;
  logic [0:0] ctrl__is_scratchpad_transaction;
  logic [0:0] ctrl__is_staging;
  logic [0:0] ctrl__is_write_transaction;
  logic [0:0] ctrl__mmaster_req_en;
  logic [0:0] ctrl__mmaster_req_rdy;
  logic [0:0] ctrl__mmaster_resp_en;
  logic [0:0] ctrl__mmaster_resp_rdy;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__stage_val;
  logic [0:0] ctrl__xminion_req_en;
  logic [0:0] ctrl__xminion_req_rdy;
  logic [0:0] ctrl__xminion_resp_en;
  logic [0:0] ctrl__xminion_resp_rdy;

  CGRAXcelCtrl__b5592e8a4ff43256 ctrl
  (
    .cgra_xminion_req_en( ctrl__cgra_xminion_req_en ),
    .cgra_xminion_req_rdy( ctrl__cgra_xminion_req_rdy ),
    .cgra_xminion_resp_en( ctrl__cgra_xminion_resp_en ),
    .cgra_xminion_resp_rdy( ctrl__cgra_xminion_resp_rdy ),
    .clk( ctrl__clk ),
    .is_CSR_transaction( ctrl__is_CSR_transaction ),
    .is_calc_done( ctrl__is_calc_done ),
    .is_go_transaction( ctrl__is_go_transaction ),
    .is_scratchpad_transaction( ctrl__is_scratchpad_transaction ),
    .is_staging( ctrl__is_staging ),
    .is_write_transaction( ctrl__is_write_transaction ),
    .mmaster_req_en( ctrl__mmaster_req_en ),
    .mmaster_req_rdy( ctrl__mmaster_req_rdy ),
    .mmaster_resp_en( ctrl__mmaster_resp_en ),
    .mmaster_resp_rdy( ctrl__mmaster_resp_rdy ),
    .reset( ctrl__reset ),
    .stage_val( ctrl__stage_val ),
    .xminion_req_en( ctrl__xminion_req_en ),
    .xminion_req_rdy( ctrl__xminion_req_rdy ),
    .xminion_resp_en( ctrl__xminion_resp_en ),
    .xminion_resp_rdy( ctrl__xminion_resp_rdy )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__cgra_xminion_req_en;
  logic [0:0] dpath__cgra_xminion_req_rdy;
  logic [0:0] dpath__cgra_xminion_resp_en;
  logic [0:0] dpath__cgra_xminion_resp_rdy;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__is_CSR_transaction;
  logic [0:0] dpath__is_calc_done;
  logic [0:0] dpath__is_go_transaction;
  logic [0:0] dpath__is_scratchpad_transaction;
  logic [0:0] dpath__is_staging;
  logic [0:0] dpath__is_write_transaction;
  CgraNetReqMsg dpath__mmaster_req_msg;
  CgraNetRespMsg dpath__mmaster_resp_msg;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__stage_val;
  CgraXcelReqMsg dpath__xminion_req_msg;
  CgraXcelRespMsg dpath__xminion_resp_msg;

  CGRAXcelDpath__b5592e8a4ff43256 dpath
  (
    .cgra_xminion_req_en( dpath__cgra_xminion_req_en ),
    .cgra_xminion_req_rdy( dpath__cgra_xminion_req_rdy ),
    .cgra_xminion_resp_en( dpath__cgra_xminion_resp_en ),
    .cgra_xminion_resp_rdy( dpath__cgra_xminion_resp_rdy ),
    .clk( dpath__clk ),
    .is_CSR_transaction( dpath__is_CSR_transaction ),
    .is_calc_done( dpath__is_calc_done ),
    .is_go_transaction( dpath__is_go_transaction ),
    .is_scratchpad_transaction( dpath__is_scratchpad_transaction ),
    .is_staging( dpath__is_staging ),
    .is_write_transaction( dpath__is_write_transaction ),
    .mmaster_req_msg( dpath__mmaster_req_msg ),
    .mmaster_resp_msg( dpath__mmaster_resp_msg ),
    .reset( dpath__reset ),
    .stage_val( dpath__stage_val ),
    .xminion_req_msg( dpath__xminion_req_msg ),
    .xminion_resp_msg( dpath__xminion_resp_msg )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign mem_master__req__en = ctrl__mmaster_req_en;
  assign ctrl__mmaster_req_rdy = mem_master__req__rdy;
  assign mem_master__req__msg = dpath__mmaster_req_msg;
  assign ctrl__mmaster_resp_en = mem_master__resp__en;
  assign mem_master__resp__rdy = ctrl__mmaster_resp_rdy;
  assign dpath__mmaster_resp_msg = mem_master__resp__msg;
  assign ctrl__xminion_req_en = xcel_minion__req__en;
  assign xcel_minion__req__rdy = ctrl__xminion_req_rdy;
  assign dpath__xminion_req_msg = xcel_minion__req__msg;
  assign xcel_minion__resp__en = ctrl__xminion_resp_en;
  assign ctrl__xminion_resp_rdy = xcel_minion__resp__rdy;
  assign xcel_minion__resp__msg = dpath__xminion_resp_msg;
  assign dpath__is_staging = ctrl__is_staging;
  assign dpath__stage_val = ctrl__stage_val;
  assign dpath__cgra_xminion_req_en = ctrl__cgra_xminion_req_en;
  assign ctrl__cgra_xminion_req_rdy = dpath__cgra_xminion_req_rdy;
  assign ctrl__cgra_xminion_resp_en = dpath__cgra_xminion_resp_en;
  assign dpath__cgra_xminion_resp_rdy = ctrl__cgra_xminion_resp_rdy;
  assign ctrl__is_go_transaction = dpath__is_go_transaction;
  assign ctrl__is_CSR_transaction = dpath__is_CSR_transaction;
  assign ctrl__is_scratchpad_transaction = dpath__is_scratchpad_transaction;
  assign ctrl__is_write_transaction = dpath__is_write_transaction;
  assign ctrl__is_calc_done = dpath__is_calc_done;

endmodule


// PyMTL Component HBEndpointRXAdapter Definition
// Full name: HBEndpointRXAdapter__hb_params_<src.hammerblade.params.HBParams object at 0x7f8dcc25ff28>__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py

module HBEndpointRXAdapter__38988abc31baed67
(
  input  logic [0:0] clk ,
  input  logic [1:0] my_x ,
  input  logic [2:0] my_y ,
  input  logic [27:0] req_addr ,
  input  logic [31:0] req_data ,
  input  logic [6:0] req_load_info ,
  input  logic [3:0] req_mask ,
  input  logic [1:0] req_src_x_cord ,
  input  logic [2:0] req_src_y_cord ,
  input  logic [0:0] req_val ,
  input  logic [0:0] req_we ,
  output logic [0:0] req_yumi ,
  input  logic [0:0] reset ,
  output logic [31:0] resp_data ,
  output logic [0:0] resp_val ,
  output logic [0:0] xcel_master__req__en ,
  output CgraXcelReqMsg xcel_master__req__msg ,
  input logic [0:0] xcel_master__req__rdy ,
  input logic [0:0] xcel_master__resp__en ,
  input CgraXcelRespMsg xcel_master__resp__msg ,
  output logic [0:0] xcel_master__resp__rdy 
);
  logic [0:0] is_DRAM_enable_addr;
  logic [0:0] is_socket_CSR_addr;
  logic [0:0] is_xcel_addr;
  logic [0:0] needs_fake_resp_r;

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:73
  // @update
  // def RX_yumi_req():
  //   s.req_yumi @= (s.is_xcel_addr & s.req_val & s.xcel_master.req.rdy) | \
  //                (~s.is_xcel_addr & s.req_val)
  
  always_comb begin : RX_yumi_req
    req_yumi = ( ( is_xcel_addr & req_val ) & xcel_master__req__rdy ) | ( ( ~is_xcel_addr ) & req_val );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:98
  // s.resp_data //= lambda: 0 if s.needs_fake_resp_r else s.xcel_master.resp.msg.data
  
  always_comb begin : _lambda__s_DUT_rx_resp_data
    resp_data = needs_fake_resp_r ? 32'd0 : xcel_master__resp__msg.data;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:96
  // s.resp_val //= lambda: s.xcel_master.resp.en | s.needs_fake_resp_r
  
  always_comb begin : _lambda__s_DUT_rx_resp_val
    resp_val = xcel_master__resp__en | needs_fake_resp_r;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:78
  // s.xcel_master.req.en //= lambda: s.req_yumi & s.is_xcel_addr
  
  always_comb begin : _lambda__s_DUT_rx_xcel_master_req_en
    xcel_master__req__en = req_yumi & is_xcel_addr;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:55
  // @update
  // def check_RX_CSR_addr():
  //   s.is_socket_CSR_addr @= s.req_addr[hp.epa_word_addr_width-1] & \
  //                         ( s.req_addr[hp.epa_word_addr_width:hp.addr_width] == 0 )
  
  always_comb begin : check_RX_CSR_addr
    is_socket_CSR_addr = req_addr[5'd16 - 5'd1] & ( req_addr[5'd27:5'd16] == 12'd0 );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:61
  // @update
  // def check_RX_DRAM_enable_addr():
  //   s.is_DRAM_enable_addr @= s.is_socket_CSR_addr & \
  //                          ( s.req_addr[0:hp.epa_word_addr_width-1] == 4 )
  
  always_comb begin : check_RX_DRAM_enable_addr
    is_DRAM_enable_addr = is_socket_CSR_addr & ( req_addr[5'd14:5'd0] == 15'd4 );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:66
  // @update
  // def check_RX_xcel_addr():
  //   s.is_xcel_addr @=s.req_addr[xp.addr_width:hp.addr_width] == 0
  
  always_comb begin : check_RX_xcel_addr
    is_xcel_addr = req_addr[5'd27:5'd12] == 16'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointRXAdapter.py:89
  // @update_ff
  // def RX_register_needs_fake_resp():
  //   s.needs_fake_resp_r <<= s.req_yumi & ((s.is_xcel_addr & s.req_we) | ~s.is_xcel_addr)
  
  always_ff @(posedge clk) begin : RX_register_needs_fake_resp
    needs_fake_resp_r <= req_yumi & ( ( is_xcel_addr & req_we ) | ( ~is_xcel_addr ) );
  end

  assign xcel_master__req__msg.wen = req_we;
  assign xcel_master__req__msg.addr = req_addr[11:0];
  assign xcel_master__req__msg.data = req_data;
  assign xcel_master__resp__rdy = 1'd1;

endmodule


// PyMTL Component HBEndpointTXAdapter Definition
// Full name: HBEndpointTXAdapter__hb_params_<src.hammerblade.params.HBParams object at 0x7f8dcc25ff28>__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointTXAdapter.py

module HBEndpointTXAdapter__38988abc31baed67
(
  input  logic [0:0] clk ,
  input  logic [1:0] my_x ,
  input  logic [2:0] my_y ,
  input  logic [7:0] req_credits ,
  output logic [80:0] req_pkt ,
  input  logic [0:0] req_rdy ,
  output logic [0:0] req_val ,
  input  logic [0:0] reset ,
  input  logic [31:0] resp_data ,
  input  logic [0:0] resp_fifo_full ,
  input  logic [1:0] resp_pkt_type ,
  input  logic [4:0] resp_reg_id ,
  input  logic [0:0] resp_val ,
  output logic [0:0] resp_yumi ,
  input logic [0:0] mem_minion__req__en ,
  input CgraNetReqMsg mem_minion__req__msg ,
  output logic [0:0] mem_minion__req__rdy ,
  output logic [0:0] mem_minion__resp__en ,
  output CgraNetRespMsg mem_minion__resp__msg ,
  input logic [0:0] mem_minion__resp__rdy 
);

  assign req_val = 1'd0;
  assign req_pkt = 81'd0;
  assign resp_yumi = 1'd0;
  assign mem_minion__req__rdy = 1'd0;
  assign mem_minion__resp__en = 1'd0;
  assign mem_minion__resp__msg = { 1'd0, 12'd0, 32'd0 };

endmodule


// PyMTL Component HBEndpointCGRAXcel Definition
// Full name: HBEndpointCGRAXcel__hb_params_<src.hammerblade.params.HBParams object at 0x7f8dcc25ff28>__xcel_params_<cgra.params.CGRAParams object at 0x7f8dcc07acc0>
// At /work/global/pp482/uecgra-src/src/hammerblade/HBEndpointCGRAXcel.py

module HBEndpointCGRAXcel_2x2
(
  input  logic [0:0] clk ,
  input  logic [27:0] in_addr_i ,
  input  logic [31:0] in_data_i ,
  input  logic [6:0] in_load_info_i ,
  input  logic [3:0] in_mask_i ,
  input  logic [1:0] in_src_x_cord_i ,
  input  logic [2:0] in_src_y_cord_i ,
  input  logic [0:0] in_v_i ,
  input  logic [0:0] in_we_i ,
  output logic [0:0] in_yumi_o ,
  input  logic [1:0] my_x_i ,
  input  logic [2:0] my_y_i ,
  input  logic [7:0] out_credits_i ,
  output logic [80:0] out_packet_o ,
  input  logic [0:0] out_ready_i ,
  output logic [0:0] out_v_o ,
  input  logic [0:0] reset ,
  input  logic [31:0] returned_data_r_i ,
  input  logic [0:0] returned_fifo_full_i ,
  input  logic [1:0] returned_pkt_type_r_i ,
  input  logic [4:0] returned_reg_id_r_i ,
  input  logic [0:0] returned_v_r_i ,
  output logic [0:0] returned_yumi_o ,
  output logic [31:0] returning_data_o ,
  output logic [0:0] returning_v_o 
);
  //-------------------------------------------------------------
  // Component cgra_xcel
  //-------------------------------------------------------------

  logic [0:0] cgra_xcel__clk;
  logic [0:0] cgra_xcel__reset;
  logic [0:0] cgra_xcel__mem_master__req__en;
  CgraNetReqMsg cgra_xcel__mem_master__req__msg;
  logic [0:0] cgra_xcel__mem_master__req__rdy;
  logic [0:0] cgra_xcel__mem_master__resp__en;
  CgraNetRespMsg cgra_xcel__mem_master__resp__msg;
  logic [0:0] cgra_xcel__mem_master__resp__rdy;
  logic [0:0] cgra_xcel__xcel_minion__req__en;
  CgraXcelReqMsg cgra_xcel__xcel_minion__req__msg;
  logic [0:0] cgra_xcel__xcel_minion__req__rdy;
  logic [0:0] cgra_xcel__xcel_minion__resp__en;
  CgraXcelRespMsg cgra_xcel__xcel_minion__resp__msg;
  logic [0:0] cgra_xcel__xcel_minion__resp__rdy;

  CGRAXcel__b5592e8a4ff43256 cgra_xcel
  (
    .clk( cgra_xcel__clk ),
    .reset( cgra_xcel__reset ),
    .mem_master__req__en( cgra_xcel__mem_master__req__en ),
    .mem_master__req__msg( cgra_xcel__mem_master__req__msg ),
    .mem_master__req__rdy( cgra_xcel__mem_master__req__rdy ),
    .mem_master__resp__en( cgra_xcel__mem_master__resp__en ),
    .mem_master__resp__msg( cgra_xcel__mem_master__resp__msg ),
    .mem_master__resp__rdy( cgra_xcel__mem_master__resp__rdy ),
    .xcel_minion__req__en( cgra_xcel__xcel_minion__req__en ),
    .xcel_minion__req__msg( cgra_xcel__xcel_minion__req__msg ),
    .xcel_minion__req__rdy( cgra_xcel__xcel_minion__req__rdy ),
    .xcel_minion__resp__en( cgra_xcel__xcel_minion__resp__en ),
    .xcel_minion__resp__msg( cgra_xcel__xcel_minion__resp__msg ),
    .xcel_minion__resp__rdy( cgra_xcel__xcel_minion__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component cgra_xcel
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rx
  //-------------------------------------------------------------

  logic [0:0] rx__clk;
  logic [1:0] rx__my_x;
  logic [2:0] rx__my_y;
  logic [27:0] rx__req_addr;
  logic [31:0] rx__req_data;
  logic [6:0] rx__req_load_info;
  logic [3:0] rx__req_mask;
  logic [1:0] rx__req_src_x_cord;
  logic [2:0] rx__req_src_y_cord;
  logic [0:0] rx__req_val;
  logic [0:0] rx__req_we;
  logic [0:0] rx__req_yumi;
  logic [0:0] rx__reset;
  logic [31:0] rx__resp_data;
  logic [0:0] rx__resp_val;
  logic [0:0] rx__xcel_master__req__en;
  CgraXcelReqMsg rx__xcel_master__req__msg;
  logic [0:0] rx__xcel_master__req__rdy;
  logic [0:0] rx__xcel_master__resp__en;
  CgraXcelRespMsg rx__xcel_master__resp__msg;
  logic [0:0] rx__xcel_master__resp__rdy;

  HBEndpointRXAdapter__38988abc31baed67 rx
  (
    .clk( rx__clk ),
    .my_x( rx__my_x ),
    .my_y( rx__my_y ),
    .req_addr( rx__req_addr ),
    .req_data( rx__req_data ),
    .req_load_info( rx__req_load_info ),
    .req_mask( rx__req_mask ),
    .req_src_x_cord( rx__req_src_x_cord ),
    .req_src_y_cord( rx__req_src_y_cord ),
    .req_val( rx__req_val ),
    .req_we( rx__req_we ),
    .req_yumi( rx__req_yumi ),
    .reset( rx__reset ),
    .resp_data( rx__resp_data ),
    .resp_val( rx__resp_val ),
    .xcel_master__req__en( rx__xcel_master__req__en ),
    .xcel_master__req__msg( rx__xcel_master__req__msg ),
    .xcel_master__req__rdy( rx__xcel_master__req__rdy ),
    .xcel_master__resp__en( rx__xcel_master__resp__en ),
    .xcel_master__resp__msg( rx__xcel_master__resp__msg ),
    .xcel_master__resp__rdy( rx__xcel_master__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component rx
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tx
  //-------------------------------------------------------------

  logic [0:0] tx__clk;
  logic [1:0] tx__my_x;
  logic [2:0] tx__my_y;
  logic [7:0] tx__req_credits;
  logic [80:0] tx__req_pkt;
  logic [0:0] tx__req_rdy;
  logic [0:0] tx__req_val;
  logic [0:0] tx__reset;
  logic [31:0] tx__resp_data;
  logic [0:0] tx__resp_fifo_full;
  logic [1:0] tx__resp_pkt_type;
  logic [4:0] tx__resp_reg_id;
  logic [0:0] tx__resp_val;
  logic [0:0] tx__resp_yumi;
  logic [0:0] tx__mem_minion__req__en;
  CgraNetReqMsg tx__mem_minion__req__msg;
  logic [0:0] tx__mem_minion__req__rdy;
  logic [0:0] tx__mem_minion__resp__en;
  CgraNetRespMsg tx__mem_minion__resp__msg;
  logic [0:0] tx__mem_minion__resp__rdy;

  HBEndpointTXAdapter__38988abc31baed67 tx
  (
    .clk( tx__clk ),
    .my_x( tx__my_x ),
    .my_y( tx__my_y ),
    .req_credits( tx__req_credits ),
    .req_pkt( tx__req_pkt ),
    .req_rdy( tx__req_rdy ),
    .req_val( tx__req_val ),
    .reset( tx__reset ),
    .resp_data( tx__resp_data ),
    .resp_fifo_full( tx__resp_fifo_full ),
    .resp_pkt_type( tx__resp_pkt_type ),
    .resp_reg_id( tx__resp_reg_id ),
    .resp_val( tx__resp_val ),
    .resp_yumi( tx__resp_yumi ),
    .mem_minion__req__en( tx__mem_minion__req__en ),
    .mem_minion__req__msg( tx__mem_minion__req__msg ),
    .mem_minion__req__rdy( tx__mem_minion__req__rdy ),
    .mem_minion__resp__en( tx__mem_minion__resp__en ),
    .mem_minion__resp__msg( tx__mem_minion__resp__msg ),
    .mem_minion__resp__rdy( tx__mem_minion__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component tx
  //-------------------------------------------------------------

  assign tx__clk = clk;
  assign tx__reset = reset;
  assign rx__clk = clk;
  assign rx__reset = reset;
  assign cgra_xcel__clk = clk;
  assign cgra_xcel__reset = reset;
  assign cgra_xcel__xcel_minion__req__en = rx__xcel_master__req__en;
  assign cgra_xcel__xcel_minion__req__msg = rx__xcel_master__req__msg;
  assign rx__xcel_master__req__rdy = cgra_xcel__xcel_minion__req__rdy;
  assign rx__xcel_master__resp__en = cgra_xcel__xcel_minion__resp__en;
  assign rx__xcel_master__resp__msg = cgra_xcel__xcel_minion__resp__msg;
  assign cgra_xcel__xcel_minion__resp__rdy = rx__xcel_master__resp__rdy;
  assign rx__req_val = in_v_i;
  assign rx__req_data = in_data_i;
  assign rx__req_mask = in_mask_i;
  assign rx__req_addr = in_addr_i;
  assign rx__req_we = in_we_i;
  assign rx__req_load_info = in_load_info_i;
  assign rx__req_src_x_cord = in_src_x_cord_i;
  assign rx__req_src_y_cord = in_src_y_cord_i;
  assign in_yumi_o = rx__req_yumi;
  assign returning_data_o = rx__resp_data;
  assign returning_v_o = rx__resp_val;
  assign rx__my_x = my_x_i;
  assign rx__my_y = my_y_i;
  assign tx__mem_minion__req__en = cgra_xcel__mem_master__req__en;
  assign tx__mem_minion__req__msg = cgra_xcel__mem_master__req__msg;
  assign cgra_xcel__mem_master__req__rdy = tx__mem_minion__req__rdy;
  assign cgra_xcel__mem_master__resp__en = tx__mem_minion__resp__en;
  assign cgra_xcel__mem_master__resp__msg = tx__mem_minion__resp__msg;
  assign tx__mem_minion__resp__rdy = cgra_xcel__mem_master__resp__rdy;
  assign out_v_o = tx__req_val;
  assign out_packet_o = tx__req_pkt;
  assign tx__req_rdy = out_ready_i;
  assign tx__req_credits = out_credits_i;
  assign tx__resp_data = returned_data_r_i;
  assign tx__resp_reg_id = returned_reg_id_r_i;
  assign tx__resp_val = returned_v_r_i;
  assign tx__resp_pkt_type = returned_pkt_type_r_i;
  assign returned_yumi_o = tx__resp_yumi;
  assign tx__resp_fifo_full = returned_fifo_full_i;
  assign tx__my_x = my_x_i;
  assign tx__my_y = my_y_i;

endmodule
