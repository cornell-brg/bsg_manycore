//-------------------------------------------------------------------------
// BrgHBTile.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct TileCtrlMsg_1__coreid_1__data_32 Definition
typedef struct packed {
  logic [0:0] coreid;
  logic [31:0] data;
} TileCtrlMsg_1__coreid_1__data_32;

// PyMTL BitStruct HBEndpointPacket__29ee445108156f7d Definition
typedef struct packed {
  logic [27:0] addr;
  logic [1:0] op;
  logic [3:0] op_ex;
  logic [4:0] reg_id;
  logic [31:0] payload;
  logic [2:0] src_y_cord;
  logic [1:0] src_x_cord;
  logic [2:0] y_cord;
  logic [1:0] x_cord;
} HBEndpointPacket__29ee445108156f7d;

// PyMTL BitStruct MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  logic [31:0] addr;
  logic [3:0] len;
  logic [3:0] wr_mask;
  logic [127:0] data;
} MemReqMsg_8_32_128_m1__35a1cc23a1d2d863;

// PyMTL BitStruct MemRespMsg_8_128_m1__c72937e2b7853c90 Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  logic [1:0] test;
  logic [3:0] len;
  logic [3:0] wr_mask;
  logic [127:0] data;
} MemRespMsg_8_128_m1__c72937e2b7853c90;

// PyMTL BitStruct MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  logic [31:0] addr;
  logic [1:0] len;
  logic [31:0] data;
} MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32;

// PyMTL BitStruct MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  logic [1:0] test;
  logic [1:0] len;
  logic [31:0] data;
} MemRespMsg__type__4__opaque_8__test_2__len_2__data_32;

// PyMTL BitStruct FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  logic [31:0] op_a;
  logic [31:0] op_b;
  logic [2:0] frnd;
} FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3;

// PyMTL BitStruct FpuRespMsg_8_32__opaque_8__result_32__fexc_5 Definition
typedef struct packed {
  logic [7:0] opaque;
  logic [31:0] result;
  logic [4:0] fexc;
} FpuRespMsg_8_32__opaque_8__result_32__fexc_5;

// PyMTL BitStruct MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 Definition
typedef struct packed {
  logic [2:0] type_;
  logic [7:0] opaque;
  logic [31:0] op_a;
  logic [31:0] op_b;
} MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32;

// PyMTL BitStruct MduRespMsg_8_32__opaque_8__res_32 Definition
typedef struct packed {
  logic [7:0] opaque;
  logic [31:0] res;
} MduRespMsg_8_32__opaque_8__res_32;

// PyMTL BitStruct StructCtrlSignals_4096_128_32_32_2__d7dbe132f9f2ed9f Definition
typedef struct packed {
  logic [0:0] reg_en_M0;
  logic [0:0] cachereq_memresp_mux_sel_M0;
  logic [0:0] addr_mux_sel_M0;
  logic [0:0] wdata_mux_sel_M0;
  logic [1:0] tag_array_val_M0;
  logic [0:0] update_tag_way_M0;
  logic [0:0] tag_array_type_M0;
  logic [25:0] tag_array_wben_M0;
  logic [0:0] ctrl_bit_rep_wr_M0;
  logic [2:0] update_tag_cmd_M0;
  logic [0:0] update_tag_sel_M0;
  logic [0:0] tag_array_idx_sel_M0;
  logic [6:0] tag_array_init_idx_M0;
  logic [0:0] is_amo_M0;
  logic [0:0] reg_en_M1;
  logic [0:0] flush_init_reg_en_M1;
  logic [0:0] data_array_val_M1;
  logic [0:0] data_array_type_M1;
  logic [0:0] evict_mux_sel_M1;
  logic [0:0] stall_reg_en_M1;
  logic [0:0] hit_stall_eng_en_M1;
  logic [0:0] ctrl_bit_rep_en_M1;
  logic [0:0] way_offset_M1;
  logic [0:0] is_init_M1;
  logic [0:0] flush_idx_mux_sel_M1;
  logic [3:0] dirty_evict_mask_M1;
  logic [1:0] wben_cmd_M1;
  logic [0:0] tag_processing_en_M1;
  logic [0:0] reg_en_M2;
  logic [0:0] read_data_mux_sel_M2;
  logic [0:0] data_size_mux_en_M2;
  logic [0:0] stall_reg_en_M2;
  logic [1:0] hit_M2;
  logic [3:0] memreq_type;
  logic [0:0] MSHR_alloc_en;
  logic [0:0] MSHR_dealloc_en;
  logic [0:0] is_amo_M2;
} StructCtrlSignals_4096_128_32_32_2__d7dbe132f9f2ed9f;

// PyMTL BitStruct StructDpathStatus_4096_128_32_32_2__d99bb19c96f0c7bf Definition
typedef struct packed {
  logic [3:0] cachereq_type_M0;
  logic [3:0] memresp_type_M0;
  logic [3:0] offset_M0;
  logic [0:0] amo_hit_M0;
  logic [3:0] cachereq_type_M1;
  logic [1:0] ctrl_bit_dty_rd_line_M1;
  logic [1:0] ctrl_bit_dty_rd_word_M1;
  logic [0:0] hit_M1;
  logic [0:0] inval_hit_M1;
  logic [0:0] hit_way_M1;
  logic [0:0] ctrl_bit_rep_rd_M1;
  logic [0:0] amo_hit_way_M1;
  logic [3:0] cachereq_type_M2;
  logic [0:0] MSHR_full;
  logic [0:0] MSHR_empty;
  logic [3:0] MSHR_type;
  logic [0:0] MSHR_ptr;
} StructDpathStatus_4096_128_32_32_2__d99bb19c96f0c7bf;

// PyMTL BitStruct StructMSHR_32_2__4f9bfcd81ca6f13c Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  logic [31:0] addr;
  logic [1:0] len;
  logic [31:0] data;
  logic [0:0] repl;
  logic [0:0] amo_hit;
  logic [3:0] dirty_bits;
} StructMSHR_32_2__4f9bfcd81ca6f13c;

// PyMTL BitStruct StructHitInfo_1__hit_1__hit_way_1 Definition
typedef struct packed {
  logic [0:0] hit;
  logic [0:0] hit_way;
} StructHitInfo_1__hit_1__hit_way_1;

// PyMTL BitStruct StructAddr_21_7_4__tag_21__index_7__offset_4 Definition
typedef struct packed {
  logic [20:0] tag;
  logic [6:0] index;
  logic [3:0] offset;
} StructAddr_21_7_4__tag_21__index_7__offset_4;

// PyMTL BitStruct StructDpathPipeline_128_2__f3cfe859759af9fc Definition
typedef struct packed {
  logic [3:0] type_;
  logic [7:0] opaque;
  StructAddr_21_7_4__tag_21__index_7__offset_4 addr;
  logic [1:0] len;
  logic [127:0] data;
} StructDpathPipeline_128_2__f3cfe859759af9fc;

// PyMTL BitStruct StructTagArray_1_4_21__val_1__dty_4__tag_21 Definition
typedef struct packed {
  logic [0:0] val;
  logic [3:0] dty;
  logic [20:0] tag;
} StructTagArray_1_4_21__val_1__dty_4__tag_21;

// PyMTL BitStruct RingMsg_2__src_1__dst_1__payload_32 Definition
typedef struct packed {
  logic [0:0] src;
  logic [0:0] dst;
  logic [31:0] payload;
} RingMsg_2__src_1__dst_1__payload_32;

// PyMTL BitStruct NetHeader8B__7a1608e9e4d537dd Definition
typedef struct packed {
  logic [31:0] addr;
  logic [1:0] debug;
  logic [3:0] wr_mask;
  logic [3:0] dst;
  logic [3:0] plen;
  logic [7:0] opaque;
  logic [3:0] type_;
  logic [3:0] len;
  logic [1:0] test;
} NetHeader8B__7a1608e9e4d537dd;

// PyMTL BitStruct NetHeader4B__ab3e1322e1bcfddf Definition
typedef struct packed {
  logic [1:0] debug;
  logic [3:0] wr_mask;
  logic [3:0] dst;
  logic [3:0] plen;
  logic [7:0] opaque;
  logic [3:0] type_;
  logic [3:0] len;
  logic [1:0] test;
} NetHeader4B__ab3e1322e1bcfddf;

// PyMTL BitStruct RegWrStruct__preg_idx_7__data_32 Definition
typedef struct packed {
  logic [6:0] preg_idx;
  logic [31:0] data;
} RegWrStruct__preg_idx_7__data_32;

// PyMTL BitStruct ClearBrStruct__ac353fa5f603c6f1 Definition
typedef struct packed {
  logic [0:0] kill;
  logic [1:0] br_mask;
  logic [31:0] pc_redirect;
  logic [0:0] br_idx;
  logic [2:0] ckpt_head;
  logic [2:0] rob_idx;
  logic [1:0] prev_br_tag;
} ClearBrStruct__ac353fa5f603c6f1;

// PyMTL BitStruct I_InstStruct__c61c86abe6488854 Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] inst_val;
  logic [1:0] br_tag;
  logic [2:0] rob_idx;
  logic [31:0] op1_val;
  logic [31:0] op2_val;
  logic [0:0] rd_en;
  logic [6:0] rd_preg;
  logic [3:0] br_type;
  logic [3:0] alu_type;
  logic [1:0] csr_type;
  logic [0:0] br_idx;
  logic [31:0] br_target;
  logic [3:0] mdu_type;
  logic [3:0] mem_type;
  logic [1:0] mem_len;
  logic [0:0] mem_ext;
  logic [31:0] st_data;
  logic [0:0] fls;
  logic [0:0] inv;
  logic [3:0] fpu_type;
  logic [0:0] killed;
} I_InstStruct__c61c86abe6488854;

// PyMTL BitStruct ResolveBranchStruct__7003e9cf5478f896 Definition
typedef struct packed {
  logic [0:0] mispredicted;
  logic [0:0] br_idx;
  logic [1:0] br_tag;
  logic [31:0] br_target;
  logic [2:0] rob_idx;
} ResolveBranchStruct__7003e9cf5478f896;

// PyMTL BitStruct X_InstStruct__b64b8c5076edb89b Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] inst_val;
  logic [1:0] br_tag;
  logic [2:0] rob_idx;
  logic [0:0] rd_en;
  logic [6:0] rd_preg;
  logic [0:0] csr_wen;
  logic [31:0] result;
  logic [0:0] killed;
} X_InstStruct__b64b8c5076edb89b;

// PyMTL BitStruct ROBEntry__81cd62f62fe20808 Definition
typedef struct packed {
  logic [0:0] inst_val;
  logic [31:0] pc;
  logic [0:0] rf_wen;
  logic [6:0] rd_ppreg;
  logic [1:0] csr_type;
  logic [11:0] csr_num;
} ROBEntry__81cd62f62fe20808;

// PyMTL BitStruct RegInstStruct__496c286c2dc8d523 Definition
typedef struct packed {
  logic [0:0] inst_val;
  logic [31:0] pc;
  logic [3:0] br_type;
  logic [1:0] csr_type;
  logic [3:0] mem_type;
  logic [0:0] rd_en;
  logic [6:0] rd_ppreg;
  logic [11:0] csr_num;
} RegInstStruct__496c286c2dc8d523;

// PyMTL BitStruct RegInstRetStruct__rob_idx_3__br_idx_1__br_tag_2 Definition
typedef struct packed {
  logic [2:0] rob_idx;
  logic [0:0] br_idx;
  logic [1:0] br_tag;
} RegInstRetStruct__rob_idx_3__br_idx_1__br_tag_2;

// PyMTL BitStruct RollbackStruct__br_idx_1__ckpt_head_3 Definition
typedef struct packed {
  logic [0:0] br_idx;
  logic [2:0] ckpt_head;
} RollbackStruct__br_idx_1__ckpt_head_3;

// PyMTL BitStruct F_InstStruct__pc_32__inst_32 Definition
typedef struct packed {
  logic [31:0] pc;
  logic [31:0] inst;
} F_InstStruct__pc_32__inst_32;

// PyMTL BitStruct D_InstStruct__e597a7f7aebd8fbc Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] inst_val;
  logic [3:0] br_type;
  logic [3:0] alu_type;
  logic [3:0] mdu_type;
  logic [3:0] mem_type;
  logic [1:0] mem_len;
  logic [0:0] mem_ext;
  logic [1:0] csr_type;
  logic [3:0] fpu_type;
  logic [1:0] br_tag;
  logic [0:0] br_idx;
  logic [31:0] br_target;
  logic [2:0] rob_idx;
  logic [0:0] rs1_en;
  logic [0:0] rs2_en;
  logic [0:0] rd_en;
  logic [6:0] rs1_preg;
  logic [6:0] rs2_preg;
  logic [6:0] rd_preg;
  logic [11:0] csr_num;
  logic [31:0] imm_val;
  logic [0:0] op1_sel;
  logic [1:0] op2_sel;
  logic [0:0] fls;
  logic [0:0] inv;
  logic [0:0] killed;
} D_InstStruct__e597a7f7aebd8fbc;

// PyMTL BitStruct MemCompleteStruct__c5bd3cabb5deb86b Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] inst_val;
  logic [1:0] br_tag;
  logic [2:0] rob_idx;
  logic [0:0] rd_en;
  logic [6:0] rd_preg;
  logic [0:0] mem_ext;
  logic [31:0] data;
  logic [0:0] killed;
} MemCompleteStruct__c5bd3cabb5deb86b;

// PyMTL BitStruct MemExecuteStruct__af5802ecac25c83f Definition
typedef struct packed {
  logic [31:0] pc;
  logic [0:0] inst_val;
  logic [1:0] br_tag;
  logic [2:0] rob_idx;
  logic [0:0] rd_en;
  logic [6:0] rd_preg;
  logic [3:0] mem_type;
  logic [1:0] mem_len;
  logic [0:0] mem_ext;
  logic [31:0] st_data;
  logic [31:0] mem_addr;
  logic [0:0] fls;
  logic [0:0] inv;
  logic [0:0] killed;
} MemExecuteStruct__af5802ecac25c83f;

// PyMTL BitStruct BrTableEntry__br_tag_2__ckpt_head_3 Definition
typedef struct packed {
  logic [1:0] br_tag;
  logic [2:0] ckpt_head;
} BrTableEntry__br_tag_2__ckpt_head_3;

// PyMTL BitStruct CSRBrTagEntry__br_tag_2__killed_1 Definition
typedef struct packed {
  logic [1:0] br_tag;
  logic [0:0] killed;
} CSRBrTagEntry__br_tag_2__killed_1;

// PyMTL BitStruct RegIdxPair__areg_idx_6__preg_idx_7 Definition
typedef struct packed {
  logic [5:0] areg_idx;
  logic [6:0] preg_idx;
} RegIdxPair__areg_idx_6__preg_idx_7;

// PyMTL BitStruct DecoderStruct__20424510df2ec9a8 Definition
typedef struct packed {
  logic [0:0] inst_val;
  logic [2:0] imm_type;
  logic [3:0] br_type;
  logic [3:0] alu_type;
  logic [3:0] mdu_type;
  logic [3:0] mem_type;
  logic [1:0] mem_len;
  logic [0:0] mem_ext;
  logic [1:0] csr_type;
  logic [3:0] fpu_type;
  logic [0:0] rs1_en;
  logic [0:0] rs2_en;
  logic [0:0] rd_en;
  logic [0:0] op1_sel;
  logic [1:0] op2_sel;
  logic [0:0] fp_rs1;
  logic [0:0] fp_rs2;
  logic [0:0] fp_rd;
} DecoderStruct__20424510df2ec9a8;

// PyMTL BitStruct IFetchReq__val_1__pc_32 Definition
typedef struct packed {
  logic [0:0] val;
  logic [31:0] pc;
} IFetchReq__val_1__pc_32;

// PyMTL BitStruct MulDivReqStruct__b78922f82ad9e943 Definition
typedef struct packed {
  logic [31:0] pc;
  logic [1:0] br_tag;
  logic [2:0] rob_idx;
  logic [6:0] rd_preg;
  logic [0:0] killed;
} MulDivReqStruct__b78922f82ad9e943;

// PyMTL BitStruct TransducerMshrMsg__e1bbe4e01acd977d Definition
typedef struct packed {
  logic [0:0] threadid;
  logic [7:0] cacheid;
  logic [3:0] type_;
  logic [3:0] write_mask;
  logic [31:0] addr;
  logic [127:0] data;
} TransducerMshrMsg__e1bbe4e01acd977d;

// PyMTL BitStruct EntryType__26f404bb414089c7 Definition
typedef struct packed {
  logic [0:0] valid;
  logic [0:0] issued;
  logic [3:0] pending;
  logic [3:0] type_;
  logic [0:0] threadid;
  logic [7:0] cacheid;
  logic [31:0] base_addr;
  logic [127:0] data;
} EntryType__26f404bb414089c7;

// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_3__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [2:0] in_ ,
  output logic [2:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__reset_value_at_up_regenrst  = 3'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 3'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component CounterEnRst Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/counters.py

module CounterEnRst__Type_8__reset_value_255
(
  input  logic [0:0] clk ,
  input  logic [0:0] count_down ,
  input  logic [0:0] en ,
  input  logic [0:0] load ,
  input  logic [7:0] load_value ,
  output logic [7:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [7:0] __const__reset_value_at_counter_ff_logic  = 8'd255;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/counters.py:24
  // @update_ff
  // def counter_ff_logic():
  //   if s.reset:
  //     s.out <<= reset_value
  //   elif s.en:
  //     if s.count_down:
  //       s.out <<= s.out - 1
  //     else:
  //       s.out <<= s.out + 1
  
  always_ff @(posedge clk) begin : counter_ff_logic
    if ( reset ) begin
      out <= 8'( __const__reset_value_at_counter_ff_logic );
    end
    else if ( en ) begin
      if ( count_down ) begin
        out <= out - 8'd1;
      end
      else
        out <= out + 8'd1;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_1__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [0:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 1'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component ReplacementPolicy Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/ReplacementPolicy.py

module ReplacementPolicy__p_BlockingCache_4096_128_32_32_2__policy_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] repreq_en ,
  input  logic [0:0] repreq_hit_ptr ,
  input  logic [0:0] repreq_is_hit ,
  input  logic [0:0] repreq_ptr ,
  output logic [0:0] repreq_rdy ,
  output logic [0:0] represp_ptr ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/ReplacementPolicy.py:39
  // @update
  // def pointer_logic():
  //   s.represp_ptr @= s.repreq_ptr
  //   if s.repreq_en:
  //     if ~s.repreq_is_hit:
  //       s.represp_ptr @= ~s.repreq_ptr
  //     elif s.repreq_is_hit:
  //       s.represp_ptr @= ~s.repreq_hit_ptr
  
  always_comb begin : pointer_logic
    represp_ptr = repreq_ptr;
    if ( repreq_en ) begin
      if ( ~repreq_is_hit ) begin
        represp_ptr = ~repreq_ptr;
      end
      else if ( repreq_is_hit ) begin
        represp_ptr = ~repreq_hit_ptr;
      end
    end
  end

  assign repreq_rdy = 1'd1;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_5__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [4:0] in_ ,
  output logic [4:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 5'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegRst__Type_1__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:39
  // @update_ff
  // def up_regrst():
  //   if s.reset: s.out <<= reset_value
  //   else:       s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regrst
    if ( reset ) begin
      out <= 1'( __const__reset_value_at_up_regrst );
    end
    else
      out <= in_;
  end

endmodule


// PyMTL Component BlockingCacheCtrlRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py

module BlockingCacheCtrlRTL__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] cachereq_en ,
  output logic [0:0] cachereq_rdy ,
  output logic [0:0] cacheresp_en ,
  input  logic [0:0] cacheresp_rdy ,
  input  logic [0:0] clk ,
  output StructCtrlSignals_4096_128_32_32_2__d7dbe132f9f2ed9f ctrl ,
  output logic [0:0] memreq_en ,
  input  logic [0:0] memreq_rdy ,
  input  logic [0:0] memresp_en ,
  output logic [0:0] memresp_rdy ,
  input  logic [0:0] reset ,
  input  StructDpathStatus_4096_128_32_32_2__d99bb19c96f0c7bf status 
);
  localparam logic [3:0] __const__WRITE  = 4'd1;
  localparam logic [2:0] __const__M0_FSM_STATE_INIT  = 3'd0;
  localparam logic [2:0] __const__M0_FSM_STATE_READY  = 3'd1;
  localparam logic [3:0] __const__READ  = 4'd0;
  localparam logic [2:0] __const__M0_FSM_STATE_REPLAY  = 3'd2;
  localparam logic [3:0] __const__INV  = 4'd14;
  localparam logic [2:0] __const__M0_FSM_STATE_INV  = 3'd3;
  localparam logic [3:0] __const__FLUSH  = 4'd15;
  localparam logic [2:0] __const__M0_FSM_STATE_FLUSH  = 3'd4;
  localparam logic [2:0] __const__M0_FSM_STATE_FLUSH_WAIT  = 3'd5;
  localparam logic [0:0] __const__TRANS_TYPE_INVALID  = 1'd0;
  localparam logic [3:0] __const__TRANS_TYPE_CACHE_INIT  = 4'd8;
  localparam logic [2:0] __const__TRANS_TYPE_CLEAN_HIT  = 3'd4;
  localparam logic [1:0] __const__TRANS_TYPE_REPLAY_WRITE  = 2'd3;
  localparam logic [1:0] __const__TRANS_TYPE_REPLAY_READ  = 2'd2;
  localparam logic [3:0] __const__TRANS_TYPE_REPLAY_INV  = 4'd13;
  localparam logic [4:0] __const__TRANS_TYPE_REPLAY_FLUSH  = 5'd18;
  localparam logic [4:0] __const__TRANS_TYPE_FLUSH_WAIT  = 5'd16;
  localparam logic [3:0] __const__TRANS_TYPE_INV_WRITE  = 4'd12;
  localparam logic [3:0] __const__TRANS_TYPE_FLUSH_READ  = 4'd15;
  localparam logic [4:0] __const__TRANS_TYPE_FLUSH_WRITE  = 5'd17;
  localparam logic [0:0] __const__TRANS_TYPE_REFILL  = 1'd1;
  localparam logic [3:0] __const__AMO_ADD  = 4'd3;
  localparam logic [3:0] __const__TRANS_TYPE_REPLAY_AMO  = 4'd10;
  localparam logic [3:0] __const__INIT  = 4'd2;
  localparam logic [2:0] __const__TRANS_TYPE_INIT_REQ  = 3'd7;
  localparam logic [2:0] __const__TRANS_TYPE_READ_REQ  = 3'd5;
  localparam logic [2:0] __const__TRANS_TYPE_WRITE_REQ  = 3'd6;
  localparam logic [3:0] __const__TRANS_TYPE_AMO_REQ  = 4'd9;
  localparam logic [3:0] __const__TRANS_TYPE_INV_START  = 4'd11;
  localparam logic [3:0] __const__TRANS_TYPE_FLUSH_START  = 4'd14;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_NONE  = 3'd0;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_CLEAR  = 3'd1;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_WR_HIT  = 3'd2;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_WR_REFILL  = 3'd3;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_RD_REFILL  = 3'd4;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_INV  = 3'd5;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_FLUSH  = 3'd6;
  localparam logic [0:0] __const__rd  = 1'd0;
  localparam logic [0:0] __const__n  = 1'd0;
  localparam logic [0:0] __const__wr  = 1'd1;
  localparam logic [25:0] __const__wben_dty_at_cs_table_M0  = 26'd31457280;
  localparam logic [0:0] __const__x  = 1'd0;
  localparam logic [0:0] __const__y  = 1'd1;
  localparam logic [25:0] __const__wben_val_at_cs_table_M0  = 26'd33554432;
  localparam logic [0:0] __const__clog_asso_at__lambda__s_dcaches_0__cacheCtrl_ctrl_tag_array_init_idx_M0  = 1'd1;
  localparam logic [1:0] __const__WriteBitEnGen_CMD_NONE  = 2'd0;
  localparam logic [1:0] __const__WriteBitEnGen_CMD_REQ  = 2'd1;
  localparam logic [1:0] __const__WriteBitEnGen_CMD_DIRTY  = 2'd2;
  localparam logic [3:0] __const__maskf_at__lambda__s_dcaches_0__cacheCtrl_ctrl_dirty_evict_mask_M1  = 4'd15;
  localparam logic [3:0] __const__AMO  = 4'd3;
  logic [2:0] FSM_state_M0_next;
  logic [0:0] counter_en_M0;
  logic [34:0] cs0;
  logic [6:0] cs1;
  logic [8:0] cs2;
  logic [0:0] ctrl_pipeline_reg_en_M1;
  logic [0:0] ctrl_pipeline_reg_en_M2;
  logic [0:0] evict_bypass;
  logic [0:0] flush_refill_M1_bypass;
  logic [0:0] has_flush_sent_M1_bypass;
  logic [0:0] hit_M1;
  logic [0:0] is_dty_M1;
  logic [0:0] is_evict_M1;
  logic [0:0] is_write_hit_clean_M0;
  logic [0:0] memresp_val_M0;
  logic [0:0] memresp_wr_ack_M0;
  logic [0:0] no_flush_needed_M1_bypass;
  logic [0:0] ostall_M1;
  logic [0:0] ostall_M2;
  logic [0:0] prev_flush_done_M0;
  logic [0:0] repreq_en_M1;
  logic [0:0] repreq_hit_ptr_M1;
  logic [0:0] repreq_is_hit_M1;
  logic [0:0] stall_M0;
  logic [0:0] stall_M1;
  logic [0:0] stall_M2;
  logic [4:0] trans_M0;
  logic [7:0] update_way_idx_M0;
  //-------------------------------------------------------------
  // Component FSM_state_M0
  //-------------------------------------------------------------

  logic [0:0] FSM_state_M0__clk;
  logic [0:0] FSM_state_M0__en;
  logic [2:0] FSM_state_M0__in_;
  logic [2:0] FSM_state_M0__out;
  logic [0:0] FSM_state_M0__reset;

  RegEnRst__Type_3__reset_value_0 FSM_state_M0
  (
    .clk( FSM_state_M0__clk ),
    .en( FSM_state_M0__en ),
    .in_( FSM_state_M0__in_ ),
    .out( FSM_state_M0__out ),
    .reset( FSM_state_M0__reset )
  );

  //-------------------------------------------------------------
  // End of component FSM_state_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component counter_M0
  //-------------------------------------------------------------

  logic [0:0] counter_M0__clk;
  logic [0:0] counter_M0__count_down;
  logic [0:0] counter_M0__en;
  logic [0:0] counter_M0__load;
  logic [7:0] counter_M0__load_value;
  logic [7:0] counter_M0__out;
  logic [0:0] counter_M0__reset;

  CounterEnRst__Type_8__reset_value_255 counter_M0
  (
    .clk( counter_M0__clk ),
    .count_down( counter_M0__count_down ),
    .en( counter_M0__en ),
    .load( counter_M0__load ),
    .load_value( counter_M0__load_value ),
    .out( counter_M0__out ),
    .reset( counter_M0__reset )
  );

  //-------------------------------------------------------------
  // End of component counter_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component has_flush_sent_M2
  //-------------------------------------------------------------

  logic [0:0] has_flush_sent_M2__clk;
  logic [0:0] has_flush_sent_M2__en;
  logic [0:0] has_flush_sent_M2__in_;
  logic [0:0] has_flush_sent_M2__out;
  logic [0:0] has_flush_sent_M2__reset;

  RegEnRst__Type_1__reset_value_0 has_flush_sent_M2
  (
    .clk( has_flush_sent_M2__clk ),
    .en( has_flush_sent_M2__en ),
    .in_( has_flush_sent_M2__in_ ),
    .out( has_flush_sent_M2__out ),
    .reset( has_flush_sent_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component has_flush_sent_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component hit_reg_M2
  //-------------------------------------------------------------

  logic [0:0] hit_reg_M2__clk;
  logic [0:0] hit_reg_M2__en;
  logic [0:0] hit_reg_M2__in_;
  logic [0:0] hit_reg_M2__out;
  logic [0:0] hit_reg_M2__reset;

  RegEnRst__Type_1__reset_value_0 hit_reg_M2
  (
    .clk( hit_reg_M2__clk ),
    .en( hit_reg_M2__en ),
    .in_( hit_reg_M2__in_ ),
    .out( hit_reg_M2__out ),
    .reset( hit_reg_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component hit_reg_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component is_evict_M2
  //-------------------------------------------------------------

  logic [0:0] is_evict_M2__clk;
  logic [0:0] is_evict_M2__en;
  logic [0:0] is_evict_M2__in_;
  logic [0:0] is_evict_M2__out;
  logic [0:0] is_evict_M2__reset;

  RegEnRst__Type_1__reset_value_0 is_evict_M2
  (
    .clk( is_evict_M2__clk ),
    .en( is_evict_M2__en ),
    .in_( is_evict_M2__in_ ),
    .out( is_evict_M2__out ),
    .reset( is_evict_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component is_evict_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component memresp_en_M0
  //-------------------------------------------------------------

  logic [0:0] memresp_en_M0__clk;
  logic [0:0] memresp_en_M0__en;
  logic [0:0] memresp_en_M0__in_;
  logic [0:0] memresp_en_M0__out;
  logic [0:0] memresp_en_M0__reset;

  RegEnRst__Type_1__reset_value_0 memresp_en_M0
  (
    .clk( memresp_en_M0__clk ),
    .en( memresp_en_M0__en ),
    .in_( memresp_en_M0__in_ ),
    .out( memresp_en_M0__out ),
    .reset( memresp_en_M0__reset )
  );

  //-------------------------------------------------------------
  // End of component memresp_en_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component replacement_M1
  //-------------------------------------------------------------

  logic [0:0] replacement_M1__clk;
  logic [0:0] replacement_M1__repreq_en;
  logic [0:0] replacement_M1__repreq_hit_ptr;
  logic [0:0] replacement_M1__repreq_is_hit;
  logic [0:0] replacement_M1__repreq_ptr;
  logic [0:0] replacement_M1__repreq_rdy;
  logic [0:0] replacement_M1__represp_ptr;
  logic [0:0] replacement_M1__reset;

  ReplacementPolicy__p_BlockingCache_4096_128_32_32_2__policy_0 replacement_M1
  (
    .clk( replacement_M1__clk ),
    .repreq_en( replacement_M1__repreq_en ),
    .repreq_hit_ptr( replacement_M1__repreq_hit_ptr ),
    .repreq_is_hit( replacement_M1__repreq_is_hit ),
    .repreq_ptr( replacement_M1__repreq_ptr ),
    .repreq_rdy( replacement_M1__repreq_rdy ),
    .represp_ptr( replacement_M1__represp_ptr ),
    .reset( replacement_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component replacement_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component trans_M1
  //-------------------------------------------------------------

  logic [0:0] trans_M1__clk;
  logic [0:0] trans_M1__en;
  logic [4:0] trans_M1__in_;
  logic [4:0] trans_M1__out;
  logic [0:0] trans_M1__reset;

  RegEnRst__Type_5__reset_value_0 trans_M1
  (
    .clk( trans_M1__clk ),
    .en( trans_M1__en ),
    .in_( trans_M1__in_ ),
    .out( trans_M1__out ),
    .reset( trans_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component trans_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component trans_M2
  //-------------------------------------------------------------

  logic [0:0] trans_M2__clk;
  logic [0:0] trans_M2__en;
  logic [4:0] trans_M2__in_;
  logic [4:0] trans_M2__out;
  logic [0:0] trans_M2__reset;

  RegEnRst__Type_5__reset_value_0 trans_M2
  (
    .clk( trans_M2__clk ),
    .en( trans_M2__en ),
    .in_( trans_M2__in_ ),
    .out( trans_M2__out ),
    .reset( trans_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component trans_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component update_tag_way_M1
  //-------------------------------------------------------------

  logic [0:0] update_tag_way_M1__clk;
  logic [0:0] update_tag_way_M1__en;
  logic [0:0] update_tag_way_M1__in_;
  logic [0:0] update_tag_way_M1__out;
  logic [0:0] update_tag_way_M1__reset;

  RegEnRst__Type_1__reset_value_0 update_tag_way_M1
  (
    .clk( update_tag_way_M1__clk ),
    .en( update_tag_way_M1__en ),
    .in_( update_tag_way_M1__in_ ),
    .out( update_tag_way_M1__out ),
    .reset( update_tag_way_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component update_tag_way_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component was_stalled
  //-------------------------------------------------------------

  logic [0:0] was_stalled__clk;
  logic [0:0] was_stalled__in_;
  logic [0:0] was_stalled__out;
  logic [0:0] was_stalled__reset;

  RegRst__Type_1__reset_value_0 was_stalled
  (
    .clk( was_stalled__clk ),
    .in_( was_stalled__in_ ),
    .out( was_stalled__out ),
    .reset( was_stalled__reset )
  );

  //-------------------------------------------------------------
  // End of component was_stalled
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component way_ptr_M1
  //-------------------------------------------------------------

  logic [0:0] way_ptr_M1__clk;
  logic [0:0] way_ptr_M1__en;
  logic [0:0] way_ptr_M1__in_;
  logic [0:0] way_ptr_M1__out;
  logic [0:0] way_ptr_M1__reset;

  RegEnRst__Type_1__reset_value_0 way_ptr_M1
  (
    .clk( way_ptr_M1__clk ),
    .en( way_ptr_M1__en ),
    .in_( way_ptr_M1__in_ ),
    .out( way_ptr_M1__out ),
    .reset( way_ptr_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component way_ptr_M1
  //-------------------------------------------------------------
  logic [25:0] __tmpvar__cs_table_M0_wben_none;
  logic [25:0] __tmpvar__cs_table_M0_wben_all;
  logic [2:0] __tmpvar__cs_table_M0_none;
  logic [2:0] __tmpvar__cs_table_M0_clear;
  logic [2:0] __tmpvar__cs_table_M0_wr_hit;
  logic [2:0] __tmpvar__cs_table_M0_wr_refill;
  logic [2:0] __tmpvar__cs_table_M0_rd_refill;
  logic [2:0] __tmpvar__cs_table_M0_inv;
  logic [2:0] __tmpvar__cs_table_M0_flush;
  logic [1:0] __tmpvar__cs_table_M1_none;
  logic [1:0] __tmpvar__cs_table_M1_req;
  logic [1:0] __tmpvar__cs_table_M1_dty;
  logic [0:0] __tmpvar__cs_table_M1_flush;
  logic [0:0] __tmpvar__cs_table_M2_flush;
  logic [0:0] __tmpvar__cs_table_M2_fl_sel;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:334
  // s.cachereq_rdy //= lambda: ~( (s.FSM_state_M0.out == M0_FSM_STATE_INIT) |
  //          s.is_write_hit_clean_M0 | s.stall_M0 | (~s.status.MSHR_empty ) |
  //          s.status.MSHR_full )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_cachereq_rdy
    cachereq_rdy = ~( ( ( ( ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INIT ) ) | is_write_hit_clean_M0 ) | stall_M0 ) | ( ~status.MSHR_empty ) ) | status.MSHR_full );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:298
  // s.counter_M0.en         //= lambda: s.ctrl.reg_en_M0 & s.counter_en_M0
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_counter_M0_en
    counter_M0__en = ctrl.reg_en_M0 & counter_en_M0;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:324
  // s.ctrl.cachereq_memresp_mux_sel_M0 //= lambda: ((s.FSM_state_M0.out == M0_FSM_STATE_REPLAY) 
  //                                                | s.memresp_en_M0.out)
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_cachereq_memresp_mux_sel_M0
    ctrl.cachereq_memresp_mux_sel_M0 = ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_REPLAY ) ) | memresp_en_M0__out;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:656
  // s.ctrl.dirty_evict_mask_M1 //= lambda: 0 if s.is_evict_M1 else maskf
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_dirty_evict_mask_M1
    ctrl.dirty_evict_mask_M1 = is_evict_M1 ? 4'd0 : 4'( __const__maskf_at__lambda__s_dcaches_0__cacheCtrl_ctrl_dirty_evict_mask_M1 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:649
  // s.ctrl.flush_idx_mux_sel_M1 //= lambda: (
  //   (s.trans_M1.out == TRANS_TYPE_FLUSH_READ) |
  //   (s.trans_M1.out == TRANS_TYPE_CACHE_INIT))
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_flush_idx_mux_sel_M1
    ctrl.flush_idx_mux_sel_M1 = ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_CACHE_INIT ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:648
  // s.ctrl.flush_init_reg_en_M1 //= lambda: s.ctrl_pipeline_reg_en_M1
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_flush_init_reg_en_M1
    ctrl.flush_init_reg_en_M1 = ctrl_pipeline_reg_en_M1;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:644
  // s.ctrl.hit_stall_eng_en_M1 //= lambda: ~s.was_stalled.out & ~s.evict_bypass
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_hit_stall_eng_en_M1
    ctrl.hit_stall_eng_en_M1 = ( ~was_stalled__out ) & ( ~evict_bypass );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:405
  // s.ctrl.is_amo_M0 //= lambda: (( s.trans_M0 == TRANS_TYPE_REPLAY_AMO ) |
  //                               ( s.trans_M0 == TRANS_TYPE_AMO_REQ ))
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_is_amo_M0
    ctrl.is_amo_M0 = ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_AMO ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_AMO_REQ ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:752
  // s.ctrl.is_amo_M2 //= lambda: ( ((s.trans_M2.out == TRANS_TYPE_AMO_REQ) |
  //                                 (s.trans_M2.out == TRANS_TYPE_REPLAY_AMO)) &
  //                                 (~s.is_evict_M2.out) )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_is_amo_M2
    ctrl.is_amo_M2 = ( ( trans_M2__out == 5'( __const__TRANS_TYPE_AMO_REQ ) ) | ( trans_M2__out == 5'( __const__TRANS_TYPE_REPLAY_AMO ) ) ) & ( ~is_evict_M2__out );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:645
  // s.ctrl.is_init_M1          //= lambda: s.trans_M1.out == TRANS_TYPE_INIT_REQ
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_is_init_M1
    ctrl.is_init_M1 = trans_M1__out == 5'( __const__TRANS_TYPE_INIT_REQ );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:638
  // s.ctrl_pipeline_reg_en_M1 //= lambda: (s.ctrl.reg_en_M1 |
  //                                       (s.trans_M0 == TRANS_TYPE_CACHE_INIT))
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_pipeline_reg_en_M1
    ctrl_pipeline_reg_en_M1 = ctrl.reg_en_M1 | ( trans_M0 == 5'( __const__TRANS_TYPE_CACHE_INIT ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:746
  // s.ctrl_pipeline_reg_en_M2 //= lambda: ( s.ctrl.reg_en_M2 | ( s.trans_M1.out 
  //                                                   == TRANS_TYPE_CACHE_INIT ) )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_pipeline_reg_en_M2
    ctrl_pipeline_reg_en_M2 = ctrl.reg_en_M2 | ( trans_M1__out == 5'( __const__TRANS_TYPE_CACHE_INIT ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:401
  // s.ctrl.reg_en_M0 //= lambda: ~s.stall_M0
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_reg_en_M0
    ctrl.reg_en_M0 = ~stall_M0;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:634
  // s.ctrl.reg_en_M1 //= lambda: (~s.stall_M1 & ~s.is_evict_M1 &
  //                              (s.trans_M0 != TRANS_TYPE_CACHE_INIT))
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_reg_en_M1
    ctrl.reg_en_M1 = ( ( ~stall_M1 ) & ( ~is_evict_M1 ) ) & ( trans_M0 != 5'( __const__TRANS_TYPE_CACHE_INIT ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:742
  // s.ctrl.reg_en_M2 //= lambda: ( ( ~s.stall_M2 ) & ( s.trans_M1.out != 
  //                                                   TRANS_TYPE_CACHE_INIT ) )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_reg_en_M2
    ctrl.reg_en_M2 = ( ~stall_M2 ) & ( trans_M1__out != 5'( __const__TRANS_TYPE_CACHE_INIT ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:643
  // s.ctrl.stall_reg_en_M1     //= lambda: ~s.was_stalled.out
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_stall_reg_en_M1
    ctrl.stall_reg_en_M1 = ~was_stalled__out;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:749
  // s.ctrl.stall_reg_en_M2 //= lambda: ~s.was_stalled.out
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_stall_reg_en_M2
    ctrl.stall_reg_en_M2 = ~was_stalled__out;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:404
  // s.ctrl.tag_array_init_idx_M0 //= lambda: s.update_way_idx_M0[ clog_asso : p.bitwidth_num_lines ]
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_tag_array_init_idx_M0
    ctrl.tag_array_init_idx_M0 = update_way_idx_M0[3'd7:3'( __const__clog_asso_at__lambda__s_dcaches_0__cacheCtrl_ctrl_tag_array_init_idx_M0 )];
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:577
  // s.ctrl.tag_processing_en_M1 //= lambda:( (~s.is_evict_M2.out) & 
  //                                          ((s.trans_M1.out==TRANS_TYPE_READ_REQ) |  
  //                                          (s.trans_M1.out==TRANS_TYPE_WRITE_REQ) |  
  //                                          (s.trans_M1.out==TRANS_TYPE_AMO_REQ) |  
  //                                          (s.trans_M1.out==TRANS_TYPE_FLUSH_READ) ) 
  //                                         ) 
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_ctrl_tag_processing_en_M1
    ctrl.tag_processing_en_M1 = ( ~is_evict_M2__out ) & ( ( ( ( trans_M1__out == 5'( __const__TRANS_TYPE_READ_REQ ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_AMO_REQ ) ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:500
  // s.flush_refill_M1_bypass //= lambda: s.trans_M1.out == TRANS_TYPE_FLUSH_WRITE
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_flush_refill_M1_bypass
    flush_refill_M1_bypass = trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_WRITE );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:132
  // s.memresp_val_M0 //= lambda: s.memresp_en_M0.out & ( s.status.memresp_type_M0 != WRITE )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_memresp_val_M0
    memresp_val_M0 = memresp_en_M0__out & ( status.memresp_type_M0 != 4'( __const__WRITE ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:136
  // s.memresp_wr_ack_M0 //= lambda: s.memresp_en_M0.out & ( s.status.memresp_type_M0 == WRITE )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_memresp_wr_ack_M0
    memresp_wr_ack_M0 = memresp_en_M0__out & ( status.memresp_type_M0 == 4'( __const__WRITE ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:152
  // s.prev_flush_done_M0 //= lambda: (s.no_flush_needed_M1_bypass | s.memresp_wr_ack_M0 
  //                                 | s.flush_refill_M1_bypass )
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_prev_flush_done_M0
    prev_flush_done_M0 = ( no_flush_needed_M1_bypass | memresp_wr_ack_M0 ) | flush_refill_M1_bypass;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:319
  // s.stall_M0 //= lambda: s.ostall_M1 | s.ostall_M2
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_stall_M0
    stall_M0 = ostall_M1 | ostall_M2;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:467
  // s.stall_M1 //= lambda: s.ostall_M1 | s.ostall_M2
  
  always_comb begin : _lambda__s_dcaches_0__cacheCtrl_stall_M1
    stall_M1 = ostall_M1 | ostall_M2;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:480
  // @update
  // def asso_data_array_offset_way_M1():
  //   s.ctrl.way_offset_M1 @= s.status.hit_way_M1
  //   if ( (s.trans_M1.out == TRANS_TYPE_REPLAY_READ) |
  //        (s.trans_M1.out == TRANS_TYPE_REPLAY_WRITE) |
  //        (s.trans_M1.out == TRANS_TYPE_REFILL) ):
  //     s.ctrl.way_offset_M1 @= s.way_ptr_M1.out
  //   elif ( (s.trans_M1.out == TRANS_TYPE_READ_REQ) |
  //          (s.trans_M1.out == TRANS_TYPE_WRITE_REQ) ):
  //     if ~s.hit_M1:
  //       if s.status.inval_hit_M1:
  //         s.ctrl.way_offset_M1 @= s.status.hit_way_M1
  //       else:
  //         s.ctrl.way_offset_M1 @= s.status.ctrl_bit_rep_rd_M1
  //   elif s.trans_M1.out == TRANS_TYPE_AMO_REQ:
  //     s.ctrl.way_offset_M1 @= s.status.amo_hit_way_M1
  //   elif ( (s.trans_M1.out == TRANS_TYPE_FLUSH_READ) |
  //          (s.trans_M1.out == TRANS_TYPE_CACHE_INIT) ):
  //     s.ctrl.way_offset_M1 @= s.update_tag_way_M1.out
  
  always_comb begin : asso_data_array_offset_way_M1
    ctrl.way_offset_M1 = status.hit_way_M1;
    if ( ( ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_READ ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_WRITE ) ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_REFILL ) ) ) begin
      ctrl.way_offset_M1 = way_ptr_M1__out;
    end
    else if ( ( trans_M1__out == 5'( __const__TRANS_TYPE_READ_REQ ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) ) begin
      if ( ~hit_M1 ) begin
        if ( status.inval_hit_M1 ) begin
          ctrl.way_offset_M1 = status.hit_way_M1;
        end
        else
          ctrl.way_offset_M1 = status.ctrl_bit_rep_rd_M1;
      end
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_AMO_REQ ) ) begin
      ctrl.way_offset_M1 = status.amo_hit_way_M1;
    end
    else if ( ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_CACHE_INIT ) ) ) begin
      ctrl.way_offset_M1 = update_tag_way_M1__out;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:360
  // @update
  // def cs_table_M0():
  //   wben_none = BitsTagWben( 0) # not enable
  //   wben_all  = BitsTagWben(-1) # all-enable
  //   none      = UpdateTagArrayUnit_CMD_NONE
  //   clear     = UpdateTagArrayUnit_CMD_CLEAR
  //   wr_hit    = UpdateTagArrayUnit_CMD_WR_HIT
  //   wr_refill = UpdateTagArrayUnit_CMD_WR_REFILL
  //   rd_refill = UpdateTagArrayUnit_CMD_RD_REFILL
  //   inv       = UpdateTagArrayUnit_CMD_INV
  //   flush     = UpdateTagArrayUnit_CMD_FLUSH
  //   #                                                             tag_wben|wdat_mux|addr_mux|tg_ty|tag_update|tidx_sel|up_tag_sel|mshr_de
  //   s.cs0                                             @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   if   s.trans_M0 == TRANS_TYPE_CACHE_INIT:   s.cs0 @= concat( wben_all,  b1(0),   b1(0),   wr,   clear,     b1(1),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_REFILL:       s.cs0 @= concat( wben_all,  b1(1),   b1(0),   wr,   rd_refill, b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_REPLAY_READ:  s.cs0 @= concat( wben_dty,      x,   b1(0),   rd,   rd_refill, b1(0),   b1(0),     y )
  //   elif s.trans_M0 == TRANS_TYPE_REPLAY_WRITE: s.cs0 @= concat( wben_all,  b1(0),   b1(0),   wr,   wr_refill, b1(0),   b1(0),     y )
  //   elif s.trans_M0 == TRANS_TYPE_REPLAY_AMO:   s.cs0 @= concat( wben_all,  b1(1),   b1(0),   wr,   clear,     b1(0),   b1(0),     y )
  //   elif s.trans_M0 == TRANS_TYPE_CLEAN_HIT:    s.cs0 @= concat( wben_all,  b1(0),   b1(1),   wr,   wr_hit,    b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_INIT_REQ:     s.cs0 @= concat( wben_all,  b1(0),   b1(0),   wr,   rd_refill, b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_READ_REQ:     s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_WRITE_REQ:    s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_AMO_REQ:      s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_INV_START:    s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_INV_WRITE:    s.cs0 @= concat( wben_val,  b1(0),   b1(0),   wr,   inv,       b1(1),   b1(1),     n )
  //   elif s.trans_M0 == TRANS_TYPE_REPLAY_INV:   s.cs0 @= concat( wben_val,  b1(0),   b1(0),   wr,   inv,       b1(1),   b1(1),     y )
  //   elif s.trans_M0 == TRANS_TYPE_FLUSH_START:  s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_FLUSH_READ:   s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(1),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_FLUSH_WAIT:   s.cs0 @= concat( wben_none, b1(0),   b1(0),   rd,   none,      b1(0),   b1(0),     n )
  //   elif s.trans_M0 == TRANS_TYPE_FLUSH_WRITE:  s.cs0 @= concat( wben_dty,  b1(0),   b1(0),   wr,   flush,     b1(1),   b1(1),     n )
  //   elif s.trans_M0 == TRANS_TYPE_REPLAY_FLUSH: s.cs0 @= concat( wben_dty,  b1(0),   b1(0),   wr,   flush,     b1(1),   b1(1),     y )
  // 
  //   s.ctrl.tag_array_wben_M0    @= s.cs0[ CS_tag_array_wben_M0     ]
  //   s.ctrl.wdata_mux_sel_M0     @= s.cs0[ CS_wdata_mux_sel_M0      ]
  //   s.ctrl.addr_mux_sel_M0      @= s.cs0[ CS_addr_mux_sel_M0       ]
  //   s.ctrl.tag_array_type_M0    @= s.cs0[ CS_tag_array_type_M0     ]
  //   s.ctrl.update_tag_cmd_M0    @= s.cs0[ CS_tag_update_cmd_M0     ]
  //   s.ctrl.tag_array_idx_sel_M0 @= s.cs0[ CS_tag_array_idx_sel_M0  ]
  //   s.ctrl.update_tag_sel_M0    @= s.cs0[ CS_update_tag_tag_sel_M0 ]
  //   s.ctrl.MSHR_dealloc_en      @= s.cs0[ CS_mshr_dealloc_M0       ] & ~s.stall_M0
  
  always_comb begin : cs_table_M0
    __tmpvar__cs_table_M0_wben_none = 26'd0;
    __tmpvar__cs_table_M0_wben_all = 26'd67108863;
    __tmpvar__cs_table_M0_none = 3'( __const__UpdateTagArrayUnit_CMD_NONE );
    __tmpvar__cs_table_M0_clear = 3'( __const__UpdateTagArrayUnit_CMD_CLEAR );
    __tmpvar__cs_table_M0_wr_hit = 3'( __const__UpdateTagArrayUnit_CMD_WR_HIT );
    __tmpvar__cs_table_M0_wr_refill = 3'( __const__UpdateTagArrayUnit_CMD_WR_REFILL );
    __tmpvar__cs_table_M0_rd_refill = 3'( __const__UpdateTagArrayUnit_CMD_RD_REFILL );
    __tmpvar__cs_table_M0_inv = 3'( __const__UpdateTagArrayUnit_CMD_INV );
    __tmpvar__cs_table_M0_flush = 3'( __const__UpdateTagArrayUnit_CMD_FLUSH );
    cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    if ( trans_M0 == 5'( __const__TRANS_TYPE_CACHE_INIT ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_all, 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_clear, 1'd1, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_REFILL ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_all, 1'd1, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_rd_refill, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_READ ) ) begin
      cs0 = { 26'( __const__wben_dty_at_cs_table_M0 ), 1'( __const__x ), 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_rd_refill, 1'd0, 1'd0, 1'( __const__y ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_WRITE ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_all, 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_wr_refill, 1'd0, 1'd0, 1'( __const__y ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_AMO ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_all, 1'd1, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_clear, 1'd0, 1'd0, 1'( __const__y ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_CLEAN_HIT ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_all, 1'd0, 1'd1, 1'( __const__wr ), __tmpvar__cs_table_M0_wr_hit, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_INIT_REQ ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_all, 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_rd_refill, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_READ_REQ ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_AMO_REQ ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_INV_START ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_INV_WRITE ) ) begin
      cs0 = { 26'( __const__wben_val_at_cs_table_M0 ), 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_inv, 1'd1, 1'd1, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_INV ) ) begin
      cs0 = { 26'( __const__wben_val_at_cs_table_M0 ), 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_inv, 1'd1, 1'd1, 1'( __const__y ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_START ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd1, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_WAIT ) ) begin
      cs0 = { __tmpvar__cs_table_M0_wben_none, 1'd0, 1'd0, 1'( __const__rd ), __tmpvar__cs_table_M0_none, 1'd0, 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_WRITE ) ) begin
      cs0 = { 26'( __const__wben_dty_at_cs_table_M0 ), 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_flush, 1'd1, 1'd1, 1'( __const__n ) };
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_FLUSH ) ) begin
      cs0 = { 26'( __const__wben_dty_at_cs_table_M0 ), 1'd0, 1'd0, 1'( __const__wr ), __tmpvar__cs_table_M0_flush, 1'd1, 1'd1, 1'( __const__y ) };
    end
    ctrl.tag_array_wben_M0 = cs0[6'd34:6'd9];
    ctrl.wdata_mux_sel_M0 = cs0[6'd8:6'd8];
    ctrl.addr_mux_sel_M0 = cs0[6'd7:6'd7];
    ctrl.tag_array_type_M0 = cs0[6'd6:6'd6];
    ctrl.update_tag_cmd_M0 = cs0[6'd5:6'd3];
    ctrl.tag_array_idx_sel_M0 = cs0[6'd2:6'd2];
    ctrl.update_tag_sel_M0 = cs0[6'd1:6'd1];
    ctrl.MSHR_dealloc_en = cs0[6'd0:6'd0] & ( ~stall_M0 );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:595
  // @update
  // def cs_table_M1():
  //   none = WriteBitEnGen_CMD_NONE
  //   req  = WriteBitEnGen_CMD_REQ
  //   dty  = WriteBitEnGen_CMD_DIRTY
  //   flush = s.has_flush_sent_M1_bypass
  //   #                                                                wben |ty |val    |ostall|evict mux|alloc_en
  //   s.cs1                                                 @= concat( none, x , n,      n,     b1(0),    n       )
  //   if   s.trans_M1.out == TRANS_TYPE_INVALID:      s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_CACHE_INIT:   s.cs1 @= concat(  dty, wr, y,      n,     b1(1),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_REFILL:       s.cs1 @= concat(  dty, wr, y,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_REPLAY_READ:  s.cs1 @= concat( none, rd, y,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_REPLAY_WRITE: s.cs1 @= concat(  req, wr, y,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_REPLAY_AMO:   s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_REPLAY_INV:   s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_CLEAN_HIT:    s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.is_evict_M1:                             s.cs1 @= concat( none, rd, y,      y,     b1(1),    y       )
  //   elif s.trans_M1.out == TRANS_TYPE_INIT_REQ:     s.cs1 @= concat(  req, wr, y,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_AMO_REQ:      s.cs1 @= concat( none, x , n,      n,     b1(0),    y       )
  //   elif s.trans_M1.out == TRANS_TYPE_INV_START:    s.cs1 @= concat( none, x , n,      n,     b1(0),    y       )
  //   elif s.trans_M1.out == TRANS_TYPE_INV_WRITE:    s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_FLUSH_START:  s.cs1 @= concat( none, x , n,      n,     b1(0),    y       )
  //   elif s.trans_M1.out == TRANS_TYPE_FLUSH_READ:   s.cs1 @= concat( none, rd, flush,  n,     b1(1),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_FLUSH_WAIT:   s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_FLUSH_WRITE:  s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif s.trans_M1.out == TRANS_TYPE_REPLAY_FLUSH: s.cs1 @= concat( none, x , n,      n,     b1(0),    n       )
  //   elif ~s.hit_M1:                                 s.cs1 @= concat( none, x , n,      n,     b1(0),    y       )
  //   elif s.hit_M1:
  //     if   s.trans_M1.out == TRANS_TYPE_READ_REQ:   s.cs1 @= concat( none, rd, y,      n,     b1(0),    n       )
  //     elif s.trans_M1.out == TRANS_TYPE_WRITE_REQ:  s.cs1 @= concat(  req, wr, y,      n,     b1(0),    n       )
  // 
  //   s.ctrl.wben_cmd_M1        @= s.cs1[ CS_data_array_wben_M1 ]
  //   s.ctrl.data_array_type_M1 @= s.cs1[ CS_data_array_type_M1 ]
  //   s.ctrl.data_array_val_M1  @= s.cs1[ CS_data_array_val_M1  ]
  //   s.ostall_M1               @= s.cs1[ CS_ostall_M1          ]
  //   s.ctrl.evict_mux_sel_M1   @= s.cs1[ CS_evict_mux_sel_M1   ]
  //   s.ctrl.MSHR_alloc_en      @= s.cs1[ CS_MSHR_alloc_en      ] & ~s.stall_M1
  
  always_comb begin : cs_table_M1
    __tmpvar__cs_table_M1_none = 2'( __const__WriteBitEnGen_CMD_NONE );
    __tmpvar__cs_table_M1_req = 2'( __const__WriteBitEnGen_CMD_REQ );
    __tmpvar__cs_table_M1_dty = 2'( __const__WriteBitEnGen_CMD_DIRTY );
    __tmpvar__cs_table_M1_flush = has_flush_sent_M1_bypass;
    cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    if ( trans_M1__out == 5'( __const__TRANS_TYPE_INVALID ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_CACHE_INIT ) ) begin
      cs1 = { __tmpvar__cs_table_M1_dty, 1'( __const__wr ), 1'( __const__y ), 1'( __const__n ), 1'd1, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_REFILL ) ) begin
      cs1 = { __tmpvar__cs_table_M1_dty, 1'( __const__wr ), 1'( __const__y ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_READ ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__rd ), 1'( __const__y ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_WRITE ) ) begin
      cs1 = { __tmpvar__cs_table_M1_req, 1'( __const__wr ), 1'( __const__y ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_AMO ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_INV ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_CLEAN_HIT ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( is_evict_M1 ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__rd ), 1'( __const__y ), 1'( __const__y ), 1'd1, 1'( __const__y ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_INIT_REQ ) ) begin
      cs1 = { __tmpvar__cs_table_M1_req, 1'( __const__wr ), 1'( __const__y ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_AMO_REQ ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__y ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_INV_START ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__y ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_INV_WRITE ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_START ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__y ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__rd ), __tmpvar__cs_table_M1_flush, 1'( __const__n ), 1'd1, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_WAIT ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_WRITE ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_REPLAY_FLUSH ) ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
    end
    else if ( ~hit_M1 ) begin
      cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__x ), 1'( __const__n ), 1'( __const__n ), 1'd0, 1'( __const__y ) };
    end
    else if ( hit_M1 ) begin
      if ( trans_M1__out == 5'( __const__TRANS_TYPE_READ_REQ ) ) begin
        cs1 = { __tmpvar__cs_table_M1_none, 1'( __const__rd ), 1'( __const__y ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
      end
      else if ( trans_M1__out == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) begin
        cs1 = { __tmpvar__cs_table_M1_req, 1'( __const__wr ), 1'( __const__y ), 1'( __const__n ), 1'd0, 1'( __const__n ) };
      end
    end
    ctrl.wben_cmd_M1 = cs1[3'd6:3'd5];
    ctrl.data_array_type_M1 = cs1[3'd4:3'd4];
    ctrl.data_array_val_M1 = cs1[3'd3:3'd3];
    ostall_M1 = cs1[3'd2:3'd2];
    ctrl.evict_mux_sel_M1 = cs1[3'd1:3'd1];
    ctrl.MSHR_alloc_en = cs1[3'd0:3'd0] & ( ~stall_M1 );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:698
  // @update
  // def cs_table_M2():
  //   flush = s.has_flush_sent_M2.out
  //   fl_sel = b1(0) if flush else b1(1)
  //   #                                                                dsize_en|rdata_mux|ostall|memreq_type|memreq|cacheresp
  //   s.cs2                                                 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   if   s.trans_M2.out == TRANS_TYPE_INVALID:      s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_CACHE_INIT:   s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_INV_START:    s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_INV_WRITE:    s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_CLEAN_HIT:    s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_FLUSH_START:  s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_FLUSH_WAIT:   s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_FLUSH_WRITE:  s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     n        )
  //   elif ~s.memreq_rdy|~s.cacheresp_rdy:            s.cs2 @= concat( n,       b1(1),    y,     READ,       n,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_FLUSH_READ:   s.cs2 @= concat( n,      fl_sel,    n,     WRITE,      flush, n        )
  //   elif s.is_evict_M2.out:                         s.cs2 @= concat( n,       b1(0),    n,     WRITE,      y,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_REPLAY_READ:  s.cs2 @= concat( y,       b1(0),    n,     READ,       n,     y        )
  //   elif s.trans_M2.out == TRANS_TYPE_REPLAY_WRITE: s.cs2 @= concat( n,       b1(1),    n,     WRITE,      n,     y        )
  //   elif s.trans_M2.out == TRANS_TYPE_REPLAY_AMO:   s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     y        )
  //   elif s.trans_M2.out == TRANS_TYPE_REPLAY_INV:   s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     y        )
  //   elif s.trans_M2.out == TRANS_TYPE_REPLAY_FLUSH: s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     y        )
  //   elif s.trans_M2.out == TRANS_TYPE_INIT_REQ:     s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     y        )
  //   elif s.trans_M2.out == TRANS_TYPE_AMO_REQ:      s.cs2 @= concat( n,       b1(1),    n,     AMO,        y,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_READ_REQ:
  //     if    s.ctrl.hit_M2[0]:                       s.cs2 @= concat( y,       b1(0),    n,     READ,       n,     y        )
  //     elif ~s.ctrl.hit_M2[0]:                       s.cs2 @= concat( n,       b1(1),    n,     READ,       y,     n        )
  //   elif s.trans_M2.out == TRANS_TYPE_WRITE_REQ:
  //     if  s.ctrl.hit_M2[0]:                         s.cs2 @= concat( n,       b1(1),    n,     READ,       n,     y        )
  //     elif ~s.ctrl.hit_M2[0]:                       s.cs2 @= concat( n,       b1(1),    n,     READ,       y,     n        )
  // 
  //   s.ctrl.data_size_mux_en_M2  @= s.cs2[ CS_data_size_mux_en_M2  ]
  //   s.ctrl.read_data_mux_sel_M2 @= s.cs2[ CS_read_data_mux_sel_M2 ]
  //   s.ostall_M2                 @= s.cs2[ CS_ostall_M2            ]
  //   if s.cs2[ CS_memreq_type ] >= AMO:
  //     s.ctrl.memreq_type        @= s.status.cachereq_type_M2
  //   else:
  //     s.ctrl.memreq_type        @= s.cs2[ CS_memreq_type          ]
  //   s.cacheresp_en              @= s.cs2[ CS_cacheresp_en         ]
  //   s.memreq_en                 @= s.cs2[ CS_memreq_en            ]
  
  always_comb begin : cs_table_M2
    __tmpvar__cs_table_M2_flush = has_flush_sent_M2__out;
    __tmpvar__cs_table_M2_fl_sel = __tmpvar__cs_table_M2_flush ? 1'd0 : 1'd1;
    cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    if ( trans_M2__out == 5'( __const__TRANS_TYPE_INVALID ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_CACHE_INIT ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_INV_START ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_INV_WRITE ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_CLEAN_HIT ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_FLUSH_START ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_FLUSH_WAIT ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_FLUSH_WRITE ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( ( ~memreq_rdy ) | ( ~cacheresp_rdy ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__y ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) begin
      cs2 = { 1'( __const__n ), __tmpvar__cs_table_M2_fl_sel, 1'( __const__n ), 4'( __const__WRITE ), __tmpvar__cs_table_M2_flush, 1'( __const__n ) };
    end
    else if ( is_evict_M2__out ) begin
      cs2 = { 1'( __const__n ), 1'd0, 1'( __const__n ), 4'( __const__WRITE ), 1'( __const__y ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_REPLAY_READ ) ) begin
      cs2 = { 1'( __const__y ), 1'd0, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_REPLAY_WRITE ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__WRITE ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_REPLAY_AMO ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_REPLAY_INV ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_REPLAY_FLUSH ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_INIT_REQ ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_AMO_REQ ) ) begin
      cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__AMO ), 1'( __const__y ), 1'( __const__n ) };
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_READ_REQ ) ) begin
      if ( ctrl.hit_M2[1'd0] ) begin
        cs2 = { 1'( __const__y ), 1'd0, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
      end
      else if ( ~ctrl.hit_M2[1'd0] ) begin
        cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__y ), 1'( __const__n ) };
      end
    end
    else if ( trans_M2__out == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) begin
      if ( ctrl.hit_M2[1'd0] ) begin
        cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__n ), 1'( __const__y ) };
      end
      else if ( ~ctrl.hit_M2[1'd0] ) begin
        cs2 = { 1'( __const__n ), 1'd1, 1'( __const__n ), 4'( __const__READ ), 1'( __const__y ), 1'( __const__n ) };
      end
    end
    ctrl.data_size_mux_en_M2 = cs2[4'd8:4'd8];
    ctrl.read_data_mux_sel_M2 = cs2[4'd7:4'd7];
    ostall_M2 = cs2[4'd6:4'd6];
    if ( cs2[4'd5:4'd2] >= 4'( __const__AMO ) ) begin
      ctrl.memreq_type = status.cachereq_type_M2;
    end
    else
      ctrl.memreq_type = cs2[4'd5:4'd2];
    cacheresp_en = cs2[4'd0:4'd0];
    memreq_en = cs2[4'd1:4'd1];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:165
  // @update
  // def fsm_M0_next_state():
  //   s.FSM_state_M0_next @= M0_FSM_STATE_INIT
  //   
  //   if   s.FSM_state_M0.out == M0_FSM_STATE_INIT:
  //     if s.counter_M0.out == 0:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_READY
  //     else:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_INIT
  //   
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_READY:
  //     if s.memresp_val_M0 & ((s.status.MSHR_type == WRITE) | (s.status.MSHR_type == READ)):
  //       # Have valid replays in the MSHR
  //       s.FSM_state_M0_next @= M0_FSM_STATE_REPLAY
  //     elif ( s.status.MSHR_empty & s.cachereq_en ):
  //       if s.status.cachereq_type_M0 == INV:
  //         s.FSM_state_M0_next @= M0_FSM_STATE_INV
  //       elif s.status.cachereq_type_M0 == FLUSH:
  //         s.FSM_state_M0_next @= M0_FSM_STATE_FLUSH
  //       else:
  //         s.FSM_state_M0_next @= M0_FSM_STATE_READY
  //     else:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_READY
  //   
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_INV:
  //     if s.counter_M0.out == 0:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_REPLAY
  //     else:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_INV
  //   
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_REPLAY:
  //     # For flush we need to wait for the final write_ack
  //     if (~s.status.MSHR_empty) & (s.status.MSHR_type == FLUSH):
  //       if s.prev_flush_done_M0:
  //         s.FSM_state_M0_next @= M0_FSM_STATE_READY
  //       else:
  //         s.FSM_state_M0_next @= M0_FSM_STATE_FLUSH_WAIT
  //     # MSHR will be dealloc this cycle
  //     else:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_READY
  //   
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_FLUSH:
  //     if s.has_flush_sent_M1_bypass:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_FLUSH_WAIT
  //     elif s.counter_M0.out == 0:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_REPLAY
  //     else:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_FLUSH
  //   
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_FLUSH_WAIT:
  //     if s.memresp_wr_ack_M0:
  //       if s.counter_M0.out == trunc(Bits32(p.total_num_cachelines - 1), p.bitwidth_num_lines):
  //         s.FSM_state_M0_next @= M0_FSM_STATE_REPLAY
  //       else:
  //         s.FSM_state_M0_next @= M0_FSM_STATE_FLUSH
  //     else:
  //       s.FSM_state_M0_next @= M0_FSM_STATE_FLUSH_WAIT
  
  always_comb begin : fsm_M0_next_state
    FSM_state_M0_next = 3'( __const__M0_FSM_STATE_INIT );
    if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INIT ) ) begin
      if ( counter_M0__out == 8'd0 ) begin
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_READY );
      end
      else
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_INIT );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_READY ) ) begin
      if ( memresp_val_M0 & ( ( status.MSHR_type == 4'( __const__WRITE ) ) | ( status.MSHR_type == 4'( __const__READ ) ) ) ) begin
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_REPLAY );
      end
      else if ( status.MSHR_empty & cachereq_en ) begin
        if ( status.cachereq_type_M0 == 4'( __const__INV ) ) begin
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_INV );
        end
        else if ( status.cachereq_type_M0 == 4'( __const__FLUSH ) ) begin
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_FLUSH );
        end
        else
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_READY );
      end
      else
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_READY );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INV ) ) begin
      if ( counter_M0__out == 8'd0 ) begin
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_REPLAY );
      end
      else
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_INV );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_REPLAY ) ) begin
      if ( ( ~status.MSHR_empty ) & ( status.MSHR_type == 4'( __const__FLUSH ) ) ) begin
        if ( prev_flush_done_M0 ) begin
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_READY );
        end
        else
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_FLUSH_WAIT );
      end
      else
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_READY );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_FLUSH ) ) begin
      if ( has_flush_sent_M1_bypass ) begin
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_FLUSH_WAIT );
      end
      else if ( counter_M0__out == 8'd0 ) begin
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_REPLAY );
      end
      else
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_FLUSH );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_FLUSH_WAIT ) ) begin
      if ( memresp_wr_ack_M0 ) begin
        if ( counter_M0__out == 8'(32'd255) ) begin
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_REPLAY );
        end
        else
          FSM_state_M0_next = 3'( __const__M0_FSM_STATE_FLUSH );
      end
      else
        FSM_state_M0_next = 3'( __const__M0_FSM_STATE_FLUSH_WAIT );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:519
  // @update
  // def status_logic_M1():
  //   s.is_evict_M1       @= n
  //   s.is_dty_M1         @= s.status.ctrl_bit_dty_rd_line_M1[s.status.ctrl_bit_rep_rd_M1]
  //   # Bits for set associative caches
  //   s.repreq_is_hit_M1  @= n
  //   s.repreq_en_M1      @= n
  //   s.repreq_hit_ptr_M1 @= x
  //   s.hit_M1            @= n
  //   s.is_write_hit_clean_M0 @= n
  // 
  //   if ( (s.trans_M1.out == TRANS_TYPE_INIT_REQ) |
  //        (s.trans_M1.out == TRANS_TYPE_WRITE_REQ)|
  //        (s.trans_M1.out == TRANS_TYPE_READ_REQ) ):
  //     s.hit_M1 @= s.status.hit_M1
  //     # if hit, dty bit will come from the way where the hit occured
  //     if s.hit_M1:
  //       s.is_dty_M1 @= s.status.ctrl_bit_dty_rd_word_M1[s.status.hit_way_M1]
  // 
  //     if s.trans_M1.out == TRANS_TYPE_INIT_REQ:
  //       s.repreq_en_M1      @= y
  //       s.repreq_is_hit_M1  @= n
  // 
  //     # Check that we don't have a situation where ~val and dty but we're
  //     # still accessing the same address.
  //     if ~s.status.inval_hit_M1:
  //       # moyang: we are not check s.is_line_valid_M1 because for invalid
  //       # but dirty cache lines (due to cache invalidation), we still need
  //       # to evict them
  //       if ~s.hit_M1 & s.is_dty_M1:
  //         s.is_evict_M1 @= y
  //       elif s.hit_M1 & ~s.is_dty_M1:
  //         if s.trans_M1.out == TRANS_TYPE_WRITE_REQ:
  //           s.is_write_hit_clean_M0 @= y
  // 
  //     if ~s.is_evict_M1:
  //       # Better to update replacement bit right away because we need it
  //       # for nonblocking capability. For blocking, we can also update
  //       # during a refill for misses
  //       s.repreq_en_M1      @= y
  //       s.repreq_hit_ptr_M1 @= s.status.hit_way_M1
  //       s.repreq_is_hit_M1  @= s.hit_M1 | s.status.inval_hit_M1
  // 
  //   elif s.trans_M1.out == TRANS_TYPE_AMO_REQ:
  //     s.hit_M1 @= s.status.hit_M1
  //     s.is_dty_M1 @= s.status.ctrl_bit_dty_rd_line_M1[s.status.hit_way_M1]
  //     s.is_evict_M1 @= s.is_dty_M1 & ( s.hit_M1 | s.status.inval_hit_M1 )
  //     if s.hit_M1 | s.status.inval_hit_M1:
  //       s.repreq_en_M1      @= y
  //       s.repreq_hit_ptr_M1 @= ~s.status.hit_way_M1
  //       s.repreq_is_hit_M1  @= y
  // 
  //   s.ctrl.ctrl_bit_rep_en_M1 @= s.repreq_en_M1 & ~s.stall_M2
  
  always_comb begin : status_logic_M1
    is_evict_M1 = 1'( __const__n );
    is_dty_M1 = status.ctrl_bit_dty_rd_line_M1[status.ctrl_bit_rep_rd_M1];
    repreq_is_hit_M1 = 1'( __const__n );
    repreq_en_M1 = 1'( __const__n );
    repreq_hit_ptr_M1 = 1'( __const__x );
    hit_M1 = 1'( __const__n );
    is_write_hit_clean_M0 = 1'( __const__n );
    if ( ( ( trans_M1__out == 5'( __const__TRANS_TYPE_INIT_REQ ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) ) | ( trans_M1__out == 5'( __const__TRANS_TYPE_READ_REQ ) ) ) begin
      hit_M1 = status.hit_M1;
      if ( hit_M1 ) begin
        is_dty_M1 = status.ctrl_bit_dty_rd_word_M1[status.hit_way_M1];
      end
      if ( trans_M1__out == 5'( __const__TRANS_TYPE_INIT_REQ ) ) begin
        repreq_en_M1 = 1'( __const__y );
        repreq_is_hit_M1 = 1'( __const__n );
      end
      if ( ~status.inval_hit_M1 ) begin
        if ( ( ~hit_M1 ) & is_dty_M1 ) begin
          is_evict_M1 = 1'( __const__y );
        end
        else if ( hit_M1 & ( ~is_dty_M1 ) ) begin
          if ( trans_M1__out == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) begin
            is_write_hit_clean_M0 = 1'( __const__y );
          end
        end
      end
      if ( ~is_evict_M1 ) begin
        repreq_en_M1 = 1'( __const__y );
        repreq_hit_ptr_M1 = status.hit_way_M1;
        repreq_is_hit_M1 = hit_M1 | status.inval_hit_M1;
      end
    end
    else if ( trans_M1__out == 5'( __const__TRANS_TYPE_AMO_REQ ) ) begin
      hit_M1 = status.hit_M1;
      is_dty_M1 = status.ctrl_bit_dty_rd_line_M1[status.hit_way_M1];
      is_evict_M1 = is_dty_M1 & ( hit_M1 | status.inval_hit_M1 );
      if ( hit_M1 | status.inval_hit_M1 ) begin
        repreq_en_M1 = 1'( __const__y );
        repreq_hit_ptr_M1 = ~status.hit_way_M1;
        repreq_is_hit_M1 = 1'( __const__y );
      end
    end
    ctrl.ctrl_bit_rep_en_M1 = repreq_en_M1 & ( ~stall_M2 );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:408
  // @update
  // def tag_array_val_logic_M0():
  //   # Most of the logic is for associativity > 1; should simplify for dmapped
  //   s.ctrl.update_tag_way_M0 @= 0
  //   for i in range(p.associativity):
  //     s.ctrl.tag_array_val_M0[i] @= n # by default all tag arrays accesses are invalid
  //   if ( (s.trans_M0 == TRANS_TYPE_CACHE_INIT) |
  //        (s.trans_M0 == TRANS_TYPE_INV_WRITE) |
  //        (s.trans_M0 == TRANS_TYPE_REPLAY_INV) |
  //        (s.trans_M0 == TRANS_TYPE_FLUSH_READ) |
  //        (s.trans_M0 == TRANS_TYPE_FLUSH_WRITE) |
  //        (s.trans_M0 == TRANS_TYPE_REPLAY_FLUSH) ):
  //     # use lower bits of the counter to select ways
  //     for i in range(p.associativity):
  //       if s.update_way_idx_M0 % p.associativity == i:
  //         s.ctrl.tag_array_val_M0[i] @= y
  //         s.ctrl.update_tag_way_M0 @= i
  //   elif ( (s.trans_M0 == TRANS_TYPE_REFILL) |
  //          (s.trans_M0 == TRANS_TYPE_REPLAY_WRITE) ):
  //     s.ctrl.tag_array_val_M0[s.status.MSHR_ptr] @= y
  //   elif (s.trans_M0 == TRANS_TYPE_REPLAY_AMO) & (s.status.amo_hit_M0):
  //     s.ctrl.tag_array_val_M0[s.status.MSHR_ptr] @= y
  //   elif s.trans_M0 == TRANS_TYPE_INIT_REQ:
  //     s.ctrl.tag_array_val_M0[s.status.ctrl_bit_rep_rd_M1] @= y
  //   elif s.trans_M0 == TRANS_TYPE_CLEAN_HIT:
  //     s.ctrl.tag_array_val_M0[s.status.hit_way_M1] @= y
  //   elif ( (s.trans_M0 == TRANS_TYPE_READ_REQ) |
  //          (s.trans_M0 == TRANS_TYPE_WRITE_REQ) |
  //          (s.trans_M0 == TRANS_TYPE_AMO_REQ) ):
  //     for i in range(p.associativity):
  //       s.ctrl.tag_array_val_M0[i] @= y # Enable all SRAMs since we are reading
  
  always_comb begin : tag_array_val_logic_M0
    ctrl.update_tag_way_M0 = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      ctrl.tag_array_val_M0[1'(i)] = 1'( __const__n );
    if ( ( ( ( ( ( trans_M0 == 5'( __const__TRANS_TYPE_CACHE_INIT ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_INV_WRITE ) ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_INV ) ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_WRITE ) ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_FLUSH ) ) ) begin
      for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
        if ( ( update_way_idx_M0 % 8'd2 ) == 8'(i) ) begin
          ctrl.tag_array_val_M0[1'(i)] = 1'( __const__y );
          ctrl.update_tag_way_M0 = 1'(i);
        end
    end
    else if ( ( trans_M0 == 5'( __const__TRANS_TYPE_REFILL ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_WRITE ) ) ) begin
      ctrl.tag_array_val_M0[status.MSHR_ptr] = 1'( __const__y );
    end
    else if ( ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_AMO ) ) & status.amo_hit_M0 ) begin
      ctrl.tag_array_val_M0[status.MSHR_ptr] = 1'( __const__y );
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_INIT_REQ ) ) begin
      ctrl.tag_array_val_M0[status.ctrl_bit_rep_rd_M1] = 1'( __const__y );
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_CLEAN_HIT ) ) begin
      ctrl.tag_array_val_M0[status.hit_way_M1] = 1'( __const__y );
    end
    else if ( ( ( trans_M0 == 5'( __const__TRANS_TYPE_READ_REQ ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_WRITE_REQ ) ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_AMO_REQ ) ) ) begin
      for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
        ctrl.tag_array_val_M0[1'(i)] = 1'( __const__y );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:231
  // @update
  // def transaction_logic_M0():
  //   s.trans_M0 @= TRANS_TYPE_INVALID
  //   if s.FSM_state_M0.out == M0_FSM_STATE_INIT:
  //     s.trans_M0 @= TRANS_TYPE_CACHE_INIT
  //   elif s.is_write_hit_clean_M0:
  //     s.trans_M0 @= TRANS_TYPE_CLEAN_HIT
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_REPLAY:
  //     if (~s.status.MSHR_empty) & (s.status.MSHR_type == WRITE):
  //       s.trans_M0 @= TRANS_TYPE_REPLAY_WRITE
  //     elif (~s.status.MSHR_empty) & (s.status.MSHR_type == READ):
  //       s.trans_M0 @= TRANS_TYPE_REPLAY_READ
  //     elif (~s.status.MSHR_empty) & (s.status.MSHR_type == INV):
  //       s.trans_M0 @= TRANS_TYPE_REPLAY_INV
  //     elif (~s.status.MSHR_empty) & (s.status.MSHR_type == FLUSH):
  //       if s.prev_flush_done_M0:
  //         s.trans_M0 @= TRANS_TYPE_REPLAY_FLUSH
  //       else:
  //         s.trans_M0 @= TRANS_TYPE_FLUSH_WAIT
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_INV:
  //     s.trans_M0 @= TRANS_TYPE_INV_WRITE
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_FLUSH:
  //     if s.has_flush_sent_M1_bypass:
  //       s.trans_M0 @= TRANS_TYPE_FLUSH_WAIT
  //     else:
  //       s.trans_M0 @= TRANS_TYPE_FLUSH_READ
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_FLUSH_WAIT:
  //     if s.memresp_wr_ack_M0:
  //       s.trans_M0 @= TRANS_TYPE_FLUSH_WRITE
  //     else:
  //       s.trans_M0 @= TRANS_TYPE_FLUSH_WAIT
  //   elif s.FSM_state_M0.out == M0_FSM_STATE_READY:
  //     if s.memresp_val_M0 & (~s.status.MSHR_empty):
  //       if (s.status.MSHR_type == WRITE) | (s.status.MSHR_type == READ):
  //         s.trans_M0 @= TRANS_TYPE_REFILL
  //       elif ( (s.status.MSHR_type >= AMO_ADD) &
  //              (s.status.MSHR_type <  INV) ):
  //         s.trans_M0 @= TRANS_TYPE_REPLAY_AMO
  // 
  //     elif s.status.MSHR_empty & s.cachereq_en:
  //       # Request from s.cachereq, not MSHR
  //       if s.status.cachereq_type_M0 == INIT:
  //         s.trans_M0 @= TRANS_TYPE_INIT_REQ
  //       elif s.status.cachereq_type_M0 == READ:
  //         s.trans_M0 @= TRANS_TYPE_READ_REQ
  //       elif s.status.cachereq_type_M0 == WRITE:
  //         s.trans_M0 @= TRANS_TYPE_WRITE_REQ
  //       elif ( (s.status.cachereq_type_M0 >= AMO_ADD) &
  //              (s.status.cachereq_type_M0 < INV) ):
  //         s.trans_M0 @= TRANS_TYPE_AMO_REQ
  //       elif s.status.cachereq_type_M0 == INV:
  //         s.trans_M0 @= TRANS_TYPE_INV_START
  //       elif s.status.cachereq_type_M0 == FLUSH:
  //         s.trans_M0 @= TRANS_TYPE_FLUSH_START
  
  always_comb begin : transaction_logic_M0
    trans_M0 = 5'( __const__TRANS_TYPE_INVALID );
    if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INIT ) ) begin
      trans_M0 = 5'( __const__TRANS_TYPE_CACHE_INIT );
    end
    else if ( is_write_hit_clean_M0 ) begin
      trans_M0 = 5'( __const__TRANS_TYPE_CLEAN_HIT );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_REPLAY ) ) begin
      if ( ( ~status.MSHR_empty ) & ( status.MSHR_type == 4'( __const__WRITE ) ) ) begin
        trans_M0 = 5'( __const__TRANS_TYPE_REPLAY_WRITE );
      end
      else if ( ( ~status.MSHR_empty ) & ( status.MSHR_type == 4'( __const__READ ) ) ) begin
        trans_M0 = 5'( __const__TRANS_TYPE_REPLAY_READ );
      end
      else if ( ( ~status.MSHR_empty ) & ( status.MSHR_type == 4'( __const__INV ) ) ) begin
        trans_M0 = 5'( __const__TRANS_TYPE_REPLAY_INV );
      end
      else if ( ( ~status.MSHR_empty ) & ( status.MSHR_type == 4'( __const__FLUSH ) ) ) begin
        if ( prev_flush_done_M0 ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_REPLAY_FLUSH );
        end
        else
          trans_M0 = 5'( __const__TRANS_TYPE_FLUSH_WAIT );
      end
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INV ) ) begin
      trans_M0 = 5'( __const__TRANS_TYPE_INV_WRITE );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_FLUSH ) ) begin
      if ( has_flush_sent_M1_bypass ) begin
        trans_M0 = 5'( __const__TRANS_TYPE_FLUSH_WAIT );
      end
      else
        trans_M0 = 5'( __const__TRANS_TYPE_FLUSH_READ );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_FLUSH_WAIT ) ) begin
      if ( memresp_wr_ack_M0 ) begin
        trans_M0 = 5'( __const__TRANS_TYPE_FLUSH_WRITE );
      end
      else
        trans_M0 = 5'( __const__TRANS_TYPE_FLUSH_WAIT );
    end
    else if ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_READY ) ) begin
      if ( memresp_val_M0 & ( ~status.MSHR_empty ) ) begin
        if ( ( status.MSHR_type == 4'( __const__WRITE ) ) | ( status.MSHR_type == 4'( __const__READ ) ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_REFILL );
        end
        else if ( ( status.MSHR_type >= 4'( __const__AMO_ADD ) ) & ( status.MSHR_type < 4'( __const__INV ) ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_REPLAY_AMO );
        end
      end
      else if ( status.MSHR_empty & cachereq_en ) begin
        if ( status.cachereq_type_M0 == 4'( __const__INIT ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_INIT_REQ );
        end
        else if ( status.cachereq_type_M0 == 4'( __const__READ ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_READ_REQ );
        end
        else if ( status.cachereq_type_M0 == 4'( __const__WRITE ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_WRITE_REQ );
        end
        else if ( ( status.cachereq_type_M0 >= 4'( __const__AMO_ADD ) ) & ( status.cachereq_type_M0 < 4'( __const__INV ) ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_AMO_REQ );
        end
        else if ( status.cachereq_type_M0 == 4'( __const__INV ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_INV_START );
        end
        else if ( status.cachereq_type_M0 == 4'( __const__FLUSH ) ) begin
          trans_M0 = 5'( __const__TRANS_TYPE_FLUSH_START );
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:288
  // @update
  // def up_counter_en_logic_M0():
  //   s.counter_en_M0 @= 0
  //   if ( (s.FSM_state_M0.out == M0_FSM_STATE_INIT) |
  //        (s.FSM_state_M0.out == M0_FSM_STATE_INV) ):
  //     s.counter_en_M0 @= 1
  //   elif s.trans_M0 == TRANS_TYPE_FLUSH_READ:
  //     s.counter_en_M0 @= 1
  
  always_comb begin : up_counter_en_logic_M0
    counter_en_M0 = 1'd0;
    if ( ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INIT ) ) | ( FSM_state_M0__out == 3'( __const__M0_FSM_STATE_INV ) ) ) begin
      counter_en_M0 = 1'd1;
    end
    else if ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) begin
      counter_en_M0 = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:502
  // @update
  // def up_flush_tag_read_logic_M1():
  //   s.no_flush_needed_M1_bypass @= 0
  //   s.has_flush_sent_M1_bypass  @= 0
  //   if s.trans_M1.out == TRANS_TYPE_FLUSH_READ:
  //     if s.status.ctrl_bit_dty_rd_line_M1[ s.update_tag_way_M1.out ]:
  //       s.no_flush_needed_M1_bypass @= 0
  //       s.has_flush_sent_M1_bypass  @= 1
  //     else:
  //       s.no_flush_needed_M1_bypass @= 1
  //       s.has_flush_sent_M1_bypass  @= 0
  
  always_comb begin : up_flush_tag_read_logic_M1
    no_flush_needed_M1_bypass = 1'd0;
    has_flush_sent_M1_bypass = 1'd0;
    if ( trans_M1__out == 5'( __const__TRANS_TYPE_FLUSH_READ ) ) begin
      if ( status.ctrl_bit_dty_rd_line_M1[update_tag_way_M1__out] ) begin
        no_flush_needed_M1_bypass = 1'd0;
        has_flush_sent_M1_bypass = 1'd1;
      end
      else begin
        no_flush_needed_M1_bypass = 1'd1;
        has_flush_sent_M1_bypass = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheCtrlRTL.py:302
  // @update
  // def update_way_idx_M0_loigc():
  //   s.update_way_idx_M0 @= s.counter_M0.out
  //   if ( ( s.trans_M0 == TRANS_TYPE_FLUSH_WRITE ) |
  //        ( s.trans_M0 == TRANS_TYPE_REPLAY_FLUSH ) ):
  //     s.update_way_idx_M0 @= s.counter_M0.out + 1
  
  always_comb begin : update_way_idx_M0_loigc
    update_way_idx_M0 = counter_M0__out;
    if ( ( trans_M0 == 5'( __const__TRANS_TYPE_FLUSH_WRITE ) ) | ( trans_M0 == 5'( __const__TRANS_TYPE_REPLAY_FLUSH ) ) ) begin
      update_way_idx_M0 = counter_M0__out + 8'd1;
    end
  end

  assign memresp_rdy = 1'd1;
  assign memresp_en_M0__clk = clk;
  assign memresp_en_M0__reset = reset;
  assign memresp_en_M0__in_ = memresp_en;
  assign memresp_en_M0__en = ctrl.reg_en_M0;
  assign counter_M0__clk = clk;
  assign counter_M0__reset = reset;
  assign FSM_state_M0__clk = clk;
  assign FSM_state_M0__reset = reset;
  assign FSM_state_M0__in_ = FSM_state_M0_next;
  assign FSM_state_M0__en = ctrl.reg_en_M0;
  assign counter_M0__count_down = 1'd1;
  assign trans_M1__clk = clk;
  assign trans_M1__reset = reset;
  assign trans_M1__in_ = trans_M0;
  assign trans_M1__en = ctrl_pipeline_reg_en_M1;
  assign way_ptr_M1__clk = clk;
  assign way_ptr_M1__reset = reset;
  assign way_ptr_M1__in_ = status.MSHR_ptr;
  assign way_ptr_M1__en = ctrl_pipeline_reg_en_M1;
  assign update_tag_way_M1__clk = clk;
  assign update_tag_way_M1__reset = reset;
  assign update_tag_way_M1__in_ = ctrl.update_tag_way_M0;
  assign update_tag_way_M1__en = ctrl_pipeline_reg_en_M1;
  assign replacement_M1__clk = clk;
  assign replacement_M1__reset = reset;
  assign replacement_M1__repreq_en = repreq_en_M1;
  assign replacement_M1__repreq_hit_ptr = repreq_hit_ptr_M1;
  assign replacement_M1__repreq_is_hit = repreq_is_hit_M1;
  assign replacement_M1__repreq_ptr = status.ctrl_bit_rep_rd_M1;
  assign ctrl.ctrl_bit_rep_wr_M0 = replacement_M1__represp_ptr;
  assign was_stalled__clk = clk;
  assign was_stalled__reset = reset;
  assign was_stalled__in_ = ostall_M2;
  assign trans_M2__clk = clk;
  assign trans_M2__reset = reset;
  assign trans_M2__in_ = trans_M1__out;
  assign trans_M2__en = ctrl_pipeline_reg_en_M2;
  assign is_evict_M2__clk = clk;
  assign is_evict_M2__reset = reset;
  assign is_evict_M2__in_ = is_evict_M1;
  assign is_evict_M2__en = ctrl_pipeline_reg_en_M2;
  assign evict_bypass = is_evict_M2__out;
  assign hit_reg_M2__clk = clk;
  assign hit_reg_M2__reset = reset;
  assign hit_reg_M2__in_ = hit_M1;
  assign hit_reg_M2__en = ctrl_pipeline_reg_en_M2;
  assign ctrl.hit_M2[0:0] = hit_reg_M2__out;
  assign has_flush_sent_M2__clk = clk;
  assign has_flush_sent_M2__reset = reset;
  assign has_flush_sent_M2__in_ = has_flush_sent_M1_bypass;
  assign has_flush_sent_M2__en = ctrl_pipeline_reg_en_M2;
  assign stall_M2 = ostall_M2;
  assign ctrl.hit_M2[1:1] = 1'd0;

endmodule


// PyMTL Component WriteBitEnGen Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py

module WriteBitEnGen__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] clk ,
  input  logic [1:0] cmd ,
  input  logic [3:0] dty_mask ,
  input  logic [1:0] len_ ,
  input  logic [3:0] offset ,
  output logic [127:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__WriteBitEnGen_CMD_REQ  = 2'd1;
  localparam logic [1:0] __const__WriteBitEnGen_CMD_DIRTY  = 2'd2;
  logic [15:0] shifted;
  logic [127:0] wben_dirty;
  logic [127:0] wben_req;
  logic [15:0] word_mask;
  logic [3:0] __tmpvar__wben_shift_logic_i_byte;
  logic [1:0] __tmpvar__wben_shift_logic_i_mask;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:201
  // s.shifted //= lambda: s.word_mask << zext(s.offset, bitwidth_nbyte)
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_WbenGen_M1_shifted
    shifted = word_mask << { { 12 { 1'b0 } }, offset };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:218
  // @update
  // def output_logic():
  //   if s.cmd == WriteBitEnGen_CMD_REQ:
  //     # if this is a write request, then the wben depends on offset
  //     s.out @= s.wben_req
  //   elif s.cmd == WriteBitEnGen_CMD_DIRTY:
  //     # we are refilling, then the wben depends on the dirty bits
  //     s.out @= s.wben_dirty
  //   else: # s.cmd == WriteBitEnGen_CMD_NONE
  //     s.out @= 0
  
  always_comb begin : output_logic
    if ( cmd == 2'( __const__WriteBitEnGen_CMD_REQ ) ) begin
      out = wben_req;
    end
    else if ( cmd == 2'( __const__WriteBitEnGen_CMD_DIRTY ) ) begin
      out = wben_dirty;
    end
    else
      out = 128'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:177
  // @update
  // def req_word_mask_logic():
  //   # Take advantage of bitwidth truncation to select word mask depending on
  //   # the data bitwidth
  //   if s.len_ == 1:
  //     s.word_mask @= 0b1
  //   elif s.len_ == 2: # assuming that data bitwidth >= 32
  //     s.word_mask @= 0b11
  //   elif s.len_ == 3:
  //     # moyang: this is a hack for CIFER project. When len == 3, we zero-extend the 32-bit word to 64-bit
  //     s.word_mask @= 0b11111111
  //   elif s.len_ == trunc(Bits32(4), p.bitwidth_len):
  //     # truncated to 0 if 32 bit data
  //     s.word_mask @= 0b1111
  //   elif s.len_ == trunc(Bits32(8), p.bitwidth_len):
  //     # truncated to 0 if 64 bit data
  //     s.word_mask @= 0b11111111
  //   elif s.len_ == trunc(Bits32(16), p.bitwidth_len):
  //     # truncated to 0 if 128 bit data
  //     s.word_mask @= 0xffff
  //   else:
  //     s.word_mask @= 0
  
  always_comb begin : req_word_mask_logic
    if ( len_ == 2'd1 ) begin
      word_mask = 16'd1;
    end
    else if ( len_ == 2'd2 ) begin
      word_mask = 16'd3;
    end
    else if ( len_ == 2'd3 ) begin
      word_mask = 16'd255;
    end
    else if ( len_ == 2'(32'd4) ) begin
      word_mask = 16'd15;
    end
    else if ( len_ == 2'(32'd8) ) begin
      word_mask = 16'd255;
    end
    else if ( len_ == 2'(32'd16) ) begin
      word_mask = 16'd65535;
    end
    else
      word_mask = 16'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:208
  // @update
  // def wben_shift_logic():
  //   # Map byte access to bits access mask:
  //   # ex: 0x1 -> 0xff
  //   for i in range( p.bitwidth_data_wben ):
  //     i_byte = trunc(Bits32(i >> 3), bitwidth_clog_nbyte)
  //     i_mask = trunc(Bits32(i >> 5), bitwidth_clog_dirty)
  //     s.wben_req[i]   @= s.shifted[ i_byte ]
  //     s.wben_dirty[i] @= ~(s.dty_mask[ i_mask ])
  
  always_comb begin : wben_shift_logic
    for ( int unsigned i = 1'd0; i < 8'd128; i += 1'd1 ) begin
      __tmpvar__wben_shift_logic_i_byte = 4'(32'( 7'(i) >> 2'd3 ));
      __tmpvar__wben_shift_logic_i_mask = 2'(32'( 7'(i) >> 3'd5 ));
      wben_req[7'(i)] = shifted[__tmpvar__wben_shift_logic_i_byte];
      wben_dirty[7'(i)] = ~dty_mask[__tmpvar__wben_shift_logic_i_mask];
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_32__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:1],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEnRst Definition
// Full name: RegEnRst__Type_StructDpathPipeline_128_2__f3cfe859759af9fc__reset_value_rd:00:000000:00:0:0:00000000000000000000000000000000
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__2b7c680d98a49c34
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  StructDpathPipeline_128_2__f3cfe859759af9fc in_ ,
  output StructDpathPipeline_128_2__f3cfe859759af9fc out ,
  input  logic [0:0] reset 
);
  localparam StructDpathPipeline_128_2__f3cfe859759af9fc __const__reset_value_at_up_regenrst  = { 4'd0, 8'd0, { 21'd0, 7'd0, 4'd0 }, 2'd0, 128'd0 };

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 174'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32__ninputs_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__c4fd530f829680a2
(
  input  logic [0:0] clk ,
  input  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 in_ [0:1],
  output MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component SramGenericPRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py

module SramGenericPRTL__num_bits_128__num_words_256
(
  input  logic [7:0] A1 ,
  input  logic [0:0] CE1 ,
  input  logic [0:0] CSB1 ,
  input  logic [127:0] I1 ,
  output logic [127:0] O1 ,
  input  logic [0:0] OEB1 ,
  input  logic [127:0] WBM1 ,
  input  logic [0:0] WEB1 ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset 
);
  localparam logic [8:0] __const__num_words_at_write_logic  = 9'd256;
  localparam logic [7:0] __const__num_bits_at_write_logic  = 8'd128;
  localparam logic [8:0] __const__num_words_at_update_sram  = 9'd256;
  logic [127:0] dout;
  logic [127:0] dout_next;
  logic [127:0] ram [0:255];
  logic [127:0] ram_next [0:255];

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:54
  // @update
  // def comb_logic():
  //   s.O1 @= s.dout if ~s.OEB1 else 0
  
  always_comb begin : comb_logic
    O1 = ( ~OEB1 ) ? dout : 128'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:41
  // @update
  // def read_logic():
  //   s.dout_next @= s.ram[ s.A1 ] if (~s.CSB1 & s.WEB1) else s.dout
  
  always_comb begin : read_logic
    dout_next = ( ( ~CSB1 ) & WEB1 ) ? ram[A1] : dout;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:46
  // @update
  // def write_logic():
  //   for i in range( num_words ):
  //     s.ram_next[i] @= s.ram[i]
  //   for i in range( num_bits ):
  //     if ~s.CSB1 & ~s.WEB1 & s.WBM1[i]:
  //       s.ram_next[s.A1][i] @= s.I1[i]
  
  always_comb begin : write_logic
    for ( int unsigned i = 1'd0; i < 9'( __const__num_words_at_write_logic ); i += 1'd1 )
      ram_next[8'(i)] = ram[8'(i)];
    for ( int unsigned i = 1'd0; i < 8'( __const__num_bits_at_write_logic ); i += 1'd1 )
      if ( ( ( ~CSB1 ) & ( ~WEB1 ) ) & WBM1[7'(i)] ) begin
        ram_next[A1][7'(i)] = I1[7'(i)];
      end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:58
  // @update_ff
  // def update_sram():
  //   s.dout <<= s.dout_next
  //   for i in range( num_words ):
  //     s.ram[i] <<= s.ram_next[i]
  
  always_ff @(posedge clk) begin : update_sram
    dout <= dout_next;
    for ( int unsigned i = 1'd0; i < 9'( __const__num_words_at_update_sram ); i += 1'd1 )
      ram[8'(i)] <= ram_next[8'(i)];
  end

endmodule


// PyMTL Component SramPRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramPRTL.py

module SramPRTL__num_bits_128__num_words_256
(
  input  logic [0:0] clk ,
  input  logic [7:0] port0_idx ,
  output logic [127:0] port0_rdata ,
  input  logic [0:0] port0_type ,
  input  logic [0:0] port0_val ,
  input  logic [127:0] port0_wben ,
  input  logic [127:0] port0_wdata ,
  input  logic [0:0] reset 
);
  logic [0:0] port0_type_bar;
  logic [0:0] port0_val_bar;
  //-------------------------------------------------------------
  // Component sram
  //-------------------------------------------------------------

  logic [7:0] sram__A1;
  logic [0:0] sram__CE1;
  logic [0:0] sram__CSB1;
  logic [127:0] sram__I1;
  logic [127:0] sram__O1;
  logic [0:0] sram__OEB1;
  logic [127:0] sram__WBM1;
  logic [0:0] sram__WEB1;
  logic [0:0] sram__clk;
  logic [0:0] sram__reset;

  SramGenericPRTL #(.num_bits(128) , .num_words(256)) sram
  (
    .A1( sram__A1 ),
    .CE1( sram__CE1 ),
    .CSB1( sram__CSB1 ),
    .I1( sram__I1 ),
    .O1( sram__O1 ),
    .OEB1( sram__OEB1 ),
    .WBM1( sram__WBM1 ),
    .WEB1( sram__WEB1 ),
    .clk( sram__clk ),
    .reset( sram__reset )
  );

  //-------------------------------------------------------------
  // End of component sram
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramPRTL.py:46
  // @update
  // def inverters():
  //   s.port0_val_bar  @= ~s.port0_val
  //   s.port0_type_bar @= ~s.port0_type
  
  always_comb begin : inverters
    port0_val_bar = ~port0_val;
    port0_type_bar = ~port0_type;
  end

  assign sram__clk = clk;
  assign sram__reset = reset;
  assign sram__CE1 = clk;
  assign sram__CSB1 = port0_val_bar;
  assign sram__OEB1 = 1'd0;
  assign sram__WBM1 = port0_wben;
  assign sram__WEB1 = port0_type_bar;
  assign sram__A1 = port0_idx;
  assign sram__I1 = port0_wdata;
  assign port0_rdata = sram__O1;

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_8__ninputs_16
(
  input  logic [0:0] clk ,
  input  logic [7:0] in_ [0:15],
  output logic [7:0] out ,
  input  logic [0:0] reset ,
  input  logic [3:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component FastSubInputMux Definition
// Full name: FastSubInputMux__bitwidth_mux_8__p_BlockingCache_4096_128_32_32_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/muxes.py

module FastSubInputMux__d4a126000fc2355e
(
  input  logic [0:0] clk ,
  input  logic [127:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [3:0] sel 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  logic [7:0] mux__in_ [0:15];
  logic [7:0] mux__out;
  logic [0:0] mux__reset;
  logic [3:0] mux__sel;

  Mux__Type_8__ninputs_16 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__in_[0] = in_[7:0];
  assign mux__in_[1] = in_[15:8];
  assign mux__in_[2] = in_[23:16];
  assign mux__in_[3] = in_[31:24];
  assign mux__in_[4] = in_[39:32];
  assign mux__in_[5] = in_[47:40];
  assign mux__in_[6] = in_[55:48];
  assign mux__in_[7] = in_[63:56];
  assign mux__in_[8] = in_[71:64];
  assign mux__in_[9] = in_[79:72];
  assign mux__in_[10] = in_[87:80];
  assign mux__in_[11] = in_[95:88];
  assign mux__in_[12] = in_[103:96];
  assign mux__in_[13] = in_[111:104];
  assign mux__in_[14] = in_[119:112];
  assign mux__in_[15] = in_[127:120];
  assign out[7:0] = mux__out[7:0];
  assign out[31:8] = 24'd0;
  assign mux__sel = sel[3:0];

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_16__ninputs_8
(
  input  logic [0:0] clk ,
  input  logic [15:0] in_ [0:7],
  output logic [15:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component FastSubInputMux Definition
// Full name: FastSubInputMux__bitwidth_mux_16__p_BlockingCache_4096_128_32_32_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/muxes.py

module FastSubInputMux__2fb1f558461068b7
(
  input  logic [0:0] clk ,
  input  logic [127:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [3:0] sel 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  logic [15:0] mux__in_ [0:7];
  logic [15:0] mux__out;
  logic [0:0] mux__reset;
  logic [2:0] mux__sel;

  Mux__Type_16__ninputs_8 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__in_[0] = in_[15:0];
  assign mux__in_[1] = in_[31:16];
  assign mux__in_[2] = in_[47:32];
  assign mux__in_[3] = in_[63:48];
  assign mux__in_[4] = in_[79:64];
  assign mux__in_[5] = in_[95:80];
  assign mux__in_[6] = in_[111:96];
  assign mux__in_[7] = in_[127:112];
  assign out[15:0] = mux__out[15:0];
  assign out[31:16] = 16'd0;
  assign mux__sel = sel[3:1];

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_32__ninputs_4
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:3],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component FastSubInputMux Definition
// Full name: FastSubInputMux__bitwidth_mux_32__p_BlockingCache_4096_128_32_32_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/muxes.py

module FastSubInputMux__cfaa87c09659bf86
(
  input  logic [0:0] clk ,
  input  logic [127:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [3:0] sel 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  logic [31:0] mux__in_ [0:3];
  logic [31:0] mux__out;
  logic [0:0] mux__reset;
  logic [1:0] mux__sel;

  Mux__Type_32__ninputs_4 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__in_[0] = in_[31:0];
  assign mux__in_[1] = in_[63:32];
  assign mux__in_[2] = in_[95:64];
  assign mux__in_[3] = in_[127:96];
  assign out[31:0] = mux__out[31:0];
  assign mux__sel = sel[3:2];

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_32__ninputs_5
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:4],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component FastDataSelectMux Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/muxes.py

module FastDataSelectMux__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] amo ,
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [127:0] in_ ,
  input  logic [1:0] len_ ,
  input  logic [3:0] offset ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__ninputs_at_output_mux_selection_logic  = 3'd5;
  //-------------------------------------------------------------
  // Component mux_blocks[0:2]
  //-------------------------------------------------------------

  logic [0:0] mux_blocks__clk [0:2];
  logic [127:0] mux_blocks__in_ [0:2];
  logic [31:0] mux_blocks__out [0:2];
  logic [0:0] mux_blocks__reset [0:2];
  logic [3:0] mux_blocks__sel [0:2];

  FastSubInputMux__d4a126000fc2355e mux_blocks__0
  (
    .clk( mux_blocks__clk[0] ),
    .in_( mux_blocks__in_[0] ),
    .out( mux_blocks__out[0] ),
    .reset( mux_blocks__reset[0] ),
    .sel( mux_blocks__sel[0] )
  );

  FastSubInputMux__2fb1f558461068b7 mux_blocks__1
  (
    .clk( mux_blocks__clk[1] ),
    .in_( mux_blocks__in_[1] ),
    .out( mux_blocks__out[1] ),
    .reset( mux_blocks__reset[1] ),
    .sel( mux_blocks__sel[1] )
  );

  FastSubInputMux__cfaa87c09659bf86 mux_blocks__2
  (
    .clk( mux_blocks__clk[2] ),
    .in_( mux_blocks__in_[2] ),
    .out( mux_blocks__out[2] ),
    .reset( mux_blocks__reset[2] ),
    .sel( mux_blocks__sel[2] )
  );

  //-------------------------------------------------------------
  // End of component mux_blocks[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_mux
  //-------------------------------------------------------------

  logic [0:0] output_mux__clk;
  logic [31:0] output_mux__in_ [0:4];
  logic [31:0] output_mux__out;
  logic [0:0] output_mux__reset;
  logic [2:0] output_mux__sel;

  Mux__Type_32__ninputs_5 output_mux
  (
    .clk( output_mux__clk ),
    .in_( output_mux__in_ ),
    .out( output_mux__out ),
    .reset( output_mux__reset ),
    .sel( output_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component output_mux
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/muxes.py:182
  // @update
  // def output_mux_selection_logic():
  //   s.output_mux.sel @= 0
  //   if s.amo:
  //     s.output_mux.sel @= 1
  //   elif ~s.en:
  //     s.output_mux.sel @= 0
  //   else:
  //     if s.len_ == 0:
  //       s.output_mux.sel @= ninputs - 1  
  //     else:
  //       for i in range(ninputs - 3):
  //         if s.len_ == 2**i:
  //           s.output_mux.sel @= BitsSel(i) + 2
  
  always_comb begin : output_mux_selection_logic
    output_mux__sel = 3'd0;
    if ( amo ) begin
      output_mux__sel = 3'd1;
    end
    else if ( ~en ) begin
      output_mux__sel = 3'd0;
    end
    else if ( len_ == 2'd0 ) begin
      output_mux__sel = 3'( __const__ninputs_at_output_mux_selection_logic ) - 3'd1;
    end
    else
      for ( int unsigned i = 1'd0; i < 3'( __const__ninputs_at_output_mux_selection_logic ) - 3'd3; i += 1'd1 )
        if ( len_ == ( 2'd2 ** 2'(i) ) ) begin
          output_mux__sel = 3'( 1'(i) ) + 3'd2;
        end
  end

  assign mux_blocks__clk[0] = clk;
  assign mux_blocks__reset[0] = reset;
  assign mux_blocks__clk[1] = clk;
  assign mux_blocks__reset[1] = reset;
  assign mux_blocks__clk[2] = clk;
  assign mux_blocks__reset[2] = reset;
  assign mux_blocks__in_[0] = in_;
  assign mux_blocks__sel[0] = offset;
  assign mux_blocks__in_[1] = in_;
  assign mux_blocks__sel[1] = offset;
  assign mux_blocks__in_[2] = in_;
  assign mux_blocks__sel[2] = offset;
  assign output_mux__clk = clk;
  assign output_mux__reset = reset;
  assign output_mux__in_[0] = 32'd0;
  assign output_mux__in_[1][31:0] = in_[31:0];
  assign output_mux__in_[2] = mux_blocks__out[0][31:0];
  assign output_mux__in_[3] = mux_blocks__out[1][31:0];
  assign output_mux__in_[4] = mux_blocks__out[2][31:0];
  assign out = output_mux__out;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_4__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_StructAddr_21_7_4__tag_21__index_7__offset_4__ninputs_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__fb9b5ee67e2c4c7c
(
  input  logic [0:0] clk ,
  input  StructAddr_21_7_4__tag_21__index_7__offset_4 in_ [0:1],
  output StructAddr_21_7_4__tag_21__index_7__offset_4 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_21__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [20:0] in_ [0:1],
  output logic [20:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_7__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_7__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [6:0] in_ [0:1],
  output logic [6:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_StructHitInfo_1__hit_1__hit_way_1__ninputs_2
(
  input  logic [0:0] clk ,
  input  StructHitInfo_1__hit_1__hit_way_1 in_ [0:1],
  output StructHitInfo_1__hit_1__hit_way_1 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_StructHitInfo_1__hit_1__hit_way_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  StructHitInfo_1__hit_1__hit_way_1 in_ ,
  output StructHitInfo_1__hit_1__hit_way_1 out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component StallEngine Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/StallEngine.py

module StallEngine__dtype_StructHitInfo_1__hit_1__hit_way_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  StructHitInfo_1__hit_1__hit_way_1 in_ ,
  output StructHitInfo_1__hit_1__hit_way_1 out ,
  input  logic [0:0] reset 
);
  //-------------------------------------------------------------
  // Component stall_mux
  //-------------------------------------------------------------

  logic [0:0] stall_mux__clk;
  StructHitInfo_1__hit_1__hit_way_1 stall_mux__in_ [0:1];
  StructHitInfo_1__hit_1__hit_way_1 stall_mux__out;
  logic [0:0] stall_mux__reset;
  logic [0:0] stall_mux__sel;

  Mux__Type_StructHitInfo_1__hit_1__hit_way_1__ninputs_2 stall_mux
  (
    .clk( stall_mux__clk ),
    .in_( stall_mux__in_ ),
    .out( stall_mux__out ),
    .reset( stall_mux__reset ),
    .sel( stall_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component stall_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component stall_reg
  //-------------------------------------------------------------

  logic [0:0] stall_reg__clk;
  logic [0:0] stall_reg__en;
  StructHitInfo_1__hit_1__hit_way_1 stall_reg__in_;
  StructHitInfo_1__hit_1__hit_way_1 stall_reg__out;
  logic [0:0] stall_reg__reset;

  RegEn__Type_StructHitInfo_1__hit_1__hit_way_1 stall_reg
  (
    .clk( stall_reg__clk ),
    .en( stall_reg__en ),
    .in_( stall_reg__in_ ),
    .out( stall_reg__out ),
    .reset( stall_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component stall_reg
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/StallEngine.py:41
  // m.sel    //= lambda: ~s.en
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_hit_stall_engine_stall_mux_sel
    stall_mux__sel = ~en;
  end

  assign stall_reg__clk = clk;
  assign stall_reg__reset = reset;
  assign stall_reg__en = en;
  assign stall_reg__in_ = in_;
  assign stall_mux__clk = clk;
  assign stall_mux__reset = reset;
  assign stall_mux__in_[0] = in_;
  assign stall_mux__in_[1] = stall_reg__out;
  assign out = stall_mux__out;

endmodule


// PyMTL Component Indexer Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py

module Indexer__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] clk ,
  input  logic [6:0] index ,
  input  logic [0:0] offset ,
  output logic [7:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:106
  // @update
  // def index_logic():
  //   # zero extend the index to the index bitwidth and then apply offset depending
  //   # on which way we want to access. For Dmapped, the offset will always be 0.
  //   s.out @= zext(s.index, p.bitwidth_num_lines) + zext(s.offset, p.bitwidth_num_lines) * \
  //            trunc( Bits32(p.nblocks_per_way), p.bitwidth_num_lines )
  
  always_comb begin : index_logic
    out = { { 1 { 1'b0 } }, index } + ( { { 7 { 1'b0 } }, offset } * 8'(32'd128) );
  end

endmodule


// PyMTL Component OffsetLenSelector Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py

module OffsetLenSelector__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] is_amo ,
  input  logic [1:0] len_i ,
  output logic [3:0] len_o ,
  input  logic [3:0] offset_i ,
  output logic [3:0] offset_o ,
  input  logic [0:0] reset 
);
  logic [3:0] amo_len;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:146
  // @update
  // def offset_selection_logic():
  //   if s.is_amo:
  //     s.offset_o @= s.offset_i
  //     s.len_o    @= s.amo_len # one word read always for len
  //   else:
  //     # Not AMO, the we want full line access where offset doesn't matter
  //     s.offset_o @= 0
  //     s.len_o    @= 0
  
  always_comb begin : offset_selection_logic
    if ( is_amo ) begin
      offset_o = offset_i;
      len_o = amo_len;
    end
    else begin
      offset_o = 4'd0;
      len_o = 4'd0;
    end
  end

  assign amo_len = 4'd4;

endmodule


// PyMTL Component RegEnRst Definition
// Full name: RegEnRst__Type_StructMSHR_32_2__4f9bfcd81ca6f13c__reset_value_rd:00:00000000:0:00000000:0
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__a27e4ad979cbccb7
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  StructMSHR_32_2__4f9bfcd81ca6f13c in_ ,
  output StructMSHR_32_2__4f9bfcd81ca6f13c out ,
  input  logic [0:0] reset 
);
  localparam StructMSHR_32_2__4f9bfcd81ca6f13c __const__reset_value_at_up_regenrst  = { 4'd0, 8'd0, 32'd0, 2'd0, 32'd0, 1'd0, 1'd0, 4'd0 };

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 84'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component MSHR Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/MSHR.py

module MSHR__p_BlockingCache_4096_128_32_32_2__entries_1
(
  input  logic [0:0] alloc_en ,
  output logic [7:0] alloc_id ,
  input  StructMSHR_32_2__4f9bfcd81ca6f13c alloc_in ,
  input  logic [0:0] clk ,
  input  logic [0:0] dealloc_en ,
  input  logic [7:0] dealloc_id ,
  output StructMSHR_32_2__4f9bfcd81ca6f13c dealloc_out ,
  output logic [0:0] empty ,
  output logic [0:0] full ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__entries_at_full_logic  = 1'd1;
  logic [0:0] num_entries_in;
  //-------------------------------------------------------------
  // Component num_entries_reg
  //-------------------------------------------------------------

  logic [0:0] num_entries_reg__clk;
  logic [0:0] num_entries_reg__in_;
  logic [0:0] num_entries_reg__out;
  logic [0:0] num_entries_reg__reset;

  RegRst__Type_1__reset_value_0 num_entries_reg
  (
    .clk( num_entries_reg__clk ),
    .in_( num_entries_reg__in_ ),
    .out( num_entries_reg__out ),
    .reset( num_entries_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component num_entries_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component storage_regs
  //-------------------------------------------------------------

  logic [0:0] storage_regs__clk;
  logic [0:0] storage_regs__en;
  StructMSHR_32_2__4f9bfcd81ca6f13c storage_regs__in_;
  StructMSHR_32_2__4f9bfcd81ca6f13c storage_regs__out;
  logic [0:0] storage_regs__reset;

  RegEnRst__a27e4ad979cbccb7 storage_regs
  (
    .clk( storage_regs__clk ),
    .en( storage_regs__en ),
    .in_( storage_regs__in_ ),
    .out( storage_regs__out ),
    .reset( storage_regs__reset )
  );

  //-------------------------------------------------------------
  // End of component storage_regs
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/MSHR.py:40
  // @update
  // def entry_logic():
  //   if s.alloc_en:    # No parallel alloc/dealloc
  //     s.num_entries_in @= s.num_entries_reg.out + 1
  //   elif s.dealloc_en:
  //     s.num_entries_in @= s.num_entries_reg.out - 1
  //   else:
  //     s.num_entries_in @= s.num_entries_reg.out
  
  always_comb begin : entry_logic
    if ( alloc_en ) begin
      num_entries_in = num_entries_reg__out + 1'd1;
    end
    else if ( dealloc_en ) begin
      num_entries_in = num_entries_reg__out - 1'd1;
    end
    else
      num_entries_in = num_entries_reg__out;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/MSHR.py:49
  // @update
  // def full_logic():
  //   # Considered full if num entries is equal to max entries or if we
  //   # have one less and are allocating an entry
  //   s.full  @= (s.num_entries_reg.out == entries) | ((s.num_entries_reg.out == entries-1) & s.alloc_en)
  //   s.empty @= (s.num_entries_reg.out == 0)
  
  always_comb begin : full_logic
    full = ( num_entries_reg__out == 1'( __const__entries_at_full_logic ) ) | ( ( num_entries_reg__out == ( 1'( __const__entries_at_full_logic ) - 1'd1 ) ) & alloc_en );
    empty = num_entries_reg__out == 1'd0;
  end

  assign num_entries_reg__clk = clk;
  assign num_entries_reg__reset = reset;
  assign num_entries_reg__in_ = num_entries_in;
  assign storage_regs__clk = clk;
  assign storage_regs__reset = reset;
  assign storage_regs__in_ = alloc_in;
  assign dealloc_out = storage_regs__out;
  assign storage_regs__en = alloc_en;
  assign alloc_id = alloc_in.opaque;

endmodule


// PyMTL Component RegEnRst Definition
// Full name: RegEnRst__Type_MemRespMsg_8_128_m1__c72937e2b7853c90__reset_value_rd:00:0:0:0:00000000000000000000000000000000
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__b7ac6c1e2cfbe42d
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  MemRespMsg_8_128_m1__c72937e2b7853c90 in_ ,
  output MemRespMsg_8_128_m1__c72937e2b7853c90 out ,
  input  logic [0:0] reset 
);
  localparam MemRespMsg_8_128_m1__c72937e2b7853c90 __const__reset_value_at_up_regenrst  = { 4'd0, 8'd0, 2'd0, 4'd0, 4'd0, 128'd0 };

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 150'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_128__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [127:0] in_ [0:1],
  output logic [127:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits128__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [127:0] in_ ,
  output logic [127:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 128'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component ReplacementBitsReg Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/registers.py

module ReplacementBitsReg__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] clk ,
  input  logic [6:0] raddr ,
  output logic [0:0] rdata ,
  input  logic [0:0] reset ,
  input  logic [6:0] waddr ,
  input  logic [0:0] wdata ,
  input  logic [0:0] wen 
);
  localparam logic [7:0] __const__nblocks_per_way_at_update_register_bits  = 8'd128;
  //-------------------------------------------------------------
  // Component replacement_register
  //-------------------------------------------------------------

  logic [0:0] replacement_register__clk;
  logic [0:0] replacement_register__en;
  logic [127:0] replacement_register__in_;
  logic [127:0] replacement_register__out;
  logic [0:0] replacement_register__reset;

  RegEnRst__Type_Bits128__reset_value_0 replacement_register
  (
    .clk( replacement_register__clk ),
    .en( replacement_register__en ),
    .in_( replacement_register__in_ ),
    .out( replacement_register__out ),
    .reset( replacement_register__reset )
  );

  //-------------------------------------------------------------
  // End of component replacement_register
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/registers.py:32
  // @update
  // def update_register_bits():
  //   for i in range( nblocks_per_way ):
  //     if s.waddr == i:
  //       s.replacement_register.in_[i] @= s.wdata
  //     else:
  //       s.replacement_register.in_[i] @= s.replacement_register.out[i]
  // 
  //   s.rdata @= s.replacement_register.out[s.raddr]
  
  always_comb begin : update_register_bits
    for ( int unsigned i = 1'd0; i < 8'( __const__nblocks_per_way_at_update_register_bits ); i += 1'd1 )
      if ( waddr == 7'(i) ) begin
        replacement_register__in_[7'(i)] = wdata;
      end
      else
        replacement_register__in_[7'(i)] = replacement_register__out[7'(i)];
    rdata = replacement_register__out[raddr];
  end

  assign replacement_register__clk = clk;
  assign replacement_register__reset = reset;
  assign replacement_register__en = wen;

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_128__ninputs_5
(
  input  logic [0:0] clk ,
  input  logic [127:0] in_ [0:4],
  output logic [127:0] out ,
  input  logic [0:0] reset ,
  input  logic [2:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component DataReplicator Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py

module DataReplicator__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] amo ,
  input  logic [0:0] clk ,
  input  logic [31:0] in_ ,
  input  logic [1:0] len_ ,
  output logic [127:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__ninputs_at_output_mux_selection_logic  = 3'd5;
  logic [127:0] double_word;
  logic [127:0] replications [0:2];
  //-------------------------------------------------------------
  // Component output_mux
  //-------------------------------------------------------------

  logic [0:0] output_mux__clk;
  logic [127:0] output_mux__in_ [0:4];
  logic [127:0] output_mux__out;
  logic [0:0] output_mux__reset;
  logic [2:0] output_mux__sel;

  Mux__Type_128__ninputs_5 output_mux
  (
    .clk( output_mux__clk ),
    .in_( output_mux__in_ ),
    .out( output_mux__out ),
    .reset( output_mux__reset ),
    .sel( output_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component output_mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:46
  // s.double_word[j:j+64] //= lambda: zext( s.in_, 64 )
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_replicator_M0_double_word_0_64_
    double_word[7'd63:7'd0] = { { 32 { 1'b0 } }, in_ };
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:46
  // s.double_word[j:j+64] //= lambda: zext( s.in_, 64 )
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_replicator_M0_double_word_64_128_
    double_word[7'd127:7'd64] = { { 32 { 1'b0 } }, in_ };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:70
  // @update
  // def output_mux_selection_logic():
  //   s.output_mux.sel @= 0
  //   if ~s.amo:
  //     s.output_mux.sel @= BitsSel(ninputs-2)
  //     if s.len_ == BitsLen(0):
  //       # choose the largest byte access available if len is 0
  //       s.output_mux.sel @= BitsSel(ninputs-2)
  //     elif s.len_ == BitsLen(3):
  //       s.output_mux.sel @= BitsSel(ninputs-1)
  //     else:
  //       # Iterate to check for matching len and then map to appropriate select
  //       for i in range(ninputs - 3):
  //         if s.len_ == BitsLen(2**i):
  //           s.output_mux.sel @= BitsSel(i) + 1
  
  always_comb begin : output_mux_selection_logic
    output_mux__sel = 3'd0;
    if ( ~amo ) begin
      output_mux__sel = 3'd3;
      if ( len_ == 2'd0 ) begin
        output_mux__sel = 3'd3;
      end
      else if ( len_ == 2'd3 ) begin
        output_mux__sel = 3'd4;
      end
      else
        for ( int unsigned i = 1'd0; i < 3'( __const__ninputs_at_output_mux_selection_logic ) - 3'd3; i += 1'd1 )
          if ( len_ == 2'( 2'd2 ** 2'(i) ) ) begin
            output_mux__sel = 3'( 1'(i) ) + 3'd1;
          end
    end
  end

  assign replications[0][7:0] = in_[7:0];
  assign replications[0][15:8] = in_[7:0];
  assign replications[0][23:16] = in_[7:0];
  assign replications[0][31:24] = in_[7:0];
  assign replications[0][39:32] = in_[7:0];
  assign replications[0][47:40] = in_[7:0];
  assign replications[0][55:48] = in_[7:0];
  assign replications[0][63:56] = in_[7:0];
  assign replications[0][71:64] = in_[7:0];
  assign replications[0][79:72] = in_[7:0];
  assign replications[0][87:80] = in_[7:0];
  assign replications[0][95:88] = in_[7:0];
  assign replications[0][103:96] = in_[7:0];
  assign replications[0][111:104] = in_[7:0];
  assign replications[0][119:112] = in_[7:0];
  assign replications[0][127:120] = in_[7:0];
  assign replications[1][15:0] = in_[15:0];
  assign replications[1][31:16] = in_[15:0];
  assign replications[1][47:32] = in_[15:0];
  assign replications[1][63:48] = in_[15:0];
  assign replications[1][79:64] = in_[15:0];
  assign replications[1][95:80] = in_[15:0];
  assign replications[1][111:96] = in_[15:0];
  assign replications[1][127:112] = in_[15:0];
  assign replications[2][31:0] = in_[31:0];
  assign replications[2][63:32] = in_[31:0];
  assign replications[2][95:64] = in_[31:0];
  assign replications[2][127:96] = in_[31:0];
  assign output_mux__clk = clk;
  assign output_mux__reset = reset;
  assign output_mux__in_[4] = double_word;
  assign output_mux__in_[0][31:0] = in_[31:0];
  assign output_mux__in_[0][127:32] = 96'd0;
  assign output_mux__in_[1] = replications[0];
  assign output_mux__in_[2] = replications[1];
  assign output_mux__in_[3] = replications[2];
  assign out = output_mux__out;

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_128
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [127:0] in_ ,
  output logic [127:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component StallEngine Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/StallEngine.py

module StallEngine__dtype_128
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [127:0] in_ ,
  output logic [127:0] out ,
  input  logic [0:0] reset 
);
  //-------------------------------------------------------------
  // Component stall_mux
  //-------------------------------------------------------------

  logic [0:0] stall_mux__clk;
  logic [127:0] stall_mux__in_ [0:1];
  logic [127:0] stall_mux__out;
  logic [0:0] stall_mux__reset;
  logic [0:0] stall_mux__sel;

  Mux__Type_128__ninputs_2 stall_mux
  (
    .clk( stall_mux__clk ),
    .in_( stall_mux__in_ ),
    .out( stall_mux__out ),
    .reset( stall_mux__reset ),
    .sel( stall_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component stall_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component stall_reg
  //-------------------------------------------------------------

  logic [0:0] stall_reg__clk;
  logic [0:0] stall_reg__en;
  logic [127:0] stall_reg__in_;
  logic [127:0] stall_reg__out;
  logic [0:0] stall_reg__reset;

  RegEn__Type_128 stall_reg
  (
    .clk( stall_reg__clk ),
    .en( stall_reg__en ),
    .in_( stall_reg__in_ ),
    .out( stall_reg__out ),
    .reset( stall_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component stall_reg
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/StallEngine.py:41
  // m.sel    //= lambda: ~s.en
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_stall_engine_M2_stall_mux_sel
    stall_mux__sel = ~en;
  end

  assign stall_reg__clk = clk;
  assign stall_reg__reset = reset;
  assign stall_reg__en = en;
  assign stall_reg__in_ = in_;
  assign stall_mux__clk = clk;
  assign stall_mux__reset = reset;
  assign stall_mux__in_[0] = in_;
  assign stall_mux__in_[1] = stall_reg__out;
  assign out = stall_mux__out;

endmodule


// PyMTL Component TagArrayRDataProcessUnit Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py

module TagArrayRDataProcessUnit__p_BlockingCache_4096_128_32_32_2
(
  input  logic [20:0] addr_tag ,
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [0:0] hit ,
  output logic [0:0] hit_way ,
  output logic [0:0] inval_hit ,
  input  logic [0:0] is_init ,
  output logic [1:0] line_dirty ,
  input  logic [3:0] offset ,
  input  logic [0:0] reset ,
  input  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array [0:1],
  output StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_entires [0:1],
  output logic [1:0] word_dirty 
);
  localparam logic [0:0] __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_PU_word_dirty_0_1_  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_PU_word_dirty_1_2_  = 1'd1;
  localparam logic [0:0] __const__y  = 1'd1;
  localparam logic [0:0] __const__n  = 1'd0;
  localparam logic [0:0] __const__CACHE_LINE_STATE_VALID  = 1'd1;
  localparam logic [0:0] __const__CACHE_LINE_STATE_INVALID  = 1'd0;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:254
  // s.word_dirty[i] //= lambda: s.tag_array[i].dty[ s.offset[2 : p.bitwidth_offset] ]
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_tag_array_PU_word_dirty_0_1_
    word_dirty[1'd0:1'd0] = tag_array[1'( __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_PU_word_dirty_0_1_ )].dty[offset[2'd3:2'd2]];
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:254
  // s.word_dirty[i] //= lambda: s.tag_array[i].dty[ s.offset[2 : p.bitwidth_offset] ]
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_tag_array_PU_word_dirty_1_2_
    word_dirty[1'd1:1'd1] = tag_array[1'( __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_PU_word_dirty_1_2_ )].dty[offset[2'd3:2'd2]];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:265
  // @update
  // def comparing_logic():
  //   s.hit       @= n
  //   s.inval_hit @= n
  //   s.hit_way   @= 0
  //   if (~s.is_init) & s.en:
  //     for i in range(p.associativity):
  //       if s.tag_array[i].val == CACHE_LINE_STATE_VALID:
  //         if s.tag_array[i].tag == s.addr_tag:
  //           s.hit      @= y
  //           s.hit_way  @= i
  //       if s.line_dirty[i] & (s.tag_array[i].val == CACHE_LINE_STATE_INVALID):
  //         # If not valid, then we check if the line is dirty at all
  //         # If its dirty, then we flag the transaction as an access to a
  //         # partially dirty line that may require special attention
  //         if s.tag_array[i].tag == s.addr_tag:
  //           s.inval_hit @= y
  //           s.hit_way   @= i
  
  always_comb begin : comparing_logic
    hit = 1'( __const__n );
    inval_hit = 1'( __const__n );
    hit_way = 1'd0;
    if ( ( ~is_init ) & en ) begin
      for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 ) begin
        if ( tag_array[1'(i)].val == 1'( __const__CACHE_LINE_STATE_VALID ) ) begin
          if ( tag_array[1'(i)].tag == addr_tag ) begin
            hit = 1'( __const__y );
            hit_way = 1'(i);
          end
        end
        if ( line_dirty[1'(i)] & ( tag_array[1'(i)].val == 1'( __const__CACHE_LINE_STATE_INVALID ) ) ) begin
          if ( tag_array[1'(i)].tag == addr_tag ) begin
            inval_hit = 1'( __const__y );
            hit_way = 1'(i);
          end
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:256
  // @update
  // def line_dirty_logic():
  //   s.line_dirty @= 0
  //   # OR all the wires together to see if a line is dirty
  //   for i in range(p.associativity):
  //     for j in range(p.bitwidth_dirty):
  //       if s.tag_array[i].dty[j] & s.en:
  //         s.line_dirty[i] @= y
  
  always_comb begin : line_dirty_logic
    line_dirty = 2'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      for ( int unsigned j = 1'd0; j < 3'd4; j += 1'd1 )
        if ( tag_array[1'(i)].dty[2'(j)] & en ) begin
          line_dirty[1'(i)] = 1'( __const__y );
        end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/arithmetics.py:284
  // @update
  // def tag_entry_output_logic():
  //   # Outputs what we're reading from the sram if the processing unit is
  //   # enabled. Otherwise we output zeros.
  //   for i in range(p.associativity):
  //     if s.en:
  //       s.tag_entires[i] @= s.tag_array[i]
  //     else:
  //       s.tag_entires[i] @= p.StructTagArray()
  
  always_comb begin : tag_entry_output_logic
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( en ) begin
        tag_entires[1'(i)] = tag_array[1'(i)];
      end
      else
        tag_entires[1'(i)] = { 1'd0, 4'd0, 21'd0 };
  end

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_StructTagArray_1_4_21__val_1__dty_4__tag_21__ninputs_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__16ac68cc30145a43
(
  input  logic [0:0] clk ,
  input  StructTagArray_1_4_21__val_1__dty_4__tag_21 in_ [0:1],
  output StructTagArray_1_4_21__val_1__dty_4__tag_21 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_StructTagArray_1_4_21__val_1__dty_4__tag_21
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  StructTagArray_1_4_21__val_1__dty_4__tag_21 in_ ,
  output StructTagArray_1_4_21__val_1__dty_4__tag_21 out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component StallEngine Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/StallEngine.py

module StallEngine__dtype_StructTagArray_1_4_21__val_1__dty_4__tag_21
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  StructTagArray_1_4_21__val_1__dty_4__tag_21 in_ ,
  output StructTagArray_1_4_21__val_1__dty_4__tag_21 out ,
  input  logic [0:0] reset 
);
  //-------------------------------------------------------------
  // Component stall_mux
  //-------------------------------------------------------------

  logic [0:0] stall_mux__clk;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 stall_mux__in_ [0:1];
  StructTagArray_1_4_21__val_1__dty_4__tag_21 stall_mux__out;
  logic [0:0] stall_mux__reset;
  logic [0:0] stall_mux__sel;

  Mux__16ac68cc30145a43 stall_mux
  (
    .clk( stall_mux__clk ),
    .in_( stall_mux__in_ ),
    .out( stall_mux__out ),
    .reset( stall_mux__reset ),
    .sel( stall_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component stall_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component stall_reg
  //-------------------------------------------------------------

  logic [0:0] stall_reg__clk;
  logic [0:0] stall_reg__en;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 stall_reg__in_;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 stall_reg__out;
  logic [0:0] stall_reg__reset;

  RegEn__Type_StructTagArray_1_4_21__val_1__dty_4__tag_21 stall_reg
  (
    .clk( stall_reg__clk ),
    .en( stall_reg__en ),
    .in_( stall_reg__in_ ),
    .out( stall_reg__out ),
    .reset( stall_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component stall_reg
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/StallEngine.py:41
  // m.sel    //= lambda: ~s.en
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_0__stall_mux_sel
    stall_mux__sel = ~en;
  end

  assign stall_reg__clk = clk;
  assign stall_reg__reset = reset;
  assign stall_reg__en = en;
  assign stall_reg__in_ = in_;
  assign stall_mux__clk = clk;
  assign stall_mux__reset = reset;
  assign stall_mux__in_[0] = in_;
  assign stall_mux__in_[1] = stall_reg__out;
  assign out = stall_mux__out;

endmodule


// PyMTL Component SramGenericPRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py

module SramGenericPRTL__num_bits_26__num_words_128
(
  input  logic [6:0] A1 ,
  input  logic [0:0] CE1 ,
  input  logic [0:0] CSB1 ,
  input  logic [25:0] I1 ,
  output logic [25:0] O1 ,
  input  logic [0:0] OEB1 ,
  input  logic [25:0] WBM1 ,
  input  logic [0:0] WEB1 ,
  input  logic [0:0] clk ,
  input  logic [0:0] reset 
);
  localparam logic [7:0] __const__num_words_at_write_logic  = 8'd128;
  localparam logic [4:0] __const__num_bits_at_write_logic  = 5'd26;
  localparam logic [7:0] __const__num_words_at_update_sram  = 8'd128;
  logic [25:0] dout;
  logic [25:0] dout_next;
  logic [25:0] ram [0:127];
  logic [25:0] ram_next [0:127];

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:54
  // @update
  // def comb_logic():
  //   s.O1 @= s.dout if ~s.OEB1 else 0
  
  always_comb begin : comb_logic
    O1 = ( ~OEB1 ) ? dout : 26'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:41
  // @update
  // def read_logic():
  //   s.dout_next @= s.ram[ s.A1 ] if (~s.CSB1 & s.WEB1) else s.dout
  
  always_comb begin : read_logic
    dout_next = ( ( ~CSB1 ) & WEB1 ) ? ram[A1] : dout;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:46
  // @update
  // def write_logic():
  //   for i in range( num_words ):
  //     s.ram_next[i] @= s.ram[i]
  //   for i in range( num_bits ):
  //     if ~s.CSB1 & ~s.WEB1 & s.WBM1[i]:
  //       s.ram_next[s.A1][i] @= s.I1[i]
  
  always_comb begin : write_logic
    for ( int unsigned i = 1'd0; i < 8'( __const__num_words_at_write_logic ); i += 1'd1 )
      ram_next[7'(i)] = ram[7'(i)];
    for ( int unsigned i = 1'd0; i < 5'( __const__num_bits_at_write_logic ); i += 1'd1 )
      if ( ( ( ~CSB1 ) & ( ~WEB1 ) ) & WBM1[5'(i)] ) begin
        ram_next[A1][5'(i)] = I1[5'(i)];
      end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramGenericPRTL.py:58
  // @update_ff
  // def update_sram():
  //   s.dout <<= s.dout_next
  //   for i in range( num_words ):
  //     s.ram[i] <<= s.ram_next[i]
  
  always_ff @(posedge clk) begin : update_sram
    dout <= dout_next;
    for ( int unsigned i = 1'd0; i < 8'( __const__num_words_at_update_sram ); i += 1'd1 )
      ram[7'(i)] <= ram_next[7'(i)];
  end

endmodule


// PyMTL Component SramPRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramPRTL.py

module SramPRTL__num_bits_26__num_words_128
(
  input  logic [0:0] clk ,
  input  logic [6:0] port0_idx ,
  output logic [25:0] port0_rdata ,
  input  logic [0:0] port0_type ,
  input  logic [0:0] port0_val ,
  input  logic [25:0] port0_wben ,
  input  logic [25:0] port0_wdata ,
  input  logic [0:0] reset 
);
  logic [0:0] port0_type_bar;
  logic [0:0] port0_val_bar;
  //-------------------------------------------------------------
  // Component sram
  //-------------------------------------------------------------

  logic [6:0] sram__A1;
  logic [0:0] sram__CE1;
  logic [0:0] sram__CSB1;
  logic [25:0] sram__I1;
  logic [25:0] sram__O1;
  logic [0:0] sram__OEB1;
  logic [25:0] sram__WBM1;
  logic [0:0] sram__WEB1;
  logic [0:0] sram__clk;
  logic [0:0] sram__reset;

  SramGenericPRTL #(.num_bits(26) , .num_words(128)) sram
  (
    .A1( sram__A1 ),
    .CE1( sram__CE1 ),
    .CSB1( sram__CSB1 ),
    .I1( sram__I1 ),
    .O1( sram__O1 ),
    .OEB1( sram__OEB1 ),
    .WBM1( sram__WBM1 ),
    .WEB1( sram__WEB1 ),
    .clk( sram__clk ),
    .reset( sram__reset )
  );

  //-------------------------------------------------------------
  // End of component sram
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/sram/SramPRTL.py:46
  // @update
  // def inverters():
  //   s.port0_val_bar  @= ~s.port0_val
  //   s.port0_type_bar @= ~s.port0_type
  
  always_comb begin : inverters
    port0_val_bar = ~port0_val;
    port0_type_bar = ~port0_type;
  end

  assign sram__clk = clk;
  assign sram__reset = reset;
  assign sram__CE1 = clk;
  assign sram__CSB1 = port0_val_bar;
  assign sram__OEB1 = 1'd0;
  assign sram__WBM1 = port0_wben;
  assign sram__WEB1 = port0_type_bar;
  assign sram__A1 = port0_idx;
  assign sram__I1 = port0_wdata;
  assign port0_rdata = sram__O1;

endmodule


// PyMTL Component UpdateTagArrayUnit Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/UpdateTagArrayUnit.py

module UpdateTagArrayUnit__p_BlockingCache_4096_128_32_32_2
(
  input  logic [0:0] clk ,
  input  logic [2:0] cmd ,
  input  logic [3:0] offset ,
  input  StructTagArray_1_4_21__val_1__dty_4__tag_21 old_entries [0:1],
  output StructTagArray_1_4_21__val_1__dty_4__tag_21 out ,
  input  logic [3:0] refill_dty ,
  input  logic [0:0] reset ,
  input  logic [0:0] way 
);
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_WR_REFILL  = 3'd3;
  localparam logic [0:0] __const__CACHE_LINE_STATE_VALID  = 1'd1;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_RD_REFILL  = 3'd4;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_WR_HIT  = 3'd2;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_CLEAR  = 3'd1;
  localparam logic [0:0] __const__CACHE_LINE_STATE_INVALID  = 1'd0;
  localparam logic [2:0] __const__UpdateTagArrayUnit_CMD_INV  = 3'd5;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/units/UpdateTagArrayUnit.py:27
  // @update
  // def new_tag_array_entry_logic():
  //   s.out.tag @= s.old_entries[s.way].tag
  //   s.out.val @= s.old_entries[s.way].val
  //   s.out.dty @= s.old_entries[s.way].dty
  //   if s.cmd == UpdateTagArrayUnit_CMD_WR_REFILL:
  //     # Refill on a write, mark the word being written as dirty, the
  //     # rest is clean
  //     s.out.val @= CACHE_LINE_STATE_VALID
  //     s.out.dty @= 0 | s.refill_dty
  //     s.out.dty[ s.offset[2 : p.bitwidth_offset] ] @= 1
  //   elif s.cmd == UpdateTagArrayUnit_CMD_RD_REFILL:
  //     # Refill for a read, simply mark valid bit and clear the dirty
  //     # bits
  //     s.out.val @= CACHE_LINE_STATE_VALID
  //     s.out.dty @= 0 | s.refill_dty
  //   elif s.cmd == UpdateTagArrayUnit_CMD_WR_HIT:
  //     # Hit a clean word, mark the word as dirty
  //     s.out.dty[ s.offset[2 : p.bitwidth_offset] ] @= 1
  //   elif s.cmd == UpdateTagArrayUnit_CMD_CLEAR:
  //     # Clear the entire entry
  //     s.out.tag @= 0
  //     s.out.val @= CACHE_LINE_STATE_INVALID
  //     s.out.dty @= 0
  //   elif s.cmd == UpdateTagArrayUnit_CMD_INV:
  //     # For cache invalidation, leave the dirty bits as is, clear the
  //     # valid bit
  //     s.out.val @= CACHE_LINE_STATE_INVALID
  
  always_comb begin : new_tag_array_entry_logic
    out.tag = old_entries[way].tag;
    out.val = old_entries[way].val;
    out.dty = old_entries[way].dty;
    if ( cmd == 3'( __const__UpdateTagArrayUnit_CMD_WR_REFILL ) ) begin
      out.val = 1'( __const__CACHE_LINE_STATE_VALID );
      out.dty = 4'd0 | refill_dty;
      out.dty[offset[2'd3:2'd2]] = 1'd1;
    end
    else if ( cmd == 3'( __const__UpdateTagArrayUnit_CMD_RD_REFILL ) ) begin
      out.val = 1'( __const__CACHE_LINE_STATE_VALID );
      out.dty = 4'd0 | refill_dty;
    end
    else if ( cmd == 3'( __const__UpdateTagArrayUnit_CMD_WR_HIT ) ) begin
      out.dty[offset[2'd3:2'd2]] = 1'd1;
    end
    else if ( cmd == 3'( __const__UpdateTagArrayUnit_CMD_CLEAR ) ) begin
      out.tag = 21'd0;
      out.val = 1'( __const__CACHE_LINE_STATE_INVALID );
      out.dty = 4'd0;
    end
    else if ( cmd == 3'( __const__UpdateTagArrayUnit_CMD_INV ) ) begin
      out.val = 1'( __const__CACHE_LINE_STATE_INVALID );
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_1__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] in_ [0:1],
  output logic [0:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BlockingCacheDpathRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py

module BlockingCacheDpathRTL__p_BlockingCache_4096_128_32_32_2
(
  input  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 cachereq_Y ,
  output MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 cacheresp_M2 ,
  input  logic [0:0] clk ,
  input  StructCtrlSignals_4096_128_32_32_2__d7dbe132f9f2ed9f ctrl ,
  output MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 memreq_M2 ,
  input  MemRespMsg_8_128_m1__c72937e2b7853c90 memresp_Y ,
  input  logic [0:0] reset ,
  output StructDpathStatus_4096_128_32_32_2__d99bb19c96f0c7bf status 
);
  localparam logic [0:0] __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_0__in_  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_1__in_  = 1'd1;
  StructMSHR_32_2__4f9bfcd81ca6f13c MSHR_alloc_in;
  StructHitInfo_1__hit_1__hit_way_1 MSHR_alloc_in_amo_hit_bypass;
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 MSHR_dealloc_mux_in_M0;
  StructMSHR_32_2__4f9bfcd81ca6f13c MSHR_dealloc_out;
  StructDpathPipeline_128_2__f3cfe859759af9fc cachereq_M0;
  StructDpathPipeline_128_2__f3cfe859759af9fc cachereq_M1_2;
  logic [31:0] cachereq_addr_M1_forward;
  logic [127:0] data_array_wdata_M1;
  StructAddr_21_7_4__tag_21__index_7__offset_4 evict_addr_M1;
  logic [0:0] hit_way_M1_bypass;
  logic [31:0] memreq_addr_bits;
  StructAddr_21_7_4__tag_21__index_7__offset_4 memreq_addr_out;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_struct_M0;
  logic [25:0] tag_array_wdata_M0;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_entries_M1_bypass [0:1];
  logic [3:0] write_mask_M1;
  //-------------------------------------------------------------
  // Component WbenGen_M1
  //-------------------------------------------------------------

  logic [0:0] WbenGen_M1__clk;
  logic [1:0] WbenGen_M1__cmd;
  logic [3:0] WbenGen_M1__dty_mask;
  logic [1:0] WbenGen_M1__len_;
  logic [3:0] WbenGen_M1__offset;
  logic [127:0] WbenGen_M1__out;
  logic [0:0] WbenGen_M1__reset;

  WriteBitEnGen__p_BlockingCache_4096_128_32_32_2 WbenGen_M1
  (
    .clk( WbenGen_M1__clk ),
    .cmd( WbenGen_M1__cmd ),
    .dty_mask( WbenGen_M1__dty_mask ),
    .len_( WbenGen_M1__len_ ),
    .offset( WbenGen_M1__offset ),
    .out( WbenGen_M1__out ),
    .reset( WbenGen_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component WbenGen_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component addr_mux_M0
  //-------------------------------------------------------------

  logic [0:0] addr_mux_M0__clk;
  logic [31:0] addr_mux_M0__in_ [0:1];
  logic [31:0] addr_mux_M0__out;
  logic [0:0] addr_mux_M0__reset;
  logic [0:0] addr_mux_M0__sel;

  Mux__Type_32__ninputs_2 addr_mux_M0
  (
    .clk( addr_mux_M0__clk ),
    .in_( addr_mux_M0__in_ ),
    .out( addr_mux_M0__out ),
    .reset( addr_mux_M0__reset ),
    .sel( addr_mux_M0__sel )
  );

  //-------------------------------------------------------------
  // End of component addr_mux_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component cachereq_M1
  //-------------------------------------------------------------

  logic [0:0] cachereq_M1__clk;
  logic [0:0] cachereq_M1__en;
  StructDpathPipeline_128_2__f3cfe859759af9fc cachereq_M1__in_;
  StructDpathPipeline_128_2__f3cfe859759af9fc cachereq_M1__out;
  logic [0:0] cachereq_M1__reset;

  RegEnRst__2b7c680d98a49c34 cachereq_M1
  (
    .clk( cachereq_M1__clk ),
    .en( cachereq_M1__en ),
    .in_( cachereq_M1__in_ ),
    .out( cachereq_M1__out ),
    .reset( cachereq_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component cachereq_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component cachereq_M2
  //-------------------------------------------------------------

  logic [0:0] cachereq_M2__clk;
  logic [0:0] cachereq_M2__en;
  StructDpathPipeline_128_2__f3cfe859759af9fc cachereq_M2__in_;
  StructDpathPipeline_128_2__f3cfe859759af9fc cachereq_M2__out;
  logic [0:0] cachereq_M2__reset;

  RegEnRst__2b7c680d98a49c34 cachereq_M2
  (
    .clk( cachereq_M2__clk ),
    .en( cachereq_M2__en ),
    .in_( cachereq_M2__in_ ),
    .out( cachereq_M2__out ),
    .reset( cachereq_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component cachereq_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component cachereq_memresp_mux_M0
  //-------------------------------------------------------------

  logic [0:0] cachereq_memresp_mux_M0__clk;
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 cachereq_memresp_mux_M0__in_ [0:1];
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 cachereq_memresp_mux_M0__out;
  logic [0:0] cachereq_memresp_mux_M0__reset;
  logic [0:0] cachereq_memresp_mux_M0__sel;

  Mux__c4fd530f829680a2 cachereq_memresp_mux_M0
  (
    .clk( cachereq_memresp_mux_M0__clk ),
    .in_( cachereq_memresp_mux_M0__in_ ),
    .out( cachereq_memresp_mux_M0__out ),
    .reset( cachereq_memresp_mux_M0__reset ),
    .sel( cachereq_memresp_mux_M0__sel )
  );

  //-------------------------------------------------------------
  // End of component cachereq_memresp_mux_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component data_array_M2
  //-------------------------------------------------------------

  logic [0:0] data_array_M2__clk;
  logic [7:0] data_array_M2__port0_idx;
  logic [127:0] data_array_M2__port0_rdata;
  logic [0:0] data_array_M2__port0_type;
  logic [0:0] data_array_M2__port0_val;
  logic [127:0] data_array_M2__port0_wben;
  logic [127:0] data_array_M2__port0_wdata;
  logic [0:0] data_array_M2__reset;

  SramPRTL__num_bits_128__num_words_256 data_array_M2
  (
    .clk( data_array_M2__clk ),
    .port0_idx( data_array_M2__port0_idx ),
    .port0_rdata( data_array_M2__port0_rdata ),
    .port0_type( data_array_M2__port0_type ),
    .port0_val( data_array_M2__port0_val ),
    .port0_wben( data_array_M2__port0_wben ),
    .port0_wdata( data_array_M2__port0_wdata ),
    .reset( data_array_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component data_array_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component data_size_mux_M2
  //-------------------------------------------------------------

  logic [0:0] data_size_mux_M2__amo;
  logic [0:0] data_size_mux_M2__clk;
  logic [0:0] data_size_mux_M2__en;
  logic [127:0] data_size_mux_M2__in_;
  logic [1:0] data_size_mux_M2__len_;
  logic [3:0] data_size_mux_M2__offset;
  logic [31:0] data_size_mux_M2__out;
  logic [0:0] data_size_mux_M2__reset;

  FastDataSelectMux__p_BlockingCache_4096_128_32_32_2 data_size_mux_M2
  (
    .amo( data_size_mux_M2__amo ),
    .clk( data_size_mux_M2__clk ),
    .en( data_size_mux_M2__en ),
    .in_( data_size_mux_M2__in_ ),
    .len_( data_size_mux_M2__len_ ),
    .offset( data_size_mux_M2__offset ),
    .out( data_size_mux_M2__out ),
    .reset( data_size_mux_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component data_size_mux_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dty_bits_mask_M1
  //-------------------------------------------------------------

  logic [0:0] dty_bits_mask_M1__clk;
  logic [0:0] dty_bits_mask_M1__en;
  logic [3:0] dty_bits_mask_M1__in_;
  logic [3:0] dty_bits_mask_M1__out;
  logic [0:0] dty_bits_mask_M1__reset;

  RegEnRst__Type_4__reset_value_0 dty_bits_mask_M1
  (
    .clk( dty_bits_mask_M1__clk ),
    .en( dty_bits_mask_M1__en ),
    .in_( dty_bits_mask_M1__in_ ),
    .out( dty_bits_mask_M1__out ),
    .reset( dty_bits_mask_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component dty_bits_mask_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component evict_mux_M1
  //-------------------------------------------------------------

  logic [0:0] evict_mux_M1__clk;
  StructAddr_21_7_4__tag_21__index_7__offset_4 evict_mux_M1__in_ [0:1];
  StructAddr_21_7_4__tag_21__index_7__offset_4 evict_mux_M1__out;
  logic [0:0] evict_mux_M1__reset;
  logic [0:0] evict_mux_M1__sel;

  Mux__fb9b5ee67e2c4c7c evict_mux_M1
  (
    .clk( evict_mux_M1__clk ),
    .in_( evict_mux_M1__in_ ),
    .out( evict_mux_M1__out ),
    .reset( evict_mux_M1__reset ),
    .sel( evict_mux_M1__sel )
  );

  //-------------------------------------------------------------
  // End of component evict_mux_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component evict_way_mux_M1
  //-------------------------------------------------------------

  logic [0:0] evict_way_mux_M1__clk;
  logic [20:0] evict_way_mux_M1__in_ [0:1];
  logic [20:0] evict_way_mux_M1__out;
  logic [0:0] evict_way_mux_M1__reset;
  logic [0:0] evict_way_mux_M1__sel;

  Mux__Type_21__ninputs_2 evict_way_mux_M1
  (
    .clk( evict_way_mux_M1__clk ),
    .in_( evict_way_mux_M1__in_ ),
    .out( evict_way_mux_M1__out ),
    .reset( evict_way_mux_M1__reset ),
    .sel( evict_way_mux_M1__sel )
  );

  //-------------------------------------------------------------
  // End of component evict_way_mux_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component flush_idx_M1
  //-------------------------------------------------------------

  logic [0:0] flush_idx_M1__clk;
  logic [0:0] flush_idx_M1__en;
  logic [6:0] flush_idx_M1__in_;
  logic [6:0] flush_idx_M1__out;
  logic [0:0] flush_idx_M1__reset;

  RegEnRst__Type_7__reset_value_0 flush_idx_M1
  (
    .clk( flush_idx_M1__clk ),
    .en( flush_idx_M1__en ),
    .in_( flush_idx_M1__in_ ),
    .out( flush_idx_M1__out ),
    .reset( flush_idx_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component flush_idx_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component flush_idx_mux_M1
  //-------------------------------------------------------------

  logic [0:0] flush_idx_mux_M1__clk;
  logic [6:0] flush_idx_mux_M1__in_ [0:1];
  logic [6:0] flush_idx_mux_M1__out;
  logic [0:0] flush_idx_mux_M1__reset;
  logic [0:0] flush_idx_mux_M1__sel;

  Mux__Type_7__ninputs_2 flush_idx_mux_M1
  (
    .clk( flush_idx_mux_M1__clk ),
    .in_( flush_idx_mux_M1__in_ ),
    .out( flush_idx_mux_M1__out ),
    .reset( flush_idx_mux_M1__reset ),
    .sel( flush_idx_mux_M1__sel )
  );

  //-------------------------------------------------------------
  // End of component flush_idx_mux_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component hit_stall_engine
  //-------------------------------------------------------------

  logic [0:0] hit_stall_engine__clk;
  logic [0:0] hit_stall_engine__en;
  StructHitInfo_1__hit_1__hit_way_1 hit_stall_engine__in_;
  StructHitInfo_1__hit_1__hit_way_1 hit_stall_engine__out;
  logic [0:0] hit_stall_engine__reset;

  StallEngine__dtype_StructHitInfo_1__hit_1__hit_way_1 hit_stall_engine
  (
    .clk( hit_stall_engine__clk ),
    .en( hit_stall_engine__en ),
    .in_( hit_stall_engine__in_ ),
    .out( hit_stall_engine__out ),
    .reset( hit_stall_engine__reset )
  );

  //-------------------------------------------------------------
  // End of component hit_stall_engine
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component index_offset_M1
  //-------------------------------------------------------------

  logic [0:0] index_offset_M1__clk;
  logic [6:0] index_offset_M1__index;
  logic [0:0] index_offset_M1__offset;
  logic [7:0] index_offset_M1__out;
  logic [0:0] index_offset_M1__reset;

  Indexer__p_BlockingCache_4096_128_32_32_2 index_offset_M1
  (
    .clk( index_offset_M1__clk ),
    .index( index_offset_M1__index ),
    .offset( index_offset_M1__offset ),
    .out( index_offset_M1__out ),
    .reset( index_offset_M1__reset )
  );

  //-------------------------------------------------------------
  // End of component index_offset_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_req_off_len_M2
  //-------------------------------------------------------------

  logic [0:0] mem_req_off_len_M2__clk;
  logic [0:0] mem_req_off_len_M2__is_amo;
  logic [1:0] mem_req_off_len_M2__len_i;
  logic [3:0] mem_req_off_len_M2__len_o;
  logic [3:0] mem_req_off_len_M2__offset_i;
  logic [3:0] mem_req_off_len_M2__offset_o;
  logic [0:0] mem_req_off_len_M2__reset;

  OffsetLenSelector__p_BlockingCache_4096_128_32_32_2 mem_req_off_len_M2
  (
    .clk( mem_req_off_len_M2__clk ),
    .is_amo( mem_req_off_len_M2__is_amo ),
    .len_i( mem_req_off_len_M2__len_i ),
    .len_o( mem_req_off_len_M2__len_o ),
    .offset_i( mem_req_off_len_M2__offset_i ),
    .offset_o( mem_req_off_len_M2__offset_o ),
    .reset( mem_req_off_len_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component mem_req_off_len_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mshr
  //-------------------------------------------------------------

  logic [0:0] mshr__alloc_en;
  logic [7:0] mshr__alloc_id;
  StructMSHR_32_2__4f9bfcd81ca6f13c mshr__alloc_in;
  logic [0:0] mshr__clk;
  logic [0:0] mshr__dealloc_en;
  logic [7:0] mshr__dealloc_id;
  StructMSHR_32_2__4f9bfcd81ca6f13c mshr__dealloc_out;
  logic [0:0] mshr__empty;
  logic [0:0] mshr__full;
  logic [0:0] mshr__reset;

  MSHR__p_BlockingCache_4096_128_32_32_2__entries_1 mshr
  (
    .alloc_en( mshr__alloc_en ),
    .alloc_id( mshr__alloc_id ),
    .alloc_in( mshr__alloc_in ),
    .clk( mshr__clk ),
    .dealloc_en( mshr__dealloc_en ),
    .dealloc_id( mshr__dealloc_id ),
    .dealloc_out( mshr__dealloc_out ),
    .empty( mshr__empty ),
    .full( mshr__full ),
    .reset( mshr__reset )
  );

  //-------------------------------------------------------------
  // End of component mshr
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pipeline_reg_M0
  //-------------------------------------------------------------

  logic [0:0] pipeline_reg_M0__clk;
  logic [0:0] pipeline_reg_M0__en;
  MemRespMsg_8_128_m1__c72937e2b7853c90 pipeline_reg_M0__in_;
  MemRespMsg_8_128_m1__c72937e2b7853c90 pipeline_reg_M0__out;
  logic [0:0] pipeline_reg_M0__reset;

  RegEnRst__b7ac6c1e2cfbe42d pipeline_reg_M0
  (
    .clk( pipeline_reg_M0__clk ),
    .en( pipeline_reg_M0__en ),
    .in_( pipeline_reg_M0__in_ ),
    .out( pipeline_reg_M0__out ),
    .reset( pipeline_reg_M0__reset )
  );

  //-------------------------------------------------------------
  // End of component pipeline_reg_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component read_data_mux_M2
  //-------------------------------------------------------------

  logic [0:0] read_data_mux_M2__clk;
  logic [127:0] read_data_mux_M2__in_ [0:1];
  logic [127:0] read_data_mux_M2__out;
  logic [0:0] read_data_mux_M2__reset;
  logic [0:0] read_data_mux_M2__sel;

  Mux__Type_128__ninputs_2 read_data_mux_M2
  (
    .clk( read_data_mux_M2__clk ),
    .in_( read_data_mux_M2__in_ ),
    .out( read_data_mux_M2__out ),
    .reset( read_data_mux_M2__reset ),
    .sel( read_data_mux_M2__sel )
  );

  //-------------------------------------------------------------
  // End of component read_data_mux_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component replacement_bits_M1
  //-------------------------------------------------------------

  logic [0:0] replacement_bits_M1__clk;
  logic [6:0] replacement_bits_M1__raddr;
  logic [0:0] replacement_bits_M1__rdata;
  logic [0:0] replacement_bits_M1__reset;
  logic [6:0] replacement_bits_M1__waddr;
  logic [0:0] replacement_bits_M1__wdata;
  logic [0:0] replacement_bits_M1__wen;

  ReplacementBitsReg__p_BlockingCache_4096_128_32_32_2 replacement_bits_M1
  (
    .clk( replacement_bits_M1__clk ),
    .raddr( replacement_bits_M1__raddr ),
    .rdata( replacement_bits_M1__rdata ),
    .reset( replacement_bits_M1__reset ),
    .waddr( replacement_bits_M1__waddr ),
    .wdata( replacement_bits_M1__wdata ),
    .wen( replacement_bits_M1__wen )
  );

  //-------------------------------------------------------------
  // End of component replacement_bits_M1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component replicator_M0
  //-------------------------------------------------------------

  logic [0:0] replicator_M0__amo;
  logic [0:0] replicator_M0__clk;
  logic [31:0] replicator_M0__in_;
  logic [1:0] replicator_M0__len_;
  logic [127:0] replicator_M0__out;
  logic [0:0] replicator_M0__reset;

  DataReplicator__p_BlockingCache_4096_128_32_32_2 replicator_M0
  (
    .amo( replicator_M0__amo ),
    .clk( replicator_M0__clk ),
    .in_( replicator_M0__in_ ),
    .len_( replicator_M0__len_ ),
    .out( replicator_M0__out ),
    .reset( replicator_M0__reset )
  );

  //-------------------------------------------------------------
  // End of component replicator_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component stall_engine_M2
  //-------------------------------------------------------------

  logic [0:0] stall_engine_M2__clk;
  logic [0:0] stall_engine_M2__en;
  logic [127:0] stall_engine_M2__in_;
  logic [127:0] stall_engine_M2__out;
  logic [0:0] stall_engine_M2__reset;

  StallEngine__dtype_128 stall_engine_M2
  (
    .clk( stall_engine_M2__clk ),
    .en( stall_engine_M2__en ),
    .in_( stall_engine_M2__in_ ),
    .out( stall_engine_M2__out ),
    .reset( stall_engine_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component stall_engine_M2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tag_array_PU
  //-------------------------------------------------------------

  logic [20:0] tag_array_PU__addr_tag;
  logic [0:0] tag_array_PU__clk;
  logic [0:0] tag_array_PU__en;
  logic [0:0] tag_array_PU__hit;
  logic [0:0] tag_array_PU__hit_way;
  logic [0:0] tag_array_PU__inval_hit;
  logic [0:0] tag_array_PU__is_init;
  logic [1:0] tag_array_PU__line_dirty;
  logic [3:0] tag_array_PU__offset;
  logic [0:0] tag_array_PU__reset;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_PU__tag_array [0:1];
  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_PU__tag_entires [0:1];
  logic [1:0] tag_array_PU__word_dirty;

  TagArrayRDataProcessUnit__p_BlockingCache_4096_128_32_32_2 tag_array_PU
  (
    .addr_tag( tag_array_PU__addr_tag ),
    .clk( tag_array_PU__clk ),
    .en( tag_array_PU__en ),
    .hit( tag_array_PU__hit ),
    .hit_way( tag_array_PU__hit_way ),
    .inval_hit( tag_array_PU__inval_hit ),
    .is_init( tag_array_PU__is_init ),
    .line_dirty( tag_array_PU__line_dirty ),
    .offset( tag_array_PU__offset ),
    .reset( tag_array_PU__reset ),
    .tag_array( tag_array_PU__tag_array ),
    .tag_entires( tag_array_PU__tag_entires ),
    .word_dirty( tag_array_PU__word_dirty )
  );

  //-------------------------------------------------------------
  // End of component tag_array_PU
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tag_array_idx_mux_M0
  //-------------------------------------------------------------

  logic [0:0] tag_array_idx_mux_M0__clk;
  logic [6:0] tag_array_idx_mux_M0__in_ [0:1];
  logic [6:0] tag_array_idx_mux_M0__out;
  logic [0:0] tag_array_idx_mux_M0__reset;
  logic [0:0] tag_array_idx_mux_M0__sel;

  Mux__Type_7__ninputs_2 tag_array_idx_mux_M0
  (
    .clk( tag_array_idx_mux_M0__clk ),
    .in_( tag_array_idx_mux_M0__in_ ),
    .out( tag_array_idx_mux_M0__out ),
    .reset( tag_array_idx_mux_M0__reset ),
    .sel( tag_array_idx_mux_M0__sel )
  );

  //-------------------------------------------------------------
  // End of component tag_array_idx_mux_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tag_array_rdata_M1[0:1]
  //-------------------------------------------------------------

  logic [0:0] tag_array_rdata_M1__clk [0:1];
  logic [0:0] tag_array_rdata_M1__en [0:1];
  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_rdata_M1__in_ [0:1];
  StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_rdata_M1__out [0:1];
  logic [0:0] tag_array_rdata_M1__reset [0:1];

  StallEngine__dtype_StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_rdata_M1__0
  (
    .clk( tag_array_rdata_M1__clk[0] ),
    .en( tag_array_rdata_M1__en[0] ),
    .in_( tag_array_rdata_M1__in_[0] ),
    .out( tag_array_rdata_M1__out[0] ),
    .reset( tag_array_rdata_M1__reset[0] )
  );

  StallEngine__dtype_StructTagArray_1_4_21__val_1__dty_4__tag_21 tag_array_rdata_M1__1
  (
    .clk( tag_array_rdata_M1__clk[1] ),
    .en( tag_array_rdata_M1__en[1] ),
    .in_( tag_array_rdata_M1__in_[1] ),
    .out( tag_array_rdata_M1__out[1] ),
    .reset( tag_array_rdata_M1__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component tag_array_rdata_M1[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tag_array_tag_mux_M0
  //-------------------------------------------------------------

  logic [0:0] tag_array_tag_mux_M0__clk;
  logic [20:0] tag_array_tag_mux_M0__in_ [0:1];
  logic [20:0] tag_array_tag_mux_M0__out;
  logic [0:0] tag_array_tag_mux_M0__reset;
  logic [0:0] tag_array_tag_mux_M0__sel;

  Mux__Type_21__ninputs_2 tag_array_tag_mux_M0
  (
    .clk( tag_array_tag_mux_M0__clk ),
    .in_( tag_array_tag_mux_M0__in_ ),
    .out( tag_array_tag_mux_M0__out ),
    .reset( tag_array_tag_mux_M0__reset ),
    .sel( tag_array_tag_mux_M0__sel )
  );

  //-------------------------------------------------------------
  // End of component tag_array_tag_mux_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tag_arrays_M1[0:1]
  //-------------------------------------------------------------

  logic [0:0] tag_arrays_M1__clk [0:1];
  logic [6:0] tag_arrays_M1__port0_idx [0:1];
  logic [25:0] tag_arrays_M1__port0_rdata [0:1];
  logic [0:0] tag_arrays_M1__port0_type [0:1];
  logic [0:0] tag_arrays_M1__port0_val [0:1];
  logic [25:0] tag_arrays_M1__port0_wben [0:1];
  logic [25:0] tag_arrays_M1__port0_wdata [0:1];
  logic [0:0] tag_arrays_M1__reset [0:1];

  SramPRTL__num_bits_26__num_words_128 tag_arrays_M1__0
  (
    .clk( tag_arrays_M1__clk[0] ),
    .port0_idx( tag_arrays_M1__port0_idx[0] ),
    .port0_rdata( tag_arrays_M1__port0_rdata[0] ),
    .port0_type( tag_arrays_M1__port0_type[0] ),
    .port0_val( tag_arrays_M1__port0_val[0] ),
    .port0_wben( tag_arrays_M1__port0_wben[0] ),
    .port0_wdata( tag_arrays_M1__port0_wdata[0] ),
    .reset( tag_arrays_M1__reset[0] )
  );

  SramPRTL__num_bits_26__num_words_128 tag_arrays_M1__1
  (
    .clk( tag_arrays_M1__clk[1] ),
    .port0_idx( tag_arrays_M1__port0_idx[1] ),
    .port0_rdata( tag_arrays_M1__port0_rdata[1] ),
    .port0_type( tag_arrays_M1__port0_type[1] ),
    .port0_val( tag_arrays_M1__port0_val[1] ),
    .port0_wben( tag_arrays_M1__port0_wben[1] ),
    .port0_wdata( tag_arrays_M1__port0_wdata[1] ),
    .reset( tag_arrays_M1__reset[1] )
  );

  //-------------------------------------------------------------
  // End of component tag_arrays_M1[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component update_tag_unit
  //-------------------------------------------------------------

  logic [0:0] update_tag_unit__clk;
  logic [2:0] update_tag_unit__cmd;
  logic [3:0] update_tag_unit__offset;
  StructTagArray_1_4_21__val_1__dty_4__tag_21 update_tag_unit__old_entries [0:1];
  StructTagArray_1_4_21__val_1__dty_4__tag_21 update_tag_unit__out;
  logic [3:0] update_tag_unit__refill_dty;
  logic [0:0] update_tag_unit__reset;
  logic [0:0] update_tag_unit__way;

  UpdateTagArrayUnit__p_BlockingCache_4096_128_32_32_2 update_tag_unit
  (
    .clk( update_tag_unit__clk ),
    .cmd( update_tag_unit__cmd ),
    .offset( update_tag_unit__offset ),
    .old_entries( update_tag_unit__old_entries ),
    .out( update_tag_unit__out ),
    .refill_dty( update_tag_unit__refill_dty ),
    .reset( update_tag_unit__reset ),
    .way( update_tag_unit__way )
  );

  //-------------------------------------------------------------
  // End of component update_tag_unit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component update_tag_way_mux_M0
  //-------------------------------------------------------------

  logic [0:0] update_tag_way_mux_M0__clk;
  logic [0:0] update_tag_way_mux_M0__in_ [0:1];
  logic [0:0] update_tag_way_mux_M0__out;
  logic [0:0] update_tag_way_mux_M0__reset;
  logic [0:0] update_tag_way_mux_M0__sel;

  Mux__Type_1__ninputs_2 update_tag_way_mux_M0
  (
    .clk( update_tag_way_mux_M0__clk ),
    .in_( update_tag_way_mux_M0__in_ ),
    .out( update_tag_way_mux_M0__out ),
    .reset( update_tag_way_mux_M0__reset ),
    .sel( update_tag_way_mux_M0__sel )
  );

  //-------------------------------------------------------------
  // End of component update_tag_way_mux_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component write_data_mux_M0
  //-------------------------------------------------------------

  logic [0:0] write_data_mux_M0__clk;
  logic [127:0] write_data_mux_M0__in_ [0:1];
  logic [127:0] write_data_mux_M0__out;
  logic [0:0] write_data_mux_M0__reset;
  logic [0:0] write_data_mux_M0__sel;

  Mux__Type_128__ninputs_2 write_data_mux_M0
  (
    .clk( write_data_mux_M0__clk ),
    .in_( write_data_mux_M0__in_ ),
    .out( write_data_mux_M0__out ),
    .reset( write_data_mux_M0__reset ),
    .sel( write_data_mux_M0__sel )
  );

  //-------------------------------------------------------------
  // End of component write_data_mux_M0
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component write_mask_M2
  //-------------------------------------------------------------

  logic [0:0] write_mask_M2__clk;
  logic [0:0] write_mask_M2__en;
  logic [3:0] write_mask_M2__in_;
  logic [3:0] write_mask_M2__out;
  logic [0:0] write_mask_M2__reset;

  RegEnRst__Type_4__reset_value_0 write_mask_M2
  (
    .clk( write_mask_M2__clk ),
    .en( write_mask_M2__en ),
    .in_( write_mask_M2__in_ ),
    .out( write_mask_M2__out ),
    .reset( write_mask_M2__reset )
  );

  //-------------------------------------------------------------
  // End of component write_mask_M2
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:189
  // s.MSHR_alloc_in.addr    //= lambda: s.cachereq_M1.out.addr
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_MSHR_alloc_in_addr
    MSHR_alloc_in.addr = cachereq_M1__out.addr;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:198
  // s.MSHR_alloc_in.dirty_bits //= lambda: (s.write_mask_M1 & s.ctrl.dirty_evict_mask_M1)
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_MSHR_alloc_in_dirty_bits
    MSHR_alloc_in.dirty_bits = write_mask_M1 & ctrl.dirty_evict_mask_M1;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:54
  // s.MSHR_dealloc_mux_in_M0 //= lambda: p.CacheReqType(s.MSHR_dealloc_out.type_,
  //   s.MSHR_dealloc_out.opaque, s.MSHR_dealloc_out.addr, s.MSHR_dealloc_out.len,
  //   s.MSHR_dealloc_out.data)
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_MSHR_dealloc_mux_in_M0
    MSHR_dealloc_mux_in_M0 = { MSHR_dealloc_out.type_, MSHR_dealloc_out.opaque, MSHR_dealloc_out.addr, MSHR_dealloc_out.len, MSHR_dealloc_out.data };
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:237
  // m.in_ //= lambda: StructHit(s.tag_array_PU.hit | s.tag_array_PU.inval_hit,
  //                             s.tag_array_PU.hit_way)
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_hit_stall_engine_in_
    hit_stall_engine__in_ = { tag_array_PU__hit | tag_array_PU__inval_hit, tag_array_PU__hit_way };
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:183
  // m.in_ //= lambda: s.tag_arrays_M1[i].port0_rdata
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_0__in_
    tag_array_rdata_M1__in_[1'd0] = tag_arrays_M1__port0_rdata[1'( __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_0__in_ )];
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:183
  // m.in_ //= lambda: s.tag_arrays_M1[i].port0_rdata
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_1__in_
    tag_array_rdata_M1__in_[1'd1] = tag_arrays_M1__port0_rdata[1'( __const__i_at__lambda__s_dcaches_0__cacheDpath_tag_array_rdata_M1_1__in_ )];
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:232
  // s.write_mask_M1 //= lambda: s.tag_array_PU.tag_entires[s.ctrl.way_offset_M1].dty
  
  always_comb begin : _lambda__s_dcaches_0__cacheDpath_write_mask_M1
    write_mask_M1 = tag_array_PU__tag_entires[ctrl.way_offset_M1].dty;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:76
  // @update
  // def cachereq_M0_addr_bits_to_bitstruct():
  //   s.cachereq_M0.addr @= s.addr_mux_M0.out
  
  always_comb begin : cachereq_M0_addr_bits_to_bitstruct
    cachereq_M0.addr = addr_mux_M0__out;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:346
  // @update
  // def memreq_addr_bits_to_bitstruct():
  //   s.memreq_addr_bits @= s.memreq_addr_out
  
  always_comb begin : memreq_addr_bits_to_bitstruct
    memreq_addr_bits = memreq_addr_out;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:131
  // @update
  // def tag_array_struct_M0_bits_to_bitstruct():
  //   s.tag_array_wdata_M0 @= s.tag_array_struct_M0
  
  always_comb begin : tag_array_struct_M0_bits_to_bitstruct
    tag_array_wdata_M0 = tag_array_struct_M0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheDpathRTL.py:159
  // @update
  // def up_cachereq_addr_M1_forward_bits_to_bitstruct():
  //   s.cachereq_addr_M1_forward @= s.cachereq_M1.out.addr
  
  always_comb begin : up_cachereq_addr_M1_forward_bits_to_bitstruct
    cachereq_addr_M1_forward = cachereq_M1__out.addr;
  end

  assign pipeline_reg_M0__clk = clk;
  assign pipeline_reg_M0__reset = reset;
  assign pipeline_reg_M0__in_ = memresp_Y;
  assign pipeline_reg_M0__en = ctrl.reg_en_M0;
  assign status.amo_hit_M0 = MSHR_dealloc_out.amo_hit;
  assign cachereq_memresp_mux_M0__clk = clk;
  assign cachereq_memresp_mux_M0__reset = reset;
  assign cachereq_memresp_mux_M0__in_[0] = cachereq_Y;
  assign cachereq_memresp_mux_M0__in_[1] = MSHR_dealloc_mux_in_M0;
  assign cachereq_memresp_mux_M0__sel = ctrl.cachereq_memresp_mux_sel_M0;
  assign cachereq_M0.len = cachereq_memresp_mux_M0__out.len;
  assign cachereq_M0.type_ = cachereq_memresp_mux_M0__out.type_;
  assign cachereq_M0.opaque = cachereq_memresp_mux_M0__out.opaque;
  assign addr_mux_M0__clk = clk;
  assign addr_mux_M0__reset = reset;
  assign addr_mux_M0__in_[0] = cachereq_memresp_mux_M0__out.addr;
  assign addr_mux_M0__in_[1] = cachereq_addr_M1_forward;
  assign addr_mux_M0__sel = ctrl.addr_mux_sel_M0;
  assign replicator_M0__clk = clk;
  assign replicator_M0__reset = reset;
  assign replicator_M0__len_ = cachereq_memresp_mux_M0__out.len;
  assign replicator_M0__in_ = cachereq_memresp_mux_M0__out.data;
  assign replicator_M0__amo = ctrl.is_amo_M0;
  assign write_data_mux_M0__clk = clk;
  assign write_data_mux_M0__reset = reset;
  assign write_data_mux_M0__in_[0] = replicator_M0__out;
  assign write_data_mux_M0__in_[1] = pipeline_reg_M0__out.data;
  assign write_data_mux_M0__sel = ctrl.wdata_mux_sel_M0;
  assign cachereq_M0.data = write_data_mux_M0__out;
  assign update_tag_way_mux_M0__clk = clk;
  assign update_tag_way_mux_M0__reset = reset;
  assign update_tag_way_mux_M0__in_[0] = hit_way_M1_bypass;
  assign update_tag_way_mux_M0__in_[1] = ctrl.update_tag_way_M0;
  assign update_tag_way_mux_M0__sel = ctrl.update_tag_sel_M0;
  assign update_tag_unit__clk = clk;
  assign update_tag_unit__reset = reset;
  assign update_tag_unit__way = update_tag_way_mux_M0__out;
  assign update_tag_unit__offset = cachereq_M0.addr.offset;
  assign update_tag_unit__cmd = ctrl.update_tag_cmd_M0;
  assign update_tag_unit__refill_dty = MSHR_dealloc_out.dirty_bits;
  assign update_tag_unit__old_entries[0] = tag_entries_M1_bypass[0];
  assign update_tag_unit__old_entries[1] = tag_entries_M1_bypass[1];
  assign tag_array_idx_mux_M0__clk = clk;
  assign tag_array_idx_mux_M0__reset = reset;
  assign tag_array_idx_mux_M0__in_[0] = cachereq_M0.addr.index;
  assign tag_array_idx_mux_M0__in_[1] = ctrl.tag_array_init_idx_M0;
  assign tag_array_idx_mux_M0__sel = ctrl.tag_array_idx_sel_M0;
  assign tag_array_tag_mux_M0__clk = clk;
  assign tag_array_tag_mux_M0__reset = reset;
  assign tag_array_tag_mux_M0__in_[0] = cachereq_M0.addr.tag;
  assign tag_array_tag_mux_M0__in_[1] = update_tag_unit__out.tag;
  assign tag_array_tag_mux_M0__sel = ctrl.update_tag_sel_M0;
  assign tag_array_struct_M0.tag = tag_array_tag_mux_M0__out;
  assign tag_array_struct_M0.val = update_tag_unit__out.val;
  assign tag_array_struct_M0.dty = update_tag_unit__out.dty;
  assign status.memresp_type_M0 = pipeline_reg_M0__out.type_;
  assign status.cachereq_type_M0 = cachereq_memresp_mux_M0__out.type_;
  assign cachereq_M1__clk = clk;
  assign cachereq_M1__reset = reset;
  assign cachereq_M1__in_ = cachereq_M0;
  assign cachereq_M1__en = ctrl.reg_en_M1;
  assign flush_idx_M1__clk = clk;
  assign flush_idx_M1__reset = reset;
  assign flush_idx_M1__in_ = ctrl.tag_array_init_idx_M0;
  assign flush_idx_M1__en = ctrl.flush_init_reg_en_M1;
  assign dty_bits_mask_M1__clk = clk;
  assign dty_bits_mask_M1__reset = reset;
  assign dty_bits_mask_M1__in_ = MSHR_dealloc_out.dirty_bits;
  assign dty_bits_mask_M1__en = ctrl.reg_en_M1;
  assign replacement_bits_M1__clk = clk;
  assign replacement_bits_M1__reset = reset;
  assign replacement_bits_M1__raddr = cachereq_M1__out.addr.index;
  assign replacement_bits_M1__waddr = cachereq_M1__out.addr.index;
  assign replacement_bits_M1__wdata = ctrl.ctrl_bit_rep_wr_M0;
  assign replacement_bits_M1__wen = ctrl.ctrl_bit_rep_en_M1;
  assign tag_arrays_M1__clk[0] = clk;
  assign tag_arrays_M1__reset[0] = reset;
  assign tag_arrays_M1__clk[1] = clk;
  assign tag_arrays_M1__reset[1] = reset;
  assign tag_arrays_M1__port0_val[0] = ctrl.tag_array_val_M0[0:0];
  assign tag_arrays_M1__port0_type[0] = ctrl.tag_array_type_M0;
  assign tag_arrays_M1__port0_idx[0] = tag_array_idx_mux_M0__out;
  assign tag_arrays_M1__port0_wdata[0] = tag_array_wdata_M0;
  assign tag_arrays_M1__port0_wben[0] = ctrl.tag_array_wben_M0;
  assign tag_arrays_M1__port0_val[1] = ctrl.tag_array_val_M0[1:1];
  assign tag_arrays_M1__port0_type[1] = ctrl.tag_array_type_M0;
  assign tag_arrays_M1__port0_idx[1] = tag_array_idx_mux_M0__out;
  assign tag_arrays_M1__port0_wdata[1] = tag_array_wdata_M0;
  assign tag_arrays_M1__port0_wben[1] = ctrl.tag_array_wben_M0;
  assign tag_array_rdata_M1__clk[0] = clk;
  assign tag_array_rdata_M1__reset[0] = reset;
  assign tag_array_rdata_M1__clk[1] = clk;
  assign tag_array_rdata_M1__reset[1] = reset;
  assign tag_array_rdata_M1__en[0] = ctrl.stall_reg_en_M1;
  assign tag_array_rdata_M1__en[1] = ctrl.stall_reg_en_M1;
  assign MSHR_alloc_in.type_ = cachereq_M1__out.type_;
  assign MSHR_alloc_in.opaque = cachereq_M1__out.opaque;
  assign MSHR_alloc_in.data = cachereq_M1__out.data[31:0];
  assign MSHR_alloc_in.len = cachereq_M1__out.len;
  assign MSHR_alloc_in.repl = ctrl.way_offset_M1;
  assign MSHR_alloc_in.amo_hit = MSHR_alloc_in_amo_hit_bypass.hit;
  assign mshr__clk = clk;
  assign mshr__reset = reset;
  assign mshr__alloc_en = ctrl.MSHR_alloc_en;
  assign mshr__alloc_in = MSHR_alloc_in;
  assign status.MSHR_full = mshr__full;
  assign status.MSHR_empty = mshr__empty;
  assign mshr__dealloc_id = pipeline_reg_M0__out.opaque;
  assign mshr__dealloc_en = ctrl.MSHR_dealloc_en;
  assign MSHR_dealloc_out = mshr__dealloc_out;
  assign tag_array_PU__clk = clk;
  assign tag_array_PU__reset = reset;
  assign tag_array_PU__addr_tag = cachereq_M1__out.addr.tag;
  assign tag_array_PU__is_init = ctrl.is_init_M1;
  assign status.hit_M1 = tag_array_PU__hit;
  assign status.hit_way_M1 = tag_array_PU__hit_way;
  assign status.inval_hit_M1 = tag_array_PU__inval_hit;
  assign tag_array_PU__offset = cachereq_M1__out.addr.offset;
  assign status.ctrl_bit_dty_rd_line_M1 = tag_array_PU__line_dirty;
  assign status.ctrl_bit_dty_rd_word_M1 = tag_array_PU__word_dirty;
  assign tag_array_PU__en = ctrl.tag_processing_en_M1;
  assign tag_array_PU__tag_array[0] = tag_array_rdata_M1__out[0];
  assign tag_entries_M1_bypass[0] = tag_array_PU__tag_entires[0];
  assign tag_array_PU__tag_array[1] = tag_array_rdata_M1__out[1];
  assign tag_entries_M1_bypass[1] = tag_array_PU__tag_entires[1];
  assign hit_way_M1_bypass = tag_array_PU__hit_way;
  assign hit_stall_engine__clk = clk;
  assign hit_stall_engine__reset = reset;
  assign hit_stall_engine__en = ctrl.hit_stall_eng_en_M1;
  assign MSHR_alloc_in_amo_hit_bypass = hit_stall_engine__out;
  assign evict_way_mux_M1__clk = clk;
  assign evict_way_mux_M1__reset = reset;
  assign evict_way_mux_M1__sel = ctrl.way_offset_M1;
  assign evict_way_mux_M1__in_[0] = tag_array_rdata_M1__out[0].tag;
  assign evict_way_mux_M1__in_[1] = tag_array_rdata_M1__out[1].tag;
  assign flush_idx_mux_M1__clk = clk;
  assign flush_idx_mux_M1__reset = reset;
  assign flush_idx_mux_M1__in_[0] = cachereq_M1__out.addr.index;
  assign flush_idx_mux_M1__in_[1] = flush_idx_M1__out;
  assign flush_idx_mux_M1__sel = ctrl.flush_idx_mux_sel_M1;
  assign evict_addr_M1.tag = evict_way_mux_M1__out;
  assign evict_addr_M1.index = flush_idx_mux_M1__out;
  assign evict_addr_M1.offset = 4'd0;
  assign evict_mux_M1__clk = clk;
  assign evict_mux_M1__reset = reset;
  assign evict_mux_M1__in_[0] = cachereq_M1__out.addr;
  assign evict_mux_M1__in_[1] = evict_addr_M1;
  assign evict_mux_M1__sel = ctrl.evict_mux_sel_M1;
  assign cachereq_M1_2.addr = evict_mux_M1__out;
  assign data_array_wdata_M1 = cachereq_M1__out.data;
  assign index_offset_M1__clk = clk;
  assign index_offset_M1__reset = reset;
  assign index_offset_M1__index = cachereq_M1_2.addr.index;
  assign index_offset_M1__offset = ctrl.way_offset_M1;
  assign WbenGen_M1__clk = clk;
  assign WbenGen_M1__reset = reset;
  assign WbenGen_M1__offset = cachereq_M1__out.addr.offset;
  assign WbenGen_M1__len_ = cachereq_M1__out.len;
  assign WbenGen_M1__dty_mask = dty_bits_mask_M1__out;
  assign WbenGen_M1__cmd = ctrl.wben_cmd_M1;
  assign cachereq_M1_2.len = cachereq_M1__out.len;
  assign cachereq_M1_2.data = cachereq_M1__out.data;
  assign cachereq_M1_2.type_ = cachereq_M1__out.type_;
  assign cachereq_M1_2.opaque = cachereq_M1__out.opaque;
  assign status.ctrl_bit_rep_rd_M1 = replacement_bits_M1__rdata;
  assign status.cachereq_type_M1 = cachereq_M1__out.type_;
  assign status.MSHR_ptr = MSHR_dealloc_out.repl;
  assign status.MSHR_type = MSHR_dealloc_out.type_;
  assign status.amo_hit_way_M1 = MSHR_alloc_in_amo_hit_bypass.hit_way;
  assign cachereq_M2__clk = clk;
  assign cachereq_M2__reset = reset;
  assign cachereq_M2__in_ = cachereq_M1_2;
  assign cachereq_M2__en = ctrl.reg_en_M2;
  assign write_mask_M2__clk = clk;
  assign write_mask_M2__reset = reset;
  assign write_mask_M2__in_ = write_mask_M1;
  assign write_mask_M2__en = ctrl.reg_en_M2;
  assign data_array_M2__clk = clk;
  assign data_array_M2__reset = reset;
  assign data_array_M2__port0_val = ctrl.data_array_val_M1;
  assign data_array_M2__port0_type = ctrl.data_array_type_M1;
  assign data_array_M2__port0_idx = index_offset_M1__out;
  assign data_array_M2__port0_wdata = data_array_wdata_M1;
  assign data_array_M2__port0_wben = WbenGen_M1__out;
  assign stall_engine_M2__clk = clk;
  assign stall_engine_M2__reset = reset;
  assign stall_engine_M2__in_ = data_array_M2__port0_rdata;
  assign stall_engine_M2__en = ctrl.stall_reg_en_M2;
  assign read_data_mux_M2__clk = clk;
  assign read_data_mux_M2__reset = reset;
  assign read_data_mux_M2__in_[0] = stall_engine_M2__out;
  assign read_data_mux_M2__in_[1] = cachereq_M2__out.data;
  assign read_data_mux_M2__sel = ctrl.read_data_mux_sel_M2;
  assign data_size_mux_M2__clk = clk;
  assign data_size_mux_M2__reset = reset;
  assign data_size_mux_M2__in_ = read_data_mux_M2__out;
  assign data_size_mux_M2__en = ctrl.data_size_mux_en_M2;
  assign data_size_mux_M2__amo = ctrl.is_amo_M2;
  assign data_size_mux_M2__len_ = cachereq_M2__out.len;
  assign data_size_mux_M2__offset = cachereq_M2__out.addr.offset;
  assign mem_req_off_len_M2__clk = clk;
  assign mem_req_off_len_M2__reset = reset;
  assign mem_req_off_len_M2__len_i = cachereq_M2__out.len;
  assign mem_req_off_len_M2__offset_i = cachereq_M2__out.addr.offset;
  assign mem_req_off_len_M2__is_amo = ctrl.is_amo_M2;
  assign status.cachereq_type_M2 = cachereq_M2__out.type_;
  assign memreq_addr_out.tag = cachereq_M2__out.addr.tag;
  assign memreq_addr_out.index = cachereq_M2__out.addr.index;
  assign memreq_addr_out.offset = mem_req_off_len_M2__offset_o;
  assign memreq_M2.type_ = ctrl.memreq_type;
  assign memreq_M2.opaque = cachereq_M2__out.opaque;
  assign memreq_M2.addr = memreq_addr_bits;
  assign memreq_M2.len = mem_req_off_len_M2__len_o;
  assign memreq_M2.wr_mask = write_mask_M2__out;
  assign memreq_M2.data = read_data_mux_M2__out;
  assign cacheresp_M2.type_ = cachereq_M2__out.type_;
  assign cacheresp_M2.opaque = cachereq_M2__out.opaque;
  assign cacheresp_M2.test = ctrl.hit_M2;
  assign cacheresp_M2.len = cachereq_M2__out.len;
  assign cacheresp_M2.data = data_size_mux_M2__out;

endmodule


// PyMTL Component BlockingCacheRTL Definition
// Full name: BlockingCacheRTL__CacheReqType_MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32__CacheRespType_MemRespMsg__type__4__opaque_8__test_2__len_2__data_32__MemReqType_MemReqMsg_8_32_128_m1__35a1cc23a1d2d863__MemRespType_MemRespMsg_8_128_m1__c72937e2b7853c90__num_bytes_4096__associativity_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_mem/blocking_cache/BlockingCacheRTL.py

module BlockingCacheRTL__97559d5d0b1f6da0
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] mem_master_ifc__req__en ,
  output MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 mem_master_ifc__req__msg ,
  input logic [0:0] mem_master_ifc__req__rdy ,
  input logic [0:0] mem_master_ifc__resp__en ,
  input MemRespMsg_8_128_m1__c72937e2b7853c90 mem_master_ifc__resp__msg ,
  output logic [0:0] mem_master_ifc__resp__rdy ,
  input logic [0:0] mem_minion_ifc__req__en ,
  input MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 mem_minion_ifc__req__msg ,
  output logic [0:0] mem_minion_ifc__req__rdy ,
  output logic [0:0] mem_minion_ifc__resp__en ,
  output MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 mem_minion_ifc__resp__msg ,
  input logic [0:0] mem_minion_ifc__resp__rdy 
);
  //-------------------------------------------------------------
  // Component cacheCtrl
  //-------------------------------------------------------------

  logic [0:0] cacheCtrl__cachereq_en;
  logic [0:0] cacheCtrl__cachereq_rdy;
  logic [0:0] cacheCtrl__cacheresp_en;
  logic [0:0] cacheCtrl__cacheresp_rdy;
  logic [0:0] cacheCtrl__clk;
  StructCtrlSignals_4096_128_32_32_2__d7dbe132f9f2ed9f cacheCtrl__ctrl;
  logic [0:0] cacheCtrl__memreq_en;
  logic [0:0] cacheCtrl__memreq_rdy;
  logic [0:0] cacheCtrl__memresp_en;
  logic [0:0] cacheCtrl__memresp_rdy;
  logic [0:0] cacheCtrl__reset;
  StructDpathStatus_4096_128_32_32_2__d99bb19c96f0c7bf cacheCtrl__status;

  BlockingCacheCtrlRTL__p_BlockingCache_4096_128_32_32_2 cacheCtrl
  (
    .cachereq_en( cacheCtrl__cachereq_en ),
    .cachereq_rdy( cacheCtrl__cachereq_rdy ),
    .cacheresp_en( cacheCtrl__cacheresp_en ),
    .cacheresp_rdy( cacheCtrl__cacheresp_rdy ),
    .clk( cacheCtrl__clk ),
    .ctrl( cacheCtrl__ctrl ),
    .memreq_en( cacheCtrl__memreq_en ),
    .memreq_rdy( cacheCtrl__memreq_rdy ),
    .memresp_en( cacheCtrl__memresp_en ),
    .memresp_rdy( cacheCtrl__memresp_rdy ),
    .reset( cacheCtrl__reset ),
    .status( cacheCtrl__status )
  );

  //-------------------------------------------------------------
  // End of component cacheCtrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component cacheDpath
  //-------------------------------------------------------------

  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 cacheDpath__cachereq_Y;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 cacheDpath__cacheresp_M2;
  logic [0:0] cacheDpath__clk;
  StructCtrlSignals_4096_128_32_32_2__d7dbe132f9f2ed9f cacheDpath__ctrl;
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 cacheDpath__memreq_M2;
  MemRespMsg_8_128_m1__c72937e2b7853c90 cacheDpath__memresp_Y;
  logic [0:0] cacheDpath__reset;
  StructDpathStatus_4096_128_32_32_2__d99bb19c96f0c7bf cacheDpath__status;

  BlockingCacheDpathRTL__p_BlockingCache_4096_128_32_32_2 cacheDpath
  (
    .cachereq_Y( cacheDpath__cachereq_Y ),
    .cacheresp_M2( cacheDpath__cacheresp_M2 ),
    .clk( cacheDpath__clk ),
    .ctrl( cacheDpath__ctrl ),
    .memreq_M2( cacheDpath__memreq_M2 ),
    .memresp_Y( cacheDpath__memresp_Y ),
    .reset( cacheDpath__reset ),
    .status( cacheDpath__status )
  );

  //-------------------------------------------------------------
  // End of component cacheDpath
  //-------------------------------------------------------------

  assign cacheDpath__clk = clk;
  assign cacheDpath__reset = reset;
  assign cacheDpath__cachereq_Y = mem_minion_ifc__req__msg;
  assign mem_minion_ifc__resp__msg = cacheDpath__cacheresp_M2;
  assign cacheDpath__memresp_Y = mem_master_ifc__resp__msg;
  assign mem_master_ifc__req__msg = cacheDpath__memreq_M2;
  assign cacheCtrl__clk = clk;
  assign cacheCtrl__reset = reset;
  assign cacheCtrl__cachereq_en = mem_minion_ifc__req__en;
  assign mem_minion_ifc__req__rdy = cacheCtrl__cachereq_rdy;
  assign cacheCtrl__memresp_en = mem_master_ifc__resp__en;
  assign mem_master_ifc__resp__rdy = cacheCtrl__memresp_rdy;
  assign mem_minion_ifc__resp__en = cacheCtrl__cacheresp_en;
  assign cacheCtrl__cacheresp_rdy = mem_minion_ifc__resp__rdy;
  assign mem_master_ifc__req__en = cacheCtrl__memreq_en;
  assign cacheCtrl__memreq_rdy = mem_master_ifc__req__rdy;
  assign cacheCtrl__status = cacheDpath__status;
  assign cacheDpath__ctrl = cacheCtrl__ctrl;

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// Full name: PipeQueue1EntryRTL__EntryType_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__a2c155c77a0d04b2
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_fpus_0__fp_addsub_in_q_q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_fpus_0__fp_addsub_in_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// Full name: PipeQueueRTL__EntryType_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__86a7c3aeb6713f23
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 q__deq__ret;
  logic [0:0] q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__a2c155c77a0d04b2 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// Full name: PipeQueue1EntryRTL__EntryType_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__34c6e99e9b0fdfd1
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuRespMsg_8_32__opaque_8__result_32__fexc_5 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_fpus_0__fp_addsub_out_q_0__q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_fpus_0__fp_addsub_out_q_0__q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// Full name: PipeQueueRTL__EntryType_FpuRespMsg_8_32__opaque_8__result_32__fexc_5__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__f55b0708e52dd198
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuRespMsg_8_32__opaque_8__result_32__fexc_5 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 q__deq__ret;
  logic [0:0] q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__34c6e99e9b0fdfd1 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL VerilogPlaceholder DW_fp_addsub_wrapper Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_addsub.py

//***********************************************************
// Pickled source file of placeholder DW_fp_addsub_wrapper_noparam
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder DW_fp_addsub_wrapper
//-----------------------------------------------------------

`ifndef DW_FP_ADDSUB_WRAPPER
`define DW_FP_ADDSUB_WRAPPER

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component DW_fp_addsub_wrapper_noparam.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component DW_fp_addsub_wrapper_noparam

`line 1 "fpu/dw_srcs/DW_fp_addsub.v" 0
////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2005 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Alexandre Tenca (Jan 2006)
//
// VERSION:   Verilog Simulation Model for FP adder/subtractor
//
// DesignWare_version: db3a591c
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------------
//
// ABSTRACT: Floating-point two-operand Adder/Subtractor
//           Computes the addition/subtraction of two FP numbers. 
//           The format of the FP numbers is defined by the number of bits 
//           in the significand (sig_width) and the number of bits in the 
//           exponent (exp_width).
//           The total number of bits in the FP number is sig_width+exp_width+1
//           since the sign bit takes the place of the MS bits in the significand
//           which is always 1 (unless the number is a denormal; a condition 
//           that can be detected testing the exponent value).
//           The output is a FP number and status flags with information about
//           special number representations and exceptions. 
//           Subtraction is forced when op=1.
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              ieee_compliance 0 or 1 (default 0)
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              b               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              rnd             3 bits
//                              rounding mode
//              op              1 bit
//                              add/sub control: 0 for add - 1 for sub
//
//              Output ports    Size & Description
//              ===========     ==================
//              z               (sig_width + exp_width + 1) bits
//                              Floating-point Number result
//              status          byte
//                              info about FP results
//
// MODIFIED:
//        7/21/2006: 
//           - includes manipulation of inexact bit
//           - fixes value assigned to HugeInfinity when rnd=4 (up) RND_eval
//           - fixes some special cases when rounding close to inf and zero
//        12/14/06: modifications based on code review by Kyung-Nam Han
//
//-------------------------------------------------------------------------------

module DW_fp_addsub (a, b, rnd, op, z, status);
parameter sig_width=23;
parameter exp_width=8;  
parameter ieee_compliance=0;                    

// declaration of inputs and outputs
input  [sig_width+exp_width:0] a,b;
input  [2:0] rnd;
input  op;
output [7:0] status;
output [sig_width+exp_width:0] z;

    // synopsys translate_off

  //-------------------------------------------------------------------------
  // Parameter legality check
  //-------------------------------------------------------------------------
  
 
  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;
    
  
    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end
  
    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end
  
    if ( (ieee_compliance < 0) || (ieee_compliance > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter ieee_compliance (legal range: 0 to 1)",
	ieee_compliance );
    end
  
    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check 




function [4-1:0] RND_eval;

  input [2:0] RND;
  input [0:0] Sign;
  input [0:0] L,R,STK;


  begin
  RND_eval[0] = 0;
  RND_eval[1] = R|STK;
  RND_eval[2] = 0;
  RND_eval[3] = 0;
  if ($time > 0)
  case (RND)
    3'b000:
    begin
      RND_eval[0] = R&(L|STK);
      RND_eval[2] = 1;
      RND_eval[3] = 0;
    end
    3'b001:
    begin
      RND_eval[0] = 0;
      RND_eval[2] = 0;
      RND_eval[3] = 0;
    end
    3'b010:
    begin
      RND_eval[0] = ~Sign & (R|STK);
      RND_eval[2] = ~Sign;
      RND_eval[3] = ~Sign;
    end
    3'b011:
    begin
      RND_eval[0] = Sign & (R|STK);
      RND_eval[2] = Sign;
      RND_eval[3] = Sign;
    end
    3'b100:
    begin
      RND_eval[0] = R;
      RND_eval[2] = 1;
      RND_eval[3] = 0;
    end
    3'b101:
    begin
      RND_eval[0] = R|STK;
      RND_eval[2] = 1;
      RND_eval[3] = 1;
    end
    default:
      $display("Error! illegal rounding mode.\n");
  endcase
  end

endfunction


// definitions used in the code

reg [8    -1:0] status_int;
reg [(exp_width + sig_width):0] z_temp,Large,Small;
reg [0:0] swap,subtract,STK;
reg [exp_width-1:0] E_Large,E_Small,E_Diff; // Exponents.
reg [sig_width-1:0] F_Large,F_Small;        // Fractions.
reg [exp_width+1:0] E_Comp;                 // The biggest possible exponent
reg [((sig_width + 3 + 3        ) - 2):0] M_Large,M_Small;       // The Mantissa numbers.
reg [((sig_width + 3 + 3        ) - 2):0] M_Z;                   // The Mantissa numbers.
reg [4-1:0] RND_val;         // Values returned by RND_eval function.
reg [(exp_width + sig_width):0] NaNFp;          // NaN FP number
reg [(exp_width + sig_width):0] b_int;          // internal value of b
reg Denormal_Large;                  // signals a denormal as a large operand
reg Denormal_Small;                  // signals a denormal as a small operand

// main process of information
always @(a or b or rnd or op)
begin
  NaNFp = {1'b0,{exp_width{1'b1}},{sig_width-1{1'b0}},1'b1};
  status_int = 0;
  b_int = b;
  b_int[(exp_width + sig_width)] = (op == 1)?~b[(exp_width + sig_width)]:b[(exp_width + sig_width)];
  subtract = a[(exp_width + sig_width)] ^ b_int[(exp_width + sig_width)];

  swap = a[((exp_width + sig_width) - 1):0] < b[((exp_width + sig_width) - 1):0];
  Large = swap ? b_int : a;
  Small = swap ? a : b_int;
  E_Large = Large[((exp_width + sig_width) - 1):sig_width];
  E_Small = Small[((exp_width + sig_width) - 1):sig_width];
  F_Large = Large[(sig_width - 1):0];
  F_Small = Small[(sig_width - 1):0];

  // 
  // NaN Input
  // 
  if ((((E_Large === ((((1 << (exp_width-1)) - 1) * 2) + 1)) && (F_Large !== 0)) ||
      ((E_Small === ((((1 << (exp_width-1)) - 1) * 2) + 1)) && (F_Large !== 0))) && ieee_compliance === 1)
    begin
      z_temp = NaNFp;
      status_int[2] = 1;
    end
  //
  // Infinity Input
  //
  else 
    if (E_Large === ((((1 << (exp_width-1)) - 1) * 2) + 1) && (F_Large === 0 || ieee_compliance === 0)) 
      begin
   	status_int[1] = 1;
        z_temp = Large;
        // zero out the fractional part
        z_temp[(sig_width - 1):0] = 0;
   	// Watch out for Inf-Inf !
   	if ( (E_Small === ((((1 << (exp_width-1)) - 1) * 2) + 1)) && (F_Large === 0 || ieee_compliance === 0) && (subtract === 1) )
    	  begin
            status_int[2] = 1;
            if (ieee_compliance)   
              begin
                status_int[1] = 0;
                z_temp = NaNFp;
              end
            else
              z_temp[(exp_width + sig_width)] = 0;  // use positive inf. to represent NaN
   	  end
      end
    //
    // Zero Input (or denormal input when ieee_compliance == 0)
    //
    else 
      if (E_Small == 0 && ((ieee_compliance == 0) || (F_Small == 0)))
        begin
           z_temp = Large;
           // watch out for 0-0 !
           if (E_Large === 0 && ((ieee_compliance == 0) || (F_Large == 0)))
      	     begin
      	       status_int[0] = 1;
               // Set the fraction to 000...
               z_temp = 0;
               if (subtract) 
                 if (rnd === 3'b011) z_temp[(exp_width + sig_width)] = 1;
                 else                z_temp[(exp_width + sig_width)] = 0;
               else                  z_temp[(exp_width + sig_width)] = a[(exp_width + sig_width)];
             end
        end
      //
      // Normal Inputs
      //
      else
        begin
          // Detect the denormal input case
          if ((E_Large == 0) && (F_Large != 0)) 
            begin
              // M_Large contains the Mantissa of denormal value
              M_Large = {2'b00,F_Large,3'b000};
              Denormal_Large = 1'b1;
            end
          else
            begin
              // M_Large is the Mantissa for Large number
              M_Large = {2'b01,F_Large,3'b000};
              Denormal_Large = 1'b0;
            end
   
          if ((E_Small == 0) && (F_Small != 0)) 
            begin
              // M_Small contains the Mantissa of denormal value
              M_Small = {2'b00,F_Small,3'b000};
              Denormal_Small = 1'b1;
            end
          else
            begin
              // M_Small is the Mantissa for Small number
              M_Small = {2'b01,F_Small,3'b000};
              Denormal_Small = 1'b0;
            end

          // When one of the inputs is a denormal, we need to
          // compensate because the exponent for a denormal is
          // actually 1, and not 0.
          if ((Denormal_Large ^ Denormal_Small) == 1'b1) 
            E_Diff = E_Large - E_Small - 1;
	  else
            E_Diff = E_Large - E_Small;

          // Shift right by E_Diff for Small number: M_Small.
          STK = 0;
          while ( (M_Small != 0) && (E_Diff != 0) )
            begin
              STK = M_Small[0] | STK;
              M_Small = M_Small >> 1;
              E_Diff = E_Diff - 1;
            end
          M_Small[0] = M_Small[0] | STK;

          // Compute M_Z result: a +/- b
          if (subtract === 0) M_Z = M_Large + M_Small;
          else M_Z = M_Large - M_Small;

          // ----------------------------------------------------------
          //  Post Process
          // -----------------------------------------------------------
          E_Comp = {2'b00, E_Large};

          //
          // Exact 0 special case after the computation.
          //
            if (M_Z === 0)
              begin
                status_int[0] = 1;
                z_temp = 0;
                // If rounding mode is -Infinity, the sign bit is 1; 
                // otherwise the sign bit is 0.
                if (rnd === 3'b011) z_temp[(exp_width + sig_width)] = 1;
              end
            //
            // Normal case after the computation.
            //
            else
              begin
                // Normalize the Mantissa for computation overflow case.
                if (M_Z[((sig_width + 3 + 3        ) - 2)] === 1)
                  begin
                    E_Comp = E_Comp + 1;
                    STK = M_Z[0];
                    M_Z = M_Z >> 1;
                    M_Z[0] = M_Z[0] | STK;
                  end

                // Normalize the Mantissa for leading zero case.
                while ( (M_Z[((sig_width + 3 + 3        ) - 2)-1] === 0) && (E_Comp > 1) )
                  begin
                    E_Comp = E_Comp - 1;
                    M_Z = M_Z << 1;
                  end

                // test if the output of the normalization unit is still not normalized
                if (M_Z[((sig_width + 3 + 3        ) - 2):((sig_width + 3 + 3        ) - 2)-1] === 0)
	          if (ieee_compliance == 1) 
                    begin
                      z_temp = {Large[(exp_width + sig_width)],{exp_width{1'b0}}, M_Z[((sig_width + 3 + 3        ) - 2)-2:3]};
                      status_int[3] = 0;
                      if ((STK == 1) || (M_Z[(3 - 1):0] != 0))
                        status_int[5] = 1;
                      if (M_Z[((sig_width + 3 + 3        ) - 2)-2:3] == 0) 
                        status_int[0] = 1; 
                    end
                  else // when denormal is not used --> becomes zero or minFP
                    begin
                      if ((rnd == 2 & ~Large[(exp_width + sig_width)]) | 
                          (rnd == 3 & Large[(exp_width + sig_width)]) | 
                          (rnd == 5)) 
                        begin
                          z_temp = {Large[(exp_width + sig_width)],{exp_width-1{1'b0}},{1'b1},{sig_width{1'b0}}};
                          status_int[0] = 0;
                        end
                      else
                        begin
                          z_temp = {Large[(exp_width + sig_width)],{exp_width{1'b0}}, {sig_width{1'b0}}};
                          status_int[0] = 1;
                        end
                      status_int[3] = 1;
                      status_int[5] = 1;
                    end
                else
                  begin
                    // Round M_Z according to the rounding mode (rnd).
                    RND_val = RND_eval(rnd, Large[(exp_width + sig_width)], M_Z[3], M_Z[(3 - 1)], (|{M_Z[1:0]}));

                    if (RND_val[0] === 1) M_Z = M_Z + (1<<3);
 
                    // Normalize the Mantissa for overflow case after rounding.
                    if ( (M_Z[((sig_width + 3 + 3        ) - 2)] === 1) )
                      begin
                        E_Comp = E_Comp + 1;
                        M_Z = M_Z >> 1;
                      end

                    //
                    // Huge
                    //
                    if (E_Comp >= ((((1 << (exp_width-1)) - 1) * 2) + 1))
                      begin
                        status_int[4] = 1;
                        status_int[5] = 1;
                        if(RND_val[2] === 1)
                          begin
                            // Infinity
                            M_Z[((sig_width + 3 + 3        ) - 2)-2:3] = 0;
                            E_Comp = ((((1 << (exp_width-1)) - 1) * 2) + 1);
                            status_int[1] = 1;
                          end
                        else
                          begin
                            // MaxNorm
                            E_Comp = ((((1 << (exp_width-1)) - 1) * 2) + 1) - 1;
                            M_Z[((sig_width + 3 + 3        ) - 2)-2:3] = -1;
                          end
                      end
                    //
                    // Tiny or Denormal
                    //
                    else 
                      if (E_Comp <= 0) E_Comp = 0 + 1;
    
                    //
                    // Normal  (continues)
                    //
                    status_int[5] = status_int[5] | RND_val[1];
                    // Reconstruct the floating point format.
                    z_temp = {Large[(exp_width + sig_width)],E_Comp[exp_width-1:0],M_Z[((sig_width + 3 + 3        ) - 2)-2:3]};
                  end //  result is normal value 
              end  // Normal computation case
        end    // non-special inputs
end

assign status = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0) || (^(rnd ^ rnd) !== 1'b0) || (^(op ^ op) !== 1'b0)) ? {8'bx} : status_int;
assign z = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0) || (^(rnd ^ rnd) !== 1'b0) || (^(op ^ op) !== 1'b0)) ? {sig_width+exp_width+1{1'bx}} : z_temp;

    // synopsys translate_on

endmodule


`endif /* DW_FP_ADDSUB_WRAPPER */

//-----------------------------------------------------------
// Wrapper of placeholder DW_fp_addsub_wrapper_noparam
//-----------------------------------------------------------

`ifndef DW_FP_ADDSUB_WRAPPER_NOPARAM
`define DW_FP_ADDSUB_WRAPPER_NOPARAM

module DW_fp_addsub_wrapper_noparam
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] a ,
  input logic [32-1:0] b ,
  input logic [1-1:0] op ,
  input logic [3-1:0] rnd ,
  output logic [8-1:0] status ,
  output logic [32-1:0] z 
);
  DW_fp_addsub
  #(
    .sig_width( 23 ),
    .exp_width( 8 ),
    .ieee_compliance( 1 )
  ) v
  (
    .a( a ),
    .b( b ),
    .op( op ),
    .rnd( rnd ),
    .status( status ),
    .z( z )
  );
endmodule

`endif /* DW_FP_ADDSUB_WRAPPER_NOPARAM */



// PyMTL Component DW_fp_addsub Definition
// Full name: DW_fp_addsub__nstages_4__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_addsub.py

module DW_fp_addsub__5367206e2cb8f6c7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  localparam logic [2:0] __const__nstages_at_up_queues  = 3'd4;
  localparam logic [2:0] __const__DW_FRND_NE  = 3'd0;
  localparam logic [2:0] __const__DW_FRND_TZ  = 3'd1;
  localparam logic [2:0] __const__DW_FRND_DN  = 3'd3;
  localparam logic [2:0] __const__DW_FRND_UP  = 3'd2;
  localparam logic [2:0] __const__DW_FRND_MM  = 3'd4;
  localparam logic [0:0] __const__DW_ADDSUB_ADD  = 1'd0;
  localparam logic [0:0] __const__DW_ADDSUB_SUB  = 1'd1;
  localparam logic [7:0] __const__DW_FEXC_NX  = 8'd32;
  localparam logic [7:0] __const__DW_FEXC_UF  = 8'd8;
  localparam logic [7:0] __const__DW_FEXC_OF  = 8'd16;
  localparam logic [7:0] __const__DW_FEXC_DZ  = 8'd128;
  localparam logic [7:0] __const__DW_FEXC_NV  = 8'd4;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_val;
  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [0:0] in_q__count;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  PipeQueueRTL__86a7c3aeb6713f23 in_q
  (
    .clk( in_q__clk ),
    .count( in_q__count ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component out_q[0:2]
  //-------------------------------------------------------------

  logic [0:0] out_q__clk [0:2];
  logic [0:0] out_q__count [0:2];
  logic [0:0] out_q__reset [0:2];
  logic [0:0] out_q__deq__en [0:2];
  logic [0:0] out_q__deq__rdy [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__deq__ret [0:2];
  logic [0:0] out_q__enq__en [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__enq__msg [0:2];
  logic [0:0] out_q__enq__rdy [0:2];

  PipeQueueRTL__f55b0708e52dd198 out_q__0
  (
    .clk( out_q__clk[0] ),
    .count( out_q__count[0] ),
    .reset( out_q__reset[0] ),
    .deq__en( out_q__deq__en[0] ),
    .deq__rdy( out_q__deq__rdy[0] ),
    .deq__ret( out_q__deq__ret[0] ),
    .enq__en( out_q__enq__en[0] ),
    .enq__msg( out_q__enq__msg[0] ),
    .enq__rdy( out_q__enq__rdy[0] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__1
  (
    .clk( out_q__clk[1] ),
    .count( out_q__count[1] ),
    .reset( out_q__reset[1] ),
    .deq__en( out_q__deq__en[1] ),
    .deq__rdy( out_q__deq__rdy[1] ),
    .deq__ret( out_q__deq__ret[1] ),
    .enq__en( out_q__enq__en[1] ),
    .enq__msg( out_q__enq__msg[1] ),
    .enq__rdy( out_q__enq__rdy[1] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__2
  (
    .clk( out_q__clk[2] ),
    .count( out_q__count[2] ),
    .reset( out_q__reset[2] ),
    .deq__en( out_q__deq__en[2] ),
    .deq__rdy( out_q__deq__rdy[2] ),
    .deq__ret( out_q__deq__ret[2] ),
    .enq__en( out_q__enq__en[2] ),
    .enq__msg( out_q__enq__msg[2] ),
    .enq__rdy( out_q__enq__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component out_q[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component unit
  //-------------------------------------------------------------

  logic [31:0] unit__a;
  logic [31:0] unit__b;
  logic [0:0] unit__clk;
  logic [0:0] unit__op;
  logic [0:0] unit__reset;
  logic [2:0] unit__rnd;
  logic [7:0] unit__status;
  logic [31:0] unit__z;

  DW_fp_addsub_wrapper_noparam unit
  (
    .a( unit__a ),
    .b( unit__b ),
    .clk( unit__clk ),
    .op( unit__op ),
    .reset( unit__reset ),
    .rnd( unit__rnd ),
    .status( unit__status ),
    .z( unit__z )
  );

  //-------------------------------------------------------------
  // End of component unit
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_addsub.py:109
  // @update
  // def comb():
  // 
  //   # default
  //   s.out_val.opaque @= 0
  //   s.out_val.result @= 0
  //   s.out_val.fexc   @= 0
  // 
  //   s.unit.a    @= 0
  //   s.unit.b    @= 0
  //   s.unit.op   @= 0
  //   s.unit.rnd  @= 0
  // 
  //   if s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy:
  // 
  //     s.unit.a @= s.in_q.deq.ret.op_a
  //     s.unit.b @= s.in_q.deq.ret.op_b
  // 
  //     # rounding mode
  //     if    s.in_q.deq.ret.frnd == FpuReqType.FRND_NE:
  //       s.unit.rnd @= DW_FRND_NE
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_TZ:
  //       s.unit.rnd @= DW_FRND_TZ
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_DN:
  //       s.unit.rnd @= DW_FRND_DN
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_UP:
  //       s.unit.rnd @= DW_FRND_UP
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_MM:
  //       s.unit.rnd @= DW_FRND_MM
  // 
  //     # op type
  //     if    s.in_q.deq.ret.type_ == FpuReqType.TYPE_FADD:
  //       s.unit.op @= DW_ADDSUB_ADD
  //     elif  s.in_q.deq.ret.type_ == FpuReqType.TYPE_FSUB:
  //       s.unit.op @= DW_ADDSUB_SUB
  // 
  //     s.out_val.opaque @= s.in_q.deq.ret.opaque
  //     s.out_val.result @= s.unit.z
  // 
  //     if s.unit.status & DW_FEXC_NX:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NX
  //     if s.unit.status & DW_FEXC_UF:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_UF
  //     if s.unit.status & DW_FEXC_OF:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_OF
  //     if s.unit.status & DW_FEXC_DZ:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_DZ
  //     if s.unit.status & DW_FEXC_NV:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NV
  
  always_comb begin : comb
    out_val.opaque = 8'd0;
    out_val.result = 32'd0;
    out_val.fexc = 5'd0;
    unit__a = 32'd0;
    unit__b = 32'd0;
    unit__op = 1'd0;
    unit__rnd = 3'd0;
    if ( in_q__deq__rdy & out_q__enq__rdy[2'd0] ) begin
      unit__a = in_q__deq__ret.op_a;
      unit__b = in_q__deq__ret.op_b;
      if ( in_q__deq__ret.frnd == 3'd0 ) begin
        unit__rnd = 3'( __const__DW_FRND_NE );
      end
      else if ( in_q__deq__ret.frnd == 3'd1 ) begin
        unit__rnd = 3'( __const__DW_FRND_TZ );
      end
      else if ( in_q__deq__ret.frnd == 3'd2 ) begin
        unit__rnd = 3'( __const__DW_FRND_DN );
      end
      else if ( in_q__deq__ret.frnd == 3'd3 ) begin
        unit__rnd = 3'( __const__DW_FRND_UP );
      end
      else if ( in_q__deq__ret.frnd == 3'd4 ) begin
        unit__rnd = 3'( __const__DW_FRND_MM );
      end
      if ( in_q__deq__ret.type_ == 4'd1 ) begin
        unit__op = 1'( __const__DW_ADDSUB_ADD );
      end
      else if ( in_q__deq__ret.type_ == 4'd2 ) begin
        unit__op = 1'( __const__DW_ADDSUB_SUB );
      end
      out_val.opaque = in_q__deq__ret.opaque;
      out_val.result = unit__z;
      if ( unit__status & 8'( __const__DW_FEXC_NX ) ) begin
        out_val.fexc = out_val.fexc | 5'd1;
      end
      if ( unit__status & 8'( __const__DW_FEXC_UF ) ) begin
        out_val.fexc = out_val.fexc | 5'd2;
      end
      if ( unit__status & 8'( __const__DW_FEXC_OF ) ) begin
        out_val.fexc = out_val.fexc | 5'd4;
      end
      if ( unit__status & 8'( __const__DW_FEXC_DZ ) ) begin
        out_val.fexc = out_val.fexc | 5'd8;
      end
      if ( unit__status & 8'( __const__DW_FEXC_NV ) ) begin
        out_val.fexc = out_val.fexc | 5'd16;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_addsub.py:89
  // @update
  // def up_queues():
  // 
  //   # in_q <-> out_q[ 0 ]
  //   s.in_q.deq.en        @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.en  @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.msg @= s.out_val
  // 
  //   # chian middle out_q
  //   if nstages > 2:
  //     for i in range( nstages - 2 ):
  //       s.out_q[ i   ].deq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.msg @= s.out_q[ i ].deq.ret
  // 
  //   # out_q[ nstages-2 ] <-> s.resp
  //   s.out_q[ nstages-2 ].deq.en @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.en                   @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.msg                  @= s.out_q[ nstages-2 ].deq.ret
  
  always_comb begin : up_queues
    in_q__deq__en = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__en[2'd0] = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__msg[2'd0] = out_val;
    if ( 3'( __const__nstages_at_up_queues ) > 3'd2 ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__nstages_at_up_queues ) - 3'd2; i += 1'd1 ) begin
        out_q__deq__en[2'(i)] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__en[2'(i) + 2'd1] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__msg[2'(i) + 2'd1] = out_q__deq__ret[2'(i)];
      end
    end
    out_q__deq__en[3'( __const__nstages_at_up_queues ) - 3'd2] = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__en = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__msg = out_q__deq__ret[3'( __const__nstages_at_up_queues ) - 3'd2];
  end

  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign in_q__enq__en = req__en;
  assign in_q__enq__msg = req__msg;
  assign req__rdy = in_q__enq__rdy;
  assign unit__clk = clk;
  assign unit__reset = reset;
  assign out_q__clk[0] = clk;
  assign out_q__reset[0] = reset;
  assign out_q__clk[1] = clk;
  assign out_q__reset[1] = reset;
  assign out_q__clk[2] = clk;
  assign out_q__reset[2] = reset;

endmodule


// PyMTL Component NormalQueue1EntryRTL Definition
// Full name: NormalQueue1EntryRTL__EntryType_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueue1EntryRTL__34c6e99e9b0fdfd1
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuRespMsg_8_32__opaque_8__result_32__fexc_5 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:453
  // s.deq.rdy //= lambda: ~s.reset & s.full
  
  always_comb begin : _lambda__s_fpus_0__fp_addsub_resp_q_q_deq_rdy
    deq__rdy = ( ~reset ) & full;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:452
  // s.enq.rdy //= lambda: ~s.reset & ~s.full
  
  always_comb begin : _lambda__s_fpus_0__fp_addsub_resp_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ~full );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:455
  // @update_ff
  // def ff_normal1():
  //   s.full <<= ~s.reset & ( ~s.deq.en & (s.enq.en | s.full) )
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_normal1
    full <= ( ~reset ) & ( ( ~deq__en ) & ( enq__en | full ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_FpuRespMsg_8_32__opaque_8__result_32__fexc_5__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueRTL__f55b0708e52dd198
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuRespMsg_8_32__opaque_8__result_32__fexc_5 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 q__deq__ret;
  logic [0:0] q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 q__enq__msg;
  logic [0:0] q__enq__rdy;

  NormalQueue1EntryRTL__34c6e99e9b0fdfd1 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL VerilogPlaceholder DW_fp_cmp_wrapper Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cmp.py

//***********************************************************
// Pickled source file of placeholder DW_fp_cmp_wrapper_noparam
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder DW_fp_cmp_wrapper
//-----------------------------------------------------------

`ifndef DW_FP_CMP_WRAPPER
`define DW_FP_CMP_WRAPPER

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component DW_fp_cmp_wrapper_noparam.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component DW_fp_cmp_wrapper_noparam

`line 1 "fpu/dw_srcs/DW_fp_cmp.v" 0
////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2006 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Alexandre Tenca, March 2006
//
// VERSION:   Verilog Simulation Model for FP Comparator
//
// DesignWare_version: 58e94b19
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------------
//
// ABSTRACT: Floating-point Comparator
//           Compares two FP numbers and generates outputs that indicate when 
//           A>B, A<B and A=B. The component also provides outputs for MAX and 
//           MIN values, with corresponding status flags.
//
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              ieee_compliance 0 or 1
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              b               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              zctr            1 bit
//                              defines the min/max operation of z0 and z1
//
//              Output ports    Size & Description
//              ===========     ==================
//              aeqb            1 bit
//                              has value 1 when a=b
//              altb            1 bit
//                              has value 1 when a<b
//              agtb            1 bit
//                              has value 1 when a>b
//              unordered       1 bit
//                              one of the inputs is NaN
//              z0              (sig_width + exp_width + 1) bits
//                              Floating-point Number that has max(a,b) when
//                              zctr=1, and min(a,b) otherwise
//              z1              (sig_width + exp_width + 1) bits
//                              Floating-point Number that has max(a,b) when
//                              zctr=0, and min(a,b) otherwise
//              status0         byte
//                              info about FP value in z0
//              status1         byte
//                              info about FP value in z1
//
// MODIFIED: 
//    4/18 - the ieee_compliance parameter is also controlling the use of nans
//           When 0, the component behaves as the MC component (no denormals
//           and no NaNs).
//
//-------------------------------------------------------------------------------

module DW_fp_cmp (a, b, zctr, aeqb, altb, agtb, unordered, z0, z1, status0, status1);
parameter sig_width=23;
parameter exp_width=8;
parameter ieee_compliance=0;

// declaration of inputs and outputs
input  [sig_width + exp_width:0] a,b;
input  zctr;
output aeqb, altb, agtb, unordered;
output [sig_width + exp_width:0] z0, z1;
output [7:0] status0, status1;

// synopsys translate_off
  //-------------------------------------------------------------------------
  // Parameter legality check
  //-------------------------------------------------------------------------
  
 
  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;
    
  
    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end
  
    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end
  
    if ( (ieee_compliance < 0) || (ieee_compliance > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter ieee_compliance (legal range: 0 to 1)",
	ieee_compliance );
    end
  
    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check 


// definitions used in the code
 
reg [0:0] sign;
reg [exp_width-1:0] Ea,Eb;
reg [sig_width:0] Ma,Mb;
reg [sig_width-1:0] Fa,Fb;
reg [(exp_width + sig_width):0] z0_int,z1_int;
reg [8    -1:0] status0_int,status1_int;
reg [0:0] agtb_int,aeqb_int,altb_int, unordered_int;
reg [1:0] chk;
reg zer_a, zer_b;

always @(a or b or zctr) 
begin

  Ea = a[((exp_width + sig_width) - 1):sig_width];
  Eb = b[((exp_width + sig_width) - 1):sig_width];
  Fa = a[(sig_width - 1):0];
  Fb = b[(sig_width - 1):0];
  zer_a = 0;
  zer_b = 0;

  if (ieee_compliance === 1 && Ea === 0)
    begin
      zer_a = Fa === 0;
      Ma = {1'b0,a[(sig_width - 1):0]};
    end
  else if (ieee_compliance === 0 && Ea === 0)
    begin
      Ma = 0;
      zer_a = 1;
    end
  else
    Ma = {1'b1,a[(sig_width - 1):0]};
  if (ieee_compliance === 1 && Eb === 0)
    begin
      zer_b = Fb === 0;
      Mb = {1'b0,b[(sig_width - 1):0]};
    end
  else if (ieee_compliance === 0 && Eb === 0)
    begin
      Mb = 0;
      zer_b = 1;
    end
  else
    Mb = {1'b1,b[(sig_width - 1):0]};
  
  sign = (a[(exp_width + sig_width)] && !zer_a) ^ (b[(exp_width + sig_width)] && !zer_b);

  status0_int = 0;
  status1_int = 0;
  z0_int = 0;
  z1_int = 0;
  agtb_int = 0;
  aeqb_int = 0;
  altb_int = 0;
  unordered_int = 0;

  //
  // NaN input
  //
  if (((Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fa !== 0)||		// a or b are NaN.
       (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fb !== 0)) && (ieee_compliance === 1))
  begin
    // nothing to do
    // z0 and z1 get the values of a and b
    unordered_int = 1;
  end
  //
  // Infinity Input
  //
  else if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1))	// a and b are Infinity.
  begin
    if (sign === 0) aeqb_int = 1;
    else if (a[(exp_width + sig_width)] === 0) agtb_int = 1;
    else altb_int = 1;
  end
  else if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1))			// Only a is Infinity.
  begin
    if (a[(exp_width + sig_width)] === 0) agtb_int = 1;
    else altb_int = 1;
  end
  else if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1))			// Only b is Infinity.
  begin
    if (b[(exp_width + sig_width)] === 0) altb_int = 1;
    else agtb_int = 1;
  end
  //
  // Zero Input
  //
  else if (zer_a && zer_b)			// a and b are Zero.
    aeqb_int = 1;	// +0 == -0
  else if (zer_a) 				// Only a is Zero.
  begin
    if (b[(exp_width + sig_width)] === 0) altb_int = 1;
    else agtb_int = 1;
  end
  else if (zer_b)				// Only b is Zero.
  begin
    if (a[(exp_width + sig_width)] === 0) agtb_int = 1;
    else altb_int = 1;
  end
  //
  // Normal/Denormal Inputs
  //
  else if (sign === 1)		// a and b have different sign bit.
  begin
    if (a[(exp_width + sig_width)] === 0) agtb_int = 1;
    else altb_int = 1;
  end
  else if (Ea !== Eb)		// a and b have the same sign, but different exponents
  begin
    if ( (!a[(exp_width + sig_width)] && Ea>Eb) || (a[(exp_width + sig_width)] && Ea<Eb) ) agtb_int = 1;
    else altb_int = 1;
  end
  else 
  begin
    if ( (!a[(exp_width + sig_width)] && Fa>Fb) || (a[(exp_width + sig_width)] && Fa<Fb) ) 
       agtb_int = 1;   // a and b have the same exponent and sign but different fractions
    else if (Fa === Fb) 
       aeqb_int = 1;
    else
       altb_int = 1;
  end

  // Check if agtb_int, aeqb_int, and altb_int are mutually exclusive.
  chk = agtb_int + aeqb_int + altb_int + unordered_int;
  if (chk !== 1) $display ("Error! agtb, aeqb, altb, and unordered are NOT mutually exclusive.");

  // assign a or b to zx outputs according to zctr flag.
  if ( (agtb_int && zctr) || (altb_int && !zctr) || (aeqb_int && !zctr) || (unordered_int) ) 
  begin
    z0_int = a;
    z1_int = b;
    status0_int[7] = 1;
    if (ieee_compliance === 1)
      begin
        if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fa !== 0) status0_int[2] = 1;
        if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fa === 0) status0_int[1] = 1;
        if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fb !== 0) status1_int[2] = 1;
        if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fb === 0) status1_int[1] = 1;
      end
    else
      begin
        if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1)) status0_int[1] = 1;
        if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1)) status1_int[1] = 1;
      end
    status0_int[0] = zer_a;
    status1_int[0] = zer_b;
  end
  else
  begin
    z0_int = b;
    z1_int = a;
    if (ieee_compliance === 1)
      begin
        if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fb !== 0) status0_int[2] = 1;
        if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fb === 0) status0_int[1] = 1;
        if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fa !== 0) status1_int[2] = 1;
        if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1) && Fa === 0) status1_int[1] = 1;
      end
    else
      begin
        if (Eb === ((((1 << (exp_width-1)) - 1) * 2) + 1)) status0_int[1] = 1;
        if (Ea === ((((1 << (exp_width-1)) - 1) * 2) + 1)) status1_int[1] = 1;
      end
    status0_int[0] = zer_b;
    status1_int[0] = zer_a;
    status1_int[7] = 1;
  end

end

assign z0 = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? {exp_width+sig_width+1{1'bx}} : z0_int;
assign z1 = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? {exp_width+sig_width+1{1'bx}} : z1_int;
assign status0 = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? {8'bx} : status0_int;
assign status1 = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? {8'bx} : status1_int;
assign agtb = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? 1'bx : agtb_int;
assign aeqb = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? 1'bx : aeqb_int;
assign altb = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? 1'bx : altb_int;
assign unordered = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0)) ? 1'bx : unordered_int;

// synopsys translate_on

endmodule


`endif /* DW_FP_CMP_WRAPPER */

//-----------------------------------------------------------
// Wrapper of placeholder DW_fp_cmp_wrapper_noparam
//-----------------------------------------------------------

`ifndef DW_FP_CMP_WRAPPER_NOPARAM
`define DW_FP_CMP_WRAPPER_NOPARAM

module DW_fp_cmp_wrapper_noparam
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] a ,
  output logic [1-1:0] aeqb ,
  output logic [1-1:0] agtb ,
  output logic [1-1:0] altb ,
  input logic [32-1:0] b ,
  output logic [8-1:0] status0 ,
  output logic [8-1:0] status1 ,
  output logic [1-1:0] unordered ,
  output logic [32-1:0] z0 ,
  output logic [32-1:0] z1 ,
  input logic [1-1:0] zctr 
);
  DW_fp_cmp
  #(
    .sig_width( 23 ),
    .exp_width( 8 ),
    .ieee_compliance( 1 )
  ) v
  (
    .a( a ),
    .aeqb( aeqb ),
    .agtb( agtb ),
    .altb( altb ),
    .b( b ),
    .status0( status0 ),
    .status1( status1 ),
    .unordered( unordered ),
    .z0( z0 ),
    .z1( z1 ),
    .zctr( zctr )
  );
endmodule

`endif /* DW_FP_CMP_WRAPPER_NOPARAM */



// PyMTL Component DW_fp_cmp Definition
// Full name: DW_fp_cmp__nstages_4__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cmp.py

module DW_fp_cmp__5367206e2cb8f6c7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  localparam logic [2:0] __const__nstages_at_up_queues  = 3'd4;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_val;
  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [0:0] in_q__count;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  PipeQueueRTL__86a7c3aeb6713f23 in_q
  (
    .clk( in_q__clk ),
    .count( in_q__count ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component out_q[0:2]
  //-------------------------------------------------------------

  logic [0:0] out_q__clk [0:2];
  logic [0:0] out_q__count [0:2];
  logic [0:0] out_q__reset [0:2];
  logic [0:0] out_q__deq__en [0:2];
  logic [0:0] out_q__deq__rdy [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__deq__ret [0:2];
  logic [0:0] out_q__enq__en [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__enq__msg [0:2];
  logic [0:0] out_q__enq__rdy [0:2];

  PipeQueueRTL__f55b0708e52dd198 out_q__0
  (
    .clk( out_q__clk[0] ),
    .count( out_q__count[0] ),
    .reset( out_q__reset[0] ),
    .deq__en( out_q__deq__en[0] ),
    .deq__rdy( out_q__deq__rdy[0] ),
    .deq__ret( out_q__deq__ret[0] ),
    .enq__en( out_q__enq__en[0] ),
    .enq__msg( out_q__enq__msg[0] ),
    .enq__rdy( out_q__enq__rdy[0] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__1
  (
    .clk( out_q__clk[1] ),
    .count( out_q__count[1] ),
    .reset( out_q__reset[1] ),
    .deq__en( out_q__deq__en[1] ),
    .deq__rdy( out_q__deq__rdy[1] ),
    .deq__ret( out_q__deq__ret[1] ),
    .enq__en( out_q__enq__en[1] ),
    .enq__msg( out_q__enq__msg[1] ),
    .enq__rdy( out_q__enq__rdy[1] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__2
  (
    .clk( out_q__clk[2] ),
    .count( out_q__count[2] ),
    .reset( out_q__reset[2] ),
    .deq__en( out_q__deq__en[2] ),
    .deq__rdy( out_q__deq__rdy[2] ),
    .deq__ret( out_q__deq__ret[2] ),
    .enq__en( out_q__enq__en[2] ),
    .enq__msg( out_q__enq__msg[2] ),
    .enq__rdy( out_q__enq__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component out_q[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component unit
  //-------------------------------------------------------------

  logic [31:0] unit__a;
  logic [0:0] unit__aeqb;
  logic [0:0] unit__agtb;
  logic [0:0] unit__altb;
  logic [31:0] unit__b;
  logic [0:0] unit__clk;
  logic [0:0] unit__reset;
  logic [7:0] unit__status0;
  logic [7:0] unit__status1;
  logic [0:0] unit__unordered;
  logic [31:0] unit__z0;
  logic [31:0] unit__z1;
  logic [0:0] unit__zctr;

  DW_fp_cmp_wrapper_noparam unit
  (
    .a( unit__a ),
    .aeqb( unit__aeqb ),
    .agtb( unit__agtb ),
    .altb( unit__altb ),
    .b( unit__b ),
    .clk( unit__clk ),
    .reset( unit__reset ),
    .status0( unit__status0 ),
    .status1( unit__status1 ),
    .unordered( unit__unordered ),
    .z0( unit__z0 ),
    .z1( unit__z1 ),
    .zctr( unit__zctr )
  );

  //-------------------------------------------------------------
  // End of component unit
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cmp.py:114
  // @update
  // def comb():
  // 
  //   # default
  //   s.out_val.opaque @= 0
  //   s.out_val.result @= 0
  //   s.out_val.fexc   @= 0
  // 
  //   s.unit.a    @= 0
  //   s.unit.b    @= 0
  //   s.unit.zctr @= 0
  // 
  //   if s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy:
  // 
  //     s.unit.a @= s.in_q.deq.ret.op_a
  //     s.unit.b @= s.in_q.deq.ret.op_b
  // 
  //     # zctr
  //     if    s.in_q.deq.ret.type_ == FpuReqType.TYPE_FMAX:
  //       s.unit.zctr @= 1
  // 
  //     # opaque
  //     s.out_val.opaque @= s.in_q.deq.ret.opaque
  // 
  //     # output
  //     if    s.in_q.deq.ret.type_ == FpuReqType.TYPE_FMIN:
  //       s.out_val.result @= s.unit.z0
  //     elif  s.in_q.deq.ret.type_ == FpuReqType.TYPE_FMAX:
  //       s.out_val.result @= s.unit.z0
  //     elif  s.in_q.deq.ret.type_ == FpuReqType.TYPE_FCEQ:
  //       s.out_val.result @= zext( s.unit.aeqb, 32 )
  //     elif  s.in_q.deq.ret.type_ == FpuReqType.TYPE_FCLT:
  //       s.out_val.result @= zext( s.unit.altb, 32 )
  //     elif  s.in_q.deq.ret.type_ == FpuReqType.TYPE_FCLE:
  //       s.out_val.result @= zext( s.unit.altb | s.unit.aeqb, 32 )
  // 
  //     # output fexc
  //     if s.unit.unordered:
  //       s.out_val.fexc @= FpuRespType.FEXC_NV
  
  always_comb begin : comb
    out_val.opaque = 8'd0;
    out_val.result = 32'd0;
    out_val.fexc = 5'd0;
    unit__a = 32'd0;
    unit__b = 32'd0;
    unit__zctr = 1'd0;
    if ( in_q__deq__rdy & out_q__enq__rdy[2'd0] ) begin
      unit__a = in_q__deq__ret.op_a;
      unit__b = in_q__deq__ret.op_b;
      if ( in_q__deq__ret.type_ == 4'd5 ) begin
        unit__zctr = 1'd1;
      end
      out_val.opaque = in_q__deq__ret.opaque;
      if ( in_q__deq__ret.type_ == 4'd4 ) begin
        out_val.result = unit__z0;
      end
      else if ( in_q__deq__ret.type_ == 4'd5 ) begin
        out_val.result = unit__z0;
      end
      else if ( in_q__deq__ret.type_ == 4'd8 ) begin
        out_val.result = { { 31 { 1'b0 } }, unit__aeqb };
      end
      else if ( in_q__deq__ret.type_ == 4'd9 ) begin
        out_val.result = { { 31 { 1'b0 } }, unit__altb };
      end
      else if ( in_q__deq__ret.type_ == 4'd10 ) begin
        out_val.result = { { 31 { 1'b0 } }, unit__altb | unit__aeqb };
      end
      if ( unit__unordered ) begin
        out_val.fexc = 5'd16;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cmp.py:94
  // @update
  // def up_queues():
  // 
  //   # in_q <-> out_q[ 0 ]
  //   s.in_q.deq.en         @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.en   @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.msg  @= s.out_val
  // 
  //   # chian middle out_q
  //   if nstages > 2:
  //     for i in range( nstages - 2 ):
  //       s.out_q[ i   ].deq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.msg @= s.out_q[ i ].deq.ret
  // 
  //   # out_q[ nstages-2 ] <-> s.resp
  //   s.out_q[ nstages-2 ].deq.en @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.en                   @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.msg                  @= s.out_q[ nstages-2 ].deq.ret
  
  always_comb begin : up_queues
    in_q__deq__en = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__en[2'd0] = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__msg[2'd0] = out_val;
    if ( 3'( __const__nstages_at_up_queues ) > 3'd2 ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__nstages_at_up_queues ) - 3'd2; i += 1'd1 ) begin
        out_q__deq__en[2'(i)] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__en[2'(i) + 2'd1] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__msg[2'(i) + 2'd1] = out_q__deq__ret[2'(i)];
      end
    end
    out_q__deq__en[3'( __const__nstages_at_up_queues ) - 3'd2] = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__en = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__msg = out_q__deq__ret[3'( __const__nstages_at_up_queues ) - 3'd2];
  end

  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign in_q__enq__en = req__en;
  assign in_q__enq__msg = req__msg;
  assign req__rdy = in_q__enq__rdy;
  assign unit__clk = clk;
  assign unit__reset = reset;
  assign out_q__clk[0] = clk;
  assign out_q__reset[0] = reset;
  assign out_q__clk[1] = clk;
  assign out_q__reset[1] = reset;
  assign out_q__clk[2] = clk;
  assign out_q__reset[2] = reset;

endmodule


// PyMTL VerilogPlaceholder DW_fp_flt2i_wrapper Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cvt.py

//***********************************************************
// Pickled source file of placeholder DW_fp_flt2i_wrapper_noparam
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder DW_fp_flt2i_wrapper
//-----------------------------------------------------------

`ifndef DW_FP_FLT2I_WRAPPER
`define DW_FP_FLT2I_WRAPPER

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component DW_fp_flt2i_wrapper_noparam.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component DW_fp_flt2i_wrapper_noparam

`line 1 "fpu/dw_srcs/DW_fp_flt2i.v" 0

////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2005 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Kyung-Nam Han, Oct. 31, 2005
//
// VERSION:   Verilog Simulation Model for DW_fp_flt2i
//
// DesignWare_version: 3b5d9457
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////

//
// ABSTRACT:  Floating-point Number Format to Integer Number Format
//            Converter
//
//              This converts a floating-point number to a signed
//              integer number.
//              Conversion to a unsigned integer number is not supported.
//
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              isize           integer size,      3 to 512 bits
//              ieee_compliance support the IEEE Compliance 
//                              including NaN and denormal expressions.
//                              0 - IEEE 754 compatible without denormal support
//                                  (NaN becomes Infinity, Denormal becomes Zero)
//                              1 - IEEE 754 standard compatible
//                                  (NaN and denormal numbers are supported)
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              rnd             3 bits
//                              Rounding Mode Input
//              z               (isize)-bits
//                              Converted Integer Output
//              status          8 bits
//                              Status Flags Output
//
// Modified:
//  Mar. 13. 2008 Kyung-Nam Han (from 0712-SP3)
//    Removed VCS Warning Message (STAR 9000232556) 
//  Sep. 09. 2009 Kyung-Nam Han (0903-SP3)
//    Added ieee_compliance parameter
//-----------------------------------------------------------------------------

module DW_fp_flt2i (a, rnd, z, status);

  parameter sig_width=23;        // RANGE 2 TO 253
  parameter exp_width=8;         // RANGE 3 TO 31
  parameter isize=32;            // RANGE 3 TO 512
  parameter ieee_compliance = 0; // RANGE 0 to 1
  
  input  [exp_width + sig_width:0] a;
  input  [2:0] rnd;
  output [isize - 1:0] z;
  output [7:0] status;
  
  // synopsys translate_off


  `define isign               0  // 0 : signed, 1 : unsigned 
  `define rnd_Width           4
  `define rnd_Inc             0
  `define rnd_Inexact         1
  `define rnd_HugeInfinity    2
  `define rnd_TinyminNorm     3
  `define Mwidth              (2 * isize + 2)
  `define Movf                (`Mwidth - 1)
  `define MM                  (`Movf - 1)
  `define ML                  (`Movf - isize)
  `define MR                  (`ML - 1)
  `define MS                  (`ML - 2)
  `define af_lsb              ((sig_width <= isize) ? 0 : (sig_width - 1) - isize + 1)
  `define DW_MI_LSB           ((sig_width <= isize) ? `MR - sig_width + 1 : 0)
  
  //-------------------------------------------------------------------------
  // Parameter legality check
  //-------------------------------------------------------------------------
    

  // XXX: berkin
  /* verilator lint_off WIDTH */
 
  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;
    
        
    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end
        
    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end
        
    if ( (isize < 3) || (isize > 512) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter isize (legal range: 3 to 512)",
	isize );
    end
        
    if ( (ieee_compliance < 0) || (ieee_compliance > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter ieee_compliance (legal range: 0 to 1)",
	ieee_compliance );
    end
     
    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check 

  //-----------------------------------------------------  
  
  
  function [`rnd_Width-1:0] rnd_eval;
  
    input [2:0] rnd;
    input [0:0] Sign;
    input [0:0] L,R,stk;
    
    
    begin
      rnd_eval[`rnd_Inc] = 0;
      rnd_eval[`rnd_Inexact] = R|stk;
      rnd_eval[`rnd_HugeInfinity] = 0;
      rnd_eval[`rnd_TinyminNorm] = 0;
      
      if ($time > 0) begin
        case (rnd)
          3'b000:
          begin
            rnd_eval[`rnd_Inc] = R&(L|stk);
            rnd_eval[`rnd_HugeInfinity] = 1;
            rnd_eval[`rnd_TinyminNorm] = 0;
          end
          3'b001:
          begin
            rnd_eval[`rnd_Inc] = 0;
            rnd_eval[`rnd_HugeInfinity] = 0;
            rnd_eval[`rnd_TinyminNorm] = 0;
          end
          3'b010:
          begin
            rnd_eval[`rnd_Inc] = ~Sign & (R|stk);
            rnd_eval[`rnd_HugeInfinity] = ~Sign;
            rnd_eval[`rnd_TinyminNorm] = ~Sign;
          end
          3'b011:
          begin
            rnd_eval[`rnd_Inc] = Sign & (R|stk);
            rnd_eval[`rnd_HugeInfinity] = Sign;
            rnd_eval[`rnd_TinyminNorm] = Sign;
          end
          3'b100:
          begin
            rnd_eval[`rnd_Inc] = R;
            rnd_eval[`rnd_HugeInfinity] = 1;
            rnd_eval[`rnd_TinyminNorm] = 0;
          end
          3'b101:
          begin
            rnd_eval[`rnd_Inc] = R|stk;
            rnd_eval[`rnd_HugeInfinity] = 1;
            rnd_eval[`rnd_TinyminNorm] = 1;
          end
          default:
          begin
            $display("Error! illegal rounding mode.\n");
            $display("a : %b", a);
            $display("rnd : %b", rnd);
          end
        endcase
      end

    end
  endfunction
  
  reg [(exp_width + sig_width):0] af;
  reg [8    -1:0] status_reg;
  reg [isize-1:0] z_reg;
  reg [exp_width-1:0] eaf;
  reg [`Mwidth-1:0] mi;
  reg [exp_width-1:0] exp;
  reg [0:0] stk;
  reg [`rnd_Width-1:0] rnd_val;  
  reg [isize-1:0] maxneg;
  reg [isize-1:0] maxpos;
  reg [(sig_width - 1):0] sig;
  reg inf_input;
  reg denorm_input;
  reg nan_input;
  reg zero_input;

  integer num;
  
  assign status = status_reg;
  assign z = z_reg;
  
  always @(a or rnd) begin : a1000_PROC
    
    af = a;
    status_reg = 0;
    mi = 0;
    exp = 0;
    stk = 0;
    eaf = af[((exp_width + sig_width) - 1):sig_width];
    num = 0;
    sig  = af[(sig_width - 1):0];

    if (ieee_compliance) begin
      inf_input = (eaf == ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (sig == 0);
      nan_input = (eaf == ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (sig != 0);
      denorm_input = (eaf == 0) & (sig != 0);
      zero_input = (eaf == 0) & (sig == 0);
    end
    else begin
      inf_input = (eaf == ((((1 << (exp_width-1)) - 1) * 2) + 1));
      nan_input = 0;
      denorm_input = 0;
      zero_input = (eaf == 0 );
    end
    
    if (inf_input) begin
      
      if (ieee_compliance) begin
        status_reg[2] = 1;
      end
      else begin
        status_reg[6] = 1;
        status_reg[5] = 1;
      end
      
    end
    else if (nan_input) begin
      
      status_reg[2] = 1;

    end
    else if (zero_input) begin
      
      status_reg[0] = 1;
      
    end
    else begin
      
      mi[`ML] = 1;
      
      if (sig_width <= isize) begin
        
        mi[`MR:`DW_MI_LSB] = af[(sig_width - 1):0];
        
      end
      else begin
        

        mi[`MR:`MR-isize+1] = af[(sig_width - 1):`af_lsb];
        num = (sig_width - 1) - isize;  // >= 0
        stk = 0;
        
        while (num != 0) begin
          stk = stk | af[num];
          num = num - 1;
        end
        
        stk = stk | af[num];
        mi[0] = stk;
      end

      if (eaf >= ((1 << (exp_width-1)) - 1)) begin
        exp = eaf - ((1 << (exp_width-1)) - 1);
        
        while (exp !== 0) begin
          if (mi[`Movf] !== 1) begin
            mi = mi << 1;
          end
          
          exp = exp - 1;
        end
      end
      else begin
        
        exp = ((1 << (exp_width-1)) - 1) - eaf;
        
        while (exp != 0) begin
          
          stk = mi[0];
          mi = mi >> 1;
          mi[0] = stk | mi[0];
          exp = exp - 1;
          
        end
      end
      
      
      if (mi[`Movf] === 1) begin
      
        status_reg[6] = 1;
        status_reg[5] = 1;
        
      end
      else begin
      
        stk = 0;
        num = `MS;
        
        while (num != 0) begin
          stk = stk | mi[num];
          num = num - 1;
        end
        
        stk = stk | mi[num];
        mi[`MS] = stk;
        
        rnd_val = rnd_eval(rnd, af[(exp_width + sig_width)], mi[`ML], mi[`MR], mi[`MS]);

        if (rnd_val[`rnd_Inc] === 1) begin
          mi = mi + (1<<`ML);
        end
        
        status_reg[5] =
        status_reg[5] | rnd_val[`rnd_Inexact];
        
        if (mi[`Movf] === 1) begin
          
          status_reg[6] = 1;
          status_reg[5] = 1;
          
        end
        else if (mi[`MM:`ML] === 0) begin
          
          status_reg[0] = 1;

          if (denorm_input) begin
            status_reg[3] = 1;
          end
          
        end
      end
      
    end

    
    
    if (`isign === 0) begin

      maxneg = 0;
      maxneg[isize-1] = 1;
      maxpos = -1;
      maxpos[isize-1] = 0;
      
      if ( (af[(exp_width + sig_width)] === 1 && mi[`MM:`ML] > maxneg) ||
        (af[(exp_width + sig_width)] === 0 && mi[`MM:`ML] > maxpos) ) begin
        
        status_reg[6] = 1;
        status_reg[5] = 1;
        
      end
      
      if (af[(exp_width + sig_width)] === 1) begin
        
        if (status_reg[6] === 1 || 
            status_reg[2] === 1) begin
          z_reg = -maxneg;
        end
        else if (status_reg[0] === 1) begin
          z_reg = 0;
        end
        else begin
          z_reg = -mi[`MM:`ML];
        end
        
      end
      else begin
        
        if (status_reg[6] === 1 ||
            status_reg[2] === 1) begin
          z_reg = maxpos;
        end
        else if (status_reg[0] === 1) begin
          z_reg = 0;
        end
        else begin
          z_reg = mi[`MM:`ML];
        end
        
      end
      
    end
    else begin
      
      $display("Error! Unsigned integer for DW_fp_flt2i is not supported.");
      
    end
  end

  `undef isign
  `undef rnd_Width
  `undef rnd_Inc
  `undef rnd_Inexact
  `undef rnd_HugeInfinity
  `undef rnd_TinyminNorm
  `undef Mwidth
  `undef Movf
  `undef MM
  `undef ML
  `undef MR
  `undef MS
  `undef af_lsb
  `undef DW_MI_LSB

  // synopsys translate_on

endmodule

`endif /* DW_FP_FLT2I_WRAPPER */

//-----------------------------------------------------------
// Wrapper of placeholder DW_fp_flt2i_wrapper_noparam
//-----------------------------------------------------------

`ifndef DW_FP_FLT2I_WRAPPER_NOPARAM
`define DW_FP_FLT2I_WRAPPER_NOPARAM

module DW_fp_flt2i_wrapper_noparam
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] a ,
  input logic [3-1:0] rnd ,
  output logic [8-1:0] status ,
  output logic [32-1:0] z 
);
  DW_fp_flt2i
  #(
    .sig_width( 23 ),
    .exp_width( 8 ),
    .isize( 32 ),
    .ieee_compliance( 1 )
  ) v
  (
    .a( a ),
    .rnd( rnd ),
    .status( status ),
    .z( z )
  );
endmodule

`endif /* DW_FP_FLT2I_WRAPPER_NOPARAM */



// PyMTL VerilogPlaceholder DW_fp_i2flt_wrapper Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cvt.py

//***********************************************************
// Pickled source file of placeholder DW_fp_i2flt_wrapper_noparam
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder DW_fp_i2flt_wrapper
//-----------------------------------------------------------

`ifndef DW_FP_I2FLT_WRAPPER
`define DW_FP_I2FLT_WRAPPER

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component DW_fp_i2flt_wrapper_noparam.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component DW_fp_i2flt_wrapper_noparam

`line 1 "fpu/dw_srcs/DW_fp_i2flt.v" 0

////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2006 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Kyung-Nam Han, Jan. 17, 2006
//
// VERSION:   Verilog Simulation Model for DW_fp_i2flt
//
// DesignWare_version: 53eb9285
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ABSTRACT:  Integer Number Format to Floatin-point Number Format
// Converter
//
//              This converts an integer number to a floating-point
//              number. Both 2's complement signed integer and unsigned
//              integer are supported.
//
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              isize           integer size,      3 to 512 bits
//              isign           signed/unsigned number flag
//                              0 - unsigned, 1 - signed integer (2's complement)
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (isize)-bits
//                              Integer Input
//              rnd             3 bits
//                              Rounding Mode Input
//              z               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Output
//              status          8 bits
//                              Status Flags Output
//
// MODIFIED:
//
//	8/1/2012    RJK - Tightened isize restriction as per STAR 9000557637
//-----------------------------------------------------------------------------

module DW_fp_i2flt (a, rnd, z, status);

  parameter sig_width = 23;  // RANGE 2 TO 253
  parameter exp_width = 8;   // RANGE 3 TO 31
  parameter isize = 32;      // RANGE 3 TO 512
  parameter isign = 1;	     // RANGE 0 TO 1
                             // 0 : unsigned, 1 : signed
  input  [isize-1:0] a;
  input  [2:0] rnd; 
  output [exp_width + sig_width:0] z;
  output [7:0] status; 

  // synopsys translate_off


  `define Mwidth  (sig_width + 4)
  `define Movf    (`Mwidth - 1)
  `define ML      2
  `define MR      1
  `define MS      0
  `define rnd_Width  4
  `define rnd_Inc  0
  `define rnd_Inexact  1
  `define rnd_HugeInfinity  2
  `define rnd_TinyminNorm  3
  `define ai_lsb ((isize - sig_width - 2 >= 0) ? isize - sig_width - 2 : 0)
	    
  // --------------------------------------------------------------------
  

  //-------------------------------------------------------------------------
  // Parameter legality check
  //-------------------------------------------------------------------------

  // XXX: berkin
  /* verilator lint_off WIDTH */
    
 
  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;
    
      
    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end
      
    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end
     
    if ( (isize < 3+isign) || (isize > 512) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m : Parameter isize must be at least 3+isign and no greater than 512" );
    end 
      
    if ( (isign < 0) || (isign > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter isign (legal range: 0 to 1)",
	isign );
    end
    
    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check 

  //---------------------------------------------------------------------


  
  function [`rnd_Width-1:0] rnd_eval;
  
    input [2:0] rnd;
    input [0:0] Sign;
    input [0:0] L,R,stk;
    
    
    begin
      rnd_eval[`rnd_Inc] = 0;
      rnd_eval[`rnd_Inexact] = R|stk;
      rnd_eval[`rnd_HugeInfinity] = 0;
      rnd_eval[`rnd_TinyminNorm] = 0;
      
      if ($time > 0) 
      begin
        case (rnd)
          3'b000:
          begin
            // round to nearest (even)
            rnd_eval[`rnd_Inc] = R&(L|stk);
            rnd_eval[`rnd_HugeInfinity] = 1;
            rnd_eval[`rnd_TinyminNorm] = 0;
          end
          3'b001:
          begin
            // round to zero
            rnd_eval[`rnd_Inc] = 0;
            rnd_eval[`rnd_HugeInfinity] = 0;
            rnd_eval[`rnd_TinyminNorm] = 0;
          end
          3'b010:
          begin
            // round to positive infinity
            rnd_eval[`rnd_Inc] = ~Sign & (R|stk);
            rnd_eval[`rnd_HugeInfinity] = ~Sign;
            rnd_eval[`rnd_TinyminNorm] = ~Sign;
          end
          3'b011:
          begin
            // round to negative infinity
            rnd_eval[`rnd_Inc] = Sign & (R|stk);
            rnd_eval[`rnd_HugeInfinity] = Sign;
            rnd_eval[`rnd_TinyminNorm] = Sign;
          end
          3'b100:
          begin
            // round to nearest (up)
            rnd_eval[`rnd_Inc] = R;
            rnd_eval[`rnd_HugeInfinity] = 1;
            rnd_eval[`rnd_TinyminNorm] = 0;
          end
          3'b101:
          begin
            // round away form 0
            rnd_eval[`rnd_Inc] = R|stk;
            rnd_eval[`rnd_HugeInfinity] = 1;
            rnd_eval[`rnd_TinyminNorm] = 1;
          end
          default:
          begin
            $display("Error! illegal rounding mode.\n");
            $display("a : %b", a);
            $display("rnd : %b", rnd);
          end
        endcase
      end
    end
  endfunction

  // --------------------------------------------------------------------
  
  reg [isize-1:0] Ai;
  reg [8    -1:0] status_reg; 
  reg [(exp_width + sig_width):0] z_reg;
  reg [isize-1:0] LZ;
  reg [isize-1:0] num;
  reg [`Mwidth-1:0] Mf;			// Mantissa for floating points.
  reg [exp_width:0] EXP;
  reg [0:0] STK;
  reg [`rnd_Width-1:0] rnd_val;
  
  // --------------------------------------------------------------------
  
  always @(a or rnd)
  begin
    Ai = a;
    status_reg = 0;
    LZ = 0;
    Mf = 0;
    EXP = 0;
    STK = 0;
  
    if (Ai === 0)				// Exact Zero
      begin
      status_reg[0] = 1; z_reg = 0; 
      end 
    else					// Nonzero Integer
      begin
      // Convert signed integer (two's complement) to unsigned magnitude representation.
      // Set the sign bit of Floating Point Number.
      if (isign === 1)		// Signed
        begin
        if(Ai[isize-1] === 1)
          begin
          Ai = ~Ai + 1;
          z_reg[(exp_width + sig_width)] = 1;
          end
        else
          begin
          z_reg[(exp_width + sig_width)] = 0;
          end
        end
      else				// Unsigned
        begin
        z_reg[(exp_width + sig_width)] = 0;
        end
  
      // Convert the unsigned magnitude representation to floating point format.
      // Left shift to normalize Ai.
      while(Ai[isize-1] != 1)
        begin
        Ai = Ai << 1;
        LZ = LZ + 1;
        end
  
      // Calculate the Biased Exponent.
      if(isize - 1 - LZ + ((1 << (exp_width-1)) - 1) >= ((((1 << (exp_width-1)) - 1) * 2) + 1))
        EXP = ((((1 << (exp_width-1)) - 1) * 2) + 1);
      else
        EXP = isize - 1 - LZ + ((1 << (exp_width-1)) - 1);
  
      // Converts integer to fraction.
      if(isize <= sig_width+2)
        // If the Mantissa fraction (sig_width+2) is big enough to hold Ai,
        // Left adjustment at `Movf-1: `Movf-1-(isize-1) = `Movf-isize >= 1
        begin
        Mf[`Movf-1:0] = Ai << (`Movf-isize);
        end
      else
        // If the Mantissa fraction (sig_width+2) is NOT big enough to hold Ai,
        // calculate the STK.
        begin
        Mf[`Movf-1:`MR] = Ai[isize-1:`ai_lsb];
        STK = 0;
        num = isize-sig_width-3;	// the mininum is 0.
        while(num !== 0)
          begin
          STK = STK | Ai[num];
          num = num - 1;
          end
        STK = STK | Ai[num];
        Mf[`MS] = STK;
        end
  
      // Round the Mantissa according to the rounding modes.
      rnd_val = rnd_eval(rnd, z_reg[(exp_width + sig_width)], Mf[`ML], Mf[`MR], Mf[`MS]);
      if (rnd_val[`rnd_Inc] === 1) Mf = Mf + (1<<`ML);
      status_reg[5] = rnd_val[`rnd_Inexact];
  
      // Normalize the Mantissa for overflow case after rounding.
      if ( (Mf[`Movf] === 1) )
        begin
        EXP = EXP + 1;
        Mf = Mf >> 1;
        end
  
      // Note: "Tiny" situation doesn't exist.
      if(EXP >= ((((1 << (exp_width-1)) - 1) * 2) + 1))			// Huge
        begin
        status_reg[4] = 1;
        status_reg[5] = 1;
        if(rnd_val[`rnd_HugeInfinity] === 1)
          begin
          // Infinity
          EXP = ((((1 << (exp_width-1)) - 1) * 2) + 1);
          //Mf[`Movf-2:`ML] = -1;
          Mf[`Movf-2:`ML] = 0;
          status_reg[1] = 1;
          end
        else
          begin
          // MaxNorm
          EXP = ((((1 << (exp_width-1)) - 1) * 2) + 1) - 1;
          Mf[`Movf-2:`ML] = -1;
          end
        end
  
      z_reg = {z_reg[(exp_width + sig_width)],EXP[exp_width-1:0],Mf[`Movf-2:`ML]};
      end
  end
  
  assign status = status_reg;
  assign z = z_reg;

  `undef Mwidth
  `undef Movf
  `undef ML
  `undef MR
  `undef MS
  `undef rnd_Width
  `undef rnd_Inc
  `undef rnd_Inexact
  `undef rnd_HugeInfinity
  `undef rnd_TinyminNorm
  `undef ai_lsb

  // synopsys translate_on
  
 endmodule

`endif /* DW_FP_I2FLT_WRAPPER */

//-----------------------------------------------------------
// Wrapper of placeholder DW_fp_i2flt_wrapper_noparam
//-----------------------------------------------------------

`ifndef DW_FP_I2FLT_WRAPPER_NOPARAM
`define DW_FP_I2FLT_WRAPPER_NOPARAM

module DW_fp_i2flt_wrapper_noparam
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] a ,
  input logic [3-1:0] rnd ,
  output logic [8-1:0] status ,
  output logic [32-1:0] z 
);
  DW_fp_i2flt
  #(
    .sig_width( 23 ),
    .exp_width( 8 ),
    .isize( 32 ),
    .isign( 1 )
  ) v
  (
    .a( a ),
    .rnd( rnd ),
    .status( status ),
    .z( z )
  );
endmodule

`endif /* DW_FP_I2FLT_WRAPPER_NOPARAM */



// PyMTL Component DW_fp_cvt Definition
// Full name: DW_fp_cvt__nstages_4__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cvt.py

module DW_fp_cvt__5367206e2cb8f6c7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  localparam logic [2:0] __const__nstages_at_up_queues  = 3'd4;
  localparam logic [2:0] __const__DW_FRND_NE  = 3'd0;
  localparam logic [2:0] __const__DW_FRND_TZ  = 3'd1;
  localparam logic [2:0] __const__DW_FRND_DN  = 3'd3;
  localparam logic [2:0] __const__DW_FRND_UP  = 3'd2;
  localparam logic [2:0] __const__DW_FRND_MM  = 3'd4;
  localparam logic [7:0] __const__DW_FEXC_NX  = 8'd32;
  localparam logic [7:0] __const__DW_FEXC_UF  = 8'd8;
  localparam logic [7:0] __const__DW_FEXC_OF  = 8'd16;
  localparam logic [7:0] __const__DW_FEXC_DZ  = 8'd128;
  localparam logic [7:0] __const__DW_FEXC_NV  = 8'd4;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_val;
  //-------------------------------------------------------------
  // Component flt2i
  //-------------------------------------------------------------

  logic [31:0] flt2i__a;
  logic [0:0] flt2i__clk;
  logic [0:0] flt2i__reset;
  logic [2:0] flt2i__rnd;
  logic [7:0] flt2i__status;
  logic [31:0] flt2i__z;

  DW_fp_flt2i_wrapper_noparam flt2i
  (
    .a( flt2i__a ),
    .clk( flt2i__clk ),
    .reset( flt2i__reset ),
    .rnd( flt2i__rnd ),
    .status( flt2i__status ),
    .z( flt2i__z )
  );

  //-------------------------------------------------------------
  // End of component flt2i
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component i2flt
  //-------------------------------------------------------------

  logic [31:0] i2flt__a;
  logic [0:0] i2flt__clk;
  logic [0:0] i2flt__reset;
  logic [2:0] i2flt__rnd;
  logic [7:0] i2flt__status;
  logic [31:0] i2flt__z;

  DW_fp_i2flt_wrapper_noparam i2flt
  (
    .a( i2flt__a ),
    .clk( i2flt__clk ),
    .reset( i2flt__reset ),
    .rnd( i2flt__rnd ),
    .status( i2flt__status ),
    .z( i2flt__z )
  );

  //-------------------------------------------------------------
  // End of component i2flt
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [0:0] in_q__count;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  PipeQueueRTL__86a7c3aeb6713f23 in_q
  (
    .clk( in_q__clk ),
    .count( in_q__count ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component out_q[0:2]
  //-------------------------------------------------------------

  logic [0:0] out_q__clk [0:2];
  logic [0:0] out_q__count [0:2];
  logic [0:0] out_q__reset [0:2];
  logic [0:0] out_q__deq__en [0:2];
  logic [0:0] out_q__deq__rdy [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__deq__ret [0:2];
  logic [0:0] out_q__enq__en [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__enq__msg [0:2];
  logic [0:0] out_q__enq__rdy [0:2];

  PipeQueueRTL__f55b0708e52dd198 out_q__0
  (
    .clk( out_q__clk[0] ),
    .count( out_q__count[0] ),
    .reset( out_q__reset[0] ),
    .deq__en( out_q__deq__en[0] ),
    .deq__rdy( out_q__deq__rdy[0] ),
    .deq__ret( out_q__deq__ret[0] ),
    .enq__en( out_q__enq__en[0] ),
    .enq__msg( out_q__enq__msg[0] ),
    .enq__rdy( out_q__enq__rdy[0] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__1
  (
    .clk( out_q__clk[1] ),
    .count( out_q__count[1] ),
    .reset( out_q__reset[1] ),
    .deq__en( out_q__deq__en[1] ),
    .deq__rdy( out_q__deq__rdy[1] ),
    .deq__ret( out_q__deq__ret[1] ),
    .enq__en( out_q__enq__en[1] ),
    .enq__msg( out_q__enq__msg[1] ),
    .enq__rdy( out_q__enq__rdy[1] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__2
  (
    .clk( out_q__clk[2] ),
    .count( out_q__count[2] ),
    .reset( out_q__reset[2] ),
    .deq__en( out_q__deq__en[2] ),
    .deq__rdy( out_q__deq__rdy[2] ),
    .deq__ret( out_q__deq__ret[2] ),
    .enq__en( out_q__enq__en[2] ),
    .enq__msg( out_q__enq__msg[2] ),
    .enq__rdy( out_q__enq__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component out_q[0:2]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cvt.py:142
  // @update
  // def comb():
  // 
  //   # default
  //   s.out_val.opaque @= 0
  //   s.out_val.result @= 0
  //   s.out_val.fexc   @= 0
  // 
  //   s.i2flt.a   @= 0
  //   s.i2flt.rnd @= 0
  // 
  //   s.flt2i.a   @= 0
  //   s.flt2i.rnd @= 0
  // 
  //   if s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy:
  // 
  //     s.out_val.opaque @= s.in_q.deq.ret.opaque
  // 
  //     #
  //     # float to int
  //     #
  //     if    s.in_q.deq.ret.type_ == FpuReqType.TYPE_FI2F:
  //       # input
  //       s.i2flt.a @= s.in_q.deq.ret.op_a
  // 
  //       # rounding mode
  //       if    s.in_q.deq.ret.frnd == FpuReqType.FRND_NE:
  //         s.i2flt.rnd @= DW_FRND_NE
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_TZ:
  //         s.i2flt.rnd @= DW_FRND_TZ
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_DN:
  //         s.i2flt.rnd @= DW_FRND_DN
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_UP:
  //         s.i2flt.rnd @= DW_FRND_UP
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_MM:
  //         s.i2flt.rnd @= DW_FRND_MM
  // 
  //       # output
  //       s.out_val.result @= s.i2flt.z
  // 
  //       # exception
  //       if s.i2flt.status & DW_FEXC_NX:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NX
  //       if s.i2flt.status & DW_FEXC_UF:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_UF
  //       if s.i2flt.status & DW_FEXC_OF:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_OF
  //       if s.i2flt.status & DW_FEXC_DZ:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_DZ
  //       if s.i2flt.status & DW_FEXC_NV:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NV
  // 
  //     #
  //     # int to float
  //     #
  //     elif  s.in_q.deq.ret.type_ == FpuReqType.TYPE_FF2I:
  //       # input
  //       s.flt2i.a @= s.in_q.deq.ret.op_a
  // 
  //       # rounding mode
  //       if    s.in_q.deq.ret.frnd == FpuReqType.FRND_NE:
  //         s.flt2i.rnd @= DW_FRND_NE
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_TZ:
  //         s.flt2i.rnd @= DW_FRND_TZ
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_DN:
  //         s.flt2i.rnd @= DW_FRND_DN
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_UP:
  //         s.flt2i.rnd @= DW_FRND_UP
  //       elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_MM:
  //         s.flt2i.rnd @= DW_FRND_MM
  // 
  //       # output
  //       s.out_val.result @= s.flt2i.z
  // 
  //       # exception
  //       if s.flt2i.status & DW_FEXC_NX:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NX
  //       if s.flt2i.status & DW_FEXC_UF:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_UF
  //       if s.flt2i.status & DW_FEXC_OF:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_OF
  //       if s.flt2i.status & DW_FEXC_DZ:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_DZ
  //       if s.flt2i.status & DW_FEXC_NV:
  //         s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NV
  
  always_comb begin : comb
    out_val.opaque = 8'd0;
    out_val.result = 32'd0;
    out_val.fexc = 5'd0;
    i2flt__a = 32'd0;
    i2flt__rnd = 3'd0;
    flt2i__a = 32'd0;
    flt2i__rnd = 3'd0;
    if ( in_q__deq__rdy & out_q__enq__rdy[2'd0] ) begin
      out_val.opaque = in_q__deq__ret.opaque;
      if ( in_q__deq__ret.type_ == 4'd6 ) begin
        i2flt__a = in_q__deq__ret.op_a;
        if ( in_q__deq__ret.frnd == 3'd0 ) begin
          i2flt__rnd = 3'( __const__DW_FRND_NE );
        end
        else if ( in_q__deq__ret.frnd == 3'd1 ) begin
          i2flt__rnd = 3'( __const__DW_FRND_TZ );
        end
        else if ( in_q__deq__ret.frnd == 3'd2 ) begin
          i2flt__rnd = 3'( __const__DW_FRND_DN );
        end
        else if ( in_q__deq__ret.frnd == 3'd3 ) begin
          i2flt__rnd = 3'( __const__DW_FRND_UP );
        end
        else if ( in_q__deq__ret.frnd == 3'd4 ) begin
          i2flt__rnd = 3'( __const__DW_FRND_MM );
        end
        out_val.result = i2flt__z;
        if ( i2flt__status & 8'( __const__DW_FEXC_NX ) ) begin
          out_val.fexc = out_val.fexc | 5'd1;
        end
        if ( i2flt__status & 8'( __const__DW_FEXC_UF ) ) begin
          out_val.fexc = out_val.fexc | 5'd2;
        end
        if ( i2flt__status & 8'( __const__DW_FEXC_OF ) ) begin
          out_val.fexc = out_val.fexc | 5'd4;
        end
        if ( i2flt__status & 8'( __const__DW_FEXC_DZ ) ) begin
          out_val.fexc = out_val.fexc | 5'd8;
        end
        if ( i2flt__status & 8'( __const__DW_FEXC_NV ) ) begin
          out_val.fexc = out_val.fexc | 5'd16;
        end
      end
      else if ( in_q__deq__ret.type_ == 4'd7 ) begin
        flt2i__a = in_q__deq__ret.op_a;
        if ( in_q__deq__ret.frnd == 3'd0 ) begin
          flt2i__rnd = 3'( __const__DW_FRND_NE );
        end
        else if ( in_q__deq__ret.frnd == 3'd1 ) begin
          flt2i__rnd = 3'( __const__DW_FRND_TZ );
        end
        else if ( in_q__deq__ret.frnd == 3'd2 ) begin
          flt2i__rnd = 3'( __const__DW_FRND_DN );
        end
        else if ( in_q__deq__ret.frnd == 3'd3 ) begin
          flt2i__rnd = 3'( __const__DW_FRND_UP );
        end
        else if ( in_q__deq__ret.frnd == 3'd4 ) begin
          flt2i__rnd = 3'( __const__DW_FRND_MM );
        end
        out_val.result = flt2i__z;
        if ( flt2i__status & 8'( __const__DW_FEXC_NX ) ) begin
          out_val.fexc = out_val.fexc | 5'd1;
        end
        if ( flt2i__status & 8'( __const__DW_FEXC_UF ) ) begin
          out_val.fexc = out_val.fexc | 5'd2;
        end
        if ( flt2i__status & 8'( __const__DW_FEXC_OF ) ) begin
          out_val.fexc = out_val.fexc | 5'd4;
        end
        if ( flt2i__status & 8'( __const__DW_FEXC_DZ ) ) begin
          out_val.fexc = out_val.fexc | 5'd8;
        end
        if ( flt2i__status & 8'( __const__DW_FEXC_NV ) ) begin
          out_val.fexc = out_val.fexc | 5'd16;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_cvt.py:122
  // @update
  // def up_queues():
  // 
  //   # in_q <-> out_q[ 0 ]
  //   s.in_q.deq.en         @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.en   @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.msg  @= s.out_val
  // 
  //   # chian middle out_q
  //   if nstages > 2:
  //     for i in range( nstages - 2 ):
  //       s.out_q[ i   ].deq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.msg @= s.out_q[ i ].deq.ret
  // 
  //   # out_q[ nstages-2 ] <-> s.resp
  //   s.out_q[ nstages-2 ].deq.en @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.en                   @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.msg                  @= s.out_q[ nstages-2 ].deq.ret
  
  always_comb begin : up_queues
    in_q__deq__en = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__en[2'd0] = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__msg[2'd0] = out_val;
    if ( 3'( __const__nstages_at_up_queues ) > 3'd2 ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__nstages_at_up_queues ) - 3'd2; i += 1'd1 ) begin
        out_q__deq__en[2'(i)] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__en[2'(i) + 2'd1] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__msg[2'(i) + 2'd1] = out_q__deq__ret[2'(i)];
      end
    end
    out_q__deq__en[3'( __const__nstages_at_up_queues ) - 3'd2] = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__en = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__msg = out_q__deq__ret[3'( __const__nstages_at_up_queues ) - 3'd2];
  end

  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign in_q__enq__en = req__en;
  assign in_q__enq__msg = req__msg;
  assign req__rdy = in_q__enq__rdy;
  assign i2flt__clk = clk;
  assign i2flt__reset = reset;
  assign flt2i__clk = clk;
  assign flt2i__reset = reset;
  assign out_q__clk[0] = clk;
  assign out_q__reset[0] = reset;
  assign out_q__clk[1] = clk;
  assign out_q__reset[1] = reset;
  assign out_q__clk[2] = clk;
  assign out_q__reset[2] = reset;

endmodule


// PyMTL VerilogPlaceholder DW_fp_div_seq_wrapper Definition
// Full name: DW_fp_div_seq_wrapper__input_reg_1__internal_reg_1__output_reg_0
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_div_seq.py

//***********************************************************
// Pickled source file of placeholder DW_fp_div_seq_wrapper__7baf9b00dddd9d01
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder DW_fp_div_seq_wrapper
//-----------------------------------------------------------

`ifndef DW_FP_DIV_SEQ_WRAPPER
`define DW_FP_DIV_SEQ_WRAPPER

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component DW_fp_div_seq_wrapper__7baf9b00dddd9d01.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!

`line 1 "/work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/dw_srcs/DW_fp_div.v" 0

////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2006 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Kyung-Nam Han, Mar. 22, 2006
//
// VERSION:   Verilog Simulation Model for DW_fp_div
//
// DesignWare_version: f5eace03
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------
//
// ABSTRACT: Floating-Point Divider
//
//              DW_fp_div calculates the floating-point division
//              while supporting six rounding modes, including four IEEE
//              standard rounding modes.
//
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              ieee_compliance support the IEEE Compliance 
//                              0 - IEEE 754 compatible without denormal support
//                                  (NaN becomes Infinity, Denormal becomes Zero)
//                              1 - IEEE 754 compatible with denormal support
//                                  (NaN and denormal numbers are supported)
//              faithful_round  select the faithful_rounding that admits 1 ulp error
//                              0 - default value. it keeps all rounding modes
//                              1 - z has 1 ulp error. RND input does not affect
//                                  the output
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              b               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              rnd             3 bits
//                              Rounding Mode Input
//
//              Output ports    Size & Description
//              ============    ==================
//              z               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Output
//              status          8 bits
//                              Status Flags Output
//
// MODIFIED: May   7. 2007 Kyung-Nam Han (from 0703-SP2)
//             Fixed the rounding error of denormal numbers 
//             when ieee_compliance = 1
//           Oct. 18. 2007 Kyung-Nam Han from 0712
//             Fixed the 'divide by zero' flag when 0/0 
//           Jan.  2. 2008 Kyung-Nam Han from 0712-SP1
//             New parameter, faithful_round, is introduced
//           Jun.  4. 2010 Kyung-Nam Han (from D-2010.03-SP3)
//             Removed VCS error [IRIPS] when sig_width = 2 and 3.
//
//-----------------------------------------------------------------------------

module DW_fp_div (a, b, rnd, z, status);

  parameter sig_width = 23;      // range 2 to 253
  parameter exp_width = 8;       // range 3 to 31
  parameter ieee_compliance = 0; // range 0 to 1
  parameter faithful_round = 0;  // range 0 to 1

  input  [sig_width + exp_width:0] a;
  input  [sig_width + exp_width:0] b;
  input  [2:0] rnd;
  output [sig_width + exp_width:0] z;
  output [7:0] status;

  // synopsys translate_off



  //-------------------------------------------------------------------------
  // parameter legality check
  //-------------------------------------------------------------------------
    
 
  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;
    
      
    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end
      
    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end
      
    if ( (ieee_compliance < 0) || (ieee_compliance > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter ieee_compliance (legal range: 0 to 1)",
	ieee_compliance );
    end
      
    if ( (faithful_round < 0) || (faithful_round > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter faithful_round (legal range: 0 to 1)",
	faithful_round );
    end
    
    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check 

  //-------------------------------------------------------------------------


  function [4-1:0] OIIlOlO1;
  
    input [2:0] rnd;
    input [0:0] I101O11O;
    input [0:0] I11110O0,O10110O1,O011IOO0;

    begin
      OIIlOlO1[0] = 0;
      OIIlOlO1[1] = O10110O1|O011IOO0;
      OIIlOlO1[2] = 0;
      OIIlOlO1[3] = 0;
      
      if ($time > 0)
      begin
        case (rnd)
          3'b000:
          begin
            // round to nearest (even)
            OIIlOlO1[0] = O10110O1&(I11110O0|O011IOO0);
            OIIlOlO1[2] = 1;
            OIIlOlO1[3] = 0;
          end
          3'b001:
          begin
            // round to zero
            OIIlOlO1[0] = 0;
            OIIlOlO1[2] = 0;
            OIIlOlO1[3] = 0;
          end
          3'b010:
          begin
            // round to positive infinity
            OIIlOlO1[0] = ~I101O11O & (O10110O1|O011IOO0);
            OIIlOlO1[2] = ~I101O11O;
            OIIlOlO1[3] = ~I101O11O;
          end
          3'b011:
          begin
            // round to negative infinity
            OIIlOlO1[0] = I101O11O & (O10110O1|O011IOO0);
            OIIlOlO1[2] = I101O11O;
            OIIlOlO1[3] = I101O11O;
          end
          3'b100:
          begin
            // round to nearest (up)
            OIIlOlO1[0] = O10110O1;
            OIIlOlO1[2] = 1;
            OIIlOlO1[3] = 0;
          end
          3'b101:
          begin
            // round away form 0
            OIIlOlO1[0] = O10110O1|O011IOO0;
            OIIlOlO1[2] = 1;
            OIIlOlO1[3] = 1;
          end
          default:
          begin
            $display("error! illegal rounding mode.\n");
            $display("a : %b", a);
            $display("rnd : %b", rnd);
          end
        endcase
      end
    end
  endfunction

  reg [(exp_width + sig_width):0] IOOIlI0I;
  reg [exp_width-1:0] l1l1O100,lO101111;
  reg [exp_width+1:0] lI00O00I;
  reg IOO1O01O;
  reg [exp_width+1:0] O10101O1;
  reg I1O1O11O;
  reg [exp_width+1:0] lO1O0OI1;
  reg signed [exp_width+1:0] IO10IOO1;
  reg l10OO10O;
  reg [sig_width:0] OlOO00lO,OOIl0010,IOOl0lII,l11Illl0,lO001Ol0;
  reg [sig_width:0] I0OI1lO0;
  reg [(2 * sig_width + 2)  :0] IOIlII10;
  reg [sig_width:0] O10110O1;
  reg O011IOO0,I101O11O;
  reg [1:0] lO011100;
  reg [4-1:0] I11IO1I1;
  reg [8    -1:0] OO000O0O;
  reg [(exp_width + sig_width):0] O00OO1I0;
  reg [(exp_width + sig_width):0] IIl1O10O;
  reg I00lIO1l;
  reg lOI111I1;
  reg O100O11l;
  reg l10OO1I0;
  reg l1O1Ol0O;
  reg I000lO00;
  reg l1OllI0I;
  reg lO00I10I;
  reg IIIl11O1;
  reg [sig_width - 1:0] OOO111OO;
  reg [sig_width - 1:0] l000I1O0;
  reg [7:0] O00O1Ol1;
  reg [7:0] II01O1O0;
  reg [exp_width + 1:0] OIIO0OOl;
  reg [sig_width:0] l0III011;
  reg [sig_width:0] OO0lIO1O;
  reg [sig_width:0] II0IIO1O;
  reg [8:0] O1lO00O0;
  reg [8:0] I0I0Il0O;
  reg [9:0] l110l11I;
  reg [sig_width + 9:0] IO00O1O1;
  reg IOOlIOOO;
  reg [8:0] OOI10OIO;
  reg [sig_width + 9:0] l0IO1lOO;
  reg [sig_width + 1:0] OO0OO1I0;
  reg [2 * sig_width - 7:0] O00OI010;
  reg [sig_width + 3:0] IOIlOO00;
  reg [sig_width + 3:0] O0O0IIII;
  reg [sig_width + 3:0] II11llO0;
  reg l0101100;
  reg [sig_width + 3:0] l0I1OOll;
  reg [((sig_width >= 11) ? 2 * sig_width - 21 : 0):0] OIlI10I1;
  reg [((sig_width >= 11) ? sig_width - 11 : 0):0] Ol1O10O0;
  reg [((sig_width >= 11) ? 2 * sig_width - 21 : 0):0] O1l11OIO;
  reg [sig_width + 3:0] Il101Il1;
  reg IOll10OO;
  reg [sig_width + 3:0] O0l0O011;
  reg [((sig_width >= 25) ? sig_width - 25 : 0):0] OOO01OO1;
  reg [((sig_width >= 24) ? 2 * sig_width - 47 : 0):0] O0O1011O;
  reg [((sig_width >= 24) ? 2 * sig_width - 47 : 0):0] llOO0II1;
  reg [((sig_width >= 25) ? sig_width - 25 : 0):0] O010I0IO;
  reg [sig_width + 3:0] OOOl110I;
  reg O00O00O1;
  reg [sig_width + 3:0] lI100I0I;
  reg [8:0] I10l01Il;
  reg [sig_width + 3:0] O1O0011O;
  reg [sig_width + 3:0] O1O1O01l;
  reg [sig_width + 3:0] l0I1OI0l;
  reg [8:8 - sig_width] IIOI0lOO;
  reg [sig_width:0] O11OOOOl;
  reg [sig_width:0] OO1110O0;
  reg [sig_width:0] I01II0I0;
  reg [sig_width:0] IOIOI010;
  reg IOO101lO;
  reg OlIlOOIO;
  reg I010IlI0;
  reg I11OIl0O;
  reg Ol01O010;


  always @(a or b or rnd) begin : a1000_PROC
    I101O11O = a[(exp_width + sig_width)] ^ b[(exp_width + sig_width)];
    l1l1O100 = a[((exp_width + sig_width) - 1):sig_width];
    lO101111 = b[((exp_width + sig_width) - 1):sig_width];
    OOO111OO = a[(sig_width - 1):0];
    l000I1O0 = b[(sig_width - 1):0];
    O00O1Ol1 = 0;
    II01O1O0 = 0;
    I0OI1lO0 = 0;

    OO000O0O = 0;

    // division table for special inputs
    //
    //  -------------------------------------------------
    //         a      /       b      |       result
    //  -------------------------------------------------
    //        nan     |      any     |        nan
    //        any     |      nan     |        nan
    //        inf     |      inf     |        nan
    //         0      |       0      |        nan
    //        inf     |      any     |        inf
    //        any     |       0      |        inf
    //         0      |      any     |         0
    //        any     |      inf     |         0
    //  -------------------------------------------------
    // when ieee_compliance = 0, 
    // denormal numbers are considered as zero and 
    // nans are considered as infinity

    if (ieee_compliance)
    begin
      I00lIO1l = (l1l1O100 == ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (OOO111OO == 0);
      lOI111I1 = (lO101111 == ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (l000I1O0 == 0);
      O100O11l = (l1l1O100 == ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (OOO111OO != 0);
      l10OO1I0 = (lO101111 == ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (l000I1O0 != 0);
      l1O1Ol0O = (l1l1O100 == 0) & (OOO111OO == 0);
      I000lO00 = (lO101111 == 0) & (l000I1O0 == 0);
      l1OllI0I = (l1l1O100 == 0) & (OOO111OO != 0);
      lO00I10I = (lO101111 == 0) & (l000I1O0 != 0);

      O00OO1I0 = {I101O11O, {(exp_width){1'b1}}, {(sig_width){1'b0}}}; 
      IIl1O10O = {1'b0, {(exp_width){1'b1}}, {(sig_width - 1){1'b0}}, 1'b1};
    end
    else
    begin
      I00lIO1l = (l1l1O100 == ((((1 << (exp_width-1)) - 1) * 2) + 1));
      lOI111I1 = (lO101111 == ((((1 << (exp_width-1)) - 1) * 2) + 1));
      O100O11l = 0;
      l10OO1I0 = 0;
      l1O1Ol0O = (l1l1O100 == 0);
      I000lO00 = (lO101111 == 0);
      l1OllI0I = 0;
      lO00I10I = 0;

      O00OO1I0 = {I101O11O, {(exp_width){1'b1}}, {(sig_width){1'b0}}};
      IIl1O10O = {1'b0, {(exp_width){1'b1}}, {(sig_width){1'b0}}};
    end

    //OO000O0O[7] = I000lO00 & ~l1O1Ol0O; 
    OO000O0O[7] = (ieee_compliance) ?
            I000lO00 & ~(l1O1Ol0O | O100O11l | I00lIO1l) :
            I000lO00 & ~(l1O1Ol0O | O100O11l); 

    if (O100O11l || l10OO1I0 || (I00lIO1l && lOI111I1) || (l1O1Ol0O && I000lO00))
    begin
      IOOIlI0I = IIl1O10O;
      OO000O0O[2] = 1;
    end
    else if (I00lIO1l || I000lO00)
    begin
      IOOIlI0I = O00OO1I0;
      OO000O0O[1] = 1;
    end
    else if (l1O1Ol0O || lOI111I1)
    begin
      OO000O0O[0] = 1;
      IOOIlI0I = 0;
      IOOIlI0I[(exp_width + sig_width)] = I101O11O;
    end
  
    else
    begin
      if (ieee_compliance) 
      begin

        if (l1OllI0I) 
        begin
          OlOO00lO = {1'b0, a[(sig_width - 1):0]};

          while(OlOO00lO[sig_width] != 1)
          begin
            OlOO00lO = OlOO00lO << 1;
            O00O1Ol1 = O00O1Ol1 + 1;
          end
        end 
        else
        begin
          OlOO00lO = {1'b1, a[(sig_width - 1):0]};
        end

        if (lO00I10I) 
        begin
          OOIl0010 = {1'b0, b[(sig_width - 1):0]};
          while(OOIl0010[sig_width] != 1)
          begin
            OOIl0010 = OOIl0010 << 1;
            II01O1O0 = II01O1O0 + 1;
          end
        end 
        else
        begin
          OOIl0010 = {1'b1, b[(sig_width - 1):0]};
        end
      end
      else
      begin
        OlOO00lO = {1'b1, a[(sig_width - 1):0]};
        OOIl0010 = {1'b1, b[(sig_width - 1):0]};
      end

      // XXX: berkin
      /* verilator lint_off WIDTH */

      I010IlI0 = (OlOO00lO == OOIl0010);
      Ol01O010 = (OOIl0010[sig_width - 1:0] == 0);
      l0III011 = OlOO00lO;
      OO0lIO1O = (ieee_compliance) ? OOIl0010 : {1'b1, l000I1O0};
      II0IIO1O = (faithful_round) ? OO0lIO1O : {OO0lIO1O, 1'b0};
      O1lO00O0 = (sig_width >= 9) ? II0IIO1O[sig_width - 1:((sig_width >= 9) ? sig_width - 9 : 0)] : {II0IIO1O[sig_width - 1:0], {(((sig_width >= 9) ? 1 : 9 - sig_width)){1'b0}}};
      l110l11I = {1'b1, O1lO00O0[8:0]};
      I0I0Il0O = {1'b1, 18'b0} / (l110l11I + 1);
      IO00O1O1 = I0I0Il0O * l0III011;
      IOOlIOOO = IO00O1O1[sig_width + 9];
      OOI10OIO = (IOOlIOOO) ? IO00O1O1[sig_width + 9:sig_width + 1] : IO00O1O1[sig_width + 8:sig_width];
      l0IO1lOO = II0IIO1O * I0I0Il0O;
      OO0OO1I0 = ~l0IO1lOO[sig_width + 1:0];
      O00OI010 = IO00O1O1[((sig_width <= 3) ? 0 : sig_width + 9):((sig_width <= 3) ? 0 : 13)] * OO0OO1I0[((sig_width <= 3) ? 0 : sig_width + 1):((sig_width <= 3) ? 0 : 5)];
      IOIlOO00 = IO00O1O1[sig_width + 9:6];
      O0O0IIII = {6'b0, O00OI010[2 * (sig_width - 3) - 1:2 * (sig_width - 3) - 1 - sig_width + 5 - 1]};
      II11llO0 = IOIlOO00 + O0O0IIII;
      l0101100 = II11llO0[sig_width + 3];
      l0I1OOll = (sig_width <= 14) ? ((l0101100) ? II11llO0 : {II11llO0[sig_width + 2:0], 1'b0}) : II11llO0;
      OIlI10I1 = (sig_width >= 11) ? OO0OO1I0[((sig_width >= 11) ? sig_width + 1 : 0):((sig_width >= 11) ? 12 : 0)] * OO0OO1I0[((sig_width >= 11) ? sig_width + 1 : 0):((sig_width >= 11) ? 12 : 0)] : 0;
      Ol1O10O0 = (sig_width >= 11) ? OIlI10I1[((sig_width >= 11) ? 2 * sig_width - 21 : 0):((sig_width >= 11) ? sig_width - 10 : 0)] : 0;
      O1l11OIO = (sig_width >= 11) ? l0I1OOll[((sig_width >= 11) ? sig_width + 3 : 0):((sig_width >= 11) ? 14 : 0)] * Ol1O10O0 : 0;
      Il101Il1 = l0I1OOll + O1l11OIO[((sig_width >= 11) ? 2 * sig_width - 21 : 0):((sig_width >= 11) ? sig_width - 10 : 0)];
      IOll10OO = Il101Il1[sig_width + 3];
      O0l0O011 = (sig_width <= 30) ? ((IOll10OO) ? Il101Il1 : {Il101Il1[sig_width + 2:0], 1'b0}) : Il101Il1;
      OOO01OO1 = (sig_width >= 25) ? Ol1O10O0[((sig_width >= 25) ? sig_width - 11 : 0):((sig_width >= 25) ? 13 : 0)] : 0;
      O0O1011O = OOO01OO1 * OOO01OO1;
      llOO0II1 = (sig_width >= 25) ? O0l0O011[((sig_width >= 25) ? sig_width + 3 : 0):((sig_width >= 25) ? 27 : 0)] * O0O1011O[((sig_width >= 25) ? 2 * sig_width - 47 : 0):((sig_width >= 25) ? sig_width - 23 : 0)] : 0;
      O010I0IO = (sig_width >= 25) ? llOO0II1[((sig_width >= 25) ? 2 * sig_width - 47 : 0):((sig_width >= 25) ? sig_width - 22 : 0)] : 0;
      OOOl110I = O0l0O011 + O010I0IO;
      O00O00O1 = OOOl110I[sig_width + 3];
      lI100I0I = ((O00O00O1) ? OOOl110I : {OOOl110I[sig_width + 2:0], 1'b0});
      I10l01Il = (sig_width == 8) ? OOI10OIO + 1 : 
               (sig_width < 8)  ? OOI10OIO + {1'b1, {(((sig_width >= 8) ? 1 : ((sig_width >= 8) ? 0 : 8 - sig_width - 1) + 1)){1'b0}}} : 
                                  0;
      O1O0011O = l0I1OOll + 4'b1000;
      O1O1O01l = O0l0O011 + 4'b1000;
      l0I1OI0l = lI100I0I + 4'b1000;
      IIOI0lOO = (sig_width == 8)  ? OOI10OIO[8:0] : 
                   (OOI10OIO[((sig_width >= 8) ? 0 : 8 - sig_width - 1)]) ? I10l01Il[8:((sig_width >= 8) ? 0 : 8 - sig_width - 1) + 1] : 
                                       OOI10OIO[8:((sig_width >= 8) ? 0 : 8 - sig_width - 1) + 1];
      O11OOOOl = (l0I1OOll[2]) ? O1O0011O[sig_width + 3:3] : l0I1OOll[sig_width + 3:3];
      OO1110O0 = (O0l0O011[2]) ? O1O1O01l[sig_width + 3:3] : O0l0O011[sig_width + 3:3];
      I01II0I0 = (lI100I0I[2]) ? l0I1OI0l[sig_width + 3:3] : lI100I0I[sig_width + 3:3];
      IOIOI010 = (sig_width <= 8) ? IIOI0lOO : (sig_width <= 14) ? O11OOOOl : (sig_width <= 30) ? OO1110O0 : I01II0I0;
      I11OIl0O = (faithful_round) ? (IOIOI010 == 0) : 0;
      IOO101lO = (sig_width <= 8) ? IOOlIOOO: (sig_width <= 14) ? l0101100 : (sig_width <= 30) ? IOll10OO : O00O00O1;
      OlIlOOIO = ~I010IlI0 & (l000I1O0 != 0);

      IOIlII10 = {OlOO00lO,{(sig_width + 2){1'b0}}} / OOIl0010;
      O10110O1 = (faithful_round) ? OlIlOOIO : {OlOO00lO,{(sig_width + 2){1'b0}}} % OOIl0010;

      lI00O00I = (l1l1O100 - O00O1Ol1 + l1OllI0I) - (lO101111 - II01O1O0 + lO00I10I) + ((1 << (exp_width-1)) - 1);
      O10101O1 = lI00O00I-1;

      l11Illl0 = (faithful_round) ?
                   ((Ol01O010 & ~ieee_compliance) ? l0III011 : IOIOI010) :
                   ((~IOIlII10[(sig_width + 2)]) ? IOIlII10[(sig_width + 2) - 1:1] : IOIlII10[(sig_width + 2):2]);
      lO011100 = ~IOIlII10[(sig_width + 2)] ? IOIlII10[1:0] : IOIlII10[2:1];
      IO10IOO1 = ~IOIlII10[(sig_width + 2)] ? O10101O1 : lI00O00I;
      IIIl11O1 = ((IO10IOO1 <= 0) | (IO10IOO1[exp_width + 1] == 1));
      O011IOO0 = (faithful_round) ? 
              ((Ol01O010 | I010IlI0) & ~IIIl11O1 ? 0 : 1) :
              ((O10110O1===0)?1'b0:1'b1); 


      if (ieee_compliance) begin
        if ((IO10IOO1 <= 0) | (IO10IOO1[exp_width + 1] == 1)) begin

          OIIO0OOl = 1 - IO10IOO1;
        
          {l11Illl0, I0OI1lO0} = {l11Illl0, {(sig_width + 1){1'b0}}} >> OIIO0OOl;

          if (OIIO0OOl > sig_width + 1) begin
            O011IOO0 = 1;
          end

          lO011100[1] = l11Illl0[0];
          lO011100[0] = I0OI1lO0[sig_width];

          if (I0OI1lO0[sig_width - 1:0] != 0) begin
            O011IOO0 = 1;
          end
        end
      end

      I11IO1I1 = OIIlOlO1(rnd, I101O11O, lO011100[1], lO011100[0], O011IOO0);
   
      lO001Ol0 = (faithful_round) ? l11Illl0 :
                    (I11IO1I1[0] === 1)? (l11Illl0+1):l11Illl0;

      if ((IO10IOO1 >= ((((1 << (exp_width-1)) - 1) * 2) + 1)) & (IO10IOO1[exp_width+1] === 1'b0))
      begin
        OO000O0O[4] = 1;
        OO000O0O[5] = 1;
        if(I11IO1I1[2] === 1)
        begin
          IOOl0lII = O00OO1I0[sig_width:0];
          lO1O0OI1 = ((((1 << (exp_width-1)) - 1) * 2) + 1);
          OO000O0O[1] = 1;
        end
        else
        begin
          IOOl0lII = -1;
          lO1O0OI1 = ((((1 << (exp_width-1)) - 1) * 2) + 1) - 1;
        end
      end
  
      else if ((IO10IOO1 <= 0) | (IO10IOO1[exp_width+1] === 1'b1)) begin
        OO000O0O[3] = 1;

        if (ieee_compliance == 0) begin
          OO000O0O[5] = 1;

          if(I11IO1I1[3] === 1) begin
            IOOl0lII = 0;
            lO1O0OI1 = 0 + 1;
          end
          else begin
            IOOl0lII = 0;
            lO1O0OI1 = 0;
            OO000O0O[0] = 1;
          end
        end
        else begin
          IOOl0lII = lO001Ol0;

          lO1O0OI1 = lO001Ol0[sig_width];

        end
      end
      else begin
        IOOl0lII = (I010IlI0 & faithful_round) ? 0 : lO001Ol0;
        lO1O0OI1 = IO10IOO1;
      end

      if ((IOOl0lII[sig_width - 1:0] == 0) & (lO1O0OI1[exp_width - 1:0] == 0)) begin
        OO000O0O[0] = 1;
      end
  
      OO000O0O[5] = OO000O0O[5] | I11IO1I1[1];
   
      IOOIlI0I = {I101O11O,lO1O0OI1[exp_width-1:0],IOOl0lII[sig_width-1:0]};
    end
  end
   
  assign status = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0) || (^(rnd ^ rnd) !== 1'b0)) ? {8'bx} : OO000O0O;
  assign z = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0) || (^(rnd ^ rnd) !== 1'b0)) ? {8'bx} : IOOIlI0I;

  // synopsys translate_on

endmodule
  
  
  

// End of all v_libs files for component DW_fp_div_seq_wrapper__7baf9b00dddd9d01

`line 1 "/work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/dw_srcs/DW_fp_div_seq.v" 0
////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2006 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Kyung-Nam Han, Sep. 25, 2006
//
// VERSION:   Verilog Simulation Model for DW_fp_div_seq
//
// DesignWare_version: 67525c4c
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ABSTRACT: Floating-Point Sequencial Divider
//
//              DW_fp_div_seq calculates the floating-point division
//              while supporting six rounding modes, including four IEEE
//              standard rounding modes.
//
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              ieee_compliance support the IEEE Compliance
//                              0 - IEEE 754 compatible without denormal support
//                                  (NaN becomes Infinity, Denormal becomes Zero)
//                              1 - IEEE 754 standard compatible
//                                  (NaN and denormal numbers are supported)
//              num_cyc         Number of cycles required for the FP sequential
//                              division operation including input and output
//                              register. Actual number of clock cycle is
//                              num_cyc - (1 - input_mode) - (1 - output_mode)
//                               - early_start + internal_reg
//              rst_mode        Synchronous / Asynchronous reset
//                              0 - Asynchronous reset
//                              1 - Synchronous reset
//              input_mode      Input register setup
//                              0 - No input register
//                              1 - Input registers are implemented
//              output_mode     Output register setup
//                              0 - No output register
//                              1 - Output registers are implemented
//              early_start     Computation start (only when input_mode = 1)
//                              0 - start computation in the 2nd cycle
//                              1 - start computation in the 1st cycle (forwarding)
//                              early_start should be 0 when input_mode = 0
//              internal_reg    Insert a register between an integer sequential divider
//                              and a normalization unit
//                              0 - No internal register
//                              1 - Internal register is implemented
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              b               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              rnd             3 bits
//                              Rounding Mode Input
//              clk             Clock
//              rst_n           Reset. (active low)
//              start           Start operation
//                              A new operation is started by setting start=1
//                              for 1 clock cycle
//              z               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Output
//              status          8 bits
//                              Status Flags Output
//              complete        Operation completed
//
// Modified:
//   6/05/07 KYUNG (0703-SP3)
//           The legal range of num_cyc parameter widened.
//   3/25/08 KYUNG (0712-SP3)
//           Fixed the reset error (STAR 9000234177)
//   1/29/10 KYUNG (D-2010.03)
//           1. Removed synchronous DFF when rst_mode = 0 (STAR 9000367314)
//           2. Fixed complete signal error at the reset  (STAR 9000371212)
//           3. Fixed divide_by_zero flag error           (STAR 9000371212)
//   2/27/12 RJK (F-2011.09-SP4)
//           Added missing message when input changes during calculation
//           while input_mode=0 (STAR 9000523798)
//   9/22/14 KYUNG (J-2014.09-SP1)
//           Modified for the support of VCS NLP feature
//   9/22/15 RJK (K-2015.06-SP3) Further update for NLP compatibility
//   2/26/16 LMSU
//           Updated to use blocking and non-blocking assigments in
//           the correct way
//-----------------------------------------------------------------------------
//
//    9/25/12  RJK (G-2012.06-SP3)
//            Corrected data corruption detection to catch input changes
//            during the first cycle of calculation (related to STAR 9000523798)

module DW_fp_div_seq (a, b, rnd, clk, rst_n, start, z, status, complete);

  parameter sig_width = 23;      // RANGE 2 TO 253
  parameter exp_width = 8;       // RANGE 3 TO 31
  parameter ieee_compliance = 0; // RANGE 0 TO 1
  parameter num_cyc = 4;         // RANGE 4 TO (2 * sig_width + 3)
  parameter rst_mode = 0;        // RANGE 0 TO 1
  parameter input_mode = 1;      // RANGE 0 TO 1
  parameter [1:0] output_mode = 1;     // RANGE 0 TO 1
  parameter early_start = 0;     // RANGE 0 TO 1
  parameter [1:0] internal_reg = 1;    // RANGE 0 TO 1


  localparam TOTAL_WIDTH = (sig_width + exp_width + 1);


//-----------------------------------------------------------------------------

  input [(exp_width + sig_width):0] a;
  input [(exp_width + sig_width):0] b;
  input [2:0] rnd;
  input clk;
  input rst_n;
  input start;

  output [(exp_width + sig_width):0] z;
  output [8    -1:0] status;
  output complete;

// synopsys translate_off

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

  
 
  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;
    
    
    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end
    
    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end
    
    if ( (ieee_compliance < 0) || (ieee_compliance > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter ieee_compliance (legal range: 0 to 1)",
	ieee_compliance );
    end
    
    if ( (num_cyc < 4) || (num_cyc > 2*sig_width+3) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter num_cyc (legal range: 4 to 2*sig_width+3)",
	num_cyc );
    end
    
    if ( (rst_mode < 0) || (rst_mode > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter rst_mode (legal range: 0 to 1)",
	rst_mode );
    end
    
    if ( (input_mode < 0) || (input_mode > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter input_mode (legal range: 0 to 1)",
	input_mode );
    end
    
    if ( (output_mode < 0) || (output_mode > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter output_mode (legal range: 0 to 1)",
	output_mode );
    end
    
    if ( (early_start < 0) || (early_start > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter early_start (legal range: 0 to 1)",
	early_start );
    end
    
    if ( (internal_reg < 0) || (internal_reg > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter internal_reg (legal range: 0 to 1)",
	internal_reg );
    end
    
    if ( (input_mode===0 && early_start===1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m : Invalid parameter combination: when input_mode=0, early_start=1 is not possible" );
    end
  
    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check 


//-----------------------------------------------------------------------------

  function integer cycle_cont;

  input l,m,n;
  integer l,m,n;
  begin
    if  ((l===1) & (m===1) & (n===0))
      cycle_cont = 3;
    else if  ((l===0) & (m===0) & (n===0))
      cycle_cont = 1;
    else if  ((l===1) & (m===0) & (n===1))
      cycle_cont = 1;
    else
      cycle_cont = 2;
  end
  endfunction

  `ifdef UPF_POWER_AWARE
  `protected
D+\7[H[_gbb&;/>OEV?+HeF17)M[>fNbedUc@YS;5:aX<7eN8#fX5)dbO)S9c+OW
QaPOO&F\&1Jf/H@_g=JIAJBS>ZXg_4<8P;V<TdW\)&]b<_[)Pb6&F;&/J\:T9]X,
22O+D-E^7KH>N(ZKD5b_c/8P45Y7ZP]#R.B&&(d,g0:(D^#TIR+8Y;aG(=HW#b=5
,#AM\__fGZX>*$
`endprotected

  `else
  integer CYC_CONT;
  `endif
  integer count;
  integer next_count;
  integer cnt_glitch;

  reg  [(exp_width + sig_width):0] ina;
  reg  [(exp_width + sig_width):0] inb;
  reg  [(exp_width + sig_width):0] next_ina;
  reg  [(exp_width + sig_width):0] next_inb;
  reg  [(exp_width + sig_width):0] next_z;
  reg  [(exp_width + sig_width):0] a_reg;
  reg  [(exp_width + sig_width):0] b_reg;
  reg  [(exp_width + sig_width):0] next_int_z;
  reg  [(exp_width + sig_width):0] int_z;
  reg  [(exp_width + sig_width):0] int_z_d1;
  reg  [(exp_width + sig_width):0] int_z_d2;
  reg  [7:0] next_int_status;
  reg  [7:0] int_status;
  reg  [7:0] int_status_d1;
  reg  [7:0] int_status_d2;
  reg  [7:0] next_status;
  reg  [2:0] rnd_reg;
  reg  next_complete;
  reg  new_input;
  reg  new_input_pre;
  reg  new_input_reg_d1;
  reg  new_input_reg_d2;
  reg  next_int_complete;
  reg  int_complete;
  reg  int_complete_d1;
  reg  int_complete_d1_syn;
  reg  int_complete_d1_asyn;
  reg  int_complete_d2;
  reg  int_complete_d2_syn;
  reg  int_complete_d2_asyn;
  reg  count_reseted;
  reg  next_count_reseted;

  wire [(exp_width + sig_width):0] ina_div;
  wire [(exp_width + sig_width):0] inb_div;
  wire [(exp_width + sig_width):0] z;
  wire [(exp_width + sig_width):0] temp_z;
  wire [(exp_width + sig_width):0] a_new;
  wire [(exp_width + sig_width):0] b_new;
  wire [7:0] status;
  wire [7:0] temp_status;
  wire [2:0] rnd_new;
  wire [1:0] output_cont;
  wire clk, rst_n;
  wire complete;
  wire start_n;
  wire start_in;

  reg  start_clk;
  reg  rst_n_clk;
  reg  reset_st;
  wire rst_n_rst;

  initial
  begin
    `ifndef UPF_POWER_AWARE
    CYC_CONT = (internal_reg) ?
                 cycle_cont(input_mode, output_mode, early_start) + 1:
                 cycle_cont(input_mode, output_mode, early_start);
    `endif
    new_input_pre = 0;
    next_count_reseted = 0;
  end

  wire corrupt_data;

generate
  if (input_mode == 0) begin : GEN_IM_EQ_0

    localparam [0:0] NO_OUT_REG = (output_mode == 0)? 1'b1 : 1'b0;
    reg [TOTAL_WIDTH-1:0] ina_hist;
    reg [TOTAL_WIDTH-1:0] inb_hist;
    wire next_corrupt_data;
    reg  corrupt_data_int;
    wire data_input_activity;
    reg  init_complete;
    wire next_alert1;
    integer change_count;

    assign next_alert1 = next_corrupt_data & rst_n & init_complete &
                                    ~start & ~complete;

    if (rst_mode == 0) begin : GEN_A_RM_EQ_0
      always @ (posedge clk or negedge rst_n) begin : ar_hist_regs_PROC
	if (rst_n === 1'b0) begin
	    ina_hist        <= a;
	    inb_hist        <= b;
	    change_count    <= 0;

	  init_complete   <= 1'b0;
	  corrupt_data_int <= 1'b0;
	end else begin
	  if ( rst_n === 1'b1) begin
	      ina_hist        <= a;
	      inb_hist        <= b;
	      change_count    <= (start == 1'b1)? 0 :
	                         (next_alert1 == 1'b1)? change_count + 1 : change_count;
	    init_complete   <= init_complete | start;
	    corrupt_data_int<= next_corrupt_data | (corrupt_data_int & ~start);
	  end else begin
	    ina_hist        <= {TOTAL_WIDTH{1'bx}};
	    inb_hist        <= {TOTAL_WIDTH{1'bx}};
	    change_count    <= -1;
	    init_complete   <= 1'bx;
	    corrupt_data_int <= 1'bX;
	  end
	end
      end
    end else begin : GEN_A_RM_NE_0
      always @ (posedge clk) begin : sr_hist_regs_PROC
	if (rst_n === 1'b0) begin
	    ina_hist        <= a;
	    inb_hist        <= b;
	    change_count    <= 0;
	  init_complete   <= 1'b0;
	  corrupt_data_int <= 1'b0;
	end else begin
	  if ( rst_n === 1'b1) begin
	      ina_hist        <= a;
	      inb_hist        <= b;
	      change_count    <= (start == 1'b1)? 0 :
	                         (next_alert1 == 1'b1)? change_count + 1 : change_count;
	    init_complete   <= init_complete | start;
	    corrupt_data_int<= next_corrupt_data | (corrupt_data_int & ~start);
	  end else begin
	    ina_hist        <= {TOTAL_WIDTH{1'bx}};
	    inb_hist        <= {TOTAL_WIDTH{1'bx}};
	    init_complete    <= 1'bx;
	    corrupt_data_int <= 1'bX;
	    change_count     <= -1;
	  end
	end
      end
    end // GEN_A_RM_NE_0

    assign data_input_activity =  (((a !== ina_hist)?1'b1:1'b0) |
				 ((b !== inb_hist)?1'b1:1'b0)) & rst_n;

    assign next_corrupt_data = (NO_OUT_REG | ~complete) &
                              (data_input_activity & ~start &
					init_complete);

`ifdef UPF_POWER_AWARE
  `protected
Ja^-K:@A#=EOc[;9J-MMC]83F2N)3W(eQQ)Qfa,8cP)=?+^NIU?B&)c:>T(^Q8].
@gZ&79(TJ71N6M+PBNNKX)JSL2X9\)(3IBX#Xf\Bgga,S)LU.gT_,EITW-6_U54&
?-Gf;L5+9/3&^H:_6XLAV,1gdOSZA+>VEA7(DVJQ-Q9U_IKPg]\LB5XPXa4@afOe
WUf<?ZWQO@d:7#>[4#[4[#_/,Y<5@/;T_@,-VBLXBF>[:.U/NAM#S#[.\1==O0#Q
ZNa#E5]1U4FW8a)#,^M_6V:#4c>,<)RAfO<9ae:5^5=G80ATDIRed+f.YIN=FULd
&X<9R54]gIf]854g9a&G:_M;UYD\H#PaVP6RT:+DIbNX#:X4;-T[OgHQ(Y,7B)@E
R0+O4)=;GdA[BTP&c<(9/&S4d=9Y+_NN3);HLHQ=ZO>V1.RQ/X7[3R3gE=<g7c:5
d:G8(I,UcN&R<a=WCdbLB4[6JfD^;SG0.aY^7RH^b54QH=6B=9f[7PKQ9@Wa<#:_
]_bXKA+Og@ZaSV&>(AAX_QUBQ-a@[V@?\Wf9YL4AXT._KZ4gX4>_e_XKDHEVXSe<
XSMR4V@?()#)[HQ+c@+W]P]HSf?CK?9f41Wd<OC,W@ZW;W6I?MG5@eG6Z),/EYdP
e:?/:]T37-2OJ^U\[HNQ>YC9^+189Tf,-dMP[WK.1V[MQ29^KYgM(LcW\X-Y5ONa
3]K.Pf1Y:/C3-OSUd&><c2MaY;>BJM2A\=cA<AEFV#I3GX/dgZ42NZ>cWP?_6Dce
/cJVF&1[E(TLS<(,EaC_]VYPZ=?/,##BJB[3Z3,GED0+TeGKM4[_]fQ-gPe.:bbJ
?F\U2NNX,58b),?+bI0)D9SWddKM5IL5-Z)ZRR^89.=(aZ4M;#.A66=4.K_4P\3.
WL;&FS/S\)<:#C,;?YD\HNOS)0D7e-JW[c_WKK/g+.A_6>(NDb=7NAc@HS>O\&(d
)2A_#2gY^(ETH.4d0<GOVP6<O0SS2cG<.gAD#03_5;V2GM5-Z0&)DY7SM1VgY3_.
,-.&f.2VERU@]F#aHM(_BIE>KDM@ff[O#F==aE.Q:WU>e)+IAPY5UQ?1b<[:(B-L
3:4A;V:d2E@=)^]+-DQ1L88PS_bLH[?dQJ6.H^5I(,Q.J1[<RM?&@aA#7QaU=[df
egW70,K4ef/I^]YZeb.\Yg:e/DY&G(E5Y1\.PF<c1;DZB(A9baf_f[]>#14_&#/]
RJK&[aP9=C^Z?T9.9K(9ZQIB:(JL94A[^6@84Q5T2Y7:YQE9V7O7Da>#ad=^9f.M
LbKHgU1#)HJ/L4X7>),91BT[<LJ2LeTA<b(;?\QC\>6F>#5g(U^8=X7Z05N_4/Kf
]>()_TUa5@a.T;7SP0([T#]gM78[L,ZC+M#[(M>?d2_-)1)1D_.e3WC9G81\CJcF
Z/@TC\NQ9=LNA0;M0=A5[TZ46+PPQG=4aX9R&X^#N,K[RK0[<:T]J[9cRT@S>;.S
XSeFd2ZIY4;6\1,(.SV>b[4<a&fD,/S)eX>L<UI&dDQ7I=S+:=:51H.a42E&(KdW
[@44CD=f.>a\?1#<IJJf5[Y(D<?DFNegc?#QX0(g3?AHYS4b3YAe=@SfBRD0,c<(
/_O<LI9==b6A35&Z?]ZYR=>X@2?db1:KS0Y=a>((DXNX0/FM2D>dU)R8A(f)YJ_N
3PDFTI(:#<#<.)N/AW35b->eTM)YeKJFXUbB+B7K-WU,g<Q.B1HcU(7NDfIVVFI:
<c;U=JM?-+c3N7[+2+[IDM[(,.07EH?5c+DRZF1L@@Q@ZKD0N3Q>7\Y/S7DPP1=2
#bP83&CEC4;-b6TfYa0N:B)]\#7QM&SEG0O<YYXMcY<(@CGc+5.gcSACSfT7]BK+
>g/IJgWCKQTLVOCWaSDMdPAGHT=+W1OWD3[;cO=^6TQ_MfcX4V(]6<>=dYC9c?8H
aO9HR<R>9K?2MNC6>419K>dO6Y:4@RKdIC7JVcNBA0e^)<>+=Cc\-1TLY>[^DRT>
-9=&V0b3=@FI&OTTX^O?99:E^7KCM1@H_XA;dR<e]gNF<-b?E:>8FDC\N;3Wf78g
/@CN\aa@1LK>dX#J&aR2&=7<:JGVDKafNR(4VK]>IebOLYEQ\aIdD.:A0GMX>Jc-
;_C7)G3Te0Q:2X_<a&&TI2[)3_95aeV5=Y.]Ue<;),.(<:8)<3-NZ++#?12KS^Z<
bZ4X_H=c2UN(IB.g;J7A2\0VP#/<2&8=?@O1R.VT<<(RVBGEV-fg0T5,ZAM#7SB;
L:T2T]e6^KE[>+S/XY58Z43.@+?ZdeZebRFTdU2][4Nd<-:/\PK5R^.0fIg-c7g8
<,BRF8a:57L+6<?IZ]/&]AQLH30;J,(<//TUQ;J^GRJ,T:W.TU[@>;[Hc#]e&I,3Q$
`endprotected

`else
    always @ (posedge clk) begin : corrupt_alert_PROC
      integer updated_count;

      updated_count = change_count;

      if (next_alert1 == 1'b1) begin
        $display("## Warning from %m: DW_fp_div_seq operand input change near %0d will cause corrupted results if operation is allowed to complete.", $time);
	updated_count = updated_count + 1;
      end

      if (((rst_n & init_complete & ~start & ~complete & next_complete) == 1'b1) &&
          (updated_count > 0)) begin
	$display(" ");
	$display("############################################################");
	$display("############################################################");
	$display("##");
	$display("## Error!! : from %m");
	$display("##");
	$display("##    This instance of DW_fp_div_seq has encountered %0d change(s)", updated_count);
	$display("##    on operand input(s) after starting the calculation.");
	$display("##    The instance is configured with no input register.");
	$display("##    So, the result of the operation was corrupted.  This");
	$display("##    message is generated at the point of completion of");
	$display("##    the operation (at time %0d), separate warning(s) were", $time );
	$display("##    generated earlier during calculation.");
	$display("##");
	$display("############################################################");
	$display("############################################################");
	$display(" ");
      end
    end
`endif

    assign corrupt_data = corrupt_data_int;

  if (output_mode == 0) begin : GEN_OM_EQ_0
    reg  alert2_issued;
    wire next_alert2;

    assign next_alert2 = next_corrupt_data & rst_n & init_complete &
                                     ~start & complete & ~alert2_issued;

`ifdef UPF_POWER_AWARE
  `protected
>4Z;bM:J6A[Ue)6Y8:_)51[8<MO?9L&:f]U:WTd.fZ]c;aLNMe(&.)5<9QF28ROe
YU=R#K7TQK@-f9Nb;5PJLX-U0RK6S_PP,S[=BFQ9V?ZLULaa)eZUG;NN@?M]IW98
]_S;f1gQRD&CG+bVaPLNPL)[X&CODJ([D@1ESC@<d@4@__PI\+T(QC)(cJB#CTfX
V402C?I[;aLBTA\GCF(/dVbHNV&dG1,?;G?3AGecRZ9dOII1T(5VdeAZ1Pg:<+QA
DV.E[\J;I,E_2NZL?4g6aMbIfIY=D=1c]LEa-gA7DR^M3SMJ0Ab@S3^.1^HT]-[\
GRbM1#QaYP\&/.F/]Z8:G4RIGgOVLOWV+;eX&A,ged]10S2?Y>IZ:-EC9e2Zg])>
QLJIJ>-POEG-.DQAEW0#=GIL:bNYV+:<M8E8]>CU/+R._E4(==(J8=JeP1?X8V&H
,95\W@RLR,a3M,bG;YC(+9>44PcJ-)@dU]-ODQG@T[[\WXJ&gaEN>5eE1P>N2e]DW$
`endprotected

`else
    always @ (posedge clk) begin : corrupt_alert2_PROC
      if (next_alert2 == 1'b1) begin
        $display( "## Warning from %m: DW_fp_div_seq operand input change near %0d causes output to no longer retain result of previous operation.", $time);
      end
    end
`endif

    if (rst_mode == 0) begin : GEN_AI_REG_AR
      always @ (posedge clk or negedge rst_n) begin : ar_alrt2_reg_PROC
        if (rst_n == 1'b0) alert2_issued <= 1'b0;

	  else alert2_issued <= ~start & (alert2_issued | next_alert2);
      end
    end else begin : GEN_AI_REG_SR
      always @ (posedge clk) begin : sr_alrt2_reg_PROC
        if (rst_n == 1'b0) alert2_issued <= 1'b0;

	  else alert2_issued <= ~start & (alert2_issued | next_alert2);
      end
    end

  end  // GEN_OM_EQ_0

  // GEN_IM_EQ_0
  end else begin : GEN_IM_NE_0
    assign corrupt_data = 1'b0;
  end // GEN_IM_NE_0
endgenerate

  assign z = (reset_st) ? 0 :
             (~input_mode & new_input) ? {TOTAL_WIDTH{1'bx}} :
             (output_cont == 2) ? int_z_d2 :
             (output_cont == 1) ? int_z_d1 :
             (corrupt_data !== 1'b0)? {TOTAL_WIDTH{1'bx}} : int_z;

  assign status = (reset_st) ? 8'b0 :
                  (~input_mode & new_input) ? {8{1'bx}} :
                  (output_cont == 2) ? int_status_d2 :
                  (output_cont == 1) ? int_status_d1 :
                  (corrupt_data !== 1'b0)? {8{1'bx}} : int_status;

  generate
  if (rst_mode == 0) begin : GEN_RM_EQ_0_A
    assign complete = (~rst_n) ? 0:
                      (output_cont == 2) ? int_complete_d2 :
                      (output_cont == 1) ? int_complete_d1 :
                      int_complete;

    assign rst_n_rst = rst_n;
  end
  else begin : GEN_RM_NE_0_A
    assign complete = (output_cont == 2) ? int_complete_d2 :
                      (output_cont == 1) ? int_complete_d1 :
                      int_complete;

    assign rst_n_rst = rst_n_clk;
  end
  endgenerate

  assign start_n = ~start;
  assign output_cont = output_mode + internal_reg;

  assign ina_div = (input_mode == 1) ? ina : a;
  assign inb_div = (input_mode == 1) ? inb : b;


  always @(posedge clk) begin : a1000_PROC
    new_input_reg_d1 <= new_input_pre;
    new_input_reg_d2 <= new_input_reg_d1;

    a_reg <= a;
    b_reg <= b;
    rnd_reg <= rnd;

    if (start == 1) begin
      start_clk <= 1;
    end else begin
      start_clk <= 0;
    end

    if (rst_n == 1) begin
      rst_n_clk <= 1;
    end else begin
      rst_n_clk <= 0;
    end

  end

    always @(ina_div or inb_div) begin : a1001_PROC
      if ( (rst_n==1'b1) && (count >= (num_cyc + CYC_CONT - 4)) )
        new_input_pre = 1;
      else
        new_input_pre = 0;
    end

    always @(rst_n or count) begin : a1002_PROC
      if ( (rst_n==1'b0) || (count < (num_cyc + CYC_CONT - 4)) )
        new_input_pre = 0;
    end

  always @(new_input_reg_d1 or new_input_reg_d2 or new_input_pre) begin : a1003_PROC
    if (input_mode & ~early_start) begin
      new_input = (internal_reg) ? new_input_reg_d1 : new_input_pre;
    end
    else begin
      if (output_cont == 2) begin
        new_input = new_input_reg_d2;
      end
      else if (output_cont == 1) begin
        new_input = new_input_reg_d1;
      end
      else begin
        new_input = new_input_pre;
      end
    end
  end

  assign a_new = (internal_reg) ? a_reg : a;
  assign b_new = (internal_reg) ? b_reg : b;
  assign rnd_new = (internal_reg) ? rnd_reg : rnd;
  assign start_in = (input_mode & ~early_start) ? 1'b0 : start;

  DW_fp_div #(sig_width, exp_width, ieee_compliance) U1 (
                      .a(ina_div),
                      .b(inb_div),
                      .rnd(rnd_new),
                      .z(temp_z),
                      .status(temp_status)
  );

  generate
  if (rst_mode == 0) begin : GEN_RM_EQ_0_C
    always @(posedge clk or negedge rst_n) begin : a1004_PROC
      if (rst_n == 0) begin
        cnt_glitch <= 0;
        int_complete_d2 <= 0;
      end
      else if (rst_n == 1) begin
        if (~rst_n) begin
          cnt_glitch <= 0;
          int_complete_d2 <= 0;
        end
        else begin
          if (cnt_glitch < (num_cyc + CYC_CONT - 4)) begin
            cnt_glitch <= cnt_glitch + 1;
          end

          int_complete_d2 <= int_complete_d1;
        end
      end
    end
  end
  else begin : GEN_RM_NE_0_C
    always @(posedge clk) begin : a1005_PROC
      if (~rst_n) begin
        cnt_glitch <= 0;
        int_complete_d2 <= 0;
      end
      else begin
        if (cnt_glitch < (num_cyc + CYC_CONT - 4)) begin
          cnt_glitch <= cnt_glitch + 1;
        end

        int_complete_d2 <= int_complete_d1;
      end
    end
  end
  endgenerate

  always @(rst_n or start or a or b or ina or inb or count_reseted or next_count or
           temp_z or temp_status or output_cont or new_input) begin : next_comb_PROC
    if (start===1'b1 & count_reseted == 0) begin
      next_count_reseted = 1'b1;

      next_ina           = a;
      next_inb           = b;
      next_complete      = 1'b0;
      next_z             = {TOTAL_WIDTH{1'bx}};
      next_status        = {TOTAL_WIDTH{1'bx}};
      next_int_complete  = 0;
      next_int_z         = {TOTAL_WIDTH{1'bx}};
      next_int_status    = {TOTAL_WIDTH{1'bx}};
    end

    else if (start===1'b0 | (start == 1'b1 & count_reseted == 1)) begin
      next_count_reseted = 1'b0;

      if (next_count >= (num_cyc+CYC_CONT-4)) begin

        next_int_complete  = rst_n;
        next_int_z         = temp_z;
        next_int_status    = temp_status;

        next_ina           = ina;
        next_inb           = inb;
        next_complete      = 1'b1;

        if (input_mode == 0 | early_start) begin
          next_z             = (new_input) ? {TOTAL_WIDTH{1'bX}} : temp_z;
          next_status        = (new_input) ? {TOTAL_WIDTH{1'bX}} : temp_status;
        end else begin
          next_z             = temp_z;
          next_status        = temp_status;
        end

      end else if (next_count === -1) begin
        next_ina           = {TOTAL_WIDTH{1'bX}};
        next_inb           = {TOTAL_WIDTH{1'bX}};
        next_complete      = 1'bX;
        next_z             = {TOTAL_WIDTH{1'bX}};
        next_status        = {TOTAL_WIDTH{1'bX}};
      end else begin
        next_ina           = ina;
        next_inb           = inb;

        if (next_count >= (num_cyc + CYC_CONT - 4 - output_cont - (input_mode - early_start))) begin

          next_int_complete  = rst_n;
          next_int_z         = temp_z;
          next_int_status    = temp_status;
        end else begin
          next_int_complete  = 0;
          next_int_z         = {TOTAL_WIDTH{1'bX}};
          next_int_status    = {TOTAL_WIDTH{1'bX}};
        end

        if (next_count == (num_cyc + CYC_CONT - 4)) begin
          next_complete = 1'b1;

          if (input_mode == 0 | early_start) begin
            next_z        = (new_input) ? {TOTAL_WIDTH{1'bX}} : temp_z;
            next_status   = (new_input) ? {TOTAL_WIDTH{1'bX}} : temp_status;
          end else begin
            next_z        = temp_z;
            next_status   = temp_status;
          end
        end else begin
          next_complete = 1'b0;
          next_z        = {TOTAL_WIDTH{1'bX}};
          next_status   = {TOTAL_WIDTH{1'bX}};
        end
      end
    end

  end

  always @(start or count_reseted or count) begin : a1006_PROC
    if (start===1'b1 & count_reseted == 0)
      next_count = 0;
    else if(start===1'b0 | (start == 1'b1 & count_reseted == 1)) begin
      if (count >= (num_cyc+CYC_CONT-4))
        next_count = count;
      else if (count === -1)
        next_count = -1;
      else
        next_count = count + 1;
    end
  end

  generate
  if (rst_mode == 0) begin : GEN_RM_EQ_0_D
    always @ (posedge clk or negedge rst_n) begin: register_PROC
      if (rst_n === 1'b0) begin
        int_z           <= 0;
        int_status      <= 0;
        int_complete    <= 0;
        count_reseted   <= 0;
        count           <= 1;
        if (input_mode) begin
          ina             <= 0;
          inb             <= 0;
        end else begin
          ina             <= a;
          inb             <= b;
        end
        int_z_d1        <= 0;
        int_z_d2        <= 0;
        int_status_d1   <= 0;
        int_status_d2   <= 0;
        int_complete_d1 <= 0;
      end else if (rst_n === 1'b1) begin
        int_z           <= next_int_z;
        int_status      <= next_int_status;
        int_complete    <= next_int_complete;
        count_reseted   <= next_count_reseted;
        count           <= next_count;
        ina             <= next_ina;
        inb             <= next_inb;
        int_z_d1        <= int_z & {((exp_width + sig_width) + 1){~reset_st}};
        int_z_d2        <= int_z_d1;
        int_status_d1   <= int_status & {8{~reset_st}};
        int_status_d2   <= int_status_d1;
        if (reset_st & start_in & (cnt_glitch < num_cyc + CYC_CONT - 4)) begin
          int_complete_d1 <= 0;
        end else begin
          int_complete_d1 <= int_complete;
        end
      end else begin
        int_z           <= {(exp_width + sig_width){1'bx}};
        int_status      <= {7{1'bx}};
        int_complete    <= 1'bx;
        count_reseted   <= 1'bx;
        count           <= -1;
        ina             <= {TOTAL_WIDTH{1'bx}};
        inb             <= {TOTAL_WIDTH{1'bx}};
        int_z_d1        <= {(exp_width + sig_width){1'bx}};
        int_z_d2        <= {(exp_width + sig_width){1'bx}};
        int_status_d1   <= {7{1'bx}};
        int_status_d2   <= {7{1'bx}};
        int_complete_d1 <= 1'bx;
      end
    end
  end
  else begin : GEN_RM_NE_0_D
    always @ ( posedge clk) begin: register_PROC
      if (rst_n === 1'b0) begin
        int_z           <= 0;
        int_status      <= 0;
        int_complete    <= 0;
        count_reseted   <= 0;
        count           <= 1;
        if (input_mode) begin
          ina             <= 0;
          inb             <= 0;
        end else begin
          ina             <= a;
          inb             <= b;
        end
        int_z_d1        <= 0;
        int_z_d2        <= 0;
        int_status_d1   <= 0;
        int_status_d2   <= 0;
        int_complete_d1 <= 0;
      end else if (rst_n === 1'b1) begin
        int_z           <= next_int_z;
        int_status      <= next_int_status;
        int_complete    <= next_int_complete;
        count_reseted   <= next_count_reseted;
        count           <= next_count;
        ina             <= next_ina;
        inb             <= next_inb;
        int_z_d1        <= int_z & {((exp_width + sig_width) + 1){~reset_st}};
        int_z_d2        <= int_z_d1;
        int_status_d1   <= int_status & {8{~reset_st}};
        int_status_d2   <= int_status_d1;
        if (reset_st & start_in & (cnt_glitch < num_cyc + CYC_CONT - 4)) begin
          int_complete_d1 <= 0;
        end else begin
          int_complete_d1 <= int_complete;
        end
      end else begin
        int_z           <= {(exp_width + sig_width){1'bx}};
        int_status      <= {7{1'bx}};
        int_complete    <= 1'bx;
        count_reseted   <= 1'bx;
        count           <= -1;
        ina             <= {TOTAL_WIDTH{1'bx}};
        inb             <= {TOTAL_WIDTH{1'bx}};
        int_z_d1        <= {(exp_width + sig_width){1'bx}};
        int_z_d2        <= {(exp_width + sig_width){1'bx}};
        int_status_d1   <= {7{1'bx}};
        int_status_d2   <= {7{1'bx}};
        int_complete_d1 <= 1'bx;
      end
    end
  end
  endgenerate

  generate
  if (rst_mode == 0) begin : GEN_RM_EQ_0_E
    always @(rst_n or start_clk) begin : a1007_PROC
      if (reset_st == 0) begin
        if (rst_n == 0) begin
          reset_st = 1;
        end else begin
          reset_st = 0;
        end
      end else begin
        if ((rst_n == 1) & (start_clk == 1)) begin
          reset_st = 0;
        end else begin
          reset_st = 1;
        end
      end
    end
  end else begin : GEN_RM_NE_0_E
    always @(rst_n_clk or start_clk) begin : a1008_PROC
      if (reset_st == 0) begin
        if (rst_n_clk == 0) begin
          reset_st = 1;
        end else begin
          reset_st = 0;
        end
      end else begin
        if ((rst_n_clk == 1) & (start_clk == 1)) begin
          reset_st = 0;
        end else begin
          reset_st = 1;
        end
      end
    end
  end
  endgenerate

  
  always @ (clk) begin : P_monitor_clk 
    if ( (clk !== 1'b0) && (clk !== 1'b1) && ($time > 0) )
      $display( "WARNING: %m :\n  at time = %t, detected unknown value, %b, on clk input.",
                $time, clk );
    end // P_monitor_clk 

// synopsys translate_on

endmodule

`endif /* DW_FP_DIV_SEQ_WRAPPER */

//-----------------------------------------------------------
// Wrapper of placeholder DW_fp_div_seq_wrapper__7baf9b00dddd9d01
//-----------------------------------------------------------

`ifndef DW_FP_DIV_SEQ_WRAPPER__7BAF9B00DDDD9D01
`define DW_FP_DIV_SEQ_WRAPPER__7BAF9B00DDDD9D01

module DW_fp_div_seq_wrapper__7baf9b00dddd9d01
(
  input logic reset,
  input logic [32-1:0] a ,
  input logic [32-1:0] b ,
  input logic [1-1:0] clk ,
  output logic [1-1:0] complete ,
  input logic [3-1:0] rnd ,
  input logic [1-1:0] rst_n ,
  input logic [1-1:0] start ,
  output logic [8-1:0] status ,
  output logic [32-1:0] z 
);
  DW_fp_div_seq
  #(
    .sig_width( 23 ),
    .exp_width( 8 ),
    .ieee_compliance( 1 ),
    .num_cyc( 20 ),
    .rst_mode( 1 ),
    .input_mode( 1 ),
    .output_mode( 0 ),
    .early_start( 0 ),
    .internal_reg( 1 )
  ) v
  (
    .a( a ),
    .b( b ),
    .clk( clk ),
    .complete( complete ),
    .rnd( rnd ),
    .rst_n( rst_n ),
    .start( start ),
    .status( status ),
    .z( z )
  );
endmodule

`endif /* DW_FP_DIV_SEQ_WRAPPER__7BAF9B00DDDD9D01 */



// PyMTL Component DW_fp_div_seq Definition
// Full name: DW_fp_div_seq__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_div_seq.py

module DW_fp_div_seq__57be055cf8afa8d8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  localparam logic [0:0] __const__IDLE_at_up_state  = 1'd0;
  localparam logic [0:0] __const__START_at_up_state  = 1'd1;
  localparam logic [1:0] __const__WAIT_at_up_state  = 2'd2;
  localparam logic [1:0] __const__END_at_up_state  = 2'd3;
  localparam logic [0:0] __const__IDLE_at_comb  = 1'd0;
  localparam logic [2:0] __const__DW_FRND_NE  = 3'd0;
  localparam logic [2:0] __const__DW_FRND_TZ  = 3'd1;
  localparam logic [2:0] __const__DW_FRND_DN  = 3'd3;
  localparam logic [2:0] __const__DW_FRND_UP  = 3'd2;
  localparam logic [2:0] __const__DW_FRND_MM  = 3'd4;
  localparam logic [1:0] __const__END_at_comb  = 2'd3;
  localparam logic [7:0] __const__DW_FEXC_NX  = 8'd32;
  localparam logic [7:0] __const__DW_FEXC_UF  = 8'd8;
  localparam logic [7:0] __const__DW_FEXC_OF  = 8'd16;
  localparam logic [7:0] __const__DW_FEXC_DZ  = 8'd128;
  localparam logic [7:0] __const__DW_FEXC_NV  = 8'd4;
  logic [7:0] opq_reg;
  logic [1:0] state_reg;
  //-------------------------------------------------------------
  // Component unit
  //-------------------------------------------------------------

  logic [31:0] unit__a;
  logic [31:0] unit__b;
  logic [0:0] unit__clk;
  logic [0:0] unit__complete;
  logic [0:0] unit__reset;
  logic [2:0] unit__rnd;
  logic [0:0] unit__rst_n;
  logic [0:0] unit__start;
  logic [7:0] unit__status;
  logic [31:0] unit__z;

  DW_fp_div_seq_wrapper__7baf9b00dddd9d01 unit
  (
    .a( unit__a ),
    .b( unit__b ),
    .clk( unit__clk ),
    .complete( unit__complete ),
    .reset( unit__reset ),
    .rnd( unit__rnd ),
    .rst_n( unit__rst_n ),
    .start( unit__start ),
    .status( unit__status ),
    .z( unit__z )
  );

  //-------------------------------------------------------------
  // End of component unit
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_div_seq.py:102
  // s.unit.rst_n //= lambda: ~s.reset
  
  always_comb begin : _lambda__s_fpus_0__fp_div_unit_rst_n
    unit__rst_n = ~reset;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_div_seq.py:129
  // @update
  // def comb():
  // 
  //   #
  //   # req
  //   #
  // 
  //   s.req.rdy @= ~s.reset & ( s.state_reg == IDLE )
  // 
  //   # default
  //   s.unit.a     @= 0
  //   s.unit.b     @= 0
  //   s.unit.rnd   @= 0
  //   s.unit.start @= 0
  // 
  //   # request
  //   if s.req.en:
  //     # set inputs to the unit
  //     s.unit.a @= s.req.msg.op_a
  //     s.unit.b @= s.req.msg.op_b
  // 
  //     # rounding mode
  //     if    s.req.msg.frnd == FpuReqType.FRND_NE:
  //       s.unit.rnd @= DW_FRND_NE
  //     elif  s.req.msg.frnd == FpuReqType.FRND_TZ:
  //       s.unit.rnd @= DW_FRND_TZ
  //     elif  s.req.msg.frnd == FpuReqType.FRND_DN:
  //       s.unit.rnd @= DW_FRND_DN
  //     elif  s.req.msg.frnd == FpuReqType.FRND_UP:
  //       s.unit.rnd @= DW_FRND_UP
  //     elif  s.req.msg.frnd == FpuReqType.FRND_MM:
  //       s.unit.rnd @= DW_FRND_MM
  // 
  //     # start the unit
  //     s.unit.start @= 1
  // 
  //   #
  //   # resp
  //   #
  // 
  //   # default
  //   s.resp.en         @= 0
  //   s.resp.msg.opaque @= s.opq_reg
  //   s.resp.msg.result @= 0
  //   s.resp.msg.fexc   @= 0
  // 
  //   if s.resp.rdy & ( s.state_reg == END ):
  //     s.resp.en         @= 1
  //     s.resp.msg.result @= s.unit.z
  // 
  //     if s.unit.status & DW_FEXC_NX:
  //       s.resp.msg.fexc @= s.resp.msg.fexc | FpuRespType.FEXC_NX
  //     if s.unit.status & DW_FEXC_UF:
  //       s.resp.msg.fexc @= s.resp.msg.fexc | FpuRespType.FEXC_UF
  //     if s.unit.status & DW_FEXC_OF:
  //       s.resp.msg.fexc @= s.resp.msg.fexc | FpuRespType.FEXC_OF
  //     if s.unit.status & DW_FEXC_DZ:
  //       s.resp.msg.fexc @= s.resp.msg.fexc | FpuRespType.FEXC_DZ
  //     if s.unit.status & DW_FEXC_NV:
  //       s.resp.msg.fexc @= s.resp.msg.fexc | FpuRespType.FEXC_NV
  
  always_comb begin : comb
    req__rdy = ( ~reset ) & ( state_reg == 2'( __const__IDLE_at_comb ) );
    unit__a = 32'd0;
    unit__b = 32'd0;
    unit__rnd = 3'd0;
    unit__start = 1'd0;
    if ( req__en ) begin
      unit__a = req__msg.op_a;
      unit__b = req__msg.op_b;
      if ( req__msg.frnd == 3'd0 ) begin
        unit__rnd = 3'( __const__DW_FRND_NE );
      end
      else if ( req__msg.frnd == 3'd1 ) begin
        unit__rnd = 3'( __const__DW_FRND_TZ );
      end
      else if ( req__msg.frnd == 3'd2 ) begin
        unit__rnd = 3'( __const__DW_FRND_DN );
      end
      else if ( req__msg.frnd == 3'd3 ) begin
        unit__rnd = 3'( __const__DW_FRND_UP );
      end
      else if ( req__msg.frnd == 3'd4 ) begin
        unit__rnd = 3'( __const__DW_FRND_MM );
      end
      unit__start = 1'd1;
    end
    resp__en = 1'd0;
    resp__msg.opaque = opq_reg;
    resp__msg.result = 32'd0;
    resp__msg.fexc = 5'd0;
    if ( resp__rdy & ( state_reg == 2'( __const__END_at_comb ) ) ) begin
      resp__en = 1'd1;
      resp__msg.result = unit__z;
      if ( unit__status & 8'( __const__DW_FEXC_NX ) ) begin
        resp__msg.fexc = resp__msg.fexc | 5'd1;
      end
      if ( unit__status & 8'( __const__DW_FEXC_UF ) ) begin
        resp__msg.fexc = resp__msg.fexc | 5'd2;
      end
      if ( unit__status & 8'( __const__DW_FEXC_OF ) ) begin
        resp__msg.fexc = resp__msg.fexc | 5'd4;
      end
      if ( unit__status & 8'( __const__DW_FEXC_DZ ) ) begin
        resp__msg.fexc = resp__msg.fexc | 5'd8;
      end
      if ( unit__status & 8'( __const__DW_FEXC_NV ) ) begin
        resp__msg.fexc = resp__msg.fexc | 5'd16;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_div_seq.py:122
  // @update_ff
  // def up_opq():
  //   if    s.reset:
  //     s.opq_reg <<= 0
  //   elif  s.req.en:
  //     s.opq_reg <<= s.req.msg.opaque
  
  always_ff @(posedge clk) begin : up_opq
    if ( reset ) begin
      opq_reg <= 8'd0;
    end
    else if ( req__en ) begin
      opq_reg <= req__msg.opaque;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_div_seq.py:104
  // @update_ff
  // def up_state():
  //   if    s.reset:
  //     s.state_reg <<= IDLE
  //   else:
  //     # IDLE -> START
  //     if    ( s.state_reg == IDLE ) & s.req.en:
  //       s.state_reg <<= START
  //     # START -> WAIT
  //     elif  s.state_reg == START:
  //       s.state_reg <<= WAIT
  //     # WAIT -> END
  //     elif  ( s.state_reg == WAIT ) & s.unit.complete:
  //       s.state_reg <<= END
  //     # END -> IDLE
  //     elif  ( s.state_reg == END ) & s.resp.en:
  //       s.state_reg <<= IDLE
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      state_reg <= 2'( __const__IDLE_at_up_state );
    end
    else if ( ( state_reg == 2'( __const__IDLE_at_up_state ) ) & req__en ) begin
      state_reg <= 2'( __const__START_at_up_state );
    end
    else if ( state_reg == 2'( __const__START_at_up_state ) ) begin
      state_reg <= 2'( __const__WAIT_at_up_state );
    end
    else if ( ( state_reg == 2'( __const__WAIT_at_up_state ) ) & unit__complete ) begin
      state_reg <= 2'( __const__END_at_up_state );
    end
    else if ( ( state_reg == 2'( __const__END_at_up_state ) ) & resp__en ) begin
      state_reg <= 2'( __const__IDLE_at_up_state );
    end
  end

  assign unit__clk = clk;
  assign unit__reset = reset;

endmodule


// PyMTL VerilogPlaceholder DW_fp_mult_wrapper Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_mult.py

//***********************************************************
// Pickled source file of placeholder DW_fp_mult_wrapper_noparam
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder DW_fp_mult_wrapper
//-----------------------------------------------------------

`ifndef DW_FP_MULT_WRAPPER
`define DW_FP_MULT_WRAPPER

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component DW_fp_mult_wrapper_noparam.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component DW_fp_mult_wrapper_noparam

`line 1 "fpu/dw_srcs/DW_fp_mult.v" 0
////////////////////////////////////////////////////////////////////////////////
//
//       This confidential and proprietary software may be used only
//     as authorized by a licensing agreement from Synopsys Inc.
//     In the event of publication, the following notice is applicable:
//
//                    (C) COPYRIGHT 2006 - 2016 SYNOPSYS INC.
//                           ALL RIGHTS RESERVED
//
//       The entire notice above must be reproduced on all authorized
//     copies.
//
// AUTHOR:    Kyung-Nam Han, Feb. 22, 2006
//
// VERSION:   Verilog Simulation Model for DW_fp_mult
//
// DesignWare_version: 89edc232
// DesignWare_release: M-2016.12-DWBB_201612.0
//
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ABSTRACT: Floating-Point Multiplier
//
//              DW_fp_mult calculates the floating-point multiplication
//              while supporting six rounding modes, including four IEEE
//              standard rounding modes.
//
//              parameters      valid values (defined in the DW manual)
//              ==========      ============
//              sig_width       significand size,  2 to 253 bits
//              exp_width       exponent size,     3 to 31 bits
//              ieee_compliance support the IEEE Compliance
//                              including NaN and denormal expressions.
//                              0 - IEEE 754 compatible without denormal support
//                                  (NaN becomes Infinity, Denormal becomes Zero)
//                              1 - IEEE 754 standard compatible
//                                  (NaN and denormal numbers are supported)
//
//              Input ports     Size & Description
//              ===========     ==================
//              a               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              b               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Input
//              rnd             3 bits
//                              Rounding Mode Input
//              z               (sig_width + exp_width + 1)-bits
//                              Floating-point Number Output
//              status          8 bits
//                              Status Flags Output
//
// Modified:
//     2009.11.12 Kyung-Nam Han
//       Bug fix for STAR9000352662, available from 2009.06-SP4
//     2015.12.10 Kyung-Nam Han
//       Bug fix for STAR9000983334, available from 2015.06-SP5
//-----------------------------------------------------------------------------

// verilator lint_off WIDTH

module DW_fp_mult (a, b, rnd, z, status);

  parameter sig_width = 23;      // RANGE 2 TO 253
  parameter exp_width = 8;       // RANGE 3 TO 31
  parameter ieee_compliance = 0; // RANGE 0 TO 1

  input  [exp_width + sig_width:0] a;
  input  [exp_width + sig_width:0] b;
  input  [2:0] rnd;
  output [exp_width + sig_width:0] z;
  output [7:0] status;

  // synopsys translate_off


  `define Mwidth (2 * sig_width + 3)
  `define Movf   (`Mwidth - 1)
  `define L      (`Movf - 1 - sig_width)
  `define R      (`L - 1)
  `define RND_Width  4
  `define RND_Inc  0
  `define RND_Inexact  1
  `define RND_HugeInfinity  2
  `define RND_TinyminNorm  3
  `define log_awidth ((sig_width + 1>65536)?((sig_width + 1>16777216)?((sig_width + 1>268435456)?((sig_width + 1>536870912)?30:29):((sig_width + 1>67108864)?((sig_width + 1>134217728)?28:27):((sig_width + 1>33554432)?26:25))):((sig_width + 1>1048576)?((sig_width + 1>4194304)?((sig_width + 1>8388608)?24:23):((sig_width + 1>2097152)?22:21)):((sig_width + 1>262144)?((sig_width + 1>524288)?20:19):((sig_width + 1>131072)?18:17)))):((sig_width + 1>256)?((sig_width + 1>4096)?((sig_width + 1>16384)?((sig_width + 1>32768)?16:15):((sig_width + 1>8192)?14:13)):((sig_width + 1>1024)?((sig_width + 1>2048)?12:11):((sig_width + 1>512)?10:9))):((sig_width + 1>16)?((sig_width + 1>64)?((sig_width + 1>128)?8:7):((sig_width + 1>32)?6:5)):((sig_width + 1>4)?((sig_width + 1>8)?4:3):((sig_width + 1>2)?2:1)))))
  `define ez_msb ((exp_width >= `log_awidth) ? exp_width + 1 : `log_awidth + 1)

  //-------------------------------------------------------------------------
  // Parameter legality check
  //-------------------------------------------------------------------------


  initial begin : parameter_check
    integer param_err_flg;

    param_err_flg = 0;


    if ( (sig_width < 2) || (sig_width > 253) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter sig_width (legal range: 2 to 253)",
	sig_width );
    end

    if ( (exp_width < 3) || (exp_width > 31) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter exp_width (legal range: 3 to 31)",
	exp_width );
    end

    if ( (ieee_compliance < 0) || (ieee_compliance > 1) ) begin
      param_err_flg = 1;
      $display(
	"ERROR: %m :\n  Invalid value (%d) for parameter ieee_compliance (legal range: 0 to 1)",
	ieee_compliance );
    end

    if ( param_err_flg == 1) begin
      $display(
        "%m :\n  Simulation aborted due to invalid parameter value(s)");
      $finish;
    end

  end // parameter_check

  //-------------------------------------------------------------------------

  //-----------------------------------------------------
  // Usage: rnd_val = rnd_eval(rnd,Sign,L,R,stk);
  // rnd_val has 4 bits:
  // rnd_val[rnd_Inc]
  // rnd_val[rnd_Inexact]
  // rnd_val[rnd_HugeInfinity]
  // rnd_val[rnd_TinyminNorm]
  //----------------------------------------------------
  // Rounding increment equations
  // MODE | Equation   | Description
  // ------------------------------------------------
  // even | R&(L|stk)  | IEEE round to nearest (even)
  // zero | 0          | IEEE round to zero
  // +inf | S'&(R|stk) | IEEE round to positive infinity
  // -inf | S&(R|stk)  | IEEE round to negative infinity
  // up   | R          | round to nearest (up)
  // away | (R|stk)    | round away from zero
  //----------------------------------------------------

  function [`RND_Width-1:0] rnd_eval;

    input [2:0] rnd;
    input [0:0] Sign;
    input [0:0] L,R,stk;

    begin
      rnd_eval[`RND_Inc] = 0;
      rnd_eval[`RND_Inexact] = R|stk;
      rnd_eval[`RND_HugeInfinity] = 0;
      rnd_eval[`RND_TinyminNorm] = 0;

      if ($time > 0)
      begin
        case (rnd)
          3'b000:
          begin
            // round to nearest (even)
            rnd_eval[`RND_Inc] = R&(L|stk);
            rnd_eval[`RND_HugeInfinity] = 1;
            rnd_eval[`RND_TinyminNorm] = 0;
          end
          3'b001:
          begin
            // round to zero
            rnd_eval[`RND_Inc] = 0;
            rnd_eval[`RND_HugeInfinity] = 0;
            rnd_eval[`RND_TinyminNorm] = 0;
          end
          3'b010:
          begin
            // round to positive infinity
            rnd_eval[`RND_Inc] = ~Sign & (R|stk);
            rnd_eval[`RND_HugeInfinity] = ~Sign;
            rnd_eval[`RND_TinyminNorm] = ~Sign;
          end
          3'b011:
          begin
            // round to negative infinity
            rnd_eval[`RND_Inc] = Sign & (R|stk);
            rnd_eval[`RND_HugeInfinity] = Sign;
            rnd_eval[`RND_TinyminNorm] = Sign;
          end
          3'b100:
          begin
            // round to nearest (up)
            rnd_eval[`RND_Inc] = R;
            rnd_eval[`RND_HugeInfinity] = 1;
            rnd_eval[`RND_TinyminNorm] = 0;
          end
          3'b101:
          begin
            // round away form 0
            rnd_eval[`RND_Inc] = R|stk;
            rnd_eval[`RND_HugeInfinity] = 1;
            rnd_eval[`RND_TinyminNorm] = 1;
          end
          default:
          begin
            $display("Error! illegal rounding mode.\n");
            $display("a : %b", a);
            $display("rnd : %b", rnd);
          end
        endcase
      end
    end
  endfunction



  reg [(exp_width + sig_width):0] z_reg;
  reg [exp_width-1:0] EA;
  reg [exp_width-1:0] EB;
  reg signed [`ez_msb:0] EZ;
  reg signed [`ez_msb:0] Range_Check;
  reg signed [`ez_msb:0] SH_Shift;
  reg signed [`ez_msb:0] EZ_Shift;
  reg [sig_width:0] MA;
  reg [sig_width:0] MB;
  reg [sig_width:0] TMP_MA;
  reg [sig_width:0] TMP_MB;
  reg [`Mwidth-1:0] MZ;
  reg STK;
  reg SIGN;
  reg [`RND_Width-1:0] RND_val;
  reg [8    -1:0] status_reg;
  reg MaxEXP_A;
  reg MaxEXP_B;
  reg InfSIG_A;
  reg InfSIG_B;
  reg Zero_A;
  reg Zero_B;
  reg Denorm_A;
  reg Denorm_B;
  reg [9:0] LZ_INA;
  reg [9:0] LZ_INB;
  reg [9:0] LZ_IN;
  reg [sig_width - 1:0] SIGA;
  reg [sig_width - 1:0] SIGB;
  reg [(exp_width + sig_width):0] NaN_Reg;
  reg [(exp_width + sig_width):0] Inf_Reg;
  reg MZ_Movf1;
  reg EZ_Zero;
  reg STK_PRE;
  reg [sig_width:0] STK_EXT;
  reg [sig_width - 1:0] NaN_Sig;
  reg [sig_width - 1:0] Inf_Sig;
  reg STK_CHECK;
  reg minnorm_case;

  integer i;

  always @(a or b or rnd) begin : a1000_PROC
    SIGN = a[(exp_width + sig_width)] ^ b[(exp_width + sig_width)];
    EA = a[((exp_width + sig_width) - 1):sig_width];
    EB = b[((exp_width + sig_width) - 1):sig_width];
    SIGA = a[(sig_width - 1):0];
    SIGB = b[(sig_width - 1):0];
    status_reg = 0;
    LZ_INA = 0;
    LZ_INB = 0;
    LZ_IN = 0;
    STK_EXT = 0;

    MaxEXP_A = (EA == ((((1 << (exp_width-1)) - 1) * 2) + 1));
    MaxEXP_B = (EB == ((((1 << (exp_width-1)) - 1) * 2) + 1));
    InfSIG_A = (SIGA == 0);
    InfSIG_B = (SIGB == 0);

    // Zero and Denormal
    if (ieee_compliance) begin
      Zero_A = (EA == 0 ) & (SIGA == 0);
      Zero_B = (EB == 0 ) & (SIGB == 0);
      Denorm_A = (EA == 0 ) & (SIGA != 0);
      Denorm_B = (EB == 0 ) & (SIGB != 0);
      // IEEE Standard
      NaN_Sig = 1;
      Inf_Sig = 0;
      NaN_Reg = {1'b0, {(exp_width){1'b1}}, NaN_Sig};
      Inf_Reg = {SIGN, {(exp_width){1'b1}}, Inf_Sig};

      if (Denorm_A) begin
        MA = {1'b0, a[(sig_width - 1):0]};
      end
      else begin
        MA = {1'b1, a[(sig_width - 1):0]};
      end

      if (Denorm_B) begin
        MB = {1'b0, b[(sig_width - 1):0]};
      end
      else begin
        MB = {1'b1, b[(sig_width - 1):0]};
      end

    end
    else begin // ieee_compliance = 0
      Zero_A = (EA == 0 );
      Zero_B = (EB == 0 );
      Denorm_A = 0;
      Denorm_B = 0;
      MA = {1'b1,a[(sig_width - 1):0]};
      MB = {1'b1,b[(sig_width - 1):0]};
      NaN_Sig = 0;
      Inf_Sig = 0;
      // from 0703-SP2, NaN has always + sign.
      NaN_Reg = {1'b0, {(exp_width){1'b1}}, NaN_Sig};
      Inf_Reg = {SIGN, {(exp_width){1'b1}}, Inf_Sig};
    end

    //
    // Infinity & NaN Input
    //
    if (ieee_compliance && ((MaxEXP_A && ~InfSIG_A) || (MaxEXP_B && ~InfSIG_B))) begin
      status_reg[2] = 1;
      z_reg = NaN_Reg;
    end
    else if ( (MaxEXP_A) || (MaxEXP_B) )	begin

      if (ieee_compliance == 0) begin
        status_reg[1] = 1;
      end

      // 0*Inf = NaN
      if ( Zero_A || Zero_B ) begin
        status_reg[2] = 1;
        z_reg = NaN_Reg;
      end
      else begin  // Infinity Case
        status_reg[1] = 1;
        z_reg = Inf_Reg;
      end

    end
    //
    // Zero Input
    //
    else if (Zero_A || Zero_B) begin
      status_reg[0] = 1;
      z_reg = 0;
      z_reg[(exp_width + sig_width)] = SIGN;
    end
    //
    // Normal & Denormal Inputs
    //
    else begin

      // Denormal Check
      TMP_MA = MA;
      if (Denorm_A)
      begin
        while(TMP_MA[sig_width] != 1)
        begin
          TMP_MA = TMP_MA << 1;
          LZ_INA = LZ_INA + 1;
        end
      end

      TMP_MB = MB;
      if (Denorm_B)
      begin
        while(TMP_MB[sig_width] != 1)
        begin
          TMP_MB = TMP_MB << 1;
          LZ_INB = LZ_INB + 1;
        end
      end

      LZ_IN = LZ_INA + LZ_INB;

      EZ = EA + EB - LZ_IN + Denorm_A + Denorm_B;
      MZ = MA * MB;	// Compute with infinite precision.

      // Left shift MZ in case of denormal multiplication
      if (ieee_compliance) begin
        MZ = MZ << LZ_IN;
      end

      // After the computation, left justify the Mantissa to `Movf-1 bit.
      // Note that the normalized Mantissa after computation is in `Movf-2 bit,
      // and now we normalize it to `Movf-1 bit.
      MZ_Movf1 = MZ[`Movf-1];

      if (MZ[`Movf-1] === 1) begin
        EZ = EZ + 1;
        minnorm_case = 0;
      end
      else begin
        MZ = MZ << 1;
        minnorm_case = (EZ - ((1 << (exp_width-1)) - 1) == 0) ? 1 : 0;
      end

      // Denormal Support
      if (ieee_compliance) begin
        Range_Check = EA + EB + Denorm_A + Denorm_B + MZ_Movf1 - ((1 << (exp_width-1)) - 1) - LZ_IN - 1;

        EZ_Shift = -Range_Check;

        if (EZ_Shift >= 0) begin
          for (i = 0; i < EZ_Shift; i = i + 1) begin
            {MZ, STK_CHECK} = {MZ, 1'b0} >> 1;
            STK_EXT = STK_EXT | STK_CHECK;
          end
        end

      end

      if (minnorm_case & ~ieee_compliance) begin
        if ({MZ[`R:0], STK_EXT} === 0) STK = 0;
        else STK = 1;
        RND_val = rnd_eval(rnd, SIGN, MZ[`L+1], MZ[`R+1], STK);
      end
      else begin
        if ({MZ[`R-1:0], STK_EXT} === 0) STK = 0;
        else STK = 1;
        RND_val = rnd_eval(rnd, SIGN, MZ[`L], MZ[`R], STK);
      end

      // Round Addition
      if (RND_val[`RND_Inc] === 1) MZ = MZ + (1<<`L);

      // Normalize the Mantissa for overflow case after rounding.
      if ( (MZ[`Movf] === 1) ) begin
        EZ = EZ + 1;
        MZ = MZ >> 1;
      end

      // Correction of denomal output.
      if (ieee_compliance & (EZ <= ((1 << (exp_width-1)) - 1)) & MZ[`Movf - 1]) EZ = EZ + 1;

      EZ_Zero = (EZ == ((1 << (exp_width-1)) - 1));

      // Adjust Exponent ((1 << (exp_width-1)) - 1).
      // Force EZ = 0 if underflow occurs becuase of subtracting ((1 << (exp_width-1)) - 1),
      if((EZ[`ez_msb] == 0) & (EZ >= ((1 << (exp_width-1)) - 1))) EZ = EZ - ((1 << (exp_width-1)) - 1);
      else EZ = 0;

      //
      // Huge
      //
      if (EZ >= ((((1 << (exp_width-1)) - 1) * 2) + 1)) begin
        status_reg[4] = 1;
        status_reg[5] = 1;

        if(RND_val[`RND_HugeInfinity] === 1) begin
          // Infinity
          MZ[`Movf-2:`L] = Inf_Sig;
          EZ = ((((1 << (exp_width-1)) - 1) * 2) + 1);
          status_reg[1] = 1;
        end
        else begin
          // MaxNorm
          EZ = ((((1 << (exp_width-1)) - 1) * 2) + 1) - 1;
          MZ[`Movf-2:`L] = -1;
        end
      end
      //
      // Tiny
      //
      else if (EZ == 0 ) begin
        status_reg[3] = 1;

        if (ieee_compliance == 0) begin
          status_reg[5] = 1;

          if(RND_val[`RND_TinyminNorm] === 1) begin
            // MinNorm
            MZ[`Movf-2:`L] = 0;
            EZ = 0  + 1;
          end
          else begin
            // 0
            MZ[`Movf-2:`L] = 0;
            EZ = 0 ;
            status_reg[0] = 1;
          end
        end

        if ((MZ[`Movf-2:`L] == 0) & (EZ[exp_width - 1:0] == 0)) begin
          status_reg[0] = 1;
        end

      end

      status_reg[5] = status_reg[5] | RND_val[`RND_Inexact] | (~(Zero_A | Zero_B) & (EZ[exp_width - 1:0] == 0) & (MZ[`Movf - 2:`L] == 0));

      // Reconstruct the floating point format.
      z_reg = {SIGN,EZ[exp_width-1:0],MZ[`Movf-2:`L]};
      end
  end

  assign status = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0) || (^(rnd ^ rnd) !== 1'b0)) ? {8'bX} : status_reg;
  assign z = ((^(a ^ a) !== 1'b0) || (^(b ^ b) !== 1'b0) || (^(rnd ^ rnd) !== 1'b0)) ? {sig_width+exp_width+1{1'bX}} : z_reg;

  `undef Mwidth
  `undef Movf
  `undef L
  `undef R
  `undef RND_Width
  `undef RND_Inc
  `undef RND_Inexact
  `undef RND_HugeInfinity
  `undef RND_TinyminNorm
  `undef log_awidth
  `undef ez_msb

  // synopsys translate_on

endmodule

// verilator lint_on WIDTH


`endif /* DW_FP_MULT_WRAPPER */

//-----------------------------------------------------------
// Wrapper of placeholder DW_fp_mult_wrapper_noparam
//-----------------------------------------------------------

`ifndef DW_FP_MULT_WRAPPER_NOPARAM
`define DW_FP_MULT_WRAPPER_NOPARAM

module DW_fp_mult_wrapper_noparam
(
  input logic reset,
  input logic clk,
  input logic [32-1:0] a ,
  input logic [32-1:0] b ,
  input logic [3-1:0] rnd ,
  output logic [8-1:0] status ,
  output logic [32-1:0] z 
);
  DW_fp_mult
  #(
    .sig_width( 23 ),
    .exp_width( 8 ),
    .ieee_compliance( 1 )
  ) v
  (
    .a( a ),
    .b( b ),
    .rnd( rnd ),
    .status( status ),
    .z( z )
  );
endmodule

`endif /* DW_FP_MULT_WRAPPER_NOPARAM */



// PyMTL Component DW_fp_mult Definition
// Full name: DW_fp_mult__nstages_4__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_mult.py

module DW_fp_mult__5367206e2cb8f6c7
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  localparam logic [2:0] __const__nstages_at_up_queues  = 3'd4;
  localparam logic [2:0] __const__DW_FRND_NE  = 3'd0;
  localparam logic [2:0] __const__DW_FRND_TZ  = 3'd1;
  localparam logic [2:0] __const__DW_FRND_DN  = 3'd3;
  localparam logic [2:0] __const__DW_FRND_UP  = 3'd2;
  localparam logic [2:0] __const__DW_FRND_MM  = 3'd4;
  localparam logic [7:0] __const__DW_FEXC_NX  = 8'd32;
  localparam logic [7:0] __const__DW_FEXC_UF  = 8'd8;
  localparam logic [7:0] __const__DW_FEXC_OF  = 8'd16;
  localparam logic [7:0] __const__DW_FEXC_DZ  = 8'd128;
  localparam logic [7:0] __const__DW_FEXC_NV  = 8'd4;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_val;
  //-------------------------------------------------------------
  // Component in_q
  //-------------------------------------------------------------

  logic [0:0] in_q__clk;
  logic [0:0] in_q__count;
  logic [0:0] in_q__reset;
  logic [0:0] in_q__deq__en;
  logic [0:0] in_q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__deq__ret;
  logic [0:0] in_q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 in_q__enq__msg;
  logic [0:0] in_q__enq__rdy;

  PipeQueueRTL__86a7c3aeb6713f23 in_q
  (
    .clk( in_q__clk ),
    .count( in_q__count ),
    .reset( in_q__reset ),
    .deq__en( in_q__deq__en ),
    .deq__rdy( in_q__deq__rdy ),
    .deq__ret( in_q__deq__ret ),
    .enq__en( in_q__enq__en ),
    .enq__msg( in_q__enq__msg ),
    .enq__rdy( in_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component in_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component out_q[0:2]
  //-------------------------------------------------------------

  logic [0:0] out_q__clk [0:2];
  logic [0:0] out_q__count [0:2];
  logic [0:0] out_q__reset [0:2];
  logic [0:0] out_q__deq__en [0:2];
  logic [0:0] out_q__deq__rdy [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__deq__ret [0:2];
  logic [0:0] out_q__enq__en [0:2];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 out_q__enq__msg [0:2];
  logic [0:0] out_q__enq__rdy [0:2];

  PipeQueueRTL__f55b0708e52dd198 out_q__0
  (
    .clk( out_q__clk[0] ),
    .count( out_q__count[0] ),
    .reset( out_q__reset[0] ),
    .deq__en( out_q__deq__en[0] ),
    .deq__rdy( out_q__deq__rdy[0] ),
    .deq__ret( out_q__deq__ret[0] ),
    .enq__en( out_q__enq__en[0] ),
    .enq__msg( out_q__enq__msg[0] ),
    .enq__rdy( out_q__enq__rdy[0] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__1
  (
    .clk( out_q__clk[1] ),
    .count( out_q__count[1] ),
    .reset( out_q__reset[1] ),
    .deq__en( out_q__deq__en[1] ),
    .deq__rdy( out_q__deq__rdy[1] ),
    .deq__ret( out_q__deq__ret[1] ),
    .enq__en( out_q__enq__en[1] ),
    .enq__msg( out_q__enq__msg[1] ),
    .enq__rdy( out_q__enq__rdy[1] )
  );

  PipeQueueRTL__f55b0708e52dd198 out_q__2
  (
    .clk( out_q__clk[2] ),
    .count( out_q__count[2] ),
    .reset( out_q__reset[2] ),
    .deq__en( out_q__deq__en[2] ),
    .deq__rdy( out_q__deq__rdy[2] ),
    .deq__ret( out_q__deq__ret[2] ),
    .enq__en( out_q__enq__en[2] ),
    .enq__msg( out_q__enq__msg[2] ),
    .enq__rdy( out_q__enq__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component out_q[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component unit
  //-------------------------------------------------------------

  logic [31:0] unit__a;
  logic [31:0] unit__b;
  logic [0:0] unit__clk;
  logic [0:0] unit__reset;
  logic [2:0] unit__rnd;
  logic [7:0] unit__status;
  logic [31:0] unit__z;

  DW_fp_mult_wrapper_noparam unit
  (
    .a( unit__a ),
    .b( unit__b ),
    .clk( unit__clk ),
    .reset( unit__reset ),
    .rnd( unit__rnd ),
    .status( unit__status ),
    .z( unit__z )
  );

  //-------------------------------------------------------------
  // End of component unit
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_mult.py:106
  // @update
  // def comb():
  // 
  //   # default
  //   s.out_val.opaque @= 0
  //   s.out_val.result @= 0
  //   s.out_val.fexc   @= 0
  // 
  //   s.unit.a    @= 0
  //   s.unit.b    @= 0
  //   s.unit.rnd  @= 0
  // 
  //   if s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy:
  // 
  //     s.unit.a @= s.in_q.deq.ret.op_a
  //     s.unit.b @= s.in_q.deq.ret.op_b
  // 
  //     # rounding mode
  //     if    s.in_q.deq.ret.frnd == FpuReqType.FRND_NE:
  //       s.unit.rnd @= DW_FRND_NE
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_TZ:
  //       s.unit.rnd @= DW_FRND_TZ
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_DN:
  //       s.unit.rnd @= DW_FRND_DN
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_UP:
  //       s.unit.rnd @= DW_FRND_UP
  //     elif  s.in_q.deq.ret.frnd == FpuReqType.FRND_MM:
  //       s.unit.rnd @= DW_FRND_MM
  // 
  //     s.out_val.opaque @= s.in_q.deq.ret.opaque
  //     s.out_val.result @= s.unit.z
  // 
  //     if s.unit.status & DW_FEXC_NX:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NX
  //     if s.unit.status & DW_FEXC_UF:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_UF
  //     if s.unit.status & DW_FEXC_OF:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_OF
  //     if s.unit.status & DW_FEXC_DZ:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_DZ
  //     if s.unit.status & DW_FEXC_NV:
  //       s.out_val.fexc @= s.out_val.fexc | FpuRespType.FEXC_NV
  
  always_comb begin : comb
    out_val.opaque = 8'd0;
    out_val.result = 32'd0;
    out_val.fexc = 5'd0;
    unit__a = 32'd0;
    unit__b = 32'd0;
    unit__rnd = 3'd0;
    if ( in_q__deq__rdy & out_q__enq__rdy[2'd0] ) begin
      unit__a = in_q__deq__ret.op_a;
      unit__b = in_q__deq__ret.op_b;
      if ( in_q__deq__ret.frnd == 3'd0 ) begin
        unit__rnd = 3'( __const__DW_FRND_NE );
      end
      else if ( in_q__deq__ret.frnd == 3'd1 ) begin
        unit__rnd = 3'( __const__DW_FRND_TZ );
      end
      else if ( in_q__deq__ret.frnd == 3'd2 ) begin
        unit__rnd = 3'( __const__DW_FRND_DN );
      end
      else if ( in_q__deq__ret.frnd == 3'd3 ) begin
        unit__rnd = 3'( __const__DW_FRND_UP );
      end
      else if ( in_q__deq__ret.frnd == 3'd4 ) begin
        unit__rnd = 3'( __const__DW_FRND_MM );
      end
      out_val.opaque = in_q__deq__ret.opaque;
      out_val.result = unit__z;
      if ( unit__status & 8'( __const__DW_FEXC_NX ) ) begin
        out_val.fexc = out_val.fexc | 5'd1;
      end
      if ( unit__status & 8'( __const__DW_FEXC_UF ) ) begin
        out_val.fexc = out_val.fexc | 5'd2;
      end
      if ( unit__status & 8'( __const__DW_FEXC_OF ) ) begin
        out_val.fexc = out_val.fexc | 5'd4;
      end
      if ( unit__status & 8'( __const__DW_FEXC_DZ ) ) begin
        out_val.fexc = out_val.fexc | 5'd8;
      end
      if ( unit__status & 8'( __const__DW_FEXC_NV ) ) begin
        out_val.fexc = out_val.fexc | 5'd16;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/DW_fp_mult.py:86
  // @update
  // def up_queues():
  // 
  //   # in_q <-> out_q[ 0 ]
  //   s.in_q.deq.en         @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.en   @= s.in_q.deq.rdy & s.out_q[ 0 ].enq.rdy
  //   s.out_q[ 0 ].enq.msg  @= s.out_val
  // 
  //   # chian middle out_q
  //   if nstages > 2:
  //     for i in range( nstages - 2 ):
  //       s.out_q[ i   ].deq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.en  @= s.out_q[ i ].deq.rdy & s.out_q[ i+1 ].enq.rdy
  //       s.out_q[ i+1 ].enq.msg @= s.out_q[ i ].deq.ret
  // 
  //   # out_q[ nstages-2 ] <-> s.resp
  //   s.out_q[ nstages-2 ].deq.en @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.en                   @= s.resp.rdy & s.out_q[ nstages-2 ].deq.rdy
  //   s.resp.msg                  @= s.out_q[ nstages-2 ].deq.ret
  
  always_comb begin : up_queues
    in_q__deq__en = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__en[2'd0] = in_q__deq__rdy & out_q__enq__rdy[2'd0];
    out_q__enq__msg[2'd0] = out_val;
    if ( 3'( __const__nstages_at_up_queues ) > 3'd2 ) begin
      for ( int unsigned i = 1'd0; i < 3'( __const__nstages_at_up_queues ) - 3'd2; i += 1'd1 ) begin
        out_q__deq__en[2'(i)] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__en[2'(i) + 2'd1] = out_q__deq__rdy[2'(i)] & out_q__enq__rdy[2'(i) + 2'd1];
        out_q__enq__msg[2'(i) + 2'd1] = out_q__deq__ret[2'(i)];
      end
    end
    out_q__deq__en[3'( __const__nstages_at_up_queues ) - 3'd2] = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__en = resp__rdy & out_q__deq__rdy[3'( __const__nstages_at_up_queues ) - 3'd2];
    resp__msg = out_q__deq__ret[3'( __const__nstages_at_up_queues ) - 3'd2];
  end

  assign in_q__clk = clk;
  assign in_q__reset = reset;
  assign in_q__enq__en = req__en;
  assign in_q__enq__msg = req__msg;
  assign req__rdy = in_q__enq__rdy;
  assign unit__clk = clk;
  assign unit__reset = reset;
  assign out_q__clk[0] = clk;
  assign out_q__reset[0] = reset;
  assign out_q__clk[1] = clk;
  assign out_q__reset[1] = reset;
  assign out_q__clk[2] = clk;
  assign out_q__reset[2] = reset;

endmodule


// PyMTL Component NormalQueue1EntryRTL Definition
// Full name: NormalQueue1EntryRTL__EntryType_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueue1EntryRTL__a2c155c77a0d04b2
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:453
  // s.deq.rdy //= lambda: ~s.reset & s.full
  
  always_comb begin : _lambda__s_fpus_0__recv_q_q_deq_rdy
    deq__rdy = ( ~reset ) & full;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:452
  // s.enq.rdy //= lambda: ~s.reset & ~s.full
  
  always_comb begin : _lambda__s_fpus_0__recv_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ~full );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:455
  // @update_ff
  // def ff_normal1():
  //   s.full <<= ~s.reset & ( ~s.deq.en & (s.enq.en | s.full) )
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_normal1
    full <= ( ~reset ) & ( ( ~deq__en ) & ( enq__en | full ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueRTL__86a7c3aeb6713f23
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 deq__ret  ,
  input logic [0:0] enq__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 q__deq__ret;
  logic [0:0] q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 q__enq__msg;
  logic [0:0] q__enq__rdy;

  NormalQueue1EntryRTL__a2c155c77a0d04b2 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component FloatingPointUnit Definition
// Full name: FloatingPointUnit__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/FloatingPointUnit.py

module FloatingPointUnit__57be055cf8afa8d8
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output FpuRespMsg_8_32__opaque_8__result_32__fexc_5 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  //-------------------------------------------------------------
  // Component fp_addsub
  //-------------------------------------------------------------

  logic [0:0] fp_addsub__clk;
  logic [0:0] fp_addsub__reset;
  logic [0:0] fp_addsub__req__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fp_addsub__req__msg;
  logic [0:0] fp_addsub__req__rdy;
  logic [0:0] fp_addsub__resp__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_addsub__resp__msg;
  logic [0:0] fp_addsub__resp__rdy;

  DW_fp_addsub__5367206e2cb8f6c7 fp_addsub
  (
    .clk( fp_addsub__clk ),
    .reset( fp_addsub__reset ),
    .req__en( fp_addsub__req__en ),
    .req__msg( fp_addsub__req__msg ),
    .req__rdy( fp_addsub__req__rdy ),
    .resp__en( fp_addsub__resp__en ),
    .resp__msg( fp_addsub__resp__msg ),
    .resp__rdy( fp_addsub__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_addsub
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_addsub_resp_q
  //-------------------------------------------------------------

  logic [0:0] fp_addsub_resp_q__clk;
  logic [0:0] fp_addsub_resp_q__count;
  logic [0:0] fp_addsub_resp_q__reset;
  logic [0:0] fp_addsub_resp_q__deq__en;
  logic [0:0] fp_addsub_resp_q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_addsub_resp_q__deq__ret;
  logic [0:0] fp_addsub_resp_q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_addsub_resp_q__enq__msg;
  logic [0:0] fp_addsub_resp_q__enq__rdy;

  NormalQueueRTL__f55b0708e52dd198 fp_addsub_resp_q
  (
    .clk( fp_addsub_resp_q__clk ),
    .count( fp_addsub_resp_q__count ),
    .reset( fp_addsub_resp_q__reset ),
    .deq__en( fp_addsub_resp_q__deq__en ),
    .deq__rdy( fp_addsub_resp_q__deq__rdy ),
    .deq__ret( fp_addsub_resp_q__deq__ret ),
    .enq__en( fp_addsub_resp_q__enq__en ),
    .enq__msg( fp_addsub_resp_q__enq__msg ),
    .enq__rdy( fp_addsub_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_addsub_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_cmp
  //-------------------------------------------------------------

  logic [0:0] fp_cmp__clk;
  logic [0:0] fp_cmp__reset;
  logic [0:0] fp_cmp__req__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fp_cmp__req__msg;
  logic [0:0] fp_cmp__req__rdy;
  logic [0:0] fp_cmp__resp__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_cmp__resp__msg;
  logic [0:0] fp_cmp__resp__rdy;

  DW_fp_cmp__5367206e2cb8f6c7 fp_cmp
  (
    .clk( fp_cmp__clk ),
    .reset( fp_cmp__reset ),
    .req__en( fp_cmp__req__en ),
    .req__msg( fp_cmp__req__msg ),
    .req__rdy( fp_cmp__req__rdy ),
    .resp__en( fp_cmp__resp__en ),
    .resp__msg( fp_cmp__resp__msg ),
    .resp__rdy( fp_cmp__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_cmp
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_cmp_resp_q
  //-------------------------------------------------------------

  logic [0:0] fp_cmp_resp_q__clk;
  logic [0:0] fp_cmp_resp_q__count;
  logic [0:0] fp_cmp_resp_q__reset;
  logic [0:0] fp_cmp_resp_q__deq__en;
  logic [0:0] fp_cmp_resp_q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_cmp_resp_q__deq__ret;
  logic [0:0] fp_cmp_resp_q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_cmp_resp_q__enq__msg;
  logic [0:0] fp_cmp_resp_q__enq__rdy;

  NormalQueueRTL__f55b0708e52dd198 fp_cmp_resp_q
  (
    .clk( fp_cmp_resp_q__clk ),
    .count( fp_cmp_resp_q__count ),
    .reset( fp_cmp_resp_q__reset ),
    .deq__en( fp_cmp_resp_q__deq__en ),
    .deq__rdy( fp_cmp_resp_q__deq__rdy ),
    .deq__ret( fp_cmp_resp_q__deq__ret ),
    .enq__en( fp_cmp_resp_q__enq__en ),
    .enq__msg( fp_cmp_resp_q__enq__msg ),
    .enq__rdy( fp_cmp_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_cmp_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_cvt
  //-------------------------------------------------------------

  logic [0:0] fp_cvt__clk;
  logic [0:0] fp_cvt__reset;
  logic [0:0] fp_cvt__req__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fp_cvt__req__msg;
  logic [0:0] fp_cvt__req__rdy;
  logic [0:0] fp_cvt__resp__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_cvt__resp__msg;
  logic [0:0] fp_cvt__resp__rdy;

  DW_fp_cvt__5367206e2cb8f6c7 fp_cvt
  (
    .clk( fp_cvt__clk ),
    .reset( fp_cvt__reset ),
    .req__en( fp_cvt__req__en ),
    .req__msg( fp_cvt__req__msg ),
    .req__rdy( fp_cvt__req__rdy ),
    .resp__en( fp_cvt__resp__en ),
    .resp__msg( fp_cvt__resp__msg ),
    .resp__rdy( fp_cvt__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_cvt
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_cvt_resp_q
  //-------------------------------------------------------------

  logic [0:0] fp_cvt_resp_q__clk;
  logic [0:0] fp_cvt_resp_q__count;
  logic [0:0] fp_cvt_resp_q__reset;
  logic [0:0] fp_cvt_resp_q__deq__en;
  logic [0:0] fp_cvt_resp_q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_cvt_resp_q__deq__ret;
  logic [0:0] fp_cvt_resp_q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_cvt_resp_q__enq__msg;
  logic [0:0] fp_cvt_resp_q__enq__rdy;

  NormalQueueRTL__f55b0708e52dd198 fp_cvt_resp_q
  (
    .clk( fp_cvt_resp_q__clk ),
    .count( fp_cvt_resp_q__count ),
    .reset( fp_cvt_resp_q__reset ),
    .deq__en( fp_cvt_resp_q__deq__en ),
    .deq__rdy( fp_cvt_resp_q__deq__rdy ),
    .deq__ret( fp_cvt_resp_q__deq__ret ),
    .enq__en( fp_cvt_resp_q__enq__en ),
    .enq__msg( fp_cvt_resp_q__enq__msg ),
    .enq__rdy( fp_cvt_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_cvt_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_div
  //-------------------------------------------------------------

  logic [0:0] fp_div__clk;
  logic [0:0] fp_div__reset;
  logic [0:0] fp_div__req__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fp_div__req__msg;
  logic [0:0] fp_div__req__rdy;
  logic [0:0] fp_div__resp__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_div__resp__msg;
  logic [0:0] fp_div__resp__rdy;

  DW_fp_div_seq__57be055cf8afa8d8 fp_div
  (
    .clk( fp_div__clk ),
    .reset( fp_div__reset ),
    .req__en( fp_div__req__en ),
    .req__msg( fp_div__req__msg ),
    .req__rdy( fp_div__req__rdy ),
    .resp__en( fp_div__resp__en ),
    .resp__msg( fp_div__resp__msg ),
    .resp__rdy( fp_div__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_div
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_div_resp_q
  //-------------------------------------------------------------

  logic [0:0] fp_div_resp_q__clk;
  logic [0:0] fp_div_resp_q__count;
  logic [0:0] fp_div_resp_q__reset;
  logic [0:0] fp_div_resp_q__deq__en;
  logic [0:0] fp_div_resp_q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_div_resp_q__deq__ret;
  logic [0:0] fp_div_resp_q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_div_resp_q__enq__msg;
  logic [0:0] fp_div_resp_q__enq__rdy;

  NormalQueueRTL__f55b0708e52dd198 fp_div_resp_q
  (
    .clk( fp_div_resp_q__clk ),
    .count( fp_div_resp_q__count ),
    .reset( fp_div_resp_q__reset ),
    .deq__en( fp_div_resp_q__deq__en ),
    .deq__rdy( fp_div_resp_q__deq__rdy ),
    .deq__ret( fp_div_resp_q__deq__ret ),
    .enq__en( fp_div_resp_q__enq__en ),
    .enq__msg( fp_div_resp_q__enq__msg ),
    .enq__rdy( fp_div_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_div_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_mult
  //-------------------------------------------------------------

  logic [0:0] fp_mult__clk;
  logic [0:0] fp_mult__reset;
  logic [0:0] fp_mult__req__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fp_mult__req__msg;
  logic [0:0] fp_mult__req__rdy;
  logic [0:0] fp_mult__resp__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_mult__resp__msg;
  logic [0:0] fp_mult__resp__rdy;

  DW_fp_mult__5367206e2cb8f6c7 fp_mult
  (
    .clk( fp_mult__clk ),
    .reset( fp_mult__reset ),
    .req__en( fp_mult__req__en ),
    .req__msg( fp_mult__req__msg ),
    .req__rdy( fp_mult__req__rdy ),
    .resp__en( fp_mult__resp__en ),
    .resp__msg( fp_mult__resp__msg ),
    .resp__rdy( fp_mult__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_mult
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fp_mult_resp_q
  //-------------------------------------------------------------

  logic [0:0] fp_mult_resp_q__clk;
  logic [0:0] fp_mult_resp_q__count;
  logic [0:0] fp_mult_resp_q__reset;
  logic [0:0] fp_mult_resp_q__deq__en;
  logic [0:0] fp_mult_resp_q__deq__rdy;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_mult_resp_q__deq__ret;
  logic [0:0] fp_mult_resp_q__enq__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fp_mult_resp_q__enq__msg;
  logic [0:0] fp_mult_resp_q__enq__rdy;

  NormalQueueRTL__f55b0708e52dd198 fp_mult_resp_q
  (
    .clk( fp_mult_resp_q__clk ),
    .count( fp_mult_resp_q__count ),
    .reset( fp_mult_resp_q__reset ),
    .deq__en( fp_mult_resp_q__deq__en ),
    .deq__rdy( fp_mult_resp_q__deq__rdy ),
    .deq__ret( fp_mult_resp_q__deq__ret ),
    .enq__en( fp_mult_resp_q__enq__en ),
    .enq__msg( fp_mult_resp_q__enq__msg ),
    .enq__rdy( fp_mult_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component fp_mult_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__count;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  NormalQueueRTL__86a7c3aeb6713f23 recv_q
  (
    .clk( recv_q__clk ),
    .count( recv_q__count ),
    .reset( recv_q__reset ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/FloatingPointUnit.py:68
  // @update
  // def up_req():
  // 
  //   # default
  //   s.recv_q.deq.en     @= 0
  //   s.fp_addsub.req.en  @= 0
  //   s.fp_mult.req.en    @= 0
  //   s.fp_div.req.en     @= 0
  //   s.fp_cmp.req.en     @= 0
  //   s.fp_cvt.req.en     @= 0
  // 
  //   if s.recv_q.deq.rdy:
  // 
  //     # FADD & FSUB
  //     if    ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FADD ) | \
  //           ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FSUB ):
  //       s.recv_q.deq.en     @= s.fp_addsub.req.rdy
  //       s.fp_addsub.req.en  @= s.fp_addsub.req.rdy
  // 
  //     # FMULT
  //     elif  ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FMUL ):
  //       s.recv_q.deq.en   @= s.fp_mult.req.rdy
  //       s.fp_mult.req.en  @= s.fp_mult.req.rdy
  // 
  //     # FDIV
  //     elif  ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FDIV ):
  //       s.recv_q.deq.en @= s.fp_div.req.rdy
  //       s.fp_div.req.en @= s.fp_div.req.rdy
  // 
  //     # FMIN, FMAX, FCEQ, FCLT, FCLE
  //     elif  ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FMIN ) | \
  //           ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FMAX ) | \
  //           ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FCEQ ) | \
  //           ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FCLT ) | \
  //           ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FCLE ):
  //       s.recv_q.deq.en @= s.fp_cmp.req.rdy
  //       s.fp_cmp.req.en @= s.fp_cmp.req.rdy
  // 
  //     # FI2F, FF2I
  //     elif  ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FI2F ) | \
  //           ( s.recv_q.deq.ret.type_ == FpuReqType.TYPE_FF2I ):
  //       s.recv_q.deq.en @= s.fp_cvt.req.rdy
  //       s.fp_cvt.req.en @= s.fp_cvt.req.rdy
  
  always_comb begin : up_req
    recv_q__deq__en = 1'd0;
    fp_addsub__req__en = 1'd0;
    fp_mult__req__en = 1'd0;
    fp_div__req__en = 1'd0;
    fp_cmp__req__en = 1'd0;
    fp_cvt__req__en = 1'd0;
    if ( recv_q__deq__rdy ) begin
      if ( ( recv_q__deq__ret.type_ == 4'd1 ) | ( recv_q__deq__ret.type_ == 4'd2 ) ) begin
        recv_q__deq__en = fp_addsub__req__rdy;
        fp_addsub__req__en = fp_addsub__req__rdy;
      end
      else if ( recv_q__deq__ret.type_ == 4'd0 ) begin
        recv_q__deq__en = fp_mult__req__rdy;
        fp_mult__req__en = fp_mult__req__rdy;
      end
      else if ( recv_q__deq__ret.type_ == 4'd3 ) begin
        recv_q__deq__en = fp_div__req__rdy;
        fp_div__req__en = fp_div__req__rdy;
      end
      else if ( ( ( ( ( recv_q__deq__ret.type_ == 4'd4 ) | ( recv_q__deq__ret.type_ == 4'd5 ) ) | ( recv_q__deq__ret.type_ == 4'd8 ) ) | ( recv_q__deq__ret.type_ == 4'd9 ) ) | ( recv_q__deq__ret.type_ == 4'd10 ) ) begin
        recv_q__deq__en = fp_cmp__req__rdy;
        fp_cmp__req__en = fp_cmp__req__rdy;
      end
      else if ( ( recv_q__deq__ret.type_ == 4'd6 ) | ( recv_q__deq__ret.type_ == 4'd7 ) ) begin
        recv_q__deq__en = fp_cvt__req__rdy;
        fp_cvt__req__en = fp_cvt__req__rdy;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/fpu/FloatingPointUnit.py:119
  // @update
  // def up_resp():
  // 
  //   # default
  //   s.resp.en   @= 0
  //   s.resp.msg  @= FpuResp()
  // 
  //   s.fp_addsub_resp_q.deq.en @= 0
  //   s.fp_mult_resp_q.deq.en   @= 0
  //   s.fp_div_resp_q.deq.en    @= 0
  //   s.fp_cmp_resp_q.deq.en    @= 0
  //   s.fp_cvt_resp_q.deq.en    @= 0
  // 
  //   if s.resp.rdy:
  //     if    s.fp_addsub_resp_q.deq.rdy:
  //       s.resp.en                 @= 1
  //       s.resp.msg                @= s.fp_addsub_resp_q.deq.ret
  //       s.fp_addsub_resp_q.deq.en @= 1
  // 
  //     elif  s.fp_mult_resp_q.deq.rdy:
  //       s.resp.en               @= 1
  //       s.resp.msg              @= s.fp_mult_resp_q.deq.ret
  //       s.fp_mult_resp_q.deq.en @= 1
  // 
  //     elif  s.fp_div_resp_q.deq.rdy:
  //       s.resp.en              @= 1
  //       s.resp.msg             @= s.fp_div_resp_q.deq.ret
  //       s.fp_div_resp_q.deq.en @= 1
  // 
  //     elif  s.fp_cmp_resp_q.deq.rdy:
  //       s.resp.en              @= 1
  //       s.resp.msg             @= s.fp_cmp_resp_q.deq.ret
  //       s.fp_cmp_resp_q.deq.en @= 1
  // 
  //     elif  s.fp_cvt_resp_q.deq.rdy:
  //       s.resp.en              @= 1
  //       s.resp.msg             @= s.fp_cvt_resp_q.deq.ret
  //       s.fp_cvt_resp_q.deq.en @= 1
  
  always_comb begin : up_resp
    resp__en = 1'd0;
    resp__msg = { 8'd0, 32'd0, 5'd0 };
    fp_addsub_resp_q__deq__en = 1'd0;
    fp_mult_resp_q__deq__en = 1'd0;
    fp_div_resp_q__deq__en = 1'd0;
    fp_cmp_resp_q__deq__en = 1'd0;
    fp_cvt_resp_q__deq__en = 1'd0;
    if ( resp__rdy ) begin
      if ( fp_addsub_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = fp_addsub_resp_q__deq__ret;
        fp_addsub_resp_q__deq__en = 1'd1;
      end
      else if ( fp_mult_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = fp_mult_resp_q__deq__ret;
        fp_mult_resp_q__deq__en = 1'd1;
      end
      else if ( fp_div_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = fp_div_resp_q__deq__ret;
        fp_div_resp_q__deq__en = 1'd1;
      end
      else if ( fp_cmp_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = fp_cmp_resp_q__deq__ret;
        fp_cmp_resp_q__deq__en = 1'd1;
      end
      else if ( fp_cvt_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = fp_cvt_resp_q__deq__ret;
        fp_cvt_resp_q__deq__en = 1'd1;
      end
    end
  end

  assign fp_addsub__clk = clk;
  assign fp_addsub__reset = reset;
  assign fp_mult__clk = clk;
  assign fp_mult__reset = reset;
  assign fp_div__clk = clk;
  assign fp_div__reset = reset;
  assign fp_cmp__clk = clk;
  assign fp_cmp__reset = reset;
  assign fp_cvt__clk = clk;
  assign fp_cvt__reset = reset;
  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = req__en;
  assign recv_q__enq__msg = req__msg;
  assign req__rdy = recv_q__enq__rdy;
  assign fp_addsub_resp_q__clk = clk;
  assign fp_addsub_resp_q__reset = reset;
  assign fp_mult_resp_q__clk = clk;
  assign fp_mult_resp_q__reset = reset;
  assign fp_div_resp_q__clk = clk;
  assign fp_div_resp_q__reset = reset;
  assign fp_cmp_resp_q__clk = clk;
  assign fp_cmp_resp_q__reset = reset;
  assign fp_cvt_resp_q__clk = clk;
  assign fp_cvt_resp_q__reset = reset;
  assign fp_addsub__req__msg = recv_q__deq__ret;
  assign fp_mult__req__msg = recv_q__deq__ret;
  assign fp_div__req__msg = recv_q__deq__ret;
  assign fp_cmp__req__msg = recv_q__deq__ret;
  assign fp_cvt__req__msg = recv_q__deq__ret;
  assign fp_addsub_resp_q__enq__en = fp_addsub__resp__en;
  assign fp_addsub_resp_q__enq__msg = fp_addsub__resp__msg;
  assign fp_addsub__resp__rdy = fp_addsub_resp_q__enq__rdy;
  assign fp_mult_resp_q__enq__en = fp_mult__resp__en;
  assign fp_mult_resp_q__enq__msg = fp_mult__resp__msg;
  assign fp_mult__resp__rdy = fp_mult_resp_q__enq__rdy;
  assign fp_div_resp_q__enq__en = fp_div__resp__en;
  assign fp_div_resp_q__enq__msg = fp_div__resp__msg;
  assign fp_div__resp__rdy = fp_div_resp_q__enq__rdy;
  assign fp_cmp_resp_q__enq__en = fp_cmp__resp__en;
  assign fp_cmp_resp_q__enq__msg = fp_cmp__resp__msg;
  assign fp_cmp__resp__rdy = fp_cmp_resp_q__enq__rdy;
  assign fp_cvt_resp_q__enq__en = fp_cvt__resp__en;
  assign fp_cvt_resp_q__enq__msg = fp_cvt__resp__msg;
  assign fp_cvt__resp__rdy = fp_cvt_resp_q__enq__rdy;

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] deq_en ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] enq_en ,
  output logic [0:0] enq_rdy ,
  output logic [0:0] raddr ,
  input  logic [0:0] reset ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  logic [0:0] deq_xfer;
  logic [0:0] enq_xfer;
  logic [0:0] head;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:84
  // s.deq_rdy //= lambda: ~s.reset & ( s.count > CountType(0) )
  
  always_comb begin : _lambda__s_intra_tile_net_m2p_net_input_units_0__queue_ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( count > 2'd0 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:87
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_intra_tile_net_m2p_net_input_units_0__queue_ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:83
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_intra_tile_net_m2p_net_input_units_0__queue_ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < 2'd2 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:86
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_intra_tile_net_m2p_net_input_units_0__queue_ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:89
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < 1'd1 ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < 1'd1 ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_RingMsg_2__src_1__dst_1__payload_32__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__168e68246e4364ad
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output RingMsg_2__src_1__dst_1__payload_32 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  RingMsg_2__src_1__dst_1__payload_32 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  RingMsg_2__src_1__dst_1__payload_32 regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// Full name: NormalQueueDpathRTL__EntryType_RingMsg_2__src_1__dst_1__payload_32__num_entries_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueDpathRTL__bde4d933cf41d046
(
  input  logic [0:0] clk ,
  output RingMsg_2__src_1__dst_1__payload_32 deq_ret ,
  input  RingMsg_2__src_1__dst_1__payload_32 enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  RingMsg_2__src_1__dst_1__payload_32 queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  RingMsg_2__src_1__dst_1__payload_32 queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__168e68246e4364ad queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_RingMsg_2__src_1__dst_1__payload_32__num_entries_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueRTL__bde4d933cf41d046
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output RingMsg_2__src_1__dst_1__payload_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input RingMsg_2__src_1__dst_1__payload_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  RingMsg_2__src_1__dst_1__payload_32 dpath__deq_ret;
  RingMsg_2__src_1__dst_1__payload_32 dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__bde4d933cf41d046 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component InputUnitRTL Definition
// Full name: InputUnitRTL__PacketType_RingMsg_2__src_1__dst_1__payload_32__QueueType_NormalQueueRTL
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__04428dd15860572e
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output RingMsg_2__src_1__dst_1__payload_32 give__ret  ,
  input logic [0:0] recv__en  ,
  input RingMsg_2__src_1__dst_1__payload_32 recv__msg  ,
  output logic [0:0] recv__rdy  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  logic [0:0] queue__deq__en;
  logic [0:0] queue__deq__rdy;
  RingMsg_2__src_1__dst_1__payload_32 queue__deq__ret;
  logic [0:0] queue__enq__en;
  RingMsg_2__src_1__dst_1__payload_32 queue__enq__msg;
  logic [0:0] queue__enq__rdy;

  NormalQueueRTL__bde4d933cf41d046 queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .deq__en( queue__deq__en ),
    .deq__rdy( queue__deq__rdy ),
    .deq__ret( queue__deq__ret ),
    .enq__en( queue__enq__en ),
    .enq__msg( queue__enq__msg ),
    .enq__rdy( queue__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__enq__en = recv__en;
  assign queue__enq__msg = recv__msg;
  assign recv__rdy = queue__enq__rdy;
  assign queue__deq__en = give__en;
  assign give__rdy = queue__deq__rdy;
  assign give__ret = queue__deq__ret;

endmodule


// PyMTL Component OutputUnitRTL Definition
// Full name: OutputUnitRTL__PacketType_RingMsg_2__src_1__dst_1__payload_32__QueueType_None
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__10412371c9808a03
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input RingMsg_2__src_1__dst_1__payload_32 get__ret  ,
  output logic [0:0] send__en  ,
  output RingMsg_2__src_1__dst_1__payload_32 send__msg  ,
  input logic [0:0] send__rdy  
);
  logic [0:0] __tmpvar__up_get_send_both_rdy;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/OutputUnitRTL.py:52
  // s.send.msg //= lambda: s.get.ret if s.send.en else PacketType()
  
  always_comb begin : _lambda__s_intra_tile_net_m2p_net_output_units_0__send_msg
    send__msg = send__en ? get__ret : { 1'd0, 1'd0, 32'd0 };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/OutputUnitRTL.py:54
  // @update
  // def up_get_send():
  //   both_rdy = s.get.rdy & s.send.rdy
  //   s.get.en  @= both_rdy
  //   s.send.en @= both_rdy
  
  always_comb begin : up_get_send
    __tmpvar__up_get_send_both_rdy = get__rdy & send__rdy;
    get__en = __tmpvar__up_get_send_both_rdy;
    send__en = __tmpvar__up_get_send_both_rdy;
  end

endmodule


// PyMTL Component XbarRouteUnitRTL Definition
// Full name: XbarRouteUnitRTL__PacketType_RingMsg_2__src_1__dst_1__payload_32__num_outports_1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitRTL.py

module XbarRouteUnitRTL__593864738d4fc0e6
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input RingMsg_2__src_1__dst_1__payload_32 get__ret  ,
  input logic [0:0] give__en [0:0] ,
  output logic [0:0] give__rdy [0:0] ,
  output RingMsg_2__src_1__dst_1__payload_32 give__ret [0:0] 
);
  localparam logic [0:0] __const__num_outports_at_up_ru_routing  = 1'd1;
  logic [0:0] give_ens;
  logic [0:0] out_dir;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitRTL.py:51
  // @update
  // def up_ru_give_en():
  //   s.get.en @= s.give_ens > 0
  
  always_comb begin : up_ru_give_en
    get__en = give_ens > 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitRTL.py:41
  // @update
  // def up_ru_routing():
  //   s.out_dir @= trunc( s.get.ret.dst, dir_nbits )
  // 
  //   for i in range( num_outports ):
  //     s.give[i].rdy @= b1(0)
  // 
  //   if s.get.rdy:
  //     s.give[ s.out_dir ].rdy @= b1(1)
  
  always_comb begin : up_ru_routing
    out_dir = get__ret.dst;
    for ( int unsigned i = 1'd0; i < 1'( __const__num_outports_at_up_ru_routing ); i += 1'd1 )
      give__rdy[1'(i)] = 1'd0;
    if ( get__rdy ) begin
      give__rdy[out_dir] = 1'd1;
    end
  end

  assign give__ret[0] = get__ret;
  assign give_ens[0:0] = give__en[0];

endmodule


// PyMTL Component SwitchUnitNullRTL Definition
// Full name: SwitchUnitNullRTL__Type_RingMsg_2__src_1__dst_1__payload_32__num_inports_1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitNullRTL.py

module SwitchUnitNullRTL__16e1e34e5445ae99
(
  input  logic [0:0] clk ,
  input  logic [0:0] hold [0:0],
  input  logic [0:0] reset ,
  output logic [0:0] get__en [0:0] ,
  input logic [0:0] get__rdy [0:0] ,
  input RingMsg_2__src_1__dst_1__payload_32 get__ret [0:0] ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output RingMsg_2__src_1__dst_1__payload_32 give__ret  
);

  assign get__en[0] = give__en;
  assign give__rdy = get__rdy[0];
  assign give__ret = get__ret[0];

endmodule


// PyMTL Component XbarRTL Definition
// Full name: XbarRTL__PacketType_RingMsg_2__src_1__dst_1__payload_32__num_inports_1__num_outports_1__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitRTL__SwitchUnitType_SwitchUnitRTL__OutputUnitType_OutputUnitRTL
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRTL.py

module XbarRTL__a7c7e18db18bc973
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:0] ,
  input RingMsg_2__src_1__dst_1__payload_32 recv__msg [0:0] ,
  output logic [0:0] recv__rdy [0:0] ,
  output logic [0:0] send__en [0:0] ,
  output RingMsg_2__src_1__dst_1__payload_32 send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] 
);
  //-------------------------------------------------------------
  // Component input_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:0];
  logic [0:0] input_units__reset [0:0];
  logic [0:0] input_units__give__en [0:0];
  logic [0:0] input_units__give__rdy [0:0];
  RingMsg_2__src_1__dst_1__payload_32 input_units__give__ret [0:0];
  logic [0:0] input_units__recv__en [0:0];
  RingMsg_2__src_1__dst_1__payload_32 input_units__recv__msg [0:0];
  logic [0:0] input_units__recv__rdy [0:0];

  InputUnitRTL__04428dd15860572e input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .give__en( input_units__give__en[0] ),
    .give__rdy( input_units__give__rdy[0] ),
    .give__ret( input_units__give__ret[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:0];
  logic [0:0] output_units__reset [0:0];
  logic [0:0] output_units__get__en [0:0];
  logic [0:0] output_units__get__rdy [0:0];
  RingMsg_2__src_1__dst_1__payload_32 output_units__get__ret [0:0];
  logic [0:0] output_units__send__en [0:0];
  RingMsg_2__src_1__dst_1__payload_32 output_units__send__msg [0:0];
  logic [0:0] output_units__send__rdy [0:0];

  OutputUnitRTL__10412371c9808a03 output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .get__en( output_units__get__en[0] ),
    .get__rdy( output_units__get__rdy[0] ),
    .get__ret( output_units__get__ret[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:0];
  logic [0:0] route_units__reset [0:0];
  logic [0:0] route_units__get__en [0:0];
  logic [0:0] route_units__get__rdy [0:0];
  RingMsg_2__src_1__dst_1__payload_32 route_units__get__ret [0:0];
  logic [0:0] route_units__give__en [0:0][0:0];
  logic [0:0] route_units__give__rdy [0:0][0:0];
  RingMsg_2__src_1__dst_1__payload_32 route_units__give__ret [0:0][0:0];

  XbarRouteUnitRTL__593864738d4fc0e6 route_units__0
  (
    .clk( route_units__clk[0] ),
    .reset( route_units__reset[0] ),
    .get__en( route_units__get__en[0] ),
    .get__rdy( route_units__get__rdy[0] ),
    .get__ret( route_units__get__ret[0] ),
    .give__en( route_units__give__en[0] ),
    .give__rdy( route_units__give__rdy[0] ),
    .give__ret( route_units__give__ret[0] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:0];
  logic [0:0] switch_units__hold [0:0][0:0];
  logic [0:0] switch_units__reset [0:0];
  logic [0:0] switch_units__get__en [0:0][0:0];
  logic [0:0] switch_units__get__rdy [0:0][0:0];
  RingMsg_2__src_1__dst_1__payload_32 switch_units__get__ret [0:0][0:0];
  logic [0:0] switch_units__give__en [0:0];
  logic [0:0] switch_units__give__rdy [0:0];
  RingMsg_2__src_1__dst_1__payload_32 switch_units__give__ret [0:0];

  SwitchUnitNullRTL__16e1e34e5445ae99 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .hold( switch_units__hold[0] ),
    .reset( switch_units__reset[0] ),
    .get__en( switch_units__get__en[0] ),
    .get__rdy( switch_units__get__rdy[0] ),
    .get__ret( switch_units__get__ret[0] ),
    .give__en( switch_units__give__en[0] ),
    .give__rdy( switch_units__give__rdy[0] ),
    .give__ret( switch_units__give__ret[0] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:0]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__give__en[0] = route_units__get__en[0];
  assign route_units__get__rdy[0] = input_units__give__rdy[0];
  assign route_units__get__ret[0] = input_units__give__ret[0];
  assign route_units__give__en[0][0] = switch_units__get__en[0][0];
  assign switch_units__get__rdy[0][0] = route_units__give__rdy[0][0];
  assign switch_units__get__ret[0][0] = route_units__give__ret[0][0];
  assign switch_units__give__en[0] = output_units__get__en[0];
  assign output_units__get__rdy[0] = switch_units__give__rdy[0];
  assign output_units__get__ret[0] = switch_units__give__ret[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];

endmodule


// PyMTL Component IntraTileCtrlNet Definition
// Full name: IntraTileCtrlNet__ncores_1__TileCtrlMsg_TileCtrlMsg_1__coreid_1__data_32
// At /work/global/mw828/cifer/cifer-chip/brg_tile/tmu/IntraTileCtrlNet.py

module IntraTileCtrlNet__2a28ef76eb7cf049
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] from_mngr__en  ,
  input TileCtrlMsg_1__coreid_1__data_32 from_mngr__msg  ,
  output logic [0:0] from_mngr__rdy  ,
  input logic [0:0] from_proc__en [0:0] ,
  input logic [31:0] from_proc__msg [0:0] ,
  output logic [0:0] from_proc__rdy [0:0] ,
  output logic [0:0] to_mngr__en  ,
  output TileCtrlMsg_1__coreid_1__data_32 to_mngr__msg  ,
  input logic [0:0] to_mngr__rdy  ,
  output logic [0:0] to_proc__en [0:0] ,
  output logic [31:0] to_proc__msg [0:0] ,
  input logic [0:0] to_proc__rdy [0:0] 
);
  localparam logic [0:0] __const__ncores_at_up_comb  = 1'd1;
  //-------------------------------------------------------------
  // Component m2p_net
  //-------------------------------------------------------------

  logic [0:0] m2p_net__clk;
  logic [0:0] m2p_net__reset;
  logic [0:0] m2p_net__recv__en [0:0];
  RingMsg_2__src_1__dst_1__payload_32 m2p_net__recv__msg [0:0];
  logic [0:0] m2p_net__recv__rdy [0:0];
  logic [0:0] m2p_net__send__en [0:0];
  RingMsg_2__src_1__dst_1__payload_32 m2p_net__send__msg [0:0];
  logic [0:0] m2p_net__send__rdy [0:0];

  XbarRTL__a7c7e18db18bc973 m2p_net
  (
    .clk( m2p_net__clk ),
    .reset( m2p_net__reset ),
    .recv__en( m2p_net__recv__en ),
    .recv__msg( m2p_net__recv__msg ),
    .recv__rdy( m2p_net__recv__rdy ),
    .send__en( m2p_net__send__en ),
    .send__msg( m2p_net__send__msg ),
    .send__rdy( m2p_net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component m2p_net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component p2m_net
  //-------------------------------------------------------------

  logic [0:0] p2m_net__clk;
  logic [0:0] p2m_net__reset;
  logic [0:0] p2m_net__recv__en [0:0];
  RingMsg_2__src_1__dst_1__payload_32 p2m_net__recv__msg [0:0];
  logic [0:0] p2m_net__recv__rdy [0:0];
  logic [0:0] p2m_net__send__en [0:0];
  RingMsg_2__src_1__dst_1__payload_32 p2m_net__send__msg [0:0];
  logic [0:0] p2m_net__send__rdy [0:0];

  XbarRTL__a7c7e18db18bc973 p2m_net
  (
    .clk( p2m_net__clk ),
    .reset( p2m_net__reset ),
    .recv__en( p2m_net__recv__en ),
    .recv__msg( p2m_net__recv__msg ),
    .recv__rdy( p2m_net__recv__rdy ),
    .send__en( p2m_net__send__en ),
    .send__msg( p2m_net__send__msg ),
    .send__rdy( p2m_net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component p2m_net
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/tmu/IntraTileCtrlNet.py:69
  // @update
  // def up_comb():
  // 
  //   # from_proc <-> p2m_net.recv
  //   for proc_id in range( ncores ):
  //     s.p2m_net.recv[ proc_id ].en          @= s.from_proc[ proc_id ].en
  //     s.from_proc[ proc_id ].rdy            @= s.p2m_net.recv[ proc_id ].rdy
  //     s.p2m_net.recv[ proc_id ].msg.src     @= proc_id
  //     s.p2m_net.recv[ proc_id ].msg.dst     @= 0
  //     s.p2m_net.recv[ proc_id ].msg.payload @= s.from_proc[ proc_id ].msg
  // 
  //   # p2m_net.send <-> to_mngr
  //   s.to_mngr.en            @= s.p2m_net.send[ 0 ].en
  //   s.p2m_net.send[ 0 ].rdy @= s.to_mngr.rdy
  //   s.to_mngr.msg.coreid    @= s.p2m_net.send[ 0 ].msg.src
  //   s.to_mngr.msg.data      @= s.p2m_net.send[ 0 ].msg.payload
  // 
  //   # to_proc <-> m2p_net.send
  //   for proc_id in range( ncores ):
  //     s.to_proc[ proc_id ].en       @= s.m2p_net.send[ proc_id ].en
  //     s.m2p_net.send[ proc_id ].rdy @= s.to_proc[ proc_id ].rdy
  //     s.to_proc[ proc_id ].msg      @= s.m2p_net.send[ proc_id ].msg.payload
  // 
  //   # m2p_net.recv <-> from_mngr
  //   s.m2p_net.recv[ 0 ].en           @= s.from_mngr.en
  //   s.from_mngr.rdy                  @= s.m2p_net.recv[ 0 ].rdy
  //   s.m2p_net.recv[ 0 ].msg.src      @= 0
  //   s.m2p_net.recv[ 0 ].msg.dst      @= s.from_mngr.msg.coreid
  //   s.m2p_net.recv[ 0 ].msg.payload  @= s.from_mngr.msg.data
  
  always_comb begin : up_comb
    for ( int unsigned proc_id = 1'd0; proc_id < 1'( __const__ncores_at_up_comb ); proc_id += 1'd1 ) begin
      p2m_net__recv__en[1'(proc_id)] = from_proc__en[1'(proc_id)];
      from_proc__rdy[1'(proc_id)] = p2m_net__recv__rdy[1'(proc_id)];
      p2m_net__recv__msg[1'(proc_id)].src = 1'(proc_id);
      p2m_net__recv__msg[1'(proc_id)].dst = 1'd0;
      p2m_net__recv__msg[1'(proc_id)].payload = from_proc__msg[1'(proc_id)];
    end
    to_mngr__en = p2m_net__send__en[1'd0];
    p2m_net__send__rdy[1'd0] = to_mngr__rdy;
    to_mngr__msg.coreid = p2m_net__send__msg[1'd0].src;
    to_mngr__msg.data = p2m_net__send__msg[1'd0].payload;
    for ( int unsigned proc_id = 1'd0; proc_id < 1'( __const__ncores_at_up_comb ); proc_id += 1'd1 ) begin
      to_proc__en[1'(proc_id)] = m2p_net__send__en[1'(proc_id)];
      m2p_net__send__rdy[1'(proc_id)] = to_proc__rdy[1'(proc_id)];
      to_proc__msg[1'(proc_id)] = m2p_net__send__msg[1'(proc_id)].payload;
    end
    m2p_net__recv__en[1'd0] = from_mngr__en;
    from_mngr__rdy = m2p_net__recv__rdy[1'd0];
    m2p_net__recv__msg[1'd0].src = 1'd0;
    m2p_net__recv__msg[1'd0].dst = from_mngr__msg.coreid;
    m2p_net__recv__msg[1'd0].payload = from_mngr__msg.data;
  end

  assign p2m_net__clk = clk;
  assign p2m_net__reset = reset;
  assign m2p_net__clk = clk;
  assign m2p_net__reset = reset;

endmodule


// PyMTL Component RegRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegRst__Type_Bits5__reset_value_00
(
  input  logic [0:0] clk ,
  input  logic [4:0] in_ ,
  output logic [4:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regrst  = 5'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:39
  // @update_ff
  // def up_regrst():
  //   if s.reset: s.out <<= reset_value
  //   else:       s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regrst
    if ( reset ) begin
      out <= 5'( __const__reset_value_at_up_regrst );
    end
    else
      out <= in_;
  end

endmodule


// PyMTL Component IntDivRem4Ctrl Definition
// Full name: IntDivRem4Ctrl__ReqT_MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32__RespT_MduRespMsg_8_32__opaque_8__res_32__nbits_32
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py

module IntDivRem4Ctrl__a04e5aace91dda76
(
  output logic [0:0] buffers_en ,
  input  logic [0:0] clk ,
  output logic [0:0] divisor_mux_sel ,
  output logic [0:0] is_div ,
  output logic [0:0] is_signed ,
  output logic [0:0] quotient_mux_sel ,
  output logic [0:0] quotient_reg_en ,
  output logic [1:0] remainder_mux_sel ,
  output logic [0:0] remainder_reg_en ,
  input  logic [0:0] req_en ,
  output logic [0:0] req_rdy ,
  input  logic [2:0] req_type ,
  input  logic [0:0] reset ,
  output logic [0:0] resp_en ,
  input  logic [0:0] resp_rdy ,
  input  logic [0:0] sub_negative1 ,
  input  logic [0:0] sub_negative2 
);
  localparam logic [0:0] __const__R_MUX_SEL_IN  = 1'd0;
  localparam logic [0:0] __const__Q_MUX_SEL_0  = 1'd0;
  localparam logic [0:0] __const__D_MUX_SEL_IN  = 1'd0;
  localparam logic [0:0] __const__R_MUX_SEL_SUB1  = 1'd1;
  localparam logic [1:0] __const__R_MUX_SEL_SUB2  = 2'd2;
  localparam logic [0:0] __const__Q_MUX_SEL_LSH  = 1'd1;
  localparam logic [0:0] __const__D_MUX_SEL_RSH  = 1'd1;
  //-------------------------------------------------------------
  // Component state
  //-------------------------------------------------------------

  logic [0:0] state__clk;
  logic [4:0] state__in_;
  logic [4:0] state__out;
  logic [0:0] state__reset;

  RegRst__Type_Bits5__reset_value_00 state
  (
    .clk( state__clk ),
    .in_( state__in_ ),
    .out( state__out ),
    .reset( state__reset )
  );

  //-------------------------------------------------------------
  // End of component state
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py:88
  // @update
  // def state_outputs():
  // 
  //   s.req_rdy     @= 0
  //   s.resp_en     @= 0
  //   s.buffers_en  @= 0
  //   s.is_div      @= 0
  //   s.is_signed   @= 0
  // 
  //   if   s.state.out == s.STATE_IDLE:
  //     s.req_rdy           @= 1
  //     s.remainder_mux_sel @= R_MUX_SEL_IN
  //     s.remainder_reg_en  @= 1
  //     s.quotient_mux_sel  @= Q_MUX_SEL_0
  //     s.quotient_reg_en   @= 1
  //     s.divisor_mux_sel   @= D_MUX_SEL_IN
  // 
  //     s.buffers_en        @= 1
  //     s.is_div            @= ( s.req_type[1] == 0 ) # div/divu = 0b100, 0b101
  //     s.is_signed         @= ( s.req_type[0] == 0 ) # div/rem = 0b100, 0b110
  // 
  //   elif s.state.out == s.STATE_DONE:
  //     s.resp_en           @= s.resp_rdy
  //     s.remainder_mux_sel @= R_MUX_SEL_IN
  //     s.remainder_reg_en  @= 0
  //     s.quotient_mux_sel  @= Q_MUX_SEL_0
  //     s.quotient_reg_en   @= 0
  //     s.divisor_mux_sel   @= D_MUX_SEL_IN
  // 
  //   else: # calculating
  // 
  //     s.remainder_reg_en @= ~( s.sub_negative1 & s.sub_negative2 )
  // 
  //     if s.sub_negative2:
  //       s.remainder_mux_sel @= R_MUX_SEL_SUB1
  //     else:
  //       s.remainder_mux_sel @= R_MUX_SEL_SUB2
  // 
  //     s.quotient_reg_en  @= 1
  //     s.quotient_mux_sel @= Q_MUX_SEL_LSH
  //     s.divisor_mux_sel  @= D_MUX_SEL_RSH
  
  always_comb begin : state_outputs
    req_rdy = 1'd0;
    resp_en = 1'd0;
    buffers_en = 1'd0;
    is_div = 1'd0;
    is_signed = 1'd0;
    if ( state__out == 5'd0 ) begin
      req_rdy = 1'd1;
      remainder_mux_sel = 2'( __const__R_MUX_SEL_IN );
      remainder_reg_en = 1'd1;
      quotient_mux_sel = 1'( __const__Q_MUX_SEL_0 );
      quotient_reg_en = 1'd1;
      divisor_mux_sel = 1'( __const__D_MUX_SEL_IN );
      buffers_en = 1'd1;
      is_div = req_type[2'd1] == 1'd0;
      is_signed = req_type[2'd0] == 1'd0;
    end
    else if ( state__out == 5'd1 ) begin
      resp_en = resp_rdy;
      remainder_mux_sel = 2'( __const__R_MUX_SEL_IN );
      remainder_reg_en = 1'd0;
      quotient_mux_sel = 1'( __const__Q_MUX_SEL_0 );
      quotient_reg_en = 1'd0;
      divisor_mux_sel = 1'( __const__D_MUX_SEL_IN );
    end
    else begin
      remainder_reg_en = ~( sub_negative1 & sub_negative2 );
      if ( sub_negative2 ) begin
        remainder_mux_sel = 2'( __const__R_MUX_SEL_SUB1 );
      end
      else
        remainder_mux_sel = 2'( __const__R_MUX_SEL_SUB2 );
      quotient_reg_en = 1'd1;
      quotient_mux_sel = 1'( __const__Q_MUX_SEL_LSH );
      divisor_mux_sel = 1'( __const__D_MUX_SEL_RSH );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py:72
  // @update
  // def state_transitions():
  // 
  //   s.state.in_ @= s.state.out
  // 
  //   if   s.state.out == s.STATE_IDLE:
  //     if s.req_en:
  //       s.state.in_ @= s.STATE_CALC
  // 
  //   elif s.state.out == s.STATE_DONE:
  //     if s.resp_rdy:
  //       s.state.in_ @= s.STATE_IDLE
  // 
  //   else:
  //     s.state.in_ @= s.state.out - 1
  
  always_comb begin : state_transitions
    state__in_ = state__out;
    if ( state__out == 5'd0 ) begin
      if ( req_en ) begin
        state__in_ = 5'd17;
      end
    end
    else if ( state__out == 5'd1 ) begin
      if ( resp_rdy ) begin
        state__in_ = 5'd0;
      end
    end
    else
      state__in_ = state__out - 5'd1;
  end

  assign state__clk = clk;
  assign state__reset = reset;

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_Bits64__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [63:0] in_ [0:1],
  output logic [63:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component Reg Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module Reg__Type_Bits64
(
  input  logic [0:0] clk ,
  input  logic [63:0] in_ ,
  output logic [63:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:10
  // @update_ff
  // def up_reg():
  //   s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_reg
    out <= in_;
  end

endmodule


// PyMTL Component RightLogicalShifter Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module RightLogicalShifter__Type_Bits64__shamt_nbits_64
(
  input  logic [0:0] clk ,
  input  logic [63:0] in_ ,
  output logic [63:0] out ,
  input  logic [0:0] reset ,
  input  logic [63:0] shamt 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:45
  // @update
  // def up_rshifter():
  //   s.out @= s.in_ >> s.shamt
  
  always_comb begin : up_rshifter
    out = in_ >> shamt;
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_Bits1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [0:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_Bits8
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [7:0] in_ ,
  output logic [7:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component LeftLogicalShifter Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module LeftLogicalShifter__Type_Bits32__shamt_nbits_32
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [31:0] shamt 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:59
  // @update
  // def up_lshifter():
  //   s.out @= s.in_ << s.shamt
  
  always_comb begin : up_lshifter
    out = in_ << shamt;
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_Bits32__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:1],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_Bits32
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_Bits64__ninputs_3
(
  input  logic [0:0] clk ,
  input  logic [63:0] in_ [0:2],
  output logic [63:0] out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_Bits64
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [63:0] in_ ,
  output logic [63:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Subtractor Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Subtractor__Type_Bits64
(
  input  logic [0:0] clk ,
  input  logic [63:0] in0 ,
  input  logic [63:0] in1 ,
  output logic [63:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:110
  // @update
  // def up_subtractor():
  //   s.out @= s.in0 - s.in1
  
  always_comb begin : up_subtractor
    out = in0 - in1;
  end

endmodule


// PyMTL Component IntDivRem4Dpath Definition
// Full name: IntDivRem4Dpath__ReqT_MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32__RespT_MduRespMsg_8_32__opaque_8__res_32__nbits_32
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py

module IntDivRem4Dpath__a04e5aace91dda76
(
  input  logic [0:0] buffers_en ,
  input  logic [0:0] clk ,
  input  logic [0:0] divisor_mux_sel ,
  input  logic [0:0] is_div ,
  input  logic [0:0] is_signed ,
  input  logic [0:0] quotient_mux_sel ,
  input  logic [0:0] quotient_reg_en ,
  input  logic [1:0] remainder_mux_sel ,
  input  logic [0:0] remainder_reg_en ,
  input  logic [31:0] req_msg_a ,
  input  logic [31:0] req_msg_b ,
  input  logic [7:0] req_msg_opaque ,
  input  logic [0:0] reset ,
  output logic [7:0] resp_opaque ,
  output logic [31:0] resp_result ,
  output logic [0:0] sub_negative1 ,
  output logic [0:0] sub_negative2 
);
  localparam logic [5:0] __const__nbits_at_comb_negate_if_needed  = 6'd32;
  localparam logic [0:0] __const__Q_MUX_SEL_0  = 1'd0;
  localparam logic [0:0] __const__Q_MUX_SEL_LSH  = 1'd1;
  localparam logic [5:0] __const__nbits_at_comb_res_negate_flags  = 6'd32;
  localparam logic [5:0] __const__nbits_at_comb_negate_rem_quo  = 6'd32;
  logic [31:0] a_negate;
  logic [31:0] b_negate;
  logic [31:0] quo_negate;
  logic [31:0] rem_negate;
  logic [0:0] res_quo_negate;
  logic [0:0] res_rem_negate;
  //-------------------------------------------------------------
  // Component divisor_mux
  //-------------------------------------------------------------

  logic [0:0] divisor_mux__clk;
  logic [63:0] divisor_mux__in_ [0:1];
  logic [63:0] divisor_mux__out;
  logic [0:0] divisor_mux__reset;
  logic [0:0] divisor_mux__sel;

  Mux__Type_Bits64__ninputs_2 divisor_mux
  (
    .clk( divisor_mux__clk ),
    .in_( divisor_mux__in_ ),
    .out( divisor_mux__out ),
    .reset( divisor_mux__reset ),
    .sel( divisor_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component divisor_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component divisor_reg
  //-------------------------------------------------------------

  logic [0:0] divisor_reg__clk;
  logic [63:0] divisor_reg__in_;
  logic [63:0] divisor_reg__out;
  logic [0:0] divisor_reg__reset;

  Reg__Type_Bits64 divisor_reg
  (
    .clk( divisor_reg__clk ),
    .in_( divisor_reg__in_ ),
    .out( divisor_reg__out ),
    .reset( divisor_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component divisor_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component divisor_rsh1
  //-------------------------------------------------------------

  logic [0:0] divisor_rsh1__clk;
  logic [63:0] divisor_rsh1__in_;
  logic [63:0] divisor_rsh1__out;
  logic [0:0] divisor_rsh1__reset;
  logic [63:0] divisor_rsh1__shamt;

  RightLogicalShifter__Type_Bits64__shamt_nbits_64 divisor_rsh1
  (
    .clk( divisor_rsh1__clk ),
    .in_( divisor_rsh1__in_ ),
    .out( divisor_rsh1__out ),
    .reset( divisor_rsh1__reset ),
    .shamt( divisor_rsh1__shamt )
  );

  //-------------------------------------------------------------
  // End of component divisor_rsh1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component divisor_rsh2
  //-------------------------------------------------------------

  logic [0:0] divisor_rsh2__clk;
  logic [63:0] divisor_rsh2__in_;
  logic [63:0] divisor_rsh2__out;
  logic [0:0] divisor_rsh2__reset;
  logic [63:0] divisor_rsh2__shamt;

  RightLogicalShifter__Type_Bits64__shamt_nbits_64 divisor_rsh2
  (
    .clk( divisor_rsh2__clk ),
    .in_( divisor_rsh2__in_ ),
    .out( divisor_rsh2__out ),
    .reset( divisor_rsh2__reset ),
    .shamt( divisor_rsh2__shamt )
  );

  //-------------------------------------------------------------
  // End of component divisor_rsh2
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component is_div_reg
  //-------------------------------------------------------------

  logic [0:0] is_div_reg__clk;
  logic [0:0] is_div_reg__en;
  logic [0:0] is_div_reg__in_;
  logic [0:0] is_div_reg__out;
  logic [0:0] is_div_reg__reset;

  RegEn__Type_Bits1 is_div_reg
  (
    .clk( is_div_reg__clk ),
    .en( is_div_reg__en ),
    .in_( is_div_reg__in_ ),
    .out( is_div_reg__out ),
    .reset( is_div_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component is_div_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component opaque_reg
  //-------------------------------------------------------------

  logic [0:0] opaque_reg__clk;
  logic [0:0] opaque_reg__en;
  logic [7:0] opaque_reg__in_;
  logic [7:0] opaque_reg__out;
  logic [0:0] opaque_reg__reset;

  RegEn__Type_Bits8 opaque_reg
  (
    .clk( opaque_reg__clk ),
    .en( opaque_reg__en ),
    .in_( opaque_reg__in_ ),
    .out( opaque_reg__out ),
    .reset( opaque_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component opaque_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component quotient_lsh
  //-------------------------------------------------------------

  logic [0:0] quotient_lsh__clk;
  logic [31:0] quotient_lsh__in_;
  logic [31:0] quotient_lsh__out;
  logic [0:0] quotient_lsh__reset;
  logic [31:0] quotient_lsh__shamt;

  LeftLogicalShifter__Type_Bits32__shamt_nbits_32 quotient_lsh
  (
    .clk( quotient_lsh__clk ),
    .in_( quotient_lsh__in_ ),
    .out( quotient_lsh__out ),
    .reset( quotient_lsh__reset ),
    .shamt( quotient_lsh__shamt )
  );

  //-------------------------------------------------------------
  // End of component quotient_lsh
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component quotient_mux
  //-------------------------------------------------------------

  logic [0:0] quotient_mux__clk;
  logic [31:0] quotient_mux__in_ [0:1];
  logic [31:0] quotient_mux__out;
  logic [0:0] quotient_mux__reset;
  logic [0:0] quotient_mux__sel;

  Mux__Type_Bits32__ninputs_2 quotient_mux
  (
    .clk( quotient_mux__clk ),
    .in_( quotient_mux__in_ ),
    .out( quotient_mux__out ),
    .reset( quotient_mux__reset ),
    .sel( quotient_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component quotient_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component quotient_reg
  //-------------------------------------------------------------

  logic [0:0] quotient_reg__clk;
  logic [0:0] quotient_reg__en;
  logic [31:0] quotient_reg__in_;
  logic [31:0] quotient_reg__out;
  logic [0:0] quotient_reg__reset;

  RegEn__Type_Bits32 quotient_reg
  (
    .clk( quotient_reg__clk ),
    .en( quotient_reg__en ),
    .in_( quotient_reg__in_ ),
    .out( quotient_reg__out ),
    .reset( quotient_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component quotient_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component remainder_mid_mux
  //-------------------------------------------------------------

  logic [0:0] remainder_mid_mux__clk;
  logic [63:0] remainder_mid_mux__in_ [0:1];
  logic [63:0] remainder_mid_mux__out;
  logic [0:0] remainder_mid_mux__reset;
  logic [0:0] remainder_mid_mux__sel;

  Mux__Type_Bits64__ninputs_2 remainder_mid_mux
  (
    .clk( remainder_mid_mux__clk ),
    .in_( remainder_mid_mux__in_ ),
    .out( remainder_mid_mux__out ),
    .reset( remainder_mid_mux__reset ),
    .sel( remainder_mid_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component remainder_mid_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component remainder_mux
  //-------------------------------------------------------------

  logic [0:0] remainder_mux__clk;
  logic [63:0] remainder_mux__in_ [0:2];
  logic [63:0] remainder_mux__out;
  logic [0:0] remainder_mux__reset;
  logic [1:0] remainder_mux__sel;

  Mux__Type_Bits64__ninputs_3 remainder_mux
  (
    .clk( remainder_mux__clk ),
    .in_( remainder_mux__in_ ),
    .out( remainder_mux__out ),
    .reset( remainder_mux__reset ),
    .sel( remainder_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component remainder_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component remainder_reg
  //-------------------------------------------------------------

  logic [0:0] remainder_reg__clk;
  logic [0:0] remainder_reg__en;
  logic [63:0] remainder_reg__in_;
  logic [63:0] remainder_reg__out;
  logic [0:0] remainder_reg__reset;

  RegEn__Type_Bits64 remainder_reg
  (
    .clk( remainder_reg__clk ),
    .en( remainder_reg__en ),
    .in_( remainder_reg__in_ ),
    .out( remainder_reg__out ),
    .reset( remainder_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component remainder_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component res_divrem_mux
  //-------------------------------------------------------------

  logic [0:0] res_divrem_mux__clk;
  logic [31:0] res_divrem_mux__in_ [0:1];
  logic [31:0] res_divrem_mux__out;
  logic [0:0] res_divrem_mux__reset;
  logic [0:0] res_divrem_mux__sel;

  Mux__Type_Bits32__ninputs_2 res_divrem_mux
  (
    .clk( res_divrem_mux__clk ),
    .in_( res_divrem_mux__in_ ),
    .out( res_divrem_mux__out ),
    .reset( res_divrem_mux__reset ),
    .sel( res_divrem_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component res_divrem_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component res_quo_mux
  //-------------------------------------------------------------

  logic [0:0] res_quo_mux__clk;
  logic [31:0] res_quo_mux__in_ [0:1];
  logic [31:0] res_quo_mux__out;
  logic [0:0] res_quo_mux__reset;
  logic [0:0] res_quo_mux__sel;

  Mux__Type_Bits32__ninputs_2 res_quo_mux
  (
    .clk( res_quo_mux__clk ),
    .in_( res_quo_mux__in_ ),
    .out( res_quo_mux__out ),
    .reset( res_quo_mux__reset ),
    .sel( res_quo_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component res_quo_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component res_quo_negate_flag
  //-------------------------------------------------------------

  logic [0:0] res_quo_negate_flag__clk;
  logic [0:0] res_quo_negate_flag__en;
  logic [0:0] res_quo_negate_flag__in_;
  logic [0:0] res_quo_negate_flag__out;
  logic [0:0] res_quo_negate_flag__reset;

  RegEn__Type_Bits1 res_quo_negate_flag
  (
    .clk( res_quo_negate_flag__clk ),
    .en( res_quo_negate_flag__en ),
    .in_( res_quo_negate_flag__in_ ),
    .out( res_quo_negate_flag__out ),
    .reset( res_quo_negate_flag__reset )
  );

  //-------------------------------------------------------------
  // End of component res_quo_negate_flag
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component res_rem_mux
  //-------------------------------------------------------------

  logic [0:0] res_rem_mux__clk;
  logic [31:0] res_rem_mux__in_ [0:1];
  logic [31:0] res_rem_mux__out;
  logic [0:0] res_rem_mux__reset;
  logic [0:0] res_rem_mux__sel;

  Mux__Type_Bits32__ninputs_2 res_rem_mux
  (
    .clk( res_rem_mux__clk ),
    .in_( res_rem_mux__in_ ),
    .out( res_rem_mux__out ),
    .reset( res_rem_mux__reset ),
    .sel( res_rem_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component res_rem_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component res_rem_negate_flag
  //-------------------------------------------------------------

  logic [0:0] res_rem_negate_flag__clk;
  logic [0:0] res_rem_negate_flag__en;
  logic [0:0] res_rem_negate_flag__in_;
  logic [0:0] res_rem_negate_flag__out;
  logic [0:0] res_rem_negate_flag__reset;

  RegEn__Type_Bits1 res_rem_negate_flag
  (
    .clk( res_rem_negate_flag__clk ),
    .en( res_rem_negate_flag__en ),
    .in_( res_rem_negate_flag__in_ ),
    .out( res_rem_negate_flag__out ),
    .reset( res_rem_negate_flag__reset )
  );

  //-------------------------------------------------------------
  // End of component res_rem_negate_flag
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component sub1
  //-------------------------------------------------------------

  logic [0:0] sub1__clk;
  logic [63:0] sub1__in0;
  logic [63:0] sub1__in1;
  logic [63:0] sub1__out;
  logic [0:0] sub1__reset;

  Subtractor__Type_Bits64 sub1
  (
    .clk( sub1__clk ),
    .in0( sub1__in0 ),
    .in1( sub1__in1 ),
    .out( sub1__out ),
    .reset( sub1__reset )
  );

  //-------------------------------------------------------------
  // End of component sub1
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component sub2
  //-------------------------------------------------------------

  logic [0:0] sub2__clk;
  logic [63:0] sub2__in0;
  logic [63:0] sub2__in1;
  logic [63:0] sub2__out;
  logic [0:0] sub2__reset;

  Subtractor__Type_Bits64 sub2
  (
    .clk( sub2__clk ),
    .in0( sub2__in0 ),
    .in1( sub2__in1 ),
    .out( sub2__out ),
    .reset( sub2__reset )
  );

  //-------------------------------------------------------------
  // End of component sub2
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py:189
  // @update
  // def comb_negate_if_needed():
  //   s.a_negate @= s.req_msg_a
  //   s.b_negate @= s.req_msg_b
  // 
  //   if s.is_signed & ( s.req_msg_b != 0 ):
  //     if s.req_msg_a[ nbits - 1 ]:
  //       s.a_negate @= ~s.req_msg_a + 1
  // 
  //     if s.req_msg_b[ nbits - 1 ]:
  //       s.b_negate @= ~s.req_msg_b + 1
  
  always_comb begin : comb_negate_if_needed
    a_negate = req_msg_a;
    b_negate = req_msg_b;
    if ( is_signed & ( req_msg_b != 32'd0 ) ) begin
      if ( req_msg_a[6'( __const__nbits_at_comb_negate_if_needed ) - 6'd1] ) begin
        a_negate = ( ~req_msg_a ) + 32'd1;
      end
      if ( req_msg_b[6'( __const__nbits_at_comb_negate_if_needed ) - 6'd1] ) begin
        b_negate = ( ~req_msg_b ) + 32'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py:274
  // @update
  // def comb_negate_rem_quo():
  //   s.rem_negate @= ~s.remainder_reg.out[ 0:nbits ] + 1
  //   s.quo_negate @= ~s.quotient_reg.out + 1
  
  always_comb begin : comb_negate_rem_quo
    rem_negate = ( ~remainder_reg__out[6'd31:6'd0] ) + 32'd1;
    quo_negate = ( ~quotient_reg__out ) + 32'd1;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py:237
  // @update
  // def comb_quotient_mux_in():
  //   s.quotient_mux.in_[ Q_MUX_SEL_0   ] @= 0
  //   s.quotient_mux.in_[ Q_MUX_SEL_LSH ] @= s.quotient_lsh.out + zext( concat( ~s.sub_negative1, ~s.sub_negative2 ), DataT )
  
  always_comb begin : comb_quotient_mux_in
    quotient_mux__in_[1'( __const__Q_MUX_SEL_0 )] = 32'd0;
    quotient_mux__in_[1'( __const__Q_MUX_SEL_LSH )] = quotient_lsh__out + { { 30 { 1'b0 } }, { ~sub_negative1, ~sub_negative2 } };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py:254
  // @update
  // def comb_res_negate_flags():
  //   s.res_rem_negate @= s.is_signed & ( s.req_msg_b != 0 ) & s.req_msg_a[nbits-1]
  //   s.res_quo_negate @= s.is_signed & ( s.req_msg_b != 0 ) & ( s.req_msg_a[nbits-1] ^ s.req_msg_b[nbits-1] )
  
  always_comb begin : comb_res_negate_flags
    res_rem_negate = ( is_signed & ( req_msg_b != 32'd0 ) ) & req_msg_a[6'( __const__nbits_at_comb_res_negate_flags ) - 6'd1];
    res_quo_negate = ( is_signed & ( req_msg_b != 32'd0 ) ) & ( req_msg_a[6'( __const__nbits_at_comb_res_negate_flags ) - 6'd1] ^ req_msg_b[6'( __const__nbits_at_comb_res_negate_flags ) - 6'd1] );
  end

  assign remainder_mux__clk = clk;
  assign remainder_mux__reset = reset;
  assign remainder_mux__sel = remainder_mux_sel;
  assign remainder_mux__in_[0][31:0] = a_negate;
  assign remainder_mux__in_[0][63:32] = 32'd0;
  assign remainder_reg__clk = clk;
  assign remainder_reg__reset = reset;
  assign remainder_reg__in_ = remainder_mux__out;
  assign remainder_reg__en = remainder_reg_en;
  assign divisor_mux__clk = clk;
  assign divisor_mux__reset = reset;
  assign divisor_mux__sel = divisor_mux_sel;
  assign divisor_mux__in_[0][30:0] = 31'd0;
  assign divisor_mux__in_[0][62:31] = b_negate;
  assign divisor_mux__in_[0][63:63] = 1'd0;
  assign divisor_reg__clk = clk;
  assign divisor_reg__reset = reset;
  assign divisor_reg__in_ = divisor_mux__out;
  assign quotient_mux__clk = clk;
  assign quotient_mux__reset = reset;
  assign quotient_mux__sel = quotient_mux_sel;
  assign quotient_reg__clk = clk;
  assign quotient_reg__reset = reset;
  assign quotient_reg__in_ = quotient_mux__out;
  assign quotient_reg__en = quotient_reg_en;
  assign quotient_lsh__clk = clk;
  assign quotient_lsh__reset = reset;
  assign quotient_lsh__in_ = quotient_reg__out;
  assign quotient_lsh__shamt = 32'd2;
  assign res_rem_negate_flag__clk = clk;
  assign res_rem_negate_flag__reset = reset;
  assign res_rem_negate_flag__en = buffers_en;
  assign res_rem_negate_flag__in_ = res_rem_negate;
  assign res_quo_negate_flag__clk = clk;
  assign res_quo_negate_flag__reset = reset;
  assign res_quo_negate_flag__en = buffers_en;
  assign res_quo_negate_flag__in_ = res_quo_negate;
  assign res_rem_mux__clk = clk;
  assign res_rem_mux__reset = reset;
  assign res_rem_mux__sel = res_rem_negate_flag__out;
  assign res_rem_mux__in_[0] = remainder_reg__out[31:0];
  assign res_rem_mux__in_[1] = rem_negate;
  assign res_quo_mux__clk = clk;
  assign res_quo_mux__reset = reset;
  assign res_quo_mux__sel = res_quo_negate_flag__out;
  assign res_quo_mux__in_[0] = quotient_reg__out;
  assign res_quo_mux__in_[1] = quo_negate;
  assign is_div_reg__clk = clk;
  assign is_div_reg__reset = reset;
  assign is_div_reg__en = buffers_en;
  assign is_div_reg__in_ = is_div;
  assign opaque_reg__clk = clk;
  assign opaque_reg__reset = reset;
  assign opaque_reg__en = buffers_en;
  assign opaque_reg__in_ = req_msg_opaque;
  assign resp_opaque = opaque_reg__out;
  assign res_divrem_mux__clk = clk;
  assign res_divrem_mux__reset = reset;
  assign res_divrem_mux__sel = is_div_reg__out;
  assign res_divrem_mux__in_[0] = res_rem_mux__out;
  assign res_divrem_mux__in_[1] = res_quo_mux__out;
  assign resp_result = res_divrem_mux__out;
  assign sub1__clk = clk;
  assign sub1__reset = reset;
  assign sub1__in0 = remainder_reg__out;
  assign sub1__in1 = divisor_reg__out;
  assign remainder_mux__in_[1] = sub1__out;
  assign sub_negative1 = sub1__out[63:63];
  assign remainder_mid_mux__clk = clk;
  assign remainder_mid_mux__reset = reset;
  assign remainder_mid_mux__sel = sub_negative1;
  assign remainder_mid_mux__in_[0] = sub1__out;
  assign remainder_mid_mux__in_[1] = remainder_reg__out;
  assign divisor_rsh1__clk = clk;
  assign divisor_rsh1__reset = reset;
  assign divisor_rsh1__in_ = divisor_reg__out;
  assign divisor_rsh1__shamt = 64'd1;
  assign sub2__clk = clk;
  assign sub2__reset = reset;
  assign sub2__in0 = remainder_mid_mux__out;
  assign sub2__in1 = divisor_rsh1__out;
  assign remainder_mux__in_[2] = sub2__out;
  assign sub_negative2 = sub2__out[63:63];
  assign divisor_rsh2__clk = clk;
  assign divisor_rsh2__reset = reset;
  assign divisor_rsh2__in_ = divisor_rsh1__out;
  assign divisor_mux__in_[1] = divisor_rsh2__out;
  assign divisor_rsh2__shamt = 64'd1;

endmodule


// PyMTL Component IntDivRem4 Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntDivRem4.py

module IntDivRem4__opq_nbits_8__data_nbits_32
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output MduRespMsg_8_32__opaque_8__res_32 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__buffers_en;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__divisor_mux_sel;
  logic [0:0] ctrl__is_div;
  logic [0:0] ctrl__is_signed;
  logic [0:0] ctrl__quotient_mux_sel;
  logic [0:0] ctrl__quotient_reg_en;
  logic [1:0] ctrl__remainder_mux_sel;
  logic [0:0] ctrl__remainder_reg_en;
  logic [0:0] ctrl__req_en;
  logic [0:0] ctrl__req_rdy;
  logic [2:0] ctrl__req_type;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__resp_en;
  logic [0:0] ctrl__resp_rdy;
  logic [0:0] ctrl__sub_negative1;
  logic [0:0] ctrl__sub_negative2;

  IntDivRem4Ctrl__a04e5aace91dda76 ctrl
  (
    .buffers_en( ctrl__buffers_en ),
    .clk( ctrl__clk ),
    .divisor_mux_sel( ctrl__divisor_mux_sel ),
    .is_div( ctrl__is_div ),
    .is_signed( ctrl__is_signed ),
    .quotient_mux_sel( ctrl__quotient_mux_sel ),
    .quotient_reg_en( ctrl__quotient_reg_en ),
    .remainder_mux_sel( ctrl__remainder_mux_sel ),
    .remainder_reg_en( ctrl__remainder_reg_en ),
    .req_en( ctrl__req_en ),
    .req_rdy( ctrl__req_rdy ),
    .req_type( ctrl__req_type ),
    .reset( ctrl__reset ),
    .resp_en( ctrl__resp_en ),
    .resp_rdy( ctrl__resp_rdy ),
    .sub_negative1( ctrl__sub_negative1 ),
    .sub_negative2( ctrl__sub_negative2 )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__buffers_en;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__divisor_mux_sel;
  logic [0:0] dpath__is_div;
  logic [0:0] dpath__is_signed;
  logic [0:0] dpath__quotient_mux_sel;
  logic [0:0] dpath__quotient_reg_en;
  logic [1:0] dpath__remainder_mux_sel;
  logic [0:0] dpath__remainder_reg_en;
  logic [31:0] dpath__req_msg_a;
  logic [31:0] dpath__req_msg_b;
  logic [7:0] dpath__req_msg_opaque;
  logic [0:0] dpath__reset;
  logic [7:0] dpath__resp_opaque;
  logic [31:0] dpath__resp_result;
  logic [0:0] dpath__sub_negative1;
  logic [0:0] dpath__sub_negative2;

  IntDivRem4Dpath__a04e5aace91dda76 dpath
  (
    .buffers_en( dpath__buffers_en ),
    .clk( dpath__clk ),
    .divisor_mux_sel( dpath__divisor_mux_sel ),
    .is_div( dpath__is_div ),
    .is_signed( dpath__is_signed ),
    .quotient_mux_sel( dpath__quotient_mux_sel ),
    .quotient_reg_en( dpath__quotient_reg_en ),
    .remainder_mux_sel( dpath__remainder_mux_sel ),
    .remainder_reg_en( dpath__remainder_reg_en ),
    .req_msg_a( dpath__req_msg_a ),
    .req_msg_b( dpath__req_msg_b ),
    .req_msg_opaque( dpath__req_msg_opaque ),
    .reset( dpath__reset ),
    .resp_opaque( dpath__resp_opaque ),
    .resp_result( dpath__resp_result ),
    .sub_negative1( dpath__sub_negative1 ),
    .sub_negative2( dpath__sub_negative2 )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__req_msg_a = req__msg.op_a;
  assign dpath__req_msg_b = req__msg.op_b;
  assign dpath__req_msg_opaque = req__msg.opaque;
  assign ctrl__req_type = req__msg.type_;
  assign ctrl__req_en = req__en;
  assign req__rdy = ctrl__req_rdy;
  assign resp__msg.res = dpath__resp_result;
  assign resp__msg.opaque = dpath__resp_opaque;
  assign resp__en = ctrl__resp_en;
  assign ctrl__resp_rdy = resp__rdy;
  assign ctrl__sub_negative1 = dpath__sub_negative1;
  assign ctrl__sub_negative2 = dpath__sub_negative2;
  assign dpath__quotient_mux_sel = ctrl__quotient_mux_sel;
  assign dpath__quotient_reg_en = ctrl__quotient_reg_en;
  assign dpath__remainder_mux_sel = ctrl__remainder_mux_sel;
  assign dpath__remainder_reg_en = ctrl__remainder_reg_en;
  assign dpath__divisor_mux_sel = ctrl__divisor_mux_sel;
  assign dpath__is_div = ctrl__is_div;
  assign dpath__buffers_en = ctrl__buffers_en;
  assign dpath__is_signed = ctrl__is_signed;

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_MduRespMsg_8_32__opaque_8__res_32__ninputs_2
(
  input  logic [0:0] clk ,
  input  MduRespMsg_8_32__opaque_8__res_32 in_ [0:1],
  output MduRespMsg_8_32__opaque_8__res_32 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component BypassQueue1EntryRTL Definition
// Full name: BypassQueue1EntryRTL__EntryType_MduRespMsg_8_32__opaque_8__res_32
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module BypassQueue1EntryRTL__0dcef6d9ec748696
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MduRespMsg_8_32__opaque_8__res_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MduRespMsg_8_32__opaque_8__res_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  MduRespMsg_8_32__opaque_8__res_32 entry;
  logic [0:0] full;
  //-------------------------------------------------------------
  // Component bypass_mux
  //-------------------------------------------------------------

  logic [0:0] bypass_mux__clk;
  MduRespMsg_8_32__opaque_8__res_32 bypass_mux__in_ [0:1];
  MduRespMsg_8_32__opaque_8__res_32 bypass_mux__out;
  logic [0:0] bypass_mux__reset;
  logic [0:0] bypass_mux__sel;

  Mux__Type_MduRespMsg_8_32__opaque_8__res_32__ninputs_2 bypass_mux
  (
    .clk( bypass_mux__clk ),
    .in_( bypass_mux__in_ ),
    .out( bypass_mux__out ),
    .reset( bypass_mux__reset ),
    .sel( bypass_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component bypass_mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:532
  // s.deq.rdy //= lambda: ~s.reset & ( s.full | s.enq.en )
  
  always_comb begin : _lambda__s_mdus_0__div_resp_q_q_deq_rdy
    deq__rdy = ( ~reset ) & ( full | enq__en );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:531
  // s.enq.rdy //= lambda: ~s.reset & ~s.full
  
  always_comb begin : _lambda__s_mdus_0__div_resp_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ~full );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:534
  // @update_ff
  // def ff_bypass1():
  //   s.full <<= ~s.reset & ( ~s.deq.en & (s.enq.en | s.full) )
  // 
  //   if s.enq.en & ~s.deq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_bypass1
    full <= ( ~reset ) & ( ( ~deq__en ) & ( enq__en | full ) );
    if ( enq__en & ( ~deq__en ) ) begin
      entry <= enq__msg;
    end
  end

  assign bypass_mux__clk = clk;
  assign bypass_mux__reset = reset;
  assign bypass_mux__in_[0] = enq__msg;
  assign bypass_mux__in_[1] = entry;
  assign deq__ret = bypass_mux__out;
  assign bypass_mux__sel = full;
  assign count = full;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_MduRespMsg_8_32__opaque_8__res_32__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module BypassQueueRTL__8ad97cf91a193d28
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MduRespMsg_8_32__opaque_8__res_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MduRespMsg_8_32__opaque_8__res_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  MduRespMsg_8_32__opaque_8__res_32 q__deq__ret;
  logic [0:0] q__enq__en;
  MduRespMsg_8_32__opaque_8__res_32 q__enq__msg;
  logic [0:0] q__enq__rdy;

  BypassQueue1EntryRTL__0dcef6d9ec748696 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// Full name: PipeQueue1EntryRTL__EntryType_MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__085dd9bb56afbe07
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_mdus_0__mul_recv_q_q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_mdus_0__mul_recv_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// Full name: PipeQueueRTL__EntryType_MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__71368e97a9270167
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 q__deq__ret;
  logic [0:0] q__enq__en;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__085dd9bb56afbe07 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__EntryType_MduRespMsg_8_32__opaque_8__res_32
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MduRespMsg_8_32__opaque_8__res_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MduRespMsg_8_32__opaque_8__res_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  MduRespMsg_8_32__opaque_8__res_32 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_mdus_0__mul_result_q_0__q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_mdus_0__mul_result_q_0__q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// Full name: PipeQueueRTL__EntryType_MduRespMsg_8_32__opaque_8__res_32__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__8ad97cf91a193d28
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MduRespMsg_8_32__opaque_8__res_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MduRespMsg_8_32__opaque_8__res_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  MduRespMsg_8_32__opaque_8__res_32 q__deq__ret;
  logic [0:0] q__enq__en;
  MduRespMsg_8_32__opaque_8__res_32 q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__EntryType_MduRespMsg_8_32__opaque_8__res_32 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component IntMulPipelined Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulPipelined.py

module IntMulPipelined__data_nbits_32__opq_nbits_8__nstages_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output MduRespMsg_8_32__opaque_8__res_32 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  localparam logic [2:0] __const__nstages_at_up_morestages  = 3'd4;
  localparam logic [5:0] __const__data_nbits_at_comb_a_mulh_negate  = 6'd32;
  localparam logic [6:0] __const__data_nbitsx2_at_comb_a_mulh_negate  = 7'd64;
  localparam logic [5:0] __const__data_nbits_at_comb_multiply  = 6'd32;
  localparam logic [5:0] __const__data_nbits_at_comb_select_hilo  = 6'd32;
  localparam logic [6:0] __const__data_nbitsx2_at_comb_select_hilo  = 7'd64;
  logic [63:0] a_mulh_negate;
  logic [63:0] ext_opa;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 in_msg;
  logic [95:0] mul_result;
  logic [31:0] resp_result;
  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__count;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  PipeQueueRTL__71368e97a9270167 recv_q
  (
    .clk( recv_q__clk ),
    .count( recv_q__count ),
    .reset( recv_q__reset ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component result_q[0:2]
  //-------------------------------------------------------------

  logic [0:0] result_q__clk [0:2];
  logic [0:0] result_q__count [0:2];
  logic [0:0] result_q__reset [0:2];
  logic [0:0] result_q__deq__en [0:2];
  logic [0:0] result_q__deq__rdy [0:2];
  MduRespMsg_8_32__opaque_8__res_32 result_q__deq__ret [0:2];
  logic [0:0] result_q__enq__en [0:2];
  MduRespMsg_8_32__opaque_8__res_32 result_q__enq__msg [0:2];
  logic [0:0] result_q__enq__rdy [0:2];

  PipeQueueRTL__8ad97cf91a193d28 result_q__0
  (
    .clk( result_q__clk[0] ),
    .count( result_q__count[0] ),
    .reset( result_q__reset[0] ),
    .deq__en( result_q__deq__en[0] ),
    .deq__rdy( result_q__deq__rdy[0] ),
    .deq__ret( result_q__deq__ret[0] ),
    .enq__en( result_q__enq__en[0] ),
    .enq__msg( result_q__enq__msg[0] ),
    .enq__rdy( result_q__enq__rdy[0] )
  );

  PipeQueueRTL__8ad97cf91a193d28 result_q__1
  (
    .clk( result_q__clk[1] ),
    .count( result_q__count[1] ),
    .reset( result_q__reset[1] ),
    .deq__en( result_q__deq__en[1] ),
    .deq__rdy( result_q__deq__rdy[1] ),
    .deq__ret( result_q__deq__ret[1] ),
    .enq__en( result_q__enq__en[1] ),
    .enq__msg( result_q__enq__msg[1] ),
    .enq__rdy( result_q__enq__rdy[1] )
  );

  PipeQueueRTL__8ad97cf91a193d28 result_q__2
  (
    .clk( result_q__clk[2] ),
    .count( result_q__count[2] ),
    .reset( result_q__reset[2] ),
    .deq__en( result_q__deq__en[2] ),
    .deq__rdy( result_q__deq__rdy[2] ),
    .deq__ret( result_q__deq__ret[2] ),
    .enq__en( result_q__enq__en[2] ),
    .enq__msg( result_q__enq__msg[2] ),
    .enq__rdy( result_q__enq__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component result_q[0:2]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulPipelined.py:128
  // @update
  // def comb_a_mulh_negate():
  //   s.a_mulh_negate[ 0 :          data_nbits   ] @= 0
  //   s.a_mulh_negate[ data_nbits : data_nbitsx2 ] @= ~s.in_msg.op_a + 1
  
  always_comb begin : comb_a_mulh_negate
    a_mulh_negate[6'd31:6'd0] = 32'd0;
    a_mulh_negate[6'd63:6'( __const__data_nbits_at_comb_a_mulh_negate )] = ( ~in_msg.op_a ) + 32'd1;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulPipelined.py:133
  // @update
  // def comb_multiply():
  //   if  ( s.in_msg.type_ == MduMsgType.TYPE_MULH ) & \
  //       s.in_msg.op_b[ data_nbits-1 ]:
  //     s.mul_result @= zext( s.ext_opa, data_nbitsx3 ) * zext( s.in_msg.op_b, data_nbitsx3 ) + zext( s.a_mulh_negate, data_nbitsx3 )
  //   else:
  //     s.mul_result @= zext( s.ext_opa, data_nbitsx3 ) * zext( s.in_msg.op_b, data_nbitsx3 )
  
  always_comb begin : comb_multiply
    if ( ( in_msg.type_ == 3'd1 ) & in_msg.op_b[6'( __const__data_nbits_at_comb_multiply ) - 6'd1] ) begin
      mul_result = ( { { 32 { 1'b0 } }, ext_opa } * { { 64 { 1'b0 } }, in_msg.op_b } ) + { { 32 { 1'b0 } }, a_mulh_negate };
    end
    else
      mul_result = { { 32 { 1'b0 } }, ext_opa } * { { 64 { 1'b0 } }, in_msg.op_b };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulPipelined.py:113
  // @update
  // def comb_opa():
  //   if ( s.in_msg.type_ == MduMsgType.TYPE_MULHSU ) | \
  //      ( s.in_msg.type_ == MduMsgType.TYPE_MULH   ):
  //     s.ext_opa @= sext( s.in_msg.op_a, data_nbitsx2 )
  //   else:
  //     s.ext_opa @= zext( s.in_msg.op_a, data_nbitsx2 )
  
  always_comb begin : comb_opa
    if ( ( in_msg.type_ == 3'd2 ) | ( in_msg.type_ == 3'd1 ) ) begin
      ext_opa = { { 32 { in_msg.op_a[31] } }, in_msg.op_a };
    end
    else
      ext_opa = { { 32 { 1'b0 } }, in_msg.op_a };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulPipelined.py:141
  // @update
  // def comb_select_hilo():
  //   if s.in_msg.type_ == MduMsgType.TYPE_MUL:
  //     s.resp_result @= s.mul_result[ 0 : data_nbits ]
  //   else:
  //     s.resp_result @= s.mul_result[ data_nbits : data_nbitsx2 ]
  
  always_comb begin : comb_select_hilo
    if ( in_msg.type_ == 3'd0 ) begin
      resp_result = mul_result[7'd31:7'd0];
    end
    else
      resp_result = mul_result[7'd63:7'( __const__data_nbits_at_comb_select_hilo )];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulPipelined.py:91
  // @update
  // def up_morestages():
  //   # recv_q <-> result_q[ 0 ]
  //   s.recv_q.deq.en                 @= s.recv_q.deq.rdy & s.result_q[ 0 ].enq.rdy
  //   s.result_q[ 0 ].enq.en          @= s.recv_q.deq.rdy & s.result_q[ 0 ].enq.rdy
  //   s.result_q[ 0 ].enq.msg.opaque  @= s.recv_q.deq.ret.opaque
  //   s.result_q[ 0 ].enq.msg.res     @= s.resp_result
  // 
  //   # chain middle result_q
  //   for i in range( nstages-2 ):
  //     s.result_q[ i   ].deq.en  @= s.result_q[ i ].deq.rdy & s.result_q[ i+1 ].enq.rdy
  //     s.result_q[ i+1 ].enq.en  @= s.result_q[ i ].deq.rdy & s.result_q[ i+1 ].enq.rdy
  //     s.result_q[ i+1 ].enq.msg @= s.result_q[ i ].deq.ret
  // 
  //   # result_q[ nstages-2 ] <-> s.resp
  //   s.result_q[ nstages-2 ].deq.en @= s.resp.rdy & s.result_q[ nstages-2 ].deq.rdy
  //   s.resp.en                      @= s.resp.rdy & s.result_q[ nstages-2 ].deq.rdy
  //   s.resp.msg                     @= s.result_q[ nstages-2 ].deq.ret
  
  always_comb begin : up_morestages
    recv_q__deq__en = recv_q__deq__rdy & result_q__enq__rdy[2'd0];
    result_q__enq__en[2'd0] = recv_q__deq__rdy & result_q__enq__rdy[2'd0];
    result_q__enq__msg[2'd0].opaque = recv_q__deq__ret.opaque;
    result_q__enq__msg[2'd0].res = resp_result;
    for ( int unsigned i = 1'd0; i < 3'( __const__nstages_at_up_morestages ) - 3'd2; i += 1'd1 ) begin
      result_q__deq__en[2'(i)] = result_q__deq__rdy[2'(i)] & result_q__enq__rdy[2'(i) + 2'd1];
      result_q__enq__en[2'(i) + 2'd1] = result_q__deq__rdy[2'(i)] & result_q__enq__rdy[2'(i) + 2'd1];
      result_q__enq__msg[2'(i) + 2'd1] = result_q__deq__ret[2'(i)];
    end
    result_q__deq__en[3'( __const__nstages_at_up_morestages ) - 3'd2] = resp__rdy & result_q__deq__rdy[3'( __const__nstages_at_up_morestages ) - 3'd2];
    resp__en = resp__rdy & result_q__deq__rdy[3'( __const__nstages_at_up_morestages ) - 3'd2];
    resp__msg = result_q__deq__ret[3'( __const__nstages_at_up_morestages ) - 3'd2];
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = req__en;
  assign recv_q__enq__msg = req__msg;
  assign req__rdy = recv_q__enq__rdy;
  assign in_msg = recv_q__deq__ret;
  assign result_q__clk[0] = clk;
  assign result_q__reset[0] = reset;
  assign result_q__clk[1] = clk;
  assign result_q__reset[1] = reset;
  assign result_q__clk[2] = clk;
  assign result_q__reset[2] = reset;

endmodule


// PyMTL Component IntMulDivUnit Definition
// Full name: IntMulDivUnit__MduReq_MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32__MduResp_MduRespMsg_8_32__opaque_8__res_32
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulDivUnit.py

module IntMulDivUnit__c5b256859b3294d6
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] req__en  ,
  input MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 req__msg  ,
  output logic [0:0] req__rdy  ,
  output logic [0:0] resp__en  ,
  output MduRespMsg_8_32__opaque_8__res_32 resp__msg  ,
  input logic [0:0] resp__rdy  
);
  //-------------------------------------------------------------
  // Component div
  //-------------------------------------------------------------

  logic [0:0] div__clk;
  logic [0:0] div__reset;
  logic [0:0] div__req__en;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 div__req__msg;
  logic [0:0] div__req__rdy;
  logic [0:0] div__resp__en;
  MduRespMsg_8_32__opaque_8__res_32 div__resp__msg;
  logic [0:0] div__resp__rdy;

  IntDivRem4__opq_nbits_8__data_nbits_32 div
  (
    .clk( div__clk ),
    .reset( div__reset ),
    .req__en( div__req__en ),
    .req__msg( div__req__msg ),
    .req__rdy( div__req__rdy ),
    .resp__en( div__resp__en ),
    .resp__msg( div__resp__msg ),
    .resp__rdy( div__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component div
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component div_resp_q
  //-------------------------------------------------------------

  logic [0:0] div_resp_q__clk;
  logic [0:0] div_resp_q__count;
  logic [0:0] div_resp_q__reset;
  logic [0:0] div_resp_q__deq__en;
  logic [0:0] div_resp_q__deq__rdy;
  MduRespMsg_8_32__opaque_8__res_32 div_resp_q__deq__ret;
  logic [0:0] div_resp_q__enq__en;
  MduRespMsg_8_32__opaque_8__res_32 div_resp_q__enq__msg;
  logic [0:0] div_resp_q__enq__rdy;

  BypassQueueRTL__8ad97cf91a193d28 div_resp_q
  (
    .clk( div_resp_q__clk ),
    .count( div_resp_q__count ),
    .reset( div_resp_q__reset ),
    .deq__en( div_resp_q__deq__en ),
    .deq__rdy( div_resp_q__deq__rdy ),
    .deq__ret( div_resp_q__deq__ret ),
    .enq__en( div_resp_q__enq__en ),
    .enq__msg( div_resp_q__enq__msg ),
    .enq__rdy( div_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component div_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mul
  //-------------------------------------------------------------

  logic [0:0] mul__clk;
  logic [0:0] mul__reset;
  logic [0:0] mul__req__en;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 mul__req__msg;
  logic [0:0] mul__req__rdy;
  logic [0:0] mul__resp__en;
  MduRespMsg_8_32__opaque_8__res_32 mul__resp__msg;
  logic [0:0] mul__resp__rdy;

  IntMulPipelined__data_nbits_32__opq_nbits_8__nstages_4 mul
  (
    .clk( mul__clk ),
    .reset( mul__reset ),
    .req__en( mul__req__en ),
    .req__msg( mul__req__msg ),
    .req__rdy( mul__req__rdy ),
    .resp__en( mul__resp__en ),
    .resp__msg( mul__resp__msg ),
    .resp__rdy( mul__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component mul
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mul_resp_q
  //-------------------------------------------------------------

  logic [0:0] mul_resp_q__clk;
  logic [0:0] mul_resp_q__count;
  logic [0:0] mul_resp_q__reset;
  logic [0:0] mul_resp_q__deq__en;
  logic [0:0] mul_resp_q__deq__rdy;
  MduRespMsg_8_32__opaque_8__res_32 mul_resp_q__deq__ret;
  logic [0:0] mul_resp_q__enq__en;
  MduRespMsg_8_32__opaque_8__res_32 mul_resp_q__enq__msg;
  logic [0:0] mul_resp_q__enq__rdy;

  BypassQueueRTL__8ad97cf91a193d28 mul_resp_q
  (
    .clk( mul_resp_q__clk ),
    .count( mul_resp_q__count ),
    .reset( mul_resp_q__reset ),
    .deq__en( mul_resp_q__deq__en ),
    .deq__rdy( mul_resp_q__deq__rdy ),
    .deq__ret( mul_resp_q__deq__ret ),
    .enq__en( mul_resp_q__enq__en ),
    .enq__msg( mul_resp_q__enq__msg ),
    .enq__rdy( mul_resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component mul_resp_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__count;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  PipeQueueRTL__71368e97a9270167 recv_q
  (
    .clk( recv_q__clk ),
    .count( recv_q__count ),
    .reset( recv_q__reset ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulDivUnit.py:59
  // @update
  // def up_req():
  // 
  //   # default
  //   s.recv_q.deq.en @= 0
  //   s.mul.req.en    @= 0
  //   s.div.req.en    @= 0
  // 
  //   if s.recv_q.deq.rdy:
  // 
  //     # multiply request
  //     if ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_MUL    ) | \
  //        ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_MULH   ) | \
  //        ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_MULHSU ) | \
  //        ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_MULHU  ):
  // 
  //       s.mul.req.en    @= s.mul.req.rdy
  //       s.recv_q.deq.en @= s.mul.req.rdy
  // 
  //     # divide request
  //     elif ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_DIV  ) | \
  //          ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_DIVU ) | \
  //          ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_REM  ) | \
  //          ( s.recv_q.deq.ret.type_ == MduMsgType.TYPE_REMU ):
  // 
  //       s.div.req.en    @= s.div.req.rdy
  //       s.recv_q.deq.en @= s.div.req.rdy
  
  always_comb begin : up_req
    recv_q__deq__en = 1'd0;
    mul__req__en = 1'd0;
    div__req__en = 1'd0;
    if ( recv_q__deq__rdy ) begin
      if ( ( ( ( recv_q__deq__ret.type_ == 3'd0 ) | ( recv_q__deq__ret.type_ == 3'd1 ) ) | ( recv_q__deq__ret.type_ == 3'd2 ) ) | ( recv_q__deq__ret.type_ == 3'd3 ) ) begin
        mul__req__en = mul__req__rdy;
        recv_q__deq__en = mul__req__rdy;
      end
      else if ( ( ( ( recv_q__deq__ret.type_ == 3'd4 ) | ( recv_q__deq__ret.type_ == 3'd5 ) ) | ( recv_q__deq__ret.type_ == 3'd6 ) ) | ( recv_q__deq__ret.type_ == 3'd7 ) ) begin
        div__req__en = div__req__rdy;
        recv_q__deq__en = div__req__rdy;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/mdu/IntMulDivUnit.py:94
  // @update
  // def up_resp():
  // 
  //   # default
  //   s.resp.en           @= 0
  //   s.resp.msg          @= MduResp()
  //   s.mul_resp_q.deq.en @= 0
  //   s.div_resp_q.deq.en @= 0
  // 
  //   if s.resp.rdy:
  //     if    s.mul_resp_q.deq.rdy:
  //       s.resp.en           @= 1
  //       s.resp.msg          @= s.mul_resp_q.deq.ret
  //       s.mul_resp_q.deq.en @= 1
  //     elif  s.div_resp_q.deq.rdy:
  //       s.resp.en           @= 1
  //       s.resp.msg          @= s.div_resp_q.deq.ret
  //       s.div_resp_q.deq.en @= 1
  
  always_comb begin : up_resp
    resp__en = 1'd0;
    resp__msg = { 8'd0, 32'd0 };
    mul_resp_q__deq__en = 1'd0;
    div_resp_q__deq__en = 1'd0;
    if ( resp__rdy ) begin
      if ( mul_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = mul_resp_q__deq__ret;
        mul_resp_q__deq__en = 1'd1;
      end
      else if ( div_resp_q__deq__rdy ) begin
        resp__en = 1'd1;
        resp__msg = div_resp_q__deq__ret;
        div_resp_q__deq__en = 1'd1;
      end
    end
  end

  assign mul__clk = clk;
  assign mul__reset = reset;
  assign div__clk = clk;
  assign div__reset = reset;
  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = req__en;
  assign recv_q__enq__msg = req__msg;
  assign req__rdy = recv_q__enq__rdy;
  assign mul_resp_q__clk = clk;
  assign mul_resp_q__reset = reset;
  assign div_resp_q__clk = clk;
  assign div_resp_q__reset = reset;
  assign mul__req__msg = recv_q__deq__ret;
  assign div__req__msg = recv_q__deq__ret;
  assign mul_resp_q__enq__en = mul__resp__en;
  assign mul_resp_q__enq__msg = mul__resp__msg;
  assign mul__resp__rdy = mul_resp_q__enq__rdy;
  assign div_resp_q__enq__en = div__resp__en;
  assign div_resp_q__enq__msg = div__resp__msg;
  assign div__resp__rdy = div_resp_q__enq__rdy;

endmodule


// PyMTL Component MemReq2NetAdapter8B Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py

module MemReq2NetAdapter8B__src_id_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [191:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [3:0] __const__READ  = 4'd0;
  localparam logic [3:0] __const__WRITE  = 4'd1;
  NetHeader8B__7a1608e9e4d537dd header;
  logic [63:0] header_bits;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py:61
  // @update
  // def up_plen():
  //   if s.recv.msg.type_ == READ:
  //     s.header.plen @= 0
  //   elif s.recv.msg.type_ == WRITE:
  //     s.header.plen @= 2
  //   else:
  //     s.header.plen @= 2  # AMO etc. have data field
  
  always_comb begin : up_plen
    if ( recv__msg.type_ == 4'( __const__READ ) ) begin
      header.plen = 4'd0;
    end
    else if ( recv__msg.type_ == 4'( __const__WRITE ) ) begin
      header.plen = 4'd2;
    end
    else
      header.plen = 4'd2;
  end

  assign header_bits[1:0] = header.test;
  assign header_bits[5:2] = header.len;
  assign header_bits[9:6] = header.type_;
  assign header_bits[17:10] = header.opaque;
  assign header_bits[21:18] = header.plen;
  assign header_bits[25:22] = header.dst;
  assign header_bits[29:26] = header.wr_mask;
  assign header_bits[31:30] = header.debug;
  assign header_bits[63:32] = header.addr;
  assign send__msg[63:0] = header_bits;
  assign send__msg[191:64] = recv__msg.data;
  assign header.addr = recv__msg.addr;
  assign header.debug = 2'd0;
  assign header.wr_mask = recv__msg.wr_mask;
  assign header.dst = 4'd0;
  assign header.opaque = 8'd0;
  assign header.type_ = recv__msg.type_;
  assign header.len = recv__msg.len;
  assign header.test = 2'd0;
  assign recv__rdy = send__rdy;
  assign send__en = recv__en;

endmodule


// PyMTL Component MemReq2NetAdapter8B Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py

module MemReq2NetAdapter8B__src_id_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [191:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [3:0] __const__READ  = 4'd0;
  localparam logic [3:0] __const__WRITE  = 4'd1;
  NetHeader8B__7a1608e9e4d537dd header;
  logic [63:0] header_bits;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py:61
  // @update
  // def up_plen():
  //   if s.recv.msg.type_ == READ:
  //     s.header.plen @= 0
  //   elif s.recv.msg.type_ == WRITE:
  //     s.header.plen @= 2
  //   else:
  //     s.header.plen @= 2  # AMO etc. have data field
  
  always_comb begin : up_plen
    if ( recv__msg.type_ == 4'( __const__READ ) ) begin
      header.plen = 4'd0;
    end
    else if ( recv__msg.type_ == 4'( __const__WRITE ) ) begin
      header.plen = 4'd2;
    end
    else
      header.plen = 4'd2;
  end

  assign header_bits[1:0] = header.test;
  assign header_bits[5:2] = header.len;
  assign header_bits[9:6] = header.type_;
  assign header_bits[17:10] = header.opaque;
  assign header_bits[21:18] = header.plen;
  assign header_bits[25:22] = header.dst;
  assign header_bits[29:26] = header.wr_mask;
  assign header_bits[31:30] = header.debug;
  assign header_bits[63:32] = header.addr;
  assign send__msg[63:0] = header_bits;
  assign send__msg[191:64] = recv__msg.data;
  assign header.addr = recv__msg.addr;
  assign header.debug = 2'd0;
  assign header.wr_mask = recv__msg.wr_mask;
  assign header.dst = 4'd0;
  assign header.opaque = 8'd1;
  assign header.type_ = recv__msg.type_;
  assign header.len = recv__msg.len;
  assign header.test = 2'd0;
  assign recv__rdy = send__rdy;
  assign send__en = recv__en;

endmodule


// PyMTL Component Counter Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/Counter.py

module Counter__Type_Bits2__reset_value_0
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] decr ,
  input  logic [0:0] incr ,
  input  logic [0:0] load ,
  input  logic [1:0] load_value ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_count  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/Counter.py:28
  // @update_ff
  // def up_count():
  // 
  //   if s.reset:
  //     s.count <<= reset_value
  // 
  //   elif s.load:
  //     s.count <<= s.load_value
  // 
  //   elif s.incr & ~s.decr:
  //     s.count <<= s.count + 1
  // 
  //   elif ~s.incr & s.decr:
  //     s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_count
    if ( reset ) begin
      count <= 2'( __const__reset_value_at_up_count );
    end
    else if ( load ) begin
      count <= load_value;
    end
    else if ( incr & ( ~decr ) ) begin
      count <= count + 2'd1;
    end
    else if ( ( ~incr ) & decr ) begin
      count <= count - 2'd1;
    end
  end

endmodule


// PyMTL Component DeserializerRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py

module DeserializerRTL__in_nbits_64__max_nblocks_3
(
  input  logic [0:0] clk ,
  input  logic [1:0] len ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input logic [63:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [191:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [1:0] __const__max_nblocks_at_up_out_r  = 2'd3;
  logic [1:0] idx;
  logic [1:0] len_r;
  logic [63:0] out_r [0:2];
  logic [0:0] state;
  logic [0:0] state_next;
  //-------------------------------------------------------------
  // Component counter
  //-------------------------------------------------------------

  logic [0:0] counter__clk;
  logic [1:0] counter__count;
  logic [0:0] counter__decr;
  logic [0:0] counter__incr;
  logic [0:0] counter__load;
  logic [1:0] counter__load_value;
  logic [0:0] counter__reset;

  Counter__Type_Bits2__reset_value_0 counter
  (
    .clk( counter__clk ),
    .count( counter__count ),
    .decr( counter__decr ),
    .incr( counter__incr ),
    .load( counter__load ),
    .load_value( counter__load_value ),
    .reset( counter__reset )
  );

  //-------------------------------------------------------------
  // End of component counter
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py:90
  // s.send.en //= lambda: ( s.state == s.STATE_RECV ) & ( s.idx ==  s.len_r ) & s.send.rdy
  
  always_comb begin : _lambda__s_mem_net_des_0__send_en
    send__en = ( ( state == 1'd1 ) & ( idx == len_r ) ) & send__rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py:92
  // @update
  // def up_recv_rdy():
  //   if s.state == s.STATE_IDLE:
  //     s.recv.rdy @= 1
  // 
  //   else: # STATE_RECV
  //     if s.idx < s.len_r:
  //       s.recv.rdy @= 1
  //     elif s.send.en:
  //       s.recv.rdy @= 1
  // 
  //     else:
  //       s.recv.rdy @= 0
  
  always_comb begin : up_recv_rdy
    if ( state == 1'd0 ) begin
      recv__rdy = 1'd1;
    end
    else if ( idx < len_r ) begin
      recv__rdy = 1'd1;
    end
    else if ( send__en ) begin
      recv__rdy = 1'd1;
    end
    else
      recv__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py:115
  // @update
  // def up_state_next():
  //   if s.state == s.STATE_IDLE:
  //     if ( s.len > 0 ) & s.recv.en:
  //       s.state_next         @= s.STATE_RECV
  //       s.counter.load       @= 1
  //       s.counter.load_value @= 1
  // 
  //     else:
  //       s.state_next         @= s.STATE_IDLE
  //       s.counter.load       @= 0
  //       s.counter.load_value @= CountType(0)
  // 
  //   else: # STATE_RECV
  //     if ( s.idx == s.len_r ) & s.send.en:
  //       if s.recv.en:
  //         s.state_next         @= s.STATE_RECV
  //         s.counter.load       @= 1
  //         s.counter.load_value @= 1
  //       else:
  //         s.state_next         @= s.STATE_IDLE
  //         s.counter.load       @= 1
  //         s.counter.load_value @= 0
  // 
  //     else:
  //       s.state_next         @= s.STATE_RECV
  //       s.counter.load       @= 0
  //       s.counter.load_value @= 0
  
  always_comb begin : up_state_next
    if ( state == 1'd0 ) begin
      if ( ( len > 2'd0 ) & recv__en ) begin
        state_next = 1'd1;
        counter__load = 1'd1;
        counter__load_value = 2'd1;
      end
      else begin
        state_next = 1'd0;
        counter__load = 1'd0;
        counter__load_value = 2'd0;
      end
    end
    else if ( ( idx == len_r ) & send__en ) begin
      if ( recv__en ) begin
        state_next = 1'd1;
        counter__load = 1'd1;
        counter__load_value = 2'd1;
      end
      else begin
        state_next = 1'd0;
        counter__load = 1'd1;
        counter__load_value = 2'd0;
      end
    end
    else begin
      state_next = 1'd1;
      counter__load = 1'd0;
      counter__load_value = 2'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py:53
  // @update_ff
  // def up_len_r():
  //   if ( s.state == s.STATE_IDLE ) & s.recv.en | \
  //      ( s.state == s.STATE_RECV ) & ( s.idx == s.len_r ) & s.send.en:
  //     s.len_r <<= s.len if s.len > 0 else 1
  //   else:
  //     if s.state_next == s.STATE_IDLE:
  //       s.len_r <<= 0
  
  always_ff @(posedge clk) begin : up_len_r
    if ( ( ( state == 1'd0 ) & recv__en ) | ( ( ( state == 1'd1 ) & ( idx == len_r ) ) & send__en ) ) begin
      len_r <= ( len > 2'd0 ) ? len : 2'd1;
    end
    else if ( state_next == 1'd0 ) begin
      len_r <= 2'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py:64
  // @update_ff
  // def up_out_r():
  //   if s.reset:
  //     for i in range( max_nblocks ):
  //       s.out_r[i] <<= InType(0)
  // 
  //   elif ( s.state == s.STATE_RECV ) & ( s.idx == s.len_r ) & s.send.en:
  //     if s.recv.en:
  //       s.out_r[0] <<= s.recv.msg
  //     else:
  //       s.out_r[0] <<= 0
  //     for i in range(1, max_nblocks):
  //       s.out_r[i] <<= 0
  // 
  //   elif s.recv.en:
  //     s.out_r[ trunc(s.idx, SelType) ] <<= s.recv.msg
  
  always_ff @(posedge clk) begin : up_out_r
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__max_nblocks_at_up_out_r ); i += 1'd1 )
        out_r[2'(i)] <= 64'd0;
    end
    else if ( ( ( state == 1'd1 ) & ( idx == len_r ) ) & send__en ) begin
      if ( recv__en ) begin
        out_r[2'd0] <= recv__msg;
      end
      else
        out_r[2'd0] <= 64'd0;
      for ( int unsigned i = 1'd1; i < 2'( __const__max_nblocks_at_up_out_r ); i += 1'd1 )
        out_r[2'(i)] <= 64'd0;
    end
    else if ( recv__en ) begin
      out_r[idx] <= recv__msg;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/DeserializerRTL.py:108
  // @update_ff
  // def up_state():
  //   if s.reset:
  //     s.state <<= s.STATE_IDLE
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      state <= 1'd0;
    end
    else
      state <= state_next;
  end

  assign counter__clk = clk;
  assign counter__reset = reset;
  assign counter__decr = 1'd0;
  assign idx = counter__count;
  assign send__msg[63:0] = out_r[0];
  assign send__msg[127:64] = out_r[1];
  assign send__msg[191:128] = out_r[2];
  assign counter__incr = recv__en;

endmodule


// PyMTL Component MemResp2NetAdapter8B Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py

module MemResp2NetAdapter8B_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input MemRespMsg_8_128_m1__c72937e2b7853c90 recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [191:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [3:0] __const__READ  = 4'd0;
  localparam logic [3:0] __const__WRITE  = 4'd1;
  NetHeader8B__7a1608e9e4d537dd header;
  logic [63:0] header_bits;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py:150
  // @update
  // def up_plen():
  //   if s.recv.msg.type_ == READ:
  //     s.header.plen @= 2
  //   elif s.recv.msg.type_ == WRITE:
  //     s.header.plen @= 0
  //   else:
  //     s.header.plen @= 2    # AMO etc. have data field
  
  always_comb begin : up_plen
    if ( recv__msg.type_ == 4'( __const__READ ) ) begin
      header.plen = 4'd2;
    end
    else if ( recv__msg.type_ == 4'( __const__WRITE ) ) begin
      header.plen = 4'd0;
    end
    else
      header.plen = 4'd2;
  end

  assign header_bits[1:0] = header.test;
  assign header_bits[5:2] = header.len;
  assign header_bits[9:6] = header.type_;
  assign header_bits[17:10] = header.opaque;
  assign header_bits[21:18] = header.plen;
  assign header_bits[25:22] = header.dst;
  assign header_bits[29:26] = header.wr_mask;
  assign header_bits[31:30] = header.debug;
  assign header_bits[63:32] = header.addr;
  assign send__msg[63:0] = header_bits;
  assign send__msg[191:64] = recv__msg.data;
  assign header.addr = 32'd0;
  assign header.debug = 2'd0;
  assign header.wr_mask = recv__msg.wr_mask;
  assign header.dst = recv__msg.opaque[3:0];
  assign header.opaque = recv__msg.opaque;
  assign header.type_ = recv__msg.type_;
  assign header.len = recv__msg.len;
  assign header.test = recv__msg.test;
  assign recv__rdy = send__rdy;
  assign send__en = recv__en;

endmodule


// PyMTL Component Net2MemRespAdapter Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py

module Net2MemRespAdapter_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input logic [191:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output MemRespMsg_8_128_m1__c72937e2b7853c90 send__msg  ,
  input logic [0:0] send__rdy  
);
  NetHeader4B__ab3e1322e1bcfddf header;
  logic [31:0] header_bits;

  assign header.test = header_bits[1:0];
  assign header.len = header_bits[5:2];
  assign header.type_ = header_bits[9:6];
  assign header.opaque = header_bits[17:10];
  assign header.plen = header_bits[21:18];
  assign header.dst = header_bits[25:22];
  assign header.wr_mask = header_bits[29:26];
  assign header.debug = header_bits[31:30];
  assign header_bits = recv__msg[31:0];
  assign send__msg.type_ = header.type_;
  assign send__msg.opaque = header.opaque;
  assign send__msg.test = header.test;
  assign send__msg.len = header.len;
  assign send__msg.data = recv__msg[191:64];
  assign recv__rdy = send__rdy;
  assign send__en = recv__en;

endmodule


// PyMTL Component Net2MemReqAdapter Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/mem_net_adapters.py

module Net2MemReqAdapter_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input logic [191:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 send__msg  ,
  input logic [0:0] send__rdy  
);
  NetHeader4B__ab3e1322e1bcfddf header;
  logic [31:0] header_bits;

  assign header.test = header_bits[1:0];
  assign header.len = header_bits[5:2];
  assign header.type_ = header_bits[9:6];
  assign header.opaque = header_bits[17:10];
  assign header.plen = header_bits[21:18];
  assign header.dst = header_bits[25:22];
  assign header.wr_mask = header_bits[29:26];
  assign header.debug = header_bits[31:30];
  assign header_bits = recv__msg[31:0];
  assign send__msg.type_ = header.type_;
  assign send__msg.opaque = header.opaque;
  assign send__msg.addr = recv__msg[63:32];
  assign send__msg.len = header.len;
  assign send__msg.wr_mask = header.wr_mask;
  assign send__msg.data = recv__msg[191:64];
  assign recv__rdy = send__rdy;
  assign send__en = recv__en;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_Bits64__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__3935155bbb528c9b
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output logic [63:0] rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  logic [63:0] wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  logic [63:0] regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueDpathRTL__EntryType_Bits64__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [63:0] deq_ret ,
  input  logic [63:0] enq_msg ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  logic [63:0] queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  logic [63:0] queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__3935155bbb528c9b queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueRTL__EntryType_Bits64__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output logic [63:0] deq__ret  ,
  input logic [0:0] enq__en  ,
  input logic [63:0] enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  logic [63:0] dpath__deq_ret;
  logic [63:0] dpath__enq_msg;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueDpathRTL__EntryType_Bits64__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component InputUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/InputUnitRTL.py

module InputUnitRTL__PacketType_Bits64__QueueType_NormalQueueRTL
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output logic [63:0] give__ret  ,
  input logic [0:0] recv__en  ,
  input logic [63:0] recv__msg  ,
  output logic [0:0] recv__rdy  
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [1:0] queue__count;
  logic [0:0] queue__reset;
  logic [0:0] queue__deq__en;
  logic [0:0] queue__deq__rdy;
  logic [63:0] queue__deq__ret;
  logic [0:0] queue__enq__en;
  logic [63:0] queue__enq__msg;
  logic [0:0] queue__enq__rdy;

  NormalQueueRTL__EntryType_Bits64__num_entries_2 queue
  (
    .clk( queue__clk ),
    .count( queue__count ),
    .reset( queue__reset ),
    .deq__en( queue__deq__en ),
    .deq__rdy( queue__deq__rdy ),
    .deq__ret( queue__deq__ret ),
    .enq__en( queue__enq__en ),
    .enq__msg( queue__enq__msg ),
    .enq__rdy( queue__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__enq__en = recv__en;
  assign queue__enq__msg = recv__msg;
  assign recv__rdy = queue__enq__rdy;
  assign queue__deq__en = give__en;
  assign give__rdy = queue__deq__rdy;
  assign give__ret = queue__deq__ret;

endmodule


// PyMTL Component OutputUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/OutputUnitRTL.py

module OutputUnitRTL__PacketType_Bits64__QueueType_None
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input logic [63:0] get__ret  ,
  output logic [0:0] send__en  ,
  output logic [63:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  logic [0:0] __tmpvar__up_get_send_both_rdy;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/OutputUnitRTL.py:52
  // s.send.msg //= lambda: s.get.ret if s.send.en else PacketType()
  
  always_comb begin : _lambda__s_mem_net_req_net_output_units_0__send_msg
    send__msg = send__en ? get__ret : 64'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/OutputUnitRTL.py:54
  // @update
  // def up_get_send():
  //   both_rdy = s.get.rdy & s.send.rdy
  //   s.get.en  @= both_rdy
  //   s.send.en @= both_rdy
  
  always_comb begin : up_get_send
    __tmpvar__up_get_send_both_rdy = get__rdy & send__rdy;
    get__en = __tmpvar__up_get_send_both_rdy;
    send__en = __tmpvar__up_get_send_both_rdy;
  end

endmodule


// PyMTL Component Counter Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/Counter.py

module Counter__Type_Bits4__reset_value_0
(
  input  logic [0:0] clk ,
  output logic [3:0] count ,
  input  logic [0:0] decr ,
  input  logic [0:0] incr ,
  input  logic [0:0] load ,
  input  logic [3:0] load_value ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_count  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/Counter.py:28
  // @update_ff
  // def up_count():
  // 
  //   if s.reset:
  //     s.count <<= reset_value
  // 
  //   elif s.load:
  //     s.count <<= s.load_value
  // 
  //   elif s.incr & ~s.decr:
  //     s.count <<= s.count + 1
  // 
  //   elif ~s.incr & s.decr:
  //     s.count <<= s.count - 1
  
  always_ff @(posedge clk) begin : up_count
    if ( reset ) begin
      count <= 4'( __const__reset_value_at_up_count );
    end
    else if ( load ) begin
      count <= load_value;
    end
    else if ( incr & ( ~decr ) ) begin
      count <= count + 4'd1;
    end
    else if ( ( ~incr ) & decr ) begin
      count <= count - 4'd1;
    end
  end

endmodule


// PyMTL Component XbarRouteUnitMflitRTL Definition
// Full name: XbarRouteUnitMflitRTL__HeaderFormat_NetHeader8B__7a1608e9e4d537dd__num_outports_1__plen_field_name_plen
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py

module XbarRouteUnitMflitRTL__683f89cb3fc5db3b
(
  input  logic [0:0] clk ,
  output logic [0:0] hold [0:0],
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input logic [63:0] get__ret  ,
  input logic [0:0] give__en [0:0] ,
  output logic [0:0] give__rdy [0:0] ,
  output logic [63:0] give__ret [0:0] 
);
  localparam logic [0:0] __const__dir_nbits_at_up_out_dir  = 1'd1;
  logic [0:0] any_give_en;
  NetHeader8B__7a1608e9e4d537dd header;
  logic [0:0] out_dir;
  logic [0:0] out_dir_r;
  logic [0:0] state;
  logic [0:0] state_next;
  //-------------------------------------------------------------
  // Component counter
  //-------------------------------------------------------------

  logic [0:0] counter__clk;
  logic [3:0] counter__count;
  logic [0:0] counter__decr;
  logic [0:0] counter__incr;
  logic [0:0] counter__load;
  logic [3:0] counter__load_value;
  logic [0:0] counter__reset;

  Counter__Type_Bits4__reset_value_0 counter
  (
    .clk( counter__clk ),
    .count( counter__count ),
    .decr( counter__decr ),
    .incr( counter__incr ),
    .load( counter__load ),
    .load_value( counter__load_value ),
    .reset( counter__reset )
  );

  //-------------------------------------------------------------
  // End of component counter
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:64
  // @update
  // def up_any_give_en():
  //   s.any_give_en @= 0
  //   for i in range( s.num_outports ):
  //     if s.give[i].en:
  //       s.any_give_en @= 1
  
  always_comb begin : up_any_give_en
    any_give_en = 1'd0;
    for ( int unsigned i = 1'd0; i < 1'd1; i += 1'd1 )
      if ( give__en[1'(i)] ) begin
        any_give_en = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:92
  // @update
  // def up_counter_decr():
  //   if s.state == s.STATE_HEADER:
  //     s.counter.decr @= 0
  //   else:
  //     s.counter.decr @= s.any_give_en
  
  always_comb begin : up_counter_decr
    if ( state == 1'd0 ) begin
      counter__decr = 1'd0;
    end
    else
      counter__decr = any_give_en;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:99
  // @update
  // def up_counter_load():
  //   if s.state == s.STATE_HEADER:
  //     s.counter.load @= ( s.state_next == s.STATE_BODY )
  //   else:
  //     s.counter.load @= 0
  
  always_comb begin : up_counter_load
    if ( state == 1'd0 ) begin
      counter__load = state_next == 1'd1;
    end
    else
      counter__load = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:119
  // @update
  // def up_give_rdy_hold():
  //   for i in range( s.num_outports ):
  //     s.give[i].rdy @= ( i == s.out_dir ) & s.get.rdy
  //     s.hold[i]     @= ( i == s.out_dir ) & ( s.state == s.STATE_BODY )
  
  always_comb begin : up_give_rdy_hold
    for ( int unsigned i = 1'd0; i < 1'd1; i += 1'd1 ) begin
      give__rdy[1'(i)] = ( 1'(i) == out_dir ) & get__rdy;
      hold[1'(i)] = ( 1'(i) == out_dir ) & ( state == 1'd1 );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:56
  // @update
  // def up_header():
  //   s.header @= s.get.ret
  
  always_comb begin : up_header
    header = get__ret;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:108
  // @update
  // def up_out_dir():
  //   if ( s.state == s.STATE_HEADER ) & s.get.rdy:
  //     s.out_dir @= s.header.dst[0:dir_nbits]
  //   else:
  //     s.out_dir @= s.out_dir_r
  
  always_comb begin : up_out_dir
    if ( ( state == 1'd0 ) & get__rdy ) begin
      out_dir = header.dst[2'd0:2'd0];
    end
    else
      out_dir = out_dir_r;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:79
  // @update
  // def up_state_next():
  //   s.state_next @= s.state
  //   if s.state == s.STATE_HEADER:
  //     # If the packet has body flits
  //     if s.any_give_en & ( s.header.plen > 0 ):
  //       s.state_next @= s.STATE_BODY
  // 
  //   else: # STATE_BODY
  //     if ( s.counter.count == 1 ) & s.any_give_en:
  //       s.state_next @= s.STATE_HEADER
  
  always_comb begin : up_state_next
    state_next = state;
    if ( state == 1'd0 ) begin
      if ( any_give_en & ( header.plen > 4'd0 ) ) begin
        state_next = 1'd1;
      end
    end
    else if ( ( counter__count == 4'd1 ) & any_give_en ) begin
      state_next = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:115
  // @update_ff
  // def up_out_dir_r():
  //   s.out_dir_r <<= s.out_dir
  
  always_ff @(posedge clk) begin : up_out_dir_r
    out_dir_r <= out_dir;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:72
  // @update_ff
  // def up_state_r():
  //   if s.reset:
  //     s.state <<= s.STATE_HEADER
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state_r
    if ( reset ) begin
      state <= 1'd0;
    end
    else
      state <= state_next;
  end

  assign counter__clk = clk;
  assign counter__reset = reset;
  assign counter__incr = 1'd0;
  assign counter__load_value = header.plen;
  assign give__ret[0] = get__ret;
  assign get__en = any_give_en;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits2__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [1:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 2'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py

module RoundRobinArbiterEn__nreqs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [1:0] grants ,
  input  logic [1:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__nreqs_at_comb_reqs_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_reqs_int  = 3'd4;
  localparam logic [1:0] __const__nreqs_at_comb_grants  = 2'd2;
  localparam logic [1:0] __const__nreqs_at_comb_priority_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_priority_int  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_kills  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_grants_int  = 3'd4;
  logic [3:0] grants_int;
  logic [4:0] kills;
  logic [0:0] priority_en;
  logic [3:0] priority_int;
  logic [3:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [1:0] priority_reg__in_;
  logic [1:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits2__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 2'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[1'(i)] = grants_int[2'(i)] | grants_int[2'( __const__nreqs_at_comb_grants ) + 2'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        grants_int[2'(i)] = reqs_int[2'(i)];
      end
      else
        grants_int[2'(i)] = ( ~kills[3'(i)] ) & reqs_int[2'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[3'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        kills[3'(i) + 3'd1] = reqs_int[2'(i)];
      end
      else
        kills[3'(i) + 3'd1] = kills[3'(i)] | ( ( ~kills[3'(i)] ) & reqs_int[2'(i)] );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 2'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[2'd1:2'd0] = priority_reg__out;
    priority_int[2'd3:2'( __const__nreqs_at_comb_priority_int )] = 2'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[2'd1:2'd0] = reqs;
    reqs_int[2'd3:2'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[1:1] = grants[0:0];
  assign priority_reg__in_[0:0] = grants[1:1];

endmodule


// PyMTL Component GrantHoldArbiter Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/GrantHoldArbiter.py

module GrantHoldArbiter__nreqs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [1:0] grants ,
  input  logic [0:0] hold ,
  input  logic [1:0] reqs ,
  input  logic [0:0] reset 
);
  logic [1:0] last_r;
  //-------------------------------------------------------------
  // Component arb
  //-------------------------------------------------------------

  logic [0:0] arb__clk;
  logic [0:0] arb__en;
  logic [1:0] arb__grants;
  logic [1:0] arb__reqs;
  logic [0:0] arb__reset;

  RoundRobinArbiterEn__nreqs_2 arb
  (
    .clk( arb__clk ),
    .en( arb__en ),
    .grants( arb__grants ),
    .reqs( arb__reqs ),
    .reset( arb__reset )
  );

  //-------------------------------------------------------------
  // End of component arb
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/GrantHoldArbiter.py:30
  // s.arb.en   //= lambda: s.en
  
  always_comb begin : _lambda__s_mem_net_req_net_switch_units_0__arbiter_arb_en
    arb__en = en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/GrantHoldArbiter.py:29
  // s.arb.reqs //= lambda: 0 if s.hold else s.reqs
  
  always_comb begin : _lambda__s_mem_net_req_net_switch_units_0__arbiter_arb_reqs
    arb__reqs = hold ? 2'd0 : reqs;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/GrantHoldArbiter.py:31
  // s.grants   //= lambda: s.arb.grants if ~s.hold else s.last_r
  
  always_comb begin : _lambda__s_mem_net_req_net_switch_units_0__arbiter_grants
    grants = ( ~hold ) ? arb__grants : last_r;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/GrantHoldArbiter.py:33
  // @update_ff
  // def up_last_r():
  //   s.last_r <<= s.grants
  
  always_ff @(posedge clk) begin : up_last_r
    last_r <= grants;
  end

  assign arb__clk = clk;
  assign arb__reset = reset;

endmodule


// PyMTL Component Encoder Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/encoders.py

module Encoder__in_nbits_2__out_nbits_1
(
  input  logic [0:0] clk ,
  input  logic [1:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( in_[1'(i)] ) begin
        out = 1'(i);
      end
  end

endmodule


// PyMTL Component SwitchUnitGrantHoldRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitGrantHoldRTL.py

module SwitchUnitGrantHoldRTL__Type_Bits64__num_inports_2
(
  input  logic [0:0] clk ,
  input  logic [1:0] hold ,
  input  logic [0:0] reset ,
  output logic [0:0] get__en [0:1] ,
  input logic [0:0] get__rdy [0:1] ,
  input logic [63:0] get__ret [0:1] ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output logic [63:0] give__ret  
);
  localparam logic [1:0] __const__num_inports_at_up_granted_get_rdy  = 2'd2;
  localparam logic [0:0] __const__i_at__lambda__s_mem_net_req_net_switch_units_0__get_0__en  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_mem_net_req_net_switch_units_0__get_1__en  = 1'd1;
  logic [0:0] any_hold;
  logic [0:0] granted_get_rdy;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [1:0] arbiter__grants;
  logic [0:0] arbiter__hold;
  logic [1:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  GrantHoldArbiter__nreqs_2 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .hold( arbiter__hold ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [1:0] encoder__in_;
  logic [0:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_2__out_nbits_1 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  logic [63:0] mux__in_ [0:1];
  logic [63:0] mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__Type_Bits64__ninputs_2 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitGrantHoldRTL.py:37
  // s.arbiter.en   //= lambda: ~s.any_hold & s.give.en
  
  always_comb begin : _lambda__s_mem_net_req_net_switch_units_0__arbiter_en
    arbiter__en = ( ~any_hold ) & give__en;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitGrantHoldRTL.py:63
  // s.get[i].en //= lambda: s.give.en & ( s.mux.sel == i )
  
  always_comb begin : _lambda__s_mem_net_req_net_switch_units_0__get_0__en
    get__en[1'd0] = give__en & ( mux__sel == 1'( __const__i_at__lambda__s_mem_net_req_net_switch_units_0__get_0__en ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitGrantHoldRTL.py:63
  // s.get[i].en //= lambda: s.give.en & ( s.mux.sel == i )
  
  always_comb begin : _lambda__s_mem_net_req_net_switch_units_0__get_1__en
    get__en[1'd1] = give__en & ( mux__sel == 1'( __const__i_at__lambda__s_mem_net_req_net_switch_units_0__get_1__en ) );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitGrantHoldRTL.py:47
  // @update
  // def up_any_hold():
  //   s.any_hold @= s.hold > 0
  
  always_comb begin : up_any_hold
    any_hold = hold > 2'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitGrantHoldRTL.py:51
  // @update
  // def up_granted_get_rdy():
  //   s.granted_get_rdy @= 0
  //   for i in range( num_inports ):
  //     if s.arbiter.grants[i]:
  //       s.granted_get_rdy @= s.get[i].rdy
  
  always_comb begin : up_granted_get_rdy
    granted_get_rdy = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_inports_at_up_granted_get_rdy ); i += 1'd1 )
      if ( arbiter__grants[1'(i)] ) begin
        granted_get_rdy = get__rdy[1'(i)];
      end
  end

  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__hold = any_hold;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign give__ret = mux__out;
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign mux__sel = encoder__out;
  assign arbiter__reqs[0:0] = get__rdy[0];
  assign mux__in_[0] = get__ret[0];
  assign arbiter__reqs[1:1] = get__rdy[1];
  assign mux__in_[1] = get__ret[1];
  assign give__rdy = granted_get_rdy;

endmodule


// PyMTL Component XbarMflitRTL Definition
// Full name: XbarMflitRTL__Header_NetHeader8B__7a1608e9e4d537dd__num_inports_2__num_outports_1__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitMflitRTL__SwitchUnitType_SwitchUnitGrantHoldRTL__OutputUnitType_OutputUnitRTL
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarMflitRTL.py

module XbarMflitRTL__3af220abc55696b9
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:1] ,
  input logic [63:0] recv__msg [0:1] ,
  output logic [0:0] recv__rdy [0:1] ,
  output logic [0:0] send__en [0:0] ,
  output logic [63:0] send__msg [0:0] ,
  input logic [0:0] send__rdy [0:0] 
);
  //-------------------------------------------------------------
  // Component input_units[0:1]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:1];
  logic [0:0] input_units__reset [0:1];
  logic [0:0] input_units__give__en [0:1];
  logic [0:0] input_units__give__rdy [0:1];
  logic [63:0] input_units__give__ret [0:1];
  logic [0:0] input_units__recv__en [0:1];
  logic [63:0] input_units__recv__msg [0:1];
  logic [0:0] input_units__recv__rdy [0:1];

  InputUnitRTL__PacketType_Bits64__QueueType_NormalQueueRTL input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .give__en( input_units__give__en[0] ),
    .give__rdy( input_units__give__rdy[0] ),
    .give__ret( input_units__give__ret[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] )
  );

  InputUnitRTL__PacketType_Bits64__QueueType_NormalQueueRTL input_units__1
  (
    .clk( input_units__clk[1] ),
    .reset( input_units__reset[1] ),
    .give__en( input_units__give__en[1] ),
    .give__rdy( input_units__give__rdy[1] ),
    .give__ret( input_units__give__ret[1] ),
    .recv__en( input_units__recv__en[1] ),
    .recv__msg( input_units__recv__msg[1] ),
    .recv__rdy( input_units__recv__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:0];
  logic [0:0] output_units__reset [0:0];
  logic [0:0] output_units__get__en [0:0];
  logic [0:0] output_units__get__rdy [0:0];
  logic [63:0] output_units__get__ret [0:0];
  logic [0:0] output_units__send__en [0:0];
  logic [63:0] output_units__send__msg [0:0];
  logic [0:0] output_units__send__rdy [0:0];

  OutputUnitRTL__PacketType_Bits64__QueueType_None output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .get__en( output_units__get__en[0] ),
    .get__rdy( output_units__get__rdy[0] ),
    .get__ret( output_units__get__ret[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:1]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:1];
  logic [0:0] route_units__hold [0:1][0:0];
  logic [0:0] route_units__reset [0:1];
  logic [0:0] route_units__get__en [0:1];
  logic [0:0] route_units__get__rdy [0:1];
  logic [63:0] route_units__get__ret [0:1];
  logic [0:0] route_units__give__en [0:1][0:0];
  logic [0:0] route_units__give__rdy [0:1][0:0];
  logic [63:0] route_units__give__ret [0:1][0:0];

  XbarRouteUnitMflitRTL__683f89cb3fc5db3b route_units__0
  (
    .clk( route_units__clk[0] ),
    .hold( route_units__hold[0] ),
    .reset( route_units__reset[0] ),
    .get__en( route_units__get__en[0] ),
    .get__rdy( route_units__get__rdy[0] ),
    .get__ret( route_units__get__ret[0] ),
    .give__en( route_units__give__en[0] ),
    .give__rdy( route_units__give__rdy[0] ),
    .give__ret( route_units__give__ret[0] )
  );

  XbarRouteUnitMflitRTL__683f89cb3fc5db3b route_units__1
  (
    .clk( route_units__clk[1] ),
    .hold( route_units__hold[1] ),
    .reset( route_units__reset[1] ),
    .get__en( route_units__get__en[1] ),
    .get__rdy( route_units__get__rdy[1] ),
    .get__ret( route_units__get__ret[1] ),
    .give__en( route_units__give__en[1] ),
    .give__rdy( route_units__give__rdy[1] ),
    .give__ret( route_units__give__ret[1] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:0];
  logic [1:0] switch_units__hold [0:0];
  logic [0:0] switch_units__reset [0:0];
  logic [0:0] switch_units__get__en [0:0][0:1];
  logic [0:0] switch_units__get__rdy [0:0][0:1];
  logic [63:0] switch_units__get__ret [0:0][0:1];
  logic [0:0] switch_units__give__en [0:0];
  logic [0:0] switch_units__give__rdy [0:0];
  logic [63:0] switch_units__give__ret [0:0];

  SwitchUnitGrantHoldRTL__Type_Bits64__num_inports_2 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .hold( switch_units__hold[0] ),
    .reset( switch_units__reset[0] ),
    .get__en( switch_units__get__en[0] ),
    .get__rdy( switch_units__get__rdy[0] ),
    .get__ret( switch_units__get__ret[0] ),
    .give__en( switch_units__give__en[0] ),
    .give__rdy( switch_units__give__rdy[0] ),
    .give__ret( switch_units__give__ret[0] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:0]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign input_units__clk[1] = clk;
  assign input_units__reset[1] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign route_units__clk[1] = clk;
  assign route_units__reset[1] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__give__en[0] = route_units__get__en[0];
  assign route_units__get__rdy[0] = input_units__give__rdy[0];
  assign route_units__get__ret[0] = input_units__give__ret[0];
  assign input_units__recv__en[1] = recv__en[1];
  assign input_units__recv__msg[1] = recv__msg[1];
  assign recv__rdy[1] = input_units__recv__rdy[1];
  assign input_units__give__en[1] = route_units__get__en[1];
  assign route_units__get__rdy[1] = input_units__give__rdy[1];
  assign route_units__get__ret[1] = input_units__give__ret[1];
  assign route_units__give__en[0][0] = switch_units__get__en[0][0];
  assign switch_units__get__rdy[0][0] = route_units__give__rdy[0][0];
  assign switch_units__get__ret[0][0] = route_units__give__ret[0][0];
  assign switch_units__hold[0][0:0] = route_units__hold[0][0];
  assign route_units__give__en[1][0] = switch_units__get__en[0][1];
  assign switch_units__get__rdy[0][1] = route_units__give__rdy[1][0];
  assign switch_units__get__ret[0][1] = route_units__give__ret[1][0];
  assign switch_units__hold[0][1:1] = route_units__hold[1][0];
  assign switch_units__give__en[0] = output_units__get__en[0];
  assign output_units__get__rdy[0] = switch_units__give__rdy[0];
  assign output_units__get__ret[0] = switch_units__give__ret[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];

endmodule


// PyMTL Component XbarRouteUnitMflitRTL Definition
// Full name: XbarRouteUnitMflitRTL__HeaderFormat_NetHeader8B__7a1608e9e4d537dd__num_outports_2__plen_field_name_plen
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py

module XbarRouteUnitMflitRTL__486dbe57746d06b3
(
  input  logic [0:0] clk ,
  output logic [0:0] hold [0:1],
  input  logic [0:0] reset ,
  output logic [0:0] get__en  ,
  input logic [0:0] get__rdy  ,
  input logic [63:0] get__ret  ,
  input logic [0:0] give__en [0:1] ,
  output logic [0:0] give__rdy [0:1] ,
  output logic [63:0] give__ret [0:1] 
);
  localparam logic [0:0] __const__dir_nbits_at_up_out_dir  = 1'd1;
  logic [0:0] any_give_en;
  NetHeader8B__7a1608e9e4d537dd header;
  logic [0:0] out_dir;
  logic [0:0] out_dir_r;
  logic [0:0] state;
  logic [0:0] state_next;
  //-------------------------------------------------------------
  // Component counter
  //-------------------------------------------------------------

  logic [0:0] counter__clk;
  logic [3:0] counter__count;
  logic [0:0] counter__decr;
  logic [0:0] counter__incr;
  logic [0:0] counter__load;
  logic [3:0] counter__load_value;
  logic [0:0] counter__reset;

  Counter__Type_Bits4__reset_value_0 counter
  (
    .clk( counter__clk ),
    .count( counter__count ),
    .decr( counter__decr ),
    .incr( counter__incr ),
    .load( counter__load ),
    .load_value( counter__load_value ),
    .reset( counter__reset )
  );

  //-------------------------------------------------------------
  // End of component counter
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:64
  // @update
  // def up_any_give_en():
  //   s.any_give_en @= 0
  //   for i in range( s.num_outports ):
  //     if s.give[i].en:
  //       s.any_give_en @= 1
  
  always_comb begin : up_any_give_en
    any_give_en = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( give__en[1'(i)] ) begin
        any_give_en = 1'd1;
      end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:92
  // @update
  // def up_counter_decr():
  //   if s.state == s.STATE_HEADER:
  //     s.counter.decr @= 0
  //   else:
  //     s.counter.decr @= s.any_give_en
  
  always_comb begin : up_counter_decr
    if ( state == 1'd0 ) begin
      counter__decr = 1'd0;
    end
    else
      counter__decr = any_give_en;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:99
  // @update
  // def up_counter_load():
  //   if s.state == s.STATE_HEADER:
  //     s.counter.load @= ( s.state_next == s.STATE_BODY )
  //   else:
  //     s.counter.load @= 0
  
  always_comb begin : up_counter_load
    if ( state == 1'd0 ) begin
      counter__load = state_next == 1'd1;
    end
    else
      counter__load = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:119
  // @update
  // def up_give_rdy_hold():
  //   for i in range( s.num_outports ):
  //     s.give[i].rdy @= ( i == s.out_dir ) & s.get.rdy
  //     s.hold[i]     @= ( i == s.out_dir ) & ( s.state == s.STATE_BODY )
  
  always_comb begin : up_give_rdy_hold
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 ) begin
      give__rdy[1'(i)] = ( 1'(i) == out_dir ) & get__rdy;
      hold[1'(i)] = ( 1'(i) == out_dir ) & ( state == 1'd1 );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:56
  // @update
  // def up_header():
  //   s.header @= s.get.ret
  
  always_comb begin : up_header
    header = get__ret;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:108
  // @update
  // def up_out_dir():
  //   if ( s.state == s.STATE_HEADER ) & s.get.rdy:
  //     s.out_dir @= s.header.dst[0:dir_nbits]
  //   else:
  //     s.out_dir @= s.out_dir_r
  
  always_comb begin : up_out_dir
    if ( ( state == 1'd0 ) & get__rdy ) begin
      out_dir = header.dst[2'd0:2'd0];
    end
    else
      out_dir = out_dir_r;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:79
  // @update
  // def up_state_next():
  //   s.state_next @= s.state
  //   if s.state == s.STATE_HEADER:
  //     # If the packet has body flits
  //     if s.any_give_en & ( s.header.plen > 0 ):
  //       s.state_next @= s.STATE_BODY
  // 
  //   else: # STATE_BODY
  //     if ( s.counter.count == 1 ) & s.any_give_en:
  //       s.state_next @= s.STATE_HEADER
  
  always_comb begin : up_state_next
    state_next = state;
    if ( state == 1'd0 ) begin
      if ( any_give_en & ( header.plen > 4'd0 ) ) begin
        state_next = 1'd1;
      end
    end
    else if ( ( counter__count == 4'd1 ) & any_give_en ) begin
      state_next = 1'd0;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:115
  // @update_ff
  // def up_out_dir_r():
  //   s.out_dir_r <<= s.out_dir
  
  always_ff @(posedge clk) begin : up_out_dir_r
    out_dir_r <= out_dir;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarRouteUnitMflitRTL.py:72
  // @update_ff
  // def up_state_r():
  //   if s.reset:
  //     s.state <<= s.STATE_HEADER
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state_r
    if ( reset ) begin
      state <= 1'd0;
    end
    else
      state <= state_next;
  end

  assign counter__clk = clk;
  assign counter__reset = reset;
  assign counter__incr = 1'd0;
  assign counter__load_value = header.plen;
  assign give__ret[0] = get__ret;
  assign give__ret[1] = get__ret;
  assign get__en = any_give_en;

endmodule


// PyMTL Component SwitchUnitNullRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/router/SwitchUnitNullRTL.py

module SwitchUnitNullRTL__Type_Bits64__num_inports_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] hold [0:0],
  input  logic [0:0] reset ,
  output logic [0:0] get__en [0:0] ,
  input logic [0:0] get__rdy [0:0] ,
  input logic [63:0] get__ret [0:0] ,
  input logic [0:0] give__en  ,
  output logic [0:0] give__rdy  ,
  output logic [63:0] give__ret  
);

  assign get__en[0] = give__en;
  assign give__rdy = get__rdy[0];
  assign give__ret = get__ret[0];

endmodule


// PyMTL Component XbarMflitRTL Definition
// Full name: XbarMflitRTL__Header_NetHeader8B__7a1608e9e4d537dd__num_inports_1__num_outports_2__InputUnitType_InputUnitRTL__RouteUnitType_XbarRouteUnitMflitRTL__SwitchUnitType_SwitchUnitGrantHoldRTL__OutputUnitType_OutputUnitRTL
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/xbar/XbarMflitRTL.py

module XbarMflitRTL__d06fa4a1b21a6061
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:0] ,
  input logic [63:0] recv__msg [0:0] ,
  output logic [0:0] recv__rdy [0:0] ,
  output logic [0:0] send__en [0:1] ,
  output logic [63:0] send__msg [0:1] ,
  input logic [0:0] send__rdy [0:1] 
);
  //-------------------------------------------------------------
  // Component input_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] input_units__clk [0:0];
  logic [0:0] input_units__reset [0:0];
  logic [0:0] input_units__give__en [0:0];
  logic [0:0] input_units__give__rdy [0:0];
  logic [63:0] input_units__give__ret [0:0];
  logic [0:0] input_units__recv__en [0:0];
  logic [63:0] input_units__recv__msg [0:0];
  logic [0:0] input_units__recv__rdy [0:0];

  InputUnitRTL__PacketType_Bits64__QueueType_NormalQueueRTL input_units__0
  (
    .clk( input_units__clk[0] ),
    .reset( input_units__reset[0] ),
    .give__en( input_units__give__en[0] ),
    .give__rdy( input_units__give__rdy[0] ),
    .give__ret( input_units__give__ret[0] ),
    .recv__en( input_units__recv__en[0] ),
    .recv__msg( input_units__recv__msg[0] ),
    .recv__rdy( input_units__recv__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component input_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component output_units[0:1]
  //-------------------------------------------------------------

  logic [0:0] output_units__clk [0:1];
  logic [0:0] output_units__reset [0:1];
  logic [0:0] output_units__get__en [0:1];
  logic [0:0] output_units__get__rdy [0:1];
  logic [63:0] output_units__get__ret [0:1];
  logic [0:0] output_units__send__en [0:1];
  logic [63:0] output_units__send__msg [0:1];
  logic [0:0] output_units__send__rdy [0:1];

  OutputUnitRTL__PacketType_Bits64__QueueType_None output_units__0
  (
    .clk( output_units__clk[0] ),
    .reset( output_units__reset[0] ),
    .get__en( output_units__get__en[0] ),
    .get__rdy( output_units__get__rdy[0] ),
    .get__ret( output_units__get__ret[0] ),
    .send__en( output_units__send__en[0] ),
    .send__msg( output_units__send__msg[0] ),
    .send__rdy( output_units__send__rdy[0] )
  );

  OutputUnitRTL__PacketType_Bits64__QueueType_None output_units__1
  (
    .clk( output_units__clk[1] ),
    .reset( output_units__reset[1] ),
    .get__en( output_units__get__en[1] ),
    .get__rdy( output_units__get__rdy[1] ),
    .get__ret( output_units__get__ret[1] ),
    .send__en( output_units__send__en[1] ),
    .send__msg( output_units__send__msg[1] ),
    .send__rdy( output_units__send__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component output_units[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component route_units[0:0]
  //-------------------------------------------------------------

  logic [0:0] route_units__clk [0:0];
  logic [0:0] route_units__hold [0:0][0:1];
  logic [0:0] route_units__reset [0:0];
  logic [0:0] route_units__get__en [0:0];
  logic [0:0] route_units__get__rdy [0:0];
  logic [63:0] route_units__get__ret [0:0];
  logic [0:0] route_units__give__en [0:0][0:1];
  logic [0:0] route_units__give__rdy [0:0][0:1];
  logic [63:0] route_units__give__ret [0:0][0:1];

  XbarRouteUnitMflitRTL__486dbe57746d06b3 route_units__0
  (
    .clk( route_units__clk[0] ),
    .hold( route_units__hold[0] ),
    .reset( route_units__reset[0] ),
    .get__en( route_units__get__en[0] ),
    .get__rdy( route_units__get__rdy[0] ),
    .get__ret( route_units__get__ret[0] ),
    .give__en( route_units__give__en[0] ),
    .give__rdy( route_units__give__rdy[0] ),
    .give__ret( route_units__give__ret[0] )
  );

  //-------------------------------------------------------------
  // End of component route_units[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component switch_units[0:1]
  //-------------------------------------------------------------

  logic [0:0] switch_units__clk [0:1];
  logic [0:0] switch_units__hold [0:1][0:0];
  logic [0:0] switch_units__reset [0:1];
  logic [0:0] switch_units__get__en [0:1][0:0];
  logic [0:0] switch_units__get__rdy [0:1][0:0];
  logic [63:0] switch_units__get__ret [0:1][0:0];
  logic [0:0] switch_units__give__en [0:1];
  logic [0:0] switch_units__give__rdy [0:1];
  logic [63:0] switch_units__give__ret [0:1];

  SwitchUnitNullRTL__Type_Bits64__num_inports_1 switch_units__0
  (
    .clk( switch_units__clk[0] ),
    .hold( switch_units__hold[0] ),
    .reset( switch_units__reset[0] ),
    .get__en( switch_units__get__en[0] ),
    .get__rdy( switch_units__get__rdy[0] ),
    .get__ret( switch_units__get__ret[0] ),
    .give__en( switch_units__give__en[0] ),
    .give__rdy( switch_units__give__rdy[0] ),
    .give__ret( switch_units__give__ret[0] )
  );

  SwitchUnitNullRTL__Type_Bits64__num_inports_1 switch_units__1
  (
    .clk( switch_units__clk[1] ),
    .hold( switch_units__hold[1] ),
    .reset( switch_units__reset[1] ),
    .get__en( switch_units__get__en[1] ),
    .get__rdy( switch_units__get__rdy[1] ),
    .get__ret( switch_units__get__ret[1] ),
    .give__en( switch_units__give__en[1] ),
    .give__rdy( switch_units__give__rdy[1] ),
    .give__ret( switch_units__give__ret[1] )
  );

  //-------------------------------------------------------------
  // End of component switch_units[0:1]
  //-------------------------------------------------------------

  assign input_units__clk[0] = clk;
  assign input_units__reset[0] = reset;
  assign route_units__clk[0] = clk;
  assign route_units__reset[0] = reset;
  assign switch_units__clk[0] = clk;
  assign switch_units__reset[0] = reset;
  assign switch_units__clk[1] = clk;
  assign switch_units__reset[1] = reset;
  assign output_units__clk[0] = clk;
  assign output_units__reset[0] = reset;
  assign output_units__clk[1] = clk;
  assign output_units__reset[1] = reset;
  assign input_units__recv__en[0] = recv__en[0];
  assign input_units__recv__msg[0] = recv__msg[0];
  assign recv__rdy[0] = input_units__recv__rdy[0];
  assign input_units__give__en[0] = route_units__get__en[0];
  assign route_units__get__rdy[0] = input_units__give__rdy[0];
  assign route_units__get__ret[0] = input_units__give__ret[0];
  assign route_units__give__en[0][0] = switch_units__get__en[0][0];
  assign switch_units__get__rdy[0][0] = route_units__give__rdy[0][0];
  assign switch_units__get__ret[0][0] = route_units__give__ret[0][0];
  assign switch_units__hold[0][0] = route_units__hold[0][0];
  assign route_units__give__en[0][1] = switch_units__get__en[1][0];
  assign switch_units__get__rdy[1][0] = route_units__give__rdy[0][1];
  assign switch_units__get__ret[1][0] = route_units__give__ret[0][1];
  assign switch_units__hold[1][0] = route_units__hold[0][1];
  assign switch_units__give__en[0] = output_units__get__en[0];
  assign output_units__get__rdy[0] = switch_units__give__rdy[0];
  assign output_units__get__ret[0] = switch_units__give__ret[0];
  assign send__en[0] = output_units__send__en[0];
  assign send__msg[0] = output_units__send__msg[0];
  assign output_units__send__rdy[0] = send__rdy[0];
  assign switch_units__give__en[1] = output_units__get__en[1];
  assign output_units__get__rdy[1] = switch_units__give__rdy[1];
  assign output_units__get__ret[1] = switch_units__give__ret[1];
  assign send__en[1] = output_units__send__en[1];
  assign send__msg[1] = output_units__send__msg[1];
  assign output_units__send__rdy[1] = send__rdy[1];

endmodule


// PyMTL Component SerializerRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py

module SerializerRTL__out_nbits_64__max_nblocks_3
(
  input  logic [0:0] clk ,
  input  logic [1:0] len ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en  ,
  input logic [191:0] recv__msg  ,
  output logic [0:0] recv__rdy  ,
  output logic [0:0] send__en  ,
  output logic [63:0] send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [6:0] __const__out_nbits_at_up_send_msg  = 7'd64;
  logic [191:0] in_r;
  logic [1:0] len_r;
  logic [0:0] state;
  logic [0:0] state_next;
  //-------------------------------------------------------------
  // Component counter
  //-------------------------------------------------------------

  logic [0:0] counter__clk;
  logic [1:0] counter__count;
  logic [0:0] counter__decr;
  logic [0:0] counter__incr;
  logic [0:0] counter__load;
  logic [1:0] counter__load_value;
  logic [0:0] counter__reset;

  Counter__Type_Bits2__reset_value_0 counter
  (
    .clk( counter__clk ),
    .count( counter__count ),
    .decr( counter__decr ),
    .incr( counter__incr ),
    .load( counter__load ),
    .load_value( counter__load_value ),
    .reset( counter__reset )
  );

  //-------------------------------------------------------------
  // End of component counter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  logic [63:0] mux__in_ [0:2];
  logic [63:0] mux__out;
  logic [0:0] mux__reset;
  logic [1:0] mux__sel;

  Mux__Type_Bits64__ninputs_3 mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:73
  // s.counter.incr //= lambda: s.send.en & ( s.state_next != s.STATE_IDLE )
  
  always_comb begin : _lambda__s_mem_net_ser_0__counter_incr
    counter__incr = send__en & ( state_next != 1'd0 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:72
  // s.counter.load //= lambda: s.recv.en | ( s.state_next == s.STATE_IDLE )
  
  always_comb begin : _lambda__s_mem_net_ser_0__counter_load
    counter__load = recv__en | ( state_next == 1'd0 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:84
  // s.recv.rdy //= lambda: s.state == s.STATE_IDLE
  
  always_comb begin : _lambda__s_mem_net_ser_0__recv_rdy
    recv__rdy = state == 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:75
  // @update
  // def up_counter_load_value():
  //   if ( s.state == s.STATE_IDLE ) & s.send.rdy & ( s.state_next != s.STATE_IDLE ):
  //     s.counter.load_value @= 1
  //   else:
  //     s.counter.load_value @= 0
  
  always_comb begin : up_counter_load_value
    if ( ( ( state == 1'd0 ) & send__rdy ) & ( state_next != 1'd0 ) ) begin
      counter__load_value = 2'd1;
    end
    else
      counter__load_value = 2'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:95
  // @update
  // def up_send_en():
  //   if ( s.state == s.STATE_IDLE ) & s.recv.en & s.send.rdy | \
  //      ( s.state == s.STATE_SEND ) & s.send.rdy:
  //     s.send.en @= 1
  //   else:
  //     s.send.en @= 0
  
  always_comb begin : up_send_en
    if ( ( ( ( state == 1'd0 ) & recv__en ) & send__rdy ) | ( ( state == 1'd1 ) & send__rdy ) ) begin
      send__en = 1'd1;
    end
    else
      send__en = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:88
  // @update
  // def up_send_msg():
  //   if ( s.state == s.STATE_IDLE ) & s.recv.en & s.send.rdy:
  //     s.send.msg @= s.recv.msg[0:out_nbits]
  //   else:
  //     s.send.msg @= s.mux.out
  
  always_comb begin : up_send_msg
    if ( ( ( state == 1'd0 ) & recv__en ) & send__rdy ) begin
      send__msg = recv__msg[8'd63:8'd0];
    end
    else
      send__msg = mux__out;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:112
  // @update
  // def up_state_next():
  //   if s.state == s.STATE_IDLE:
  //     # If length is 1, bypass to IDLE
  //     if ( s.len == 1 ) & s.send.en:
  //       s.state_next @= s.STATE_IDLE
  // 
  //     elif s.recv.en:
  //       s.state_next @= s.STATE_SEND
  // 
  //     else:
  //       s.state_next @= s.STATE_IDLE
  // 
  //   else: # STATE_SEND
  //     if ( s.counter.count == s.len_r - 1 ) & s.send.rdy:
  //       s.state_next @= s.STATE_IDLE
  //     else:
  //       s.state_next @= s.STATE_SEND
  
  always_comb begin : up_state_next
    if ( state == 1'd0 ) begin
      if ( ( len == 2'd1 ) & send__en ) begin
        state_next = 1'd0;
      end
      else if ( recv__en ) begin
        state_next = 1'd1;
      end
      else
        state_next = 1'd0;
    end
    else if ( ( counter__count == ( len_r - 2'd1 ) ) & send__rdy ) begin
      state_next = 1'd0;
    end
    else
      state_next = 1'd1;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:54
  // @update_ff
  // def up_in_r():
  //   if s.recv.en & ( s.state_next != s.STATE_IDLE ):
  //     s.in_r  <<= s.recv.msg
  //     # Force len to 1 if it is set to be 0 to avoid undefined behavior
  //     s.len_r <<= s.len if s.len > 0 else 1
  //   else:
  //     s.in_r  <<= s.in_r
  //     s.len_r <<= 0 if s.state_next == s.STATE_IDLE else s.len_r
  
  always_ff @(posedge clk) begin : up_in_r
    if ( recv__en & ( state_next != 1'd0 ) ) begin
      in_r <= recv__msg;
      len_r <= ( len > 2'd0 ) ? len : 2'd1;
    end
    else begin
      in_r <= in_r;
      len_r <= ( state_next == 1'd0 ) ? 2'd0 : len_r;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_net/ocnlib/rtl/SerializerRTL.py:105
  // @update_ff
  // def up_state():
  //   if s.reset:
  //     s.state <<= s.STATE_IDLE
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      state <= 1'd0;
    end
    else
      state <= state_next;
  end

  assign counter__clk = clk;
  assign counter__reset = reset;
  assign counter__decr = 1'd0;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__in_[0] = in_r[63:0];
  assign mux__in_[1] = in_r[127:64];
  assign mux__in_[2] = in_r[191:128];
  assign mux__sel = counter__count[1:0];

endmodule


// PyMTL Component MasterMinionXbar Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/MasterMinionXbar.py

module MasterMinionXbar__ncaches_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] cache_ifc__req__en [0:1],
  input MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 cache_ifc__req__msg [0:1],
  output logic [0:0] cache_ifc__req__rdy [0:1],
  output logic [0:0] cache_ifc__resp__en [0:1],
  output MemRespMsg_8_128_m1__c72937e2b7853c90 cache_ifc__resp__msg [0:1],
  input logic [0:0] cache_ifc__resp__rdy [0:1],
  output logic [0:0] mem_ifc__req__en ,
  output MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 mem_ifc__req__msg ,
  input logic [0:0] mem_ifc__req__rdy ,
  input logic [0:0] mem_ifc__resp__en ,
  input MemRespMsg_8_128_m1__c72937e2b7853c90 mem_ifc__resp__msg ,
  output logic [0:0] mem_ifc__resp__rdy 
);
  localparam logic [1:0] __const__ncaches_at_up_length  = 2'd2;
  logic [1:0] des_len [0:2];
  logic [1:0] ser_len [0:2];
  //-------------------------------------------------------------
  // Component c2net[0:1]
  //-------------------------------------------------------------

  logic [0:0] c2net__clk [0:1];
  logic [0:0] c2net__reset [0:1];
  logic [0:0] c2net__recv__en [0:1];
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 c2net__recv__msg [0:1];
  logic [0:0] c2net__recv__rdy [0:1];
  logic [0:0] c2net__send__en [0:1];
  logic [191:0] c2net__send__msg [0:1];
  logic [0:0] c2net__send__rdy [0:1];

  MemReq2NetAdapter8B__src_id_0 c2net__0
  (
    .clk( c2net__clk[0] ),
    .reset( c2net__reset[0] ),
    .recv__en( c2net__recv__en[0] ),
    .recv__msg( c2net__recv__msg[0] ),
    .recv__rdy( c2net__recv__rdy[0] ),
    .send__en( c2net__send__en[0] ),
    .send__msg( c2net__send__msg[0] ),
    .send__rdy( c2net__send__rdy[0] )
  );

  MemReq2NetAdapter8B__src_id_1 c2net__1
  (
    .clk( c2net__clk[1] ),
    .reset( c2net__reset[1] ),
    .recv__en( c2net__recv__en[1] ),
    .recv__msg( c2net__recv__msg[1] ),
    .recv__rdy( c2net__recv__rdy[1] ),
    .send__en( c2net__send__en[1] ),
    .send__msg( c2net__send__msg[1] ),
    .send__rdy( c2net__send__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component c2net[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component des[0:2]
  //-------------------------------------------------------------

  logic [0:0] des__clk [0:2];
  logic [1:0] des__len [0:2];
  logic [0:0] des__reset [0:2];
  logic [0:0] des__recv__en [0:2];
  logic [63:0] des__recv__msg [0:2];
  logic [0:0] des__recv__rdy [0:2];
  logic [0:0] des__send__en [0:2];
  logic [191:0] des__send__msg [0:2];
  logic [0:0] des__send__rdy [0:2];

  DeserializerRTL__in_nbits_64__max_nblocks_3 des__0
  (
    .clk( des__clk[0] ),
    .len( des__len[0] ),
    .reset( des__reset[0] ),
    .recv__en( des__recv__en[0] ),
    .recv__msg( des__recv__msg[0] ),
    .recv__rdy( des__recv__rdy[0] ),
    .send__en( des__send__en[0] ),
    .send__msg( des__send__msg[0] ),
    .send__rdy( des__send__rdy[0] )
  );

  DeserializerRTL__in_nbits_64__max_nblocks_3 des__1
  (
    .clk( des__clk[1] ),
    .len( des__len[1] ),
    .reset( des__reset[1] ),
    .recv__en( des__recv__en[1] ),
    .recv__msg( des__recv__msg[1] ),
    .recv__rdy( des__recv__rdy[1] ),
    .send__en( des__send__en[1] ),
    .send__msg( des__send__msg[1] ),
    .send__rdy( des__send__rdy[1] )
  );

  DeserializerRTL__in_nbits_64__max_nblocks_3 des__2
  (
    .clk( des__clk[2] ),
    .len( des__len[2] ),
    .reset( des__reset[2] ),
    .recv__en( des__recv__en[2] ),
    .recv__msg( des__recv__msg[2] ),
    .recv__rdy( des__recv__rdy[2] ),
    .send__en( des__send__en[2] ),
    .send__msg( des__send__msg[2] ),
    .send__rdy( des__send__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component des[0:2]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component m2net
  //-------------------------------------------------------------

  logic [0:0] m2net__clk;
  logic [0:0] m2net__reset;
  logic [0:0] m2net__recv__en;
  MemRespMsg_8_128_m1__c72937e2b7853c90 m2net__recv__msg;
  logic [0:0] m2net__recv__rdy;
  logic [0:0] m2net__send__en;
  logic [191:0] m2net__send__msg;
  logic [0:0] m2net__send__rdy;

  MemResp2NetAdapter8B_noparam m2net
  (
    .clk( m2net__clk ),
    .reset( m2net__reset ),
    .recv__en( m2net__recv__en ),
    .recv__msg( m2net__recv__msg ),
    .recv__rdy( m2net__recv__rdy ),
    .send__en( m2net__send__en ),
    .send__msg( m2net__send__msg ),
    .send__rdy( m2net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component m2net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component net2c[0:1]
  //-------------------------------------------------------------

  logic [0:0] net2c__clk [0:1];
  logic [0:0] net2c__reset [0:1];
  logic [0:0] net2c__recv__en [0:1];
  logic [191:0] net2c__recv__msg [0:1];
  logic [0:0] net2c__recv__rdy [0:1];
  logic [0:0] net2c__send__en [0:1];
  MemRespMsg_8_128_m1__c72937e2b7853c90 net2c__send__msg [0:1];
  logic [0:0] net2c__send__rdy [0:1];

  Net2MemRespAdapter_noparam net2c__0
  (
    .clk( net2c__clk[0] ),
    .reset( net2c__reset[0] ),
    .recv__en( net2c__recv__en[0] ),
    .recv__msg( net2c__recv__msg[0] ),
    .recv__rdy( net2c__recv__rdy[0] ),
    .send__en( net2c__send__en[0] ),
    .send__msg( net2c__send__msg[0] ),
    .send__rdy( net2c__send__rdy[0] )
  );

  Net2MemRespAdapter_noparam net2c__1
  (
    .clk( net2c__clk[1] ),
    .reset( net2c__reset[1] ),
    .recv__en( net2c__recv__en[1] ),
    .recv__msg( net2c__recv__msg[1] ),
    .recv__rdy( net2c__recv__rdy[1] ),
    .send__en( net2c__send__en[1] ),
    .send__msg( net2c__send__msg[1] ),
    .send__rdy( net2c__send__rdy[1] )
  );

  //-------------------------------------------------------------
  // End of component net2c[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component net2m
  //-------------------------------------------------------------

  logic [0:0] net2m__clk;
  logic [0:0] net2m__reset;
  logic [0:0] net2m__recv__en;
  logic [191:0] net2m__recv__msg;
  logic [0:0] net2m__recv__rdy;
  logic [0:0] net2m__send__en;
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 net2m__send__msg;
  logic [0:0] net2m__send__rdy;

  Net2MemReqAdapter_noparam net2m
  (
    .clk( net2m__clk ),
    .reset( net2m__reset ),
    .recv__en( net2m__recv__en ),
    .recv__msg( net2m__recv__msg ),
    .recv__rdy( net2m__recv__rdy ),
    .send__en( net2m__send__en ),
    .send__msg( net2m__send__msg ),
    .send__rdy( net2m__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component net2m
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req_net
  //-------------------------------------------------------------

  logic [0:0] req_net__clk;
  logic [0:0] req_net__reset;
  logic [0:0] req_net__recv__en [0:1];
  logic [63:0] req_net__recv__msg [0:1];
  logic [0:0] req_net__recv__rdy [0:1];
  logic [0:0] req_net__send__en [0:0];
  logic [63:0] req_net__send__msg [0:0];
  logic [0:0] req_net__send__rdy [0:0];

  XbarMflitRTL__3af220abc55696b9 req_net
  (
    .clk( req_net__clk ),
    .reset( req_net__reset ),
    .recv__en( req_net__recv__en ),
    .recv__msg( req_net__recv__msg ),
    .recv__rdy( req_net__recv__rdy ),
    .send__en( req_net__send__en ),
    .send__msg( req_net__send__msg ),
    .send__rdy( req_net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component req_net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component resp_net
  //-------------------------------------------------------------

  logic [0:0] resp_net__clk;
  logic [0:0] resp_net__reset;
  logic [0:0] resp_net__recv__en [0:0];
  logic [63:0] resp_net__recv__msg [0:0];
  logic [0:0] resp_net__recv__rdy [0:0];
  logic [0:0] resp_net__send__en [0:1];
  logic [63:0] resp_net__send__msg [0:1];
  logic [0:0] resp_net__send__rdy [0:1];

  XbarMflitRTL__d06fa4a1b21a6061 resp_net
  (
    .clk( resp_net__clk ),
    .reset( resp_net__reset ),
    .recv__en( resp_net__recv__en ),
    .recv__msg( resp_net__recv__msg ),
    .recv__rdy( resp_net__recv__rdy ),
    .send__en( resp_net__send__en ),
    .send__msg( resp_net__send__msg ),
    .send__rdy( resp_net__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component resp_net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ser[0:2]
  //-------------------------------------------------------------

  logic [0:0] ser__clk [0:2];
  logic [1:0] ser__len [0:2];
  logic [0:0] ser__reset [0:2];
  logic [0:0] ser__recv__en [0:2];
  logic [191:0] ser__recv__msg [0:2];
  logic [0:0] ser__recv__rdy [0:2];
  logic [0:0] ser__send__en [0:2];
  logic [63:0] ser__send__msg [0:2];
  logic [0:0] ser__send__rdy [0:2];

  SerializerRTL__out_nbits_64__max_nblocks_3 ser__0
  (
    .clk( ser__clk[0] ),
    .len( ser__len[0] ),
    .reset( ser__reset[0] ),
    .recv__en( ser__recv__en[0] ),
    .recv__msg( ser__recv__msg[0] ),
    .recv__rdy( ser__recv__rdy[0] ),
    .send__en( ser__send__en[0] ),
    .send__msg( ser__send__msg[0] ),
    .send__rdy( ser__send__rdy[0] )
  );

  SerializerRTL__out_nbits_64__max_nblocks_3 ser__1
  (
    .clk( ser__clk[1] ),
    .len( ser__len[1] ),
    .reset( ser__reset[1] ),
    .recv__en( ser__recv__en[1] ),
    .recv__msg( ser__recv__msg[1] ),
    .recv__rdy( ser__recv__rdy[1] ),
    .send__en( ser__send__en[1] ),
    .send__msg( ser__send__msg[1] ),
    .send__rdy( ser__send__rdy[1] )
  );

  SerializerRTL__out_nbits_64__max_nblocks_3 ser__2
  (
    .clk( ser__clk[2] ),
    .len( ser__len[2] ),
    .reset( ser__reset[2] ),
    .recv__en( ser__recv__en[2] ),
    .recv__msg( ser__recv__msg[2] ),
    .recv__rdy( ser__recv__rdy[2] ),
    .send__en( ser__send__en[2] ),
    .send__msg( ser__send__msg[2] ),
    .send__rdy( ser__send__rdy[2] )
  );

  //-------------------------------------------------------------
  // End of component ser[0:2]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/mem_net/MasterMinionXbar.py:67
  // @update
  // def up_length():
  //   for i in range( ncaches ):
  //     s.ser_len[i] @= s.c2net[i].send.msg[18:20] + 1
  //     s.des_len[i] @= s.resp_net.send[i].msg[18:20] + 1
  // 
  //   s.ser_len[ncaches] @= s.m2net.send.msg[18:20] + 1
  //   s.des_len[ncaches] @= s.req_net.send[0].msg[18:20] + 1
  
  always_comb begin : up_length
    for ( int unsigned i = 1'd0; i < 2'( __const__ncaches_at_up_length ); i += 1'd1 ) begin
      ser_len[2'(i)] = c2net__send__msg[1'(i)][8'd19:8'd18] + 2'd1;
      des_len[2'(i)] = resp_net__send__msg[1'(i)][6'd19:6'd18] + 2'd1;
    end
    ser_len[2'( __const__ncaches_at_up_length )] = m2net__send__msg[8'd19:8'd18] + 2'd1;
    des_len[2'( __const__ncaches_at_up_length )] = req_net__send__msg[1'd0][6'd19:6'd18] + 2'd1;
  end

  assign req_net__clk = clk;
  assign req_net__reset = reset;
  assign resp_net__clk = clk;
  assign resp_net__reset = reset;
  assign ser__clk[0] = clk;
  assign ser__reset[0] = reset;
  assign ser__clk[1] = clk;
  assign ser__reset[1] = reset;
  assign ser__clk[2] = clk;
  assign ser__reset[2] = reset;
  assign des__clk[0] = clk;
  assign des__reset[0] = reset;
  assign des__clk[1] = clk;
  assign des__reset[1] = reset;
  assign des__clk[2] = clk;
  assign des__reset[2] = reset;
  assign c2net__clk[0] = clk;
  assign c2net__reset[0] = reset;
  assign c2net__clk[1] = clk;
  assign c2net__reset[1] = reset;
  assign net2m__clk = clk;
  assign net2m__reset = reset;
  assign m2net__clk = clk;
  assign m2net__reset = reset;
  assign net2c__clk[0] = clk;
  assign net2c__reset[0] = reset;
  assign net2c__clk[1] = clk;
  assign net2c__reset[1] = reset;
  assign ser__len[0] = ser_len[0];
  assign des__len[0] = des_len[0];
  assign ser__len[1] = ser_len[1];
  assign des__len[1] = des_len[1];
  assign ser__len[2] = ser_len[2];
  assign des__len[2] = des_len[2];
  assign c2net__recv__en[0] = cache_ifc__req__en[0];
  assign c2net__recv__msg[0] = cache_ifc__req__msg[0];
  assign cache_ifc__req__rdy[0] = c2net__recv__rdy[0];
  assign ser__recv__en[0] = c2net__send__en[0];
  assign ser__recv__msg[0] = c2net__send__msg[0];
  assign c2net__send__rdy[0] = ser__recv__rdy[0];
  assign req_net__recv__en[0] = ser__send__en[0];
  assign req_net__recv__msg[0] = ser__send__msg[0];
  assign ser__send__rdy[0] = req_net__recv__rdy[0];
  assign des__recv__en[0] = resp_net__send__en[0];
  assign des__recv__msg[0] = resp_net__send__msg[0];
  assign resp_net__send__rdy[0] = des__recv__rdy[0];
  assign net2c__recv__en[0] = des__send__en[0];
  assign net2c__recv__msg[0] = des__send__msg[0];
  assign des__send__rdy[0] = net2c__recv__rdy[0];
  assign cache_ifc__resp__en[0] = net2c__send__en[0];
  assign cache_ifc__resp__msg[0] = net2c__send__msg[0];
  assign net2c__send__rdy[0] = cache_ifc__resp__rdy[0];
  assign c2net__recv__en[1] = cache_ifc__req__en[1];
  assign c2net__recv__msg[1] = cache_ifc__req__msg[1];
  assign cache_ifc__req__rdy[1] = c2net__recv__rdy[1];
  assign ser__recv__en[1] = c2net__send__en[1];
  assign ser__recv__msg[1] = c2net__send__msg[1];
  assign c2net__send__rdy[1] = ser__recv__rdy[1];
  assign req_net__recv__en[1] = ser__send__en[1];
  assign req_net__recv__msg[1] = ser__send__msg[1];
  assign ser__send__rdy[1] = req_net__recv__rdy[1];
  assign des__recv__en[1] = resp_net__send__en[1];
  assign des__recv__msg[1] = resp_net__send__msg[1];
  assign resp_net__send__rdy[1] = des__recv__rdy[1];
  assign net2c__recv__en[1] = des__send__en[1];
  assign net2c__recv__msg[1] = des__send__msg[1];
  assign des__send__rdy[1] = net2c__recv__rdy[1];
  assign cache_ifc__resp__en[1] = net2c__send__en[1];
  assign cache_ifc__resp__msg[1] = net2c__send__msg[1];
  assign net2c__send__rdy[1] = cache_ifc__resp__rdy[1];
  assign des__recv__en[2] = req_net__send__en[0];
  assign des__recv__msg[2] = req_net__send__msg[0];
  assign req_net__send__rdy[0] = des__recv__rdy[2];
  assign net2m__recv__en = des__send__en[2];
  assign net2m__recv__msg = des__send__msg[2];
  assign des__send__rdy[2] = net2m__recv__rdy;
  assign mem_ifc__req__en = net2m__send__en;
  assign mem_ifc__req__msg = net2m__send__msg;
  assign net2m__send__rdy = mem_ifc__req__rdy;
  assign m2net__recv__en = mem_ifc__resp__en;
  assign m2net__recv__msg = mem_ifc__resp__msg;
  assign mem_ifc__resp__rdy = m2net__recv__rdy;
  assign ser__recv__en[2] = m2net__send__en;
  assign ser__recv__msg[2] = m2net__send__msg;
  assign m2net__send__rdy = ser__recv__rdy[2];
  assign resp_net__recv__en[0] = ser__send__en[2];
  assign resp_net__recv__msg[0] = ser__send__msg[2];
  assign ser__send__rdy[2] = resp_net__recv__rdy[0];

endmodule


// PyMTL Component AluRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/MiscRTL.py

module AluRTL__nbits_32
(
  input  logic [0:0] clk ,
  input  logic [3:0] fn ,
  input  logic [31:0] in0 ,
  input  logic [31:0] in1 ,
  output logic [0:0] ops_lt ,
  output logic [0:0] ops_ltu ,
  output logic [0:0] ops_ne ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__alu_add  = 4'd1;
  localparam logic [3:0] __const__alu_sub  = 4'd2;
  localparam logic [3:0] __const__alu_sll  = 4'd3;
  localparam logic [3:0] __const__alu_or  = 4'd4;
  localparam logic [3:0] __const__alu_lt  = 4'd5;
  localparam logic [3:0] __const__alu_ltu  = 4'd6;
  localparam logic [3:0] __const__alu_and  = 4'd7;
  localparam logic [3:0] __const__alu_xor  = 4'd8;
  localparam logic [3:0] __const__alu_nor  = 4'd9;
  localparam logic [3:0] __const__alu_srl  = 4'd10;
  localparam logic [3:0] __const__alu_sra  = 4'd11;
  localparam logic [3:0] __const__alu_cp0  = 4'd12;
  localparam logic [3:0] __const__alu_cp1  = 4'd13;
  localparam logic [3:0] __const__alu_adz  = 4'd14;
  logic [32:0] tmp_a;
  logic [63:0] tmp_b;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/MiscRTL.py:80
  // @update
  // def comb_logic():
  //   # default
  //   s.out   @= 0
  //   s.tmp_a @= 0
  //   s.tmp_b @= 0
  // 
  //   if   s.fn == alu_add: s.out @= s.in0 + s.in1                      # ADD
  //   elif s.fn == alu_sub: s.out @= s.in0 - s.in1                      # SUB
  //   elif s.fn == alu_sll: s.out @= s.in0 << zext( s.in1[0:5], dtype ) # SLL
  //   elif s.fn == alu_or : s.out @= s.in0 | s.in1                      # OR
  //   elif s.fn == alu_lt :                                             # LT
  //     s.tmp_a @= sext( s.in0, 33 ) - sext( s.in1, 33 )
  //     s.out   @= zext( s.tmp_a[ 32 ], 32 )
  //   elif s.fn == alu_ltu:                                             # LTU
  //     s.out @= zext( s.in0 < s.in1, 32 )
  //   elif s.fn == alu_and: s.out @= s.in0 & s.in1                      # AND
  //   elif s.fn == alu_xor: s.out @= s.in0 ^ s.in1                      # XOR
  //   elif s.fn == alu_nor: s.out @= ~( s.in0 | s.in1 )                 # NOR
  //   elif s.fn == alu_srl: s.out @= s.in0 >> zext( s.in1[0:5], dtype ) # SRL
  //   elif s.fn == alu_sra:                                             # SRA
  //     s.tmp_b @= sext( s.in0, 64 ) >> zext( s.in1[0:5], 64 )
  //     s.out   @= s.tmp_b[0:32]
  //   elif s.fn == alu_cp0: s.out @= s.in0                              # COPY OP0
  //   elif s.fn == alu_cp1: s.out @= s.in1                              # COPY OP1
  //   elif s.fn == alu_adz:                                             # ADDZ for clearing LSB
  //     s.tmp_b     @= zext( s.in0, 64 ) + zext( s.in1, 64 )
  //     s.out[0]    @= 0
  //     s.out[1:32] @= s.tmp_b[1:32]
  // 
  //   s.ops_ne  @= s.in0 != s.in1
  //   s.ops_lt  @= s.tmp_a[ 32 ]
  //   s.ops_ltu @= s.in0 < s.in1
  
  always_comb begin : comb_logic
    out = 32'd0;
    tmp_a = 33'd0;
    tmp_b = 64'd0;
    if ( fn == 4'( __const__alu_add ) ) begin
      out = in0 + in1;
    end
    else if ( fn == 4'( __const__alu_sub ) ) begin
      out = in0 - in1;
    end
    else if ( fn == 4'( __const__alu_sll ) ) begin
      out = in0 << { { 27 { 1'b0 } }, in1[5'd4:5'd0] };
    end
    else if ( fn == 4'( __const__alu_or ) ) begin
      out = in0 | in1;
    end
    else if ( fn == 4'( __const__alu_lt ) ) begin
      tmp_a = { { 1 { in0[31] } }, in0 } - { { 1 { in1[31] } }, in1 };
      out = { { 31 { 1'b0 } }, tmp_a[6'd32] };
    end
    else if ( fn == 4'( __const__alu_ltu ) ) begin
      out = { { 31 { 1'b0 } }, in0 < in1 };
    end
    else if ( fn == 4'( __const__alu_and ) ) begin
      out = in0 & in1;
    end
    else if ( fn == 4'( __const__alu_xor ) ) begin
      out = in0 ^ in1;
    end
    else if ( fn == 4'( __const__alu_nor ) ) begin
      out = ~( in0 | in1 );
    end
    else if ( fn == 4'( __const__alu_srl ) ) begin
      out = in0 >> { { 27 { 1'b0 } }, in1[5'd4:5'd0] };
    end
    else if ( fn == 4'( __const__alu_sra ) ) begin
      tmp_b = { { 32 { in0[31] } }, in0 } >> { { 59 { 1'b0 } }, in1[5'd4:5'd0] };
      out = tmp_b[6'd31:6'd0];
    end
    else if ( fn == 4'( __const__alu_cp0 ) ) begin
      out = in0;
    end
    else if ( fn == 4'( __const__alu_cp1 ) ) begin
      out = in1;
    end
    else if ( fn == 4'( __const__alu_adz ) ) begin
      tmp_b = { { 32 { 1'b0 } }, in0 } + { { 32 { 1'b0 } }, in1 };
      out[5'd0] = 1'd0;
      out[5'd31:5'd1] = tmp_b[6'd31:6'd1];
    end
    ops_ne = in0 != in1;
    ops_lt = tmp_a[6'd32];
    ops_ltu = in0 < in1;
  end

endmodule


// PyMTL Component Incrementer Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Incrementer__Type_Bits32__amount_4
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__amount_at_up_incrementer  = 3'd4;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:71
  // @update
  // def up_incrementer():
  //   s.out @= s.in_ + amount
  
  always_comb begin : up_incrementer
    out = in_ + 32'( __const__amount_at_up_incrementer );
  end

endmodule


// PyMTL Component TaggedPipeQueue1EntryRTL Definition
// Full name: TaggedPipeQueue1EntryRTL__EntryStruct_I_InstStruct__c61c86abe6488854__ClearBrStruct_ClearBrStruct__ac353fa5f603c6f1__BranchTag_Bits2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedPipeQueue1EntryRTL.py

module TaggedPipeQueue1EntryRTL__bc00a7d41594514f
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output I_InstStruct__c61c86abe6488854 deq__ret  ,
  input logic [0:0] enq__en  ,
  input I_InstStruct__c61c86abe6488854 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  I_InstStruct__c61c86abe6488854 entry;
  logic [0:0] full;
  I_InstStruct__c61c86abe6488854 updated_entry;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedPipeQueue1EntryRTL.py:81
  // @update
  // def up_comb():
  // 
  //   s.enq.rdy @= ~s.full | s.deq.en
  //   s.deq.rdy @= s.full
  // 
  //   #s.updated_entry @= deepcopy( s.entry )
  //   s.updated_entry @= s.entry
  // 
  //   if  s.clear_br.en & \
  //       ( ( s.entry.br_tag & s.clear_br.msg.br_mask ) != 0 ):
  // 
  //     if  s.clear_br.msg.kill:
  //       s.updated_entry.killed @= 1
  //     else:
  //       s.updated_entry.br_tag @= s.entry.br_tag & ~s.clear_br.msg.br_mask
  // 
  //   s.deq.ret @= s.updated_entry
  
  always_comb begin : up_comb
    enq__rdy = ( ~full ) | deq__en;
    deq__rdy = full;
    updated_entry = entry;
    if ( clear_br__en & ( ( entry.br_tag & clear_br__msg.br_mask ) != 2'd0 ) ) begin
      if ( clear_br__msg.kill ) begin
        updated_entry.killed = 1'd1;
      end
      else
        updated_entry.br_tag = entry.br_tag & ( ~clear_br__msg.br_mask );
    end
    deq__ret = updated_entry;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedPipeQueue1EntryRTL.py:56
  // @update_ff
  // def up_states():
  // 
  //   # reset
  //   if    s.reset:
  //     s.full <<= 0
  // 
  //   # enq and deq
  //   elif  s.enq.en & s.deq.en:
  //     s.full  <<= 1
  //     s.entry <<= s.enq.msg
  // 
  //   # not enq and deq
  //   elif  ~s.enq.en & s.deq.en:
  //     s.full <<= 0
  // 
  //   # enq and not deq
  //   elif  s.enq.en & ~s.deq.en:
  //     s.full  <<= 1
  //     s.entry <<= s.enq.msg
  // 
  //   # not enq and not deq
  //   else:
  //     s.entry <<= s.updated_entry
  
  always_ff @(posedge clk) begin : up_states
    if ( reset ) begin
      full <= 1'd0;
    end
    else if ( enq__en & deq__en ) begin
      full <= 1'd1;
      entry <= enq__msg;
    end
    else if ( ( ~enq__en ) & deq__en ) begin
      full <= 1'd0;
    end
    else if ( enq__en & ( ~deq__en ) ) begin
      full <= 1'd1;
      entry <= enq__msg;
    end
    else
      entry <= updated_entry;
  end

endmodule


// PyMTL Component ALUExecuteUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/ALUExecuteUnitRTL.py

module ALUExecuteUnitRTL_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] bypass__en  ,
  output RegWrStruct__preg_idx_7__data_32 bypass__msg  ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] recv_inst__en  ,
  input I_InstStruct__c61c86abe6488854 recv_inst__msg  ,
  output logic [0:0] recv_inst__rdy  ,
  output logic [0:0] resolve_br__en  ,
  output ResolveBranchStruct__7003e9cf5478f896 resolve_br__msg  ,
  output logic [0:0] send_inst__en  ,
  output X_InstStruct__b64b8c5076edb89b send_inst__msg  ,
  input logic [0:0] send_inst__rdy  
);
  localparam logic [1:0] __const__csr_wr  = 2'd2;
  localparam logic [3:0] __const__br_eq  = 4'd4;
  localparam logic [3:0] __const__br_ne  = 4'd1;
  localparam logic [3:0] __const__br_lt  = 4'd2;
  localparam logic [3:0] __const__br_ge  = 4'd5;
  localparam logic [3:0] __const__br_lu  = 4'd3;
  localparam logic [3:0] __const__br_gu  = 4'd6;
  localparam logic [3:0] __const__jalr  = 4'd7;
  localparam logic [3:0] __const__jal  = 4'd8;
  I_InstStruct__c61c86abe6488854 in_msg;
  //-------------------------------------------------------------
  // Component alu
  //-------------------------------------------------------------

  logic [0:0] alu__clk;
  logic [3:0] alu__fn;
  logic [31:0] alu__in0;
  logic [31:0] alu__in1;
  logic [0:0] alu__ops_lt;
  logic [0:0] alu__ops_ltu;
  logic [0:0] alu__ops_ne;
  logic [31:0] alu__out;
  logic [0:0] alu__reset;

  AluRTL__nbits_32 alu
  (
    .clk( alu__clk ),
    .fn( alu__fn ),
    .in0( alu__in0 ),
    .in1( alu__in1 ),
    .ops_lt( alu__ops_lt ),
    .ops_ltu( alu__ops_ltu ),
    .ops_ne( alu__ops_ne ),
    .out( alu__out ),
    .reset( alu__reset )
  );

  //-------------------------------------------------------------
  // End of component alu
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pc_plus4
  //-------------------------------------------------------------

  logic [0:0] pc_plus4__clk;
  logic [31:0] pc_plus4__in_;
  logic [31:0] pc_plus4__out;
  logic [0:0] pc_plus4__reset;

  Incrementer__Type_Bits32__amount_4 pc_plus4
  (
    .clk( pc_plus4__clk ),
    .in_( pc_plus4__in_ ),
    .out( pc_plus4__out ),
    .reset( pc_plus4__reset )
  );

  //-------------------------------------------------------------
  // End of component pc_plus4
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 recv_q__clear_br__msg;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  I_InstStruct__c61c86abe6488854 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  I_InstStruct__c61c86abe6488854 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  TaggedPipeQueue1EntryRTL__bc00a7d41594514f recv_q
  (
    .clk( recv_q__clk ),
    .reset( recv_q__reset ),
    .clear_br__en( recv_q__clear_br__en ),
    .clear_br__msg( recv_q__clear_br__msg ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component res_sel_mux
  //-------------------------------------------------------------

  logic [0:0] res_sel_mux__clk;
  logic [31:0] res_sel_mux__in_ [0:1];
  logic [31:0] res_sel_mux__out;
  logic [0:0] res_sel_mux__reset;
  logic [0:0] res_sel_mux__sel;

  Mux__Type_Bits32__ninputs_2 res_sel_mux
  (
    .clk( res_sel_mux__clk ),
    .in_( res_sel_mux__in_ ),
    .out( res_sel_mux__out ),
    .reset( res_sel_mux__reset ),
    .sel( res_sel_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component res_sel_mux
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/ALUExecuteUnitRTL.py:90
  // s.send_inst.msg.csr_wen     //= lambda: s.in_msg.csr_type == csr_wr
  
  always_comb begin : _lambda__s_procs_0__alu_pipe_send_inst_msg_csr_wen
    send_inst__msg.csr_wen = in_msg.csr_type == 2'( __const__csr_wr );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/ALUExecuteUnitRTL.py:94
  // @update
  // def execute_comb():
  // 
  //   # default
  //   s.recv_q.deq.en               @= 0
  //   s.send_inst.en                @= 0
  //   s.resolve_br.en               @= 0
  //   s.resolve_br.msg.mispredicted @= 0
  //   s.resolve_br.msg.br_target    @= 0
  //   s.bypass.en                   @= 0
  //   s.res_sel_mux.sel             @= 0
  // 
  //   if s.recv_q.deq.rdy & s.send_inst.rdy:
  //     # dequeue in_msg
  //     s.recv_q.deq.en @= 1
  // 
  //     if ~s.recv_q.deq.ret.killed:
  // 
  //       # resolve branches
  //       if    s.in_msg.br_type == br_eq:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= ~s.alu.ops_ne
  //         s.resolve_br.msg.br_target    @= s.in_msg.br_target
  //       elif  s.in_msg.br_type == br_ne:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= s.alu.ops_ne
  //         s.resolve_br.msg.br_target    @= s.in_msg.br_target
  //       elif  s.in_msg.br_type == br_lt:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= s.alu.ops_lt
  //         s.resolve_br.msg.br_target    @= s.in_msg.br_target
  //       elif  s.in_msg.br_type == br_ge:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= ~s.alu.ops_lt
  //         s.resolve_br.msg.br_target    @= s.in_msg.br_target
  //       elif  s.in_msg.br_type == br_lu:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= s.alu.ops_ltu
  //         s.resolve_br.msg.br_target    @= s.in_msg.br_target
  //       elif  s.in_msg.br_type == br_gu:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= ~s.alu.ops_ltu
  //         s.resolve_br.msg.br_target    @= s.in_msg.br_target
  //       elif  s.in_msg.br_type == jalr:
  //         s.resolve_br.en               @= 1
  //         s.resolve_br.msg.mispredicted @= 1
  //         s.resolve_br.msg.br_target    @= s.alu.out
  // 
  //       # for jal and jalr, output is from pc_plus4
  //       if  ( s.in_msg.br_type == jal ) | ( s.in_msg.br_type == jalr ):
  //         s.res_sel_mux.sel @= 1
  // 
  //       # bypass if writing to RF
  //       s.bypass.en @= s.in_msg.rd_en
  // 
  //       # send inst to the next unit
  //       s.send_inst.en @= 1
  
  always_comb begin : execute_comb
    recv_q__deq__en = 1'd0;
    send_inst__en = 1'd0;
    resolve_br__en = 1'd0;
    resolve_br__msg.mispredicted = 1'd0;
    resolve_br__msg.br_target = 32'd0;
    bypass__en = 1'd0;
    res_sel_mux__sel = 1'd0;
    if ( recv_q__deq__rdy & send_inst__rdy ) begin
      recv_q__deq__en = 1'd1;
      if ( ~recv_q__deq__ret.killed ) begin
        if ( in_msg.br_type == 4'( __const__br_eq ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = ~alu__ops_ne;
          resolve_br__msg.br_target = in_msg.br_target;
        end
        else if ( in_msg.br_type == 4'( __const__br_ne ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = alu__ops_ne;
          resolve_br__msg.br_target = in_msg.br_target;
        end
        else if ( in_msg.br_type == 4'( __const__br_lt ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = alu__ops_lt;
          resolve_br__msg.br_target = in_msg.br_target;
        end
        else if ( in_msg.br_type == 4'( __const__br_ge ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = ~alu__ops_lt;
          resolve_br__msg.br_target = in_msg.br_target;
        end
        else if ( in_msg.br_type == 4'( __const__br_lu ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = alu__ops_ltu;
          resolve_br__msg.br_target = in_msg.br_target;
        end
        else if ( in_msg.br_type == 4'( __const__br_gu ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = ~alu__ops_ltu;
          resolve_br__msg.br_target = in_msg.br_target;
        end
        else if ( in_msg.br_type == 4'( __const__jalr ) ) begin
          resolve_br__en = 1'd1;
          resolve_br__msg.mispredicted = 1'd1;
          resolve_br__msg.br_target = alu__out;
        end
        if ( ( in_msg.br_type == 4'( __const__jal ) ) | ( in_msg.br_type == 4'( __const__jalr ) ) ) begin
          res_sel_mux__sel = 1'd1;
        end
        bypass__en = in_msg.rd_en;
        send_inst__en = 1'd1;
      end
    end
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = recv_inst__en;
  assign recv_q__enq__msg = recv_inst__msg;
  assign recv_inst__rdy = recv_q__enq__rdy;
  assign recv_q__clear_br__en = clear_br__en;
  assign recv_q__clear_br__msg = clear_br__msg;
  assign in_msg = recv_q__deq__ret;
  assign pc_plus4__clk = clk;
  assign pc_plus4__reset = reset;
  assign pc_plus4__in_ = in_msg.pc;
  assign alu__clk = clk;
  assign alu__reset = reset;
  assign alu__in0 = in_msg.op1_val;
  assign alu__in1 = in_msg.op2_val;
  assign alu__fn = in_msg.alu_type;
  assign res_sel_mux__clk = clk;
  assign res_sel_mux__reset = reset;
  assign res_sel_mux__in_[0] = alu__out;
  assign res_sel_mux__in_[1] = pc_plus4__out;
  assign resolve_br__msg.br_idx = in_msg.br_idx;
  assign resolve_br__msg.br_tag = in_msg.br_tag;
  assign resolve_br__msg.rob_idx = in_msg.rob_idx;
  assign bypass__msg.preg_idx = in_msg.rd_preg;
  assign bypass__msg.data = res_sel_mux__out;
  assign send_inst__msg.pc = in_msg.pc;
  assign send_inst__msg.inst_val = in_msg.inst_val;
  assign send_inst__msg.br_tag = in_msg.br_tag;
  assign send_inst__msg.rob_idx = in_msg.rob_idx;
  assign send_inst__msg.rd_en = in_msg.rd_en;
  assign send_inst__msg.rd_preg = in_msg.rd_preg;
  assign send_inst__msg.result = res_sel_mux__out;
  assign send_inst__msg.killed = 1'd0;

endmodule


// PyMTL Component CommitUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/CommitUnitRTL.py

module CommitUnitRTL_noparam
(
  input  logic [0:0] clk ,
  output logic [0:0] committed ,
  output logic [31:0] committed_pc ,
  input  logic [0:0] reset ,
  output logic [0:0] commit_csr__en  ,
  output logic [11:0] commit_csr__msg  ,
  input logic [0:0] commit_csr__suc  ,
  output logic [0:0] commit_head__en  ,
  input logic [0:0] commit_head__rdy  ,
  output logic [0:0] free_reg__en  ,
  output logic [6:0] free_reg__msg  ,
  input logic [0:0] free_reg__rdy  ,
  output logic [0:0] get_head__en  ,
  input logic [0:0] get_head__rdy  ,
  input ROBEntry__81cd62f62fe20808 get_head__ret  
);
  localparam logic [1:0] __const__csr_wr  = 2'd2;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/CommitUnitRTL.py:51
  // @update
  // def commit_comb():
  // 
  //   # default
  //   s.get_head.en     @= 0
  //   s.commit_head.en  @= 0
  //   s.free_reg.en     @= 0
  //   s.commit_csr.en   @= 0
  //   s.committed_pc    @= 0
  // 
  //   # inspect the head instruction
  //   if  s.get_head.rdy:
  //     s.get_head.en @= 1
  // 
  //     # ready to commit head inst
  //     if    s.commit_head.rdy:
  // 
  //       # csr write: commit when commit_csr succeeds
  //       if    s.get_head.ret.csr_type == csr_wr:
  //         s.commit_csr.en  @= 1
  //         s.commit_head.en @= s.commit_csr.suc
  // 
  //       # insts writing to RF: commit when free_reg is ready
  //       elif  s.get_head.ret.rf_wen:
  //         if  s.free_reg.rdy:
  //           s.free_reg.en     @= 1
  //           s.commit_head.en  @= 1
  // 
  //       # default: just commit
  //       else:
  //         s.commit_head.en @= 1
  // 
  //       # update committed PC
  //       if s.commit_head.en:
  //         s.committed_pc @= s.get_head.ret.pc
  
  always_comb begin : commit_comb
    get_head__en = 1'd0;
    commit_head__en = 1'd0;
    free_reg__en = 1'd0;
    commit_csr__en = 1'd0;
    committed_pc = 32'd0;
    if ( get_head__rdy ) begin
      get_head__en = 1'd1;
      if ( commit_head__rdy ) begin
        if ( get_head__ret.csr_type == 2'( __const__csr_wr ) ) begin
          commit_csr__en = 1'd1;
          commit_head__en = commit_csr__suc;
        end
        else if ( get_head__ret.rf_wen ) begin
          if ( free_reg__rdy ) begin
            free_reg__en = 1'd1;
            commit_head__en = 1'd1;
          end
        end
        else
          commit_head__en = 1'd1;
        if ( commit_head__en ) begin
          committed_pc = get_head__ret.pc;
        end
      end
    end
  end

  assign free_reg__msg = get_head__ret.rd_ppreg;
  assign commit_csr__msg = get_head__ret.csr_num;
  assign committed = commit_head__en;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits32__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 32'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits32__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 32'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component CSRFlowManagerRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CSRFlowManagerRTL.py

module CSRFlowManagerRTL__numcores_1__coreid_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] committed ,
  input  logic [0:0] go_bit ,
  input  logic [31:0] ntiles ,
  input  logic [0:0] reset ,
  output logic [0:0] stats_en ,
  input  logic [31:0] tile_x ,
  input  logic [31:0] tile_y ,
  input  logic [31:0] tileid ,
  input logic [0:0] commit_csr__en  ,
  input logic [11:0] commit_csr__msg  ,
  output logic [0:0] commit_csr__suc  ,
  input logic [0:0] mngr2proc__en  ,
  input logic [31:0] mngr2proc__msg  ,
  output logic [0:0] mngr2proc__rdy  ,
  output logic [0:0] proc2mngr__en  ,
  output logic [31:0] proc2mngr__msg  ,
  input logic [0:0] proc2mngr__rdy  ,
  input logic [0:0] rd_csr__en  ,
  input logic [11:0] rd_csr__msg  ,
  output logic [31:0] rd_csr__ret  ,
  output logic [0:0] rd_csr__suc  ,
  input logic [0:0] wr_csr__en  ,
  input logic [31:0] wr_csr__msg  
);
  localparam logic [11:0] __const__CSR_STATS_EN  = 12'd1985;
  localparam logic [11:0] __const__CSR_NUMCORES  = 12'd4033;
  localparam logic [11:0] __const__CSR_COREID  = 12'd3860;
  localparam logic [11:0] __const__CSR_NUMTILES  = 12'd4034;
  localparam logic [11:0] __const__CSR_TILEID  = 12'd4035;
  localparam logic [11:0] __const__CSR_TILEX  = 12'd4036;
  localparam logic [11:0] __const__CSR_TILEY  = 12'd4037;
  localparam logic [11:0] __const__CSR_MNGR2PROC  = 12'd4032;
  localparam logic [11:0] __const__CSR_CYCLE  = 12'd3072;
  localparam logic [11:0] __const__CSR_CYCLEH  = 12'd3200;
  localparam logic [11:0] __const__CSR_INSTRET  = 12'd3074;
  localparam logic [11:0] __const__CSR_INSTRETH  = 12'd3202;
  localparam logic [11:0] __const__CSR_PROC2MNGR  = 12'd1984;
  logic [63:0] csr_cycle_reg;
  logic [63:0] csr_instret_reg;
  //-------------------------------------------------------------
  // Component csr_coreid_reg
  //-------------------------------------------------------------

  logic [0:0] csr_coreid_reg__clk;
  logic [0:0] csr_coreid_reg__en;
  logic [31:0] csr_coreid_reg__in_;
  logic [31:0] csr_coreid_reg__out;
  logic [0:0] csr_coreid_reg__reset;

  RegEnRst__Type_Bits32__reset_value_0 csr_coreid_reg
  (
    .clk( csr_coreid_reg__clk ),
    .en( csr_coreid_reg__en ),
    .in_( csr_coreid_reg__in_ ),
    .out( csr_coreid_reg__out ),
    .reset( csr_coreid_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component csr_coreid_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component csr_numcore_reg
  //-------------------------------------------------------------

  logic [0:0] csr_numcore_reg__clk;
  logic [0:0] csr_numcore_reg__en;
  logic [31:0] csr_numcore_reg__in_;
  logic [31:0] csr_numcore_reg__out;
  logic [0:0] csr_numcore_reg__reset;

  RegEnRst__Type_Bits32__reset_value_1 csr_numcore_reg
  (
    .clk( csr_numcore_reg__clk ),
    .en( csr_numcore_reg__en ),
    .in_( csr_numcore_reg__in_ ),
    .out( csr_numcore_reg__out ),
    .reset( csr_numcore_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component csr_numcore_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component csr_stats_en_reg
  //-------------------------------------------------------------

  logic [0:0] csr_stats_en_reg__clk;
  logic [0:0] csr_stats_en_reg__en;
  logic [31:0] csr_stats_en_reg__in_;
  logic [31:0] csr_stats_en_reg__out;
  logic [0:0] csr_stats_en_reg__reset;

  RegEnRst__Type_Bits32__reset_value_0 csr_stats_en_reg
  (
    .clk( csr_stats_en_reg__clk ),
    .en( csr_stats_en_reg__en ),
    .in_( csr_stats_en_reg__in_ ),
    .out( csr_stats_en_reg__out ),
    .reset( csr_stats_en_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component csr_stats_en_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component csr_tmp_value_reg
  //-------------------------------------------------------------

  logic [0:0] csr_tmp_value_reg__clk;
  logic [0:0] csr_tmp_value_reg__en;
  logic [31:0] csr_tmp_value_reg__in_;
  logic [31:0] csr_tmp_value_reg__out;
  logic [0:0] csr_tmp_value_reg__reset;

  RegEn__Type_Bits32 csr_tmp_value_reg
  (
    .clk( csr_tmp_value_reg__clk ),
    .en( csr_tmp_value_reg__en ),
    .in_( csr_tmp_value_reg__in_ ),
    .out( csr_tmp_value_reg__out ),
    .reset( csr_tmp_value_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component csr_tmp_value_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CSRFlowManagerRTL.py:96
  // @update
  // def comb_csr():
  //   # default
  //   s.rd_csr.suc            @= 0
  //   s.rd_csr.ret            @= 0
  // 
  //   s.commit_csr.suc        @= 0
  // 
  //   s.mngr2proc.rdy         @= 0
  //   s.proc2mngr.en          @= 0
  //   s.proc2mngr.msg         @= 0
  // 
  //   s.csr_numcore_reg.en    @= 0
  //   s.csr_coreid_reg.en     @= 0
  //   s.csr_tmp_value_reg.en  @= 0
  //   s.csr_stats_en_reg.en   @= 0
  // 
  //   s.csr_numcore_reg.in_   @= s.csr_numcore_reg.out
  //   s.csr_coreid_reg.in_    @= s.csr_coreid_reg.out
  //   s.csr_tmp_value_reg.in_ @= s.wr_csr.msg
  //   s.csr_stats_en_reg.in_  @= s.csr_tmp_value_reg.out
  // 
  //   #
  //   # read CSR
  //   #
  //   if  s.rd_csr.en:
  // 
  //     # CSR_STATS_EN
  //     if    s.rd_csr.msg == CSR_STATS_EN:
  //       s.rd_csr.ret @= s.csr_stats_en_reg.out
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_NUMCORES
  //     elif  s.rd_csr.msg == CSR_NUMCORES:
  //       s.rd_csr.ret @= s.csr_numcore_reg.out
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_COREID
  //     elif  s.rd_csr.msg == CSR_COREID:
  //       s.rd_csr.ret @= s.csr_coreid_reg.out
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_NUMTILES
  //     elif  s.rd_csr.msg == CSR_NUMTILES:
  //       s.rd_csr.ret @= s.ntiles
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_TILEID
  //     elif  s.rd_csr.msg == CSR_TILEID:
  //       s.rd_csr.ret @= s.tileid
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_TILEX
  //     elif  s.rd_csr.msg == CSR_TILEX:
  //       s.rd_csr.ret @= s.tile_x
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_TILEY
  //     elif  s.rd_csr.msg == CSR_TILEY:
  //       s.rd_csr.ret @= s.tile_y
  //       s.rd_csr.suc @= 1
  // 
  //     # CSR_MNGR2PROC
  //     elif  s.rd_csr.msg == CSR_MNGR2PROC:
  //       s.mngr2proc.rdy @= 1
  //       s.rd_csr.ret    @= s.mngr2proc.msg
  //       s.rd_csr.suc    @= s.mngr2proc.en
  // 
  //     # CSR_CYCLE
  //     elif  s.rd_csr.msg == CSR_CYCLE:
  //       s.rd_csr.ret  @= s.csr_cycle_reg[0:32]
  //       s.rd_csr.suc  @= 1
  // 
  //     # CSR_CYCLEH
  //     elif  s.rd_csr.msg == CSR_CYCLEH:
  //       s.rd_csr.ret  @= s.csr_cycle_reg[32:64]
  //       s.rd_csr.suc  @= 1
  // 
  //     # CSR_INSTRET
  //     elif  s.rd_csr.msg == CSR_INSTRET:
  //       s.rd_csr.ret  @= s.csr_instret_reg[0:32]
  //       s.rd_csr.suc  @= 1
  // 
  //     # CSR_INSTRETH
  //     elif  s.rd_csr.msg == CSR_INSTRETH:
  //       s.rd_csr.ret  @= s.csr_instret_reg[32:64]
  //       s.rd_csr.suc  @= 1
  // 
  //   #
  //   # write CSR: simply write the value into csr_tmp_value_reg
  //   #
  //   elif  s.wr_csr.en:
  //     s.csr_tmp_value_reg.en @= 1
  // 
  //   #
  //   # commit csr: CSR_PROC2MNGR
  //   #
  //   elif  s.commit_csr.en & ( s.commit_csr.msg == CSR_PROC2MNGR ):
  // 
  //     s.commit_csr.suc @= s.proc2mngr.rdy
  //     s.proc2mngr.en   @= s.proc2mngr.rdy
  //     s.proc2mngr.msg  @= s.csr_tmp_value_reg.out
  // 
  //   #
  //   # commit csr: CSR_STATS_EN
  //   #
  //   elif  s.commit_csr.en & ( s.commit_csr.msg == CSR_STATS_EN ):
  // 
  //     s.commit_csr.suc      @= 1
  //     s.csr_stats_en_reg.en @= 1
  
  always_comb begin : comb_csr
    rd_csr__suc = 1'd0;
    rd_csr__ret = 32'd0;
    commit_csr__suc = 1'd0;
    mngr2proc__rdy = 1'd0;
    proc2mngr__en = 1'd0;
    proc2mngr__msg = 32'd0;
    csr_numcore_reg__en = 1'd0;
    csr_coreid_reg__en = 1'd0;
    csr_tmp_value_reg__en = 1'd0;
    csr_stats_en_reg__en = 1'd0;
    csr_numcore_reg__in_ = csr_numcore_reg__out;
    csr_coreid_reg__in_ = csr_coreid_reg__out;
    csr_tmp_value_reg__in_ = wr_csr__msg;
    csr_stats_en_reg__in_ = csr_tmp_value_reg__out;
    if ( rd_csr__en ) begin
      if ( rd_csr__msg == 12'( __const__CSR_STATS_EN ) ) begin
        rd_csr__ret = csr_stats_en_reg__out;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_NUMCORES ) ) begin
        rd_csr__ret = csr_numcore_reg__out;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_COREID ) ) begin
        rd_csr__ret = csr_coreid_reg__out;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_NUMTILES ) ) begin
        rd_csr__ret = ntiles;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_TILEID ) ) begin
        rd_csr__ret = tileid;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_TILEX ) ) begin
        rd_csr__ret = tile_x;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_TILEY ) ) begin
        rd_csr__ret = tile_y;
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_MNGR2PROC ) ) begin
        mngr2proc__rdy = 1'd1;
        rd_csr__ret = mngr2proc__msg;
        rd_csr__suc = mngr2proc__en;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_CYCLE ) ) begin
        rd_csr__ret = csr_cycle_reg[6'd31:6'd0];
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_CYCLEH ) ) begin
        rd_csr__ret = csr_cycle_reg[6'd63:6'd32];
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_INSTRET ) ) begin
        rd_csr__ret = csr_instret_reg[6'd31:6'd0];
        rd_csr__suc = 1'd1;
      end
      else if ( rd_csr__msg == 12'( __const__CSR_INSTRETH ) ) begin
        rd_csr__ret = csr_instret_reg[6'd63:6'd32];
        rd_csr__suc = 1'd1;
      end
    end
    else if ( wr_csr__en ) begin
      csr_tmp_value_reg__en = 1'd1;
    end
    else if ( commit_csr__en & ( commit_csr__msg == 12'( __const__CSR_PROC2MNGR ) ) ) begin
      commit_csr__suc = proc2mngr__rdy;
      proc2mngr__en = proc2mngr__rdy;
      proc2mngr__msg = csr_tmp_value_reg__out;
    end
    else if ( commit_csr__en & ( commit_csr__msg == 12'( __const__CSR_STATS_EN ) ) ) begin
      commit_csr__suc = 1'd1;
      csr_stats_en_reg__en = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CSRFlowManagerRTL.py:83
  // @update_ff
  // def up_counter_csrs():
  //   if s.reset:
  //     s.csr_cycle_reg   <<= 0
  //     s.csr_instret_reg <<= 0
  //   elif s.go_bit:
  //     s.csr_cycle_reg <<= s.csr_cycle_reg + 1
  //     if s.committed:
  //       s.csr_instret_reg <<= s.csr_instret_reg + 1
  
  always_ff @(posedge clk) begin : up_counter_csrs
    if ( reset ) begin
      csr_cycle_reg <= 64'd0;
      csr_instret_reg <= 64'd0;
    end
    else if ( go_bit ) begin
      csr_cycle_reg <= csr_cycle_reg + 64'd1;
      if ( committed ) begin
        csr_instret_reg <= csr_instret_reg + 64'd1;
      end
    end
  end

  assign csr_tmp_value_reg__clk = clk;
  assign csr_tmp_value_reg__reset = reset;
  assign csr_stats_en_reg__clk = clk;
  assign csr_stats_en_reg__reset = reset;
  assign csr_numcore_reg__clk = clk;
  assign csr_numcore_reg__reset = reset;
  assign csr_coreid_reg__clk = clk;
  assign csr_coreid_reg__reset = reset;
  assign stats_en = csr_stats_en_reg__out[0:0];

endmodule


// PyMTL Component EntryAllocatorRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/EntryAllocatorRTL.py

module EntryAllocatorRTL__num_entries_2__EntryIdx_Bits1
(
  input  logic [0:0] clk ,
  output logic [0:0] empty ,
  input  logic [0:0] free [0:1],
  input  logic [0:0] reset ,
  input logic [0:0] allocate__en  ,
  output logic [0:0] allocate__rdy  ,
  output logic [0:0] allocate__ret  
);
  localparam logic [1:0] __const__num_entries_at_up_mask  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_comb  = 2'd2;
  logic [0:0] free_idx;
  logic [1:0] mask;
  logic [1:0] next_mask;
  logic [0:0] __tmpvar__up_comb_idx;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/EntryAllocatorRTL.py:62
  // @update
  // def up_comb():
  //   # empty output
  //   s.empty @= ( s.mask == 2**num_entries - 1 )
  // 
  //   # start with the current mask
  //   s.next_mask @= s.mask
  // 
  //   # free
  //   for i in range( num_entries ):
  //     if s.free[ i ]:
  //       s.next_mask[ i ] @= 1
  // 
  //   # allocate
  //   s.allocate.rdy @= ( s.next_mask != 0 )
  // 
  //   s.free_idx @= 0
  //   if s.allocate.en:
  //     for i in range( num_entries ):
  //       idx = num_entries - 1 - i
  //       if s.next_mask[ idx ]:
  //         s.free_idx @= idx
  //     s.next_mask[ s.free_idx ] @= 0
  // 
  //   s.allocate.ret @= s.free_idx
  
  always_comb begin : up_comb
    empty = mask == ( ( 2'd2 ** 2'( __const__num_entries_at_up_comb ) ) - 2'd1 );
    next_mask = mask;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
      if ( free[1'(i)] ) begin
        next_mask[1'(i)] = 1'd1;
      end
    allocate__rdy = next_mask != 2'd0;
    free_idx = 1'd0;
    if ( allocate__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 ) begin
        __tmpvar__up_comb_idx = ( 2'( __const__num_entries_at_up_comb ) - 2'd1 ) - 1'(i);
        if ( next_mask[1'(__tmpvar__up_comb_idx)] ) begin
          free_idx = 1'(__tmpvar__up_comb_idx);
        end
      end
      next_mask[free_idx] = 1'd0;
    end
    allocate__ret = free_idx;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/EntryAllocatorRTL.py:55
  // @update_ff
  // def up_mask():
  //   if    s.reset:
  //     s.mask <<= 2**num_entries - 1
  //   else:
  //     s.mask <<= s.next_mask
  
  always_ff @(posedge clk) begin : up_mask
    if ( reset ) begin
      mask <= ( 2'd2 ** 2'( __const__num_entries_at_up_mask ) ) - 3'd1;
    end
    else
      mask <= next_mask;
  end

endmodule


// PyMTL Component BranchTableRTL Definition
// Full name: BranchTableRTL__num_entries_2__BranchTag_Bits2__EntryType_BrTableEntry__br_tag_2__ckpt_head_3__EntryIdx_Bits1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/BranchTableRTL.py

module BranchTableRTL__e19387a326f5dc3d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate__en  ,
  input BrTableEntry__br_tag_2__ckpt_head_3 allocate__msg  ,
  output logic [0:0] allocate__rdy  ,
  output logic [0:0] allocate__ret  ,
  input logic [0:0] free__en  ,
  input logic [0:0] free__msg  ,
  input logic [0:0] get__en  ,
  input logic [0:0] get__msg  ,
  output BrTableEntry__br_tag_2__ckpt_head_3 get__ret  ,
  input logic [0:0] kill_entries__en  ,
  input logic [1:0] kill_entries__msg  ,
  input logic [0:0] mask_entries__en  ,
  input logic [1:0] mask_entries__msg  
);
  localparam logic [1:0] __const__num_entries_at_up_ff  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_comb  = 2'd2;
  BrTableEntry__br_tag_2__ckpt_head_3 entry [0:1];
  BrTableEntry__br_tag_2__ckpt_head_3 next_entry [0:1];
  logic [0:0] next_val [0:1];
  logic [0:0] val [0:1];
  //-------------------------------------------------------------
  // Component entry_alloc
  //-------------------------------------------------------------

  logic [0:0] entry_alloc__clk;
  logic [0:0] entry_alloc__empty;
  logic [0:0] entry_alloc__free [0:1];
  logic [0:0] entry_alloc__reset;
  logic [0:0] entry_alloc__allocate__en;
  logic [0:0] entry_alloc__allocate__rdy;
  logic [0:0] entry_alloc__allocate__ret;

  EntryAllocatorRTL__num_entries_2__EntryIdx_Bits1 entry_alloc
  (
    .clk( entry_alloc__clk ),
    .empty( entry_alloc__empty ),
    .free( entry_alloc__free ),
    .reset( entry_alloc__reset ),
    .allocate__en( entry_alloc__allocate__en ),
    .allocate__rdy( entry_alloc__allocate__rdy ),
    .allocate__ret( entry_alloc__allocate__ret )
  );

  //-------------------------------------------------------------
  // End of component entry_alloc
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__up_comb_idx;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/BranchTableRTL.py:75
  // @update
  // def up_comb():
  // 
  //   # default
  //   s.entry_alloc.allocate.en @= 0
  //   for i in range( num_entries ):
  //     s.next_val[ i ]         @= s.val[ i ]
  //     s.next_entry[ i ]       @= s.entry[ i ]
  //     s.entry_alloc.free[ i ] @= 0
  // 
  //   # get
  //   if s.get.en:
  //     s.get.ret @= s.entry[ s.get.msg ]
  //   else:
  //     s.get.ret @= s.entry[ 0 ]
  // 
  //   # free
  //   if s.free.en:
  //     idx = s.free.msg
  //     s.next_val[ idx ]         @= 0
  //     s.entry_alloc.free[ idx ] @= 1
  // 
  //   # Either kill_entries, mask_entries, or allocate can happen at a
  //   # time. They can not be called in parallel
  //   s.allocate.rdy @= ~s.kill_entries.en & \
  //                     ~s.mask_entries.en & \
  //                     s.entry_alloc.allocate.rdy
  //   s.allocate.ret @= s.entry_alloc.allocate.ret
  // 
  //   # kill
  //   if s.kill_entries.en:
  // 
  //     # if valid and matched, invalidate and free this entry
  //     for i in range( num_entries ):
  //       if  s.val[ i ] & ( ( s.entry[ i ].br_tag & s.kill_entries.msg ) != 0 ):
  //         s.next_val[ i ]         @= 0
  //         s.entry_alloc.free[ i ] @= 1
  // 
  //   # clear_br
  //   elif s.mask_entries.en:
  // 
  //     # if valid and matched, clear the masked bit
  //     for i in range( num_entries ):
  //       if  s.val[ i ] & ( ( s.entry[ i ].br_tag & s.mask_entries.msg ) != 0 ):
  //         s.next_entry[ i ].br_tag @= s.entry[ i ].br_tag & ~s.mask_entries.msg
  // 
  //   # allocate
  //   elif s.allocate.en:
  //     s.entry_alloc.allocate.en @= 1
  // 
  //     idx = s.entry_alloc.allocate.ret
  //     s.next_val[ idx ]   @= 1
  //     s.next_entry[ idx ] @= s.allocate.msg
  
  always_comb begin : up_comb
    entry_alloc__allocate__en = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 ) begin
      next_val[1'(i)] = val[1'(i)];
      next_entry[1'(i)] = entry[1'(i)];
      entry_alloc__free[1'(i)] = 1'd0;
    end
    if ( get__en ) begin
      get__ret = entry[get__msg];
    end
    else
      get__ret = entry[1'd0];
    if ( free__en ) begin
      __tmpvar__up_comb_idx = free__msg;
      next_val[__tmpvar__up_comb_idx] = 1'd0;
      entry_alloc__free[__tmpvar__up_comb_idx] = 1'd1;
    end
    allocate__rdy = ( ( ~kill_entries__en ) & ( ~mask_entries__en ) ) & entry_alloc__allocate__rdy;
    allocate__ret = entry_alloc__allocate__ret;
    if ( kill_entries__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
        if ( val[1'(i)] & ( ( entry[1'(i)].br_tag & kill_entries__msg ) != 2'd0 ) ) begin
          next_val[1'(i)] = 1'd0;
          entry_alloc__free[1'(i)] = 1'd1;
        end
    end
    else if ( mask_entries__en ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
        if ( val[1'(i)] & ( ( entry[1'(i)].br_tag & mask_entries__msg ) != 2'd0 ) ) begin
          next_entry[1'(i)].br_tag = entry[1'(i)].br_tag & ( ~mask_entries__msg );
        end
    end
    else if ( allocate__en ) begin
      entry_alloc__allocate__en = 1'd1;
      __tmpvar__up_comb_idx = entry_alloc__allocate__ret;
      next_val[__tmpvar__up_comb_idx] = 1'd1;
      next_entry[__tmpvar__up_comb_idx] = allocate__msg;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/BranchTableRTL.py:63
  // @update_ff
  // def up_ff():
  // 
  //   if s.reset:
  //     for i in range( num_entries ):
  //       s.val[ i ]    <<= 0
  //       s.entry[ i ]  <<= EntryType()
  //   else:
  //     for i in range( num_entries ):
  //       s.val[ i ]    <<= s.next_val[ i ]
  //       s.entry[ i ]  <<= s.next_entry[ i ]
  
  always_ff @(posedge clk) begin : up_ff
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 ) begin
        val[1'(i)] <= 1'd0;
        entry[1'(i)] <= { 2'd0, 3'd0 };
      end
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 ) begin
        val[1'(i)] <= next_val[1'(i)];
        entry[1'(i)] <= next_entry[1'(i)];
      end
  end

  assign entry_alloc__clk = clk;
  assign entry_alloc__reset = reset;

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__EntryType_ClearBrStruct__ac353fa5f603c6f1
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output ClearBrStruct__ac353fa5f603c6f1 deq__ret  ,
  input logic [0:0] enq__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  ClearBrStruct__ac353fa5f603c6f1 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_procs_0__ctrl_flow_clear_back_end_q_q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_procs_0__ctrl_flow_clear_back_end_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// Full name: PipeQueueRTL__EntryType_ClearBrStruct__ac353fa5f603c6f1__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__cf3ca53535e70b70
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output ClearBrStruct__ac353fa5f603c6f1 deq__ret  ,
  input logic [0:0] enq__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  ClearBrStruct__ac353fa5f603c6f1 q__deq__ret;
  logic [0:0] q__enq__en;
  ClearBrStruct__ac353fa5f603c6f1 q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__EntryType_ClearBrStruct__ac353fa5f603c6f1 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component TaggedNormalQueue1EntryRTL Definition
// Full name: TaggedNormalQueue1EntryRTL__EntryStruct_CSRBrTagEntry__br_tag_2__killed_1__ClearBrStruct_ClearBrStruct__ac353fa5f603c6f1__BranchTag_Bits2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedNormalQueue1EntryRTL.py

module TaggedNormalQueue1EntryRTL__12efd344bc568fc2
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output CSRBrTagEntry__br_tag_2__killed_1 deq__ret  ,
  input logic [0:0] enq__en  ,
  input CSRBrTagEntry__br_tag_2__killed_1 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  CSRBrTagEntry__br_tag_2__killed_1 entry;
  logic [0:0] full;
  CSRBrTagEntry__br_tag_2__killed_1 updated_entry;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedNormalQueue1EntryRTL.py:69
  // @update
  // def up_comb():
  // 
  //   s.enq.rdy @= ~s.full
  //   s.deq.rdy @= s.full
  // 
  //   s.updated_entry @= s.entry
  // 
  //   if  s.clear_br.en & \
  //       ( ( s.entry.br_tag & s.clear_br.msg.br_mask ) != 0 ):
  // 
  //     if  s.clear_br.msg.kill:
  //       s.updated_entry.killed @= 1
  //     else:
  //       s.updated_entry.br_tag @= s.entry.br_tag & ~s.clear_br.msg.br_mask
  // 
  //   s.deq.ret @= s.updated_entry
  
  always_comb begin : up_comb
    enq__rdy = ~full;
    deq__rdy = full;
    updated_entry = entry;
    if ( clear_br__en & ( ( entry.br_tag & clear_br__msg.br_mask ) != 2'd0 ) ) begin
      if ( clear_br__msg.kill ) begin
        updated_entry.killed = 1'd1;
      end
      else
        updated_entry.br_tag = entry.br_tag & ( ~clear_br__msg.br_mask );
    end
    deq__ret = updated_entry;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedNormalQueue1EntryRTL.py:56
  // @update_ff
  // def up_states():
  // 
  //   if  s.reset:
  //     s.full  <<= 0
  //   elif  s.enq.en:
  //     s.full  <<= 1
  //     s.entry <<= s.enq.msg
  //   elif  s.deq.en:
  //     s.full  <<= 0
  //   else:
  //     s.entry <<= s.updated_entry
  
  always_ff @(posedge clk) begin : up_states
    if ( reset ) begin
      full <= 1'd0;
    end
    else if ( enq__en ) begin
      full <= 1'd1;
      entry <= enq__msg;
    end
    else if ( deq__en ) begin
      full <= 1'd0;
    end
    else
      entry <= updated_entry;
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_ROBEntry__81cd62f62fe20808
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  ROBEntry__81cd62f62fe20808 in_ ,
  output ROBEntry__81cd62f62fe20808 out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits3__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [2:0] in_ ,
  output logic [2:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 3'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits1__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [0:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 1'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits4__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component ReorderBufferRTL Definition
// Full name: ReorderBufferRTL__num_entries_8__ROBIdx_Bits3__ROBEntry_ROBEntry__81cd62f62fe20808
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/ReorderBufferRTL.py

module ReorderBufferRTL__5a014318295b2d50
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate__en  ,
  input ROBEntry__81cd62f62fe20808 allocate__msg  ,
  output logic [0:0] allocate__rdy  ,
  output logic [2:0] allocate__ret  ,
  input logic [0:0] commit__en  ,
  output logic [0:0] commit__rdy  ,
  input logic [0:0] complete__en  ,
  input logic [2:0] complete__msg  ,
  input logic [0:0] get_head__en  ,
  output logic [0:0] get_head__rdy  ,
  output ROBEntry__81cd62f62fe20808 get_head__ret  ,
  input logic [0:0] rollback__en  ,
  input logic [2:0] rollback__msg  
);
  localparam logic [3:0] __const__num_entries_at_comb  = 4'd8;
  logic [2:0] new_head;
  logic [3:0] new_size;
  logic [2:0] new_tail;
  //-------------------------------------------------------------
  // Component data[0:7]
  //-------------------------------------------------------------

  logic [0:0] data__clk [0:7];
  logic [0:0] data__en [0:7];
  ROBEntry__81cd62f62fe20808 data__in_ [0:7];
  ROBEntry__81cd62f62fe20808 data__out [0:7];
  logic [0:0] data__reset [0:7];

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__0
  (
    .clk( data__clk[0] ),
    .en( data__en[0] ),
    .in_( data__in_[0] ),
    .out( data__out[0] ),
    .reset( data__reset[0] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__1
  (
    .clk( data__clk[1] ),
    .en( data__en[1] ),
    .in_( data__in_[1] ),
    .out( data__out[1] ),
    .reset( data__reset[1] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__2
  (
    .clk( data__clk[2] ),
    .en( data__en[2] ),
    .in_( data__in_[2] ),
    .out( data__out[2] ),
    .reset( data__reset[2] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__3
  (
    .clk( data__clk[3] ),
    .en( data__en[3] ),
    .in_( data__in_[3] ),
    .out( data__out[3] ),
    .reset( data__reset[3] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__4
  (
    .clk( data__clk[4] ),
    .en( data__en[4] ),
    .in_( data__in_[4] ),
    .out( data__out[4] ),
    .reset( data__reset[4] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__5
  (
    .clk( data__clk[5] ),
    .en( data__en[5] ),
    .in_( data__in_[5] ),
    .out( data__out[5] ),
    .reset( data__reset[5] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__6
  (
    .clk( data__clk[6] ),
    .en( data__en[6] ),
    .in_( data__in_[6] ),
    .out( data__out[6] ),
    .reset( data__reset[6] )
  );

  RegEn__Type_ROBEntry__81cd62f62fe20808 data__7
  (
    .clk( data__clk[7] ),
    .en( data__en[7] ),
    .in_( data__in_[7] ),
    .out( data__out[7] ),
    .reset( data__reset[7] )
  );

  //-------------------------------------------------------------
  // End of component data[0:7]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component head_reg
  //-------------------------------------------------------------

  logic [0:0] head_reg__clk;
  logic [0:0] head_reg__en;
  logic [2:0] head_reg__in_;
  logic [2:0] head_reg__out;
  logic [0:0] head_reg__reset;

  RegEnRst__Type_Bits3__reset_value_0 head_reg
  (
    .clk( head_reg__clk ),
    .en( head_reg__en ),
    .in_( head_reg__in_ ),
    .out( head_reg__out ),
    .reset( head_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component head_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pending[0:7]
  //-------------------------------------------------------------

  logic [0:0] pending__clk [0:7];
  logic [0:0] pending__en [0:7];
  logic [0:0] pending__in_ [0:7];
  logic [0:0] pending__out [0:7];
  logic [0:0] pending__reset [0:7];

  RegEnRst__Type_Bits1__reset_value_0 pending__0
  (
    .clk( pending__clk[0] ),
    .en( pending__en[0] ),
    .in_( pending__in_[0] ),
    .out( pending__out[0] ),
    .reset( pending__reset[0] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__1
  (
    .clk( pending__clk[1] ),
    .en( pending__en[1] ),
    .in_( pending__in_[1] ),
    .out( pending__out[1] ),
    .reset( pending__reset[1] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__2
  (
    .clk( pending__clk[2] ),
    .en( pending__en[2] ),
    .in_( pending__in_[2] ),
    .out( pending__out[2] ),
    .reset( pending__reset[2] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__3
  (
    .clk( pending__clk[3] ),
    .en( pending__en[3] ),
    .in_( pending__in_[3] ),
    .out( pending__out[3] ),
    .reset( pending__reset[3] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__4
  (
    .clk( pending__clk[4] ),
    .en( pending__en[4] ),
    .in_( pending__in_[4] ),
    .out( pending__out[4] ),
    .reset( pending__reset[4] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__5
  (
    .clk( pending__clk[5] ),
    .en( pending__en[5] ),
    .in_( pending__in_[5] ),
    .out( pending__out[5] ),
    .reset( pending__reset[5] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__6
  (
    .clk( pending__clk[6] ),
    .en( pending__en[6] ),
    .in_( pending__in_[6] ),
    .out( pending__out[6] ),
    .reset( pending__reset[6] )
  );

  RegEnRst__Type_Bits1__reset_value_0 pending__7
  (
    .clk( pending__clk[7] ),
    .en( pending__en[7] ),
    .in_( pending__in_[7] ),
    .out( pending__out[7] ),
    .reset( pending__reset[7] )
  );

  //-------------------------------------------------------------
  // End of component pending[0:7]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component size_reg
  //-------------------------------------------------------------

  logic [0:0] size_reg__clk;
  logic [0:0] size_reg__en;
  logic [3:0] size_reg__in_;
  logic [3:0] size_reg__out;
  logic [0:0] size_reg__reset;

  RegEnRst__Type_Bits4__reset_value_0 size_reg
  (
    .clk( size_reg__clk ),
    .en( size_reg__en ),
    .in_( size_reg__in_ ),
    .out( size_reg__out ),
    .reset( size_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component size_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tail_reg
  //-------------------------------------------------------------

  logic [0:0] tail_reg__clk;
  logic [0:0] tail_reg__en;
  logic [2:0] tail_reg__in_;
  logic [2:0] tail_reg__out;
  logic [0:0] tail_reg__reset;

  RegEnRst__Type_Bits3__reset_value_0 tail_reg
  (
    .clk( tail_reg__clk ),
    .en( tail_reg__en ),
    .in_( tail_reg__in_ ),
    .out( tail_reg__out ),
    .reset( tail_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component tail_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/ReorderBufferRTL.py:74
  // @update
  // def comb():
  //   # default
  //   s.head_reg.en   @= 0
  //   s.head_reg.in_  @= s.head_reg.out
  //   s.tail_reg.en   @= 0
  //   s.tail_reg.in_  @= s.tail_reg.out
  //   s.size_reg.en   @= 0
  //   s.size_reg.in_  @= s.size_reg.out
  // 
  //   s.get_head.ret  @= s.data[ 0 ].out
  // 
  //   for i in range( num_entries ):
  //     s.data[ i ].en      @= 0
  //     s.data[ i ].in_     @= s.data[ i ].out
  //     s.pending[ i ].en   @= 0
  //     s.pending[ i ].in_  @= s.pending[ i ].out
  // 
  //   # set if allocate should be ready
  //   # NOTE: if the current buffer is full, we don't allow any
  //   # new allocation to take place even if we're committing the head
  //   # inst in the same cycle
  //   # NOTE: if a rollback is ongoing, allocate is not ready
  //   if  s.rollback.en | ( s.size_reg.out == num_entries ):
  //     s.allocate.rdy @= 0
  //   else:
  //     s.allocate.rdy @= 1
  // 
  //   # set if commit should be ready
  //   if  ( s.size_reg.out > 0 ) & \
  //       ( s.pending[ s.head_reg.out ].out == 0 ):
  //     s.commit.rdy @= 1
  //   else:
  //     s.commit.rdy @= 0
  // 
  //   # set if get_head should be ready
  //   if  s.size_reg.out > 0:
  //     s.get_head.rdy @= 1
  //   else:
  //     s.get_head.rdy @= 0
  // 
  //   # new values for head, tail, size
  //   s.new_head @= s.head_reg.out
  //   s.new_tail @= s.tail_reg.out
  //   s.new_size @= s.size_reg.out
  // 
  //   #
  //   # complete
  //   #
  //   if  s.complete.en:
  //     s.pending[ s.complete.msg ].en  @= 1
  //     s.pending[ s.complete.msg ].in_ @= 0
  // 
  //   #
  //   # get_head
  //   #
  //   if  s.get_head.en:
  //     s.get_head.ret @= s.data[ s.head_reg.out ].out
  // 
  //   #
  //   # commit
  //   #
  //   if  s.commit.en:
  // 
  //     # update head
  //     s.head_reg.en @= 1
  //     if s.new_head == num_entries - 1:
  //       s.new_head @= 0
  //     else:
  //       s.new_head @= s.new_head + 1
  // 
  //     # update size
  //     s.size_reg.en @= b1( 1 )
  //     s.new_size    @= s.new_size - 1
  // 
  //   #
  //   # rollback
  //   #
  //   if  s.rollback.en:
  // 
  //     # update tail to the rollback idx + 1
  //     s.tail_reg.en @= 1
  //     s.new_tail    @= s.rollback.msg + 1
  // 
  //     # update size
  //     s.size_reg.en @= 1
  //     if s.new_head < s.new_tail:
  //       s.new_size @= zext( s.new_tail - s.new_head, SizeT )
  //     else:
  //       s.new_size @= num_entries - zext( s.new_head - s.new_tail, SizeT )
  // 
  //   #
  //   # allocate (can't happen concurrently with rollback)
  //   #
  //   elif  s.allocate.en:
  // 
  //     # update tail
  //     s.tail_reg.en @= 1
  //     if  s.new_tail == num_entries - 1:
  //       s.new_tail @= 0
  //     else:
  //       s.new_tail @= s.new_tail + 1
  // 
  //     # update size
  //     s.size_reg.en @= 1
  //     s.new_size    @= s.new_size + 1
  // 
  //     # init the newly allocated entry
  //     s.data[ s.tail_reg.out ].en  @= 1
  //     s.data[ s.tail_reg.out ].in_ @= s.allocate.msg
  // 
  //     # set the pending bit
  //     s.pending[ s.tail_reg.out ].en  @= 1
  //     s.pending[ s.tail_reg.out ].in_ @= 1
  // 
  //   # update head_reg, tail_reg, size_reg
  //   s.head_reg.in_ @= s.new_head
  //   s.tail_reg.in_ @= s.new_tail
  //   s.size_reg.in_ @= s.new_size
  
  always_comb begin : comb
    head_reg__en = 1'd0;
    head_reg__in_ = head_reg__out;
    tail_reg__en = 1'd0;
    tail_reg__in_ = tail_reg__out;
    size_reg__en = 1'd0;
    size_reg__in_ = size_reg__out;
    get_head__ret = data__out[3'd0];
    for ( int unsigned i = 1'd0; i < 4'( __const__num_entries_at_comb ); i += 1'd1 ) begin
      data__en[3'(i)] = 1'd0;
      data__in_[3'(i)] = data__out[3'(i)];
      pending__en[3'(i)] = 1'd0;
      pending__in_[3'(i)] = pending__out[3'(i)];
    end
    if ( rollback__en | ( size_reg__out == 4'( __const__num_entries_at_comb ) ) ) begin
      allocate__rdy = 1'd0;
    end
    else
      allocate__rdy = 1'd1;
    if ( ( size_reg__out > 4'd0 ) & ( pending__out[head_reg__out] == 1'd0 ) ) begin
      commit__rdy = 1'd1;
    end
    else
      commit__rdy = 1'd0;
    if ( size_reg__out > 4'd0 ) begin
      get_head__rdy = 1'd1;
    end
    else
      get_head__rdy = 1'd0;
    new_head = head_reg__out;
    new_tail = tail_reg__out;
    new_size = size_reg__out;
    if ( complete__en ) begin
      pending__en[complete__msg] = 1'd1;
      pending__in_[complete__msg] = 1'd0;
    end
    if ( get_head__en ) begin
      get_head__ret = data__out[head_reg__out];
    end
    if ( commit__en ) begin
      head_reg__en = 1'd1;
      if ( new_head == ( 3'( __const__num_entries_at_comb ) - 3'd1 ) ) begin
        new_head = 3'd0;
      end
      else
        new_head = new_head + 3'd1;
      size_reg__en = 1'd1;
      new_size = new_size - 4'd1;
    end
    if ( rollback__en ) begin
      tail_reg__en = 1'd1;
      new_tail = rollback__msg + 3'd1;
      size_reg__en = 1'd1;
      if ( new_head < new_tail ) begin
        new_size = { { 1 { 1'b0 } }, new_tail - new_head };
      end
      else
        new_size = 4'( __const__num_entries_at_comb ) - { { 1 { 1'b0 } }, new_head - new_tail };
    end
    else if ( allocate__en ) begin
      tail_reg__en = 1'd1;
      if ( new_tail == ( 3'( __const__num_entries_at_comb ) - 3'd1 ) ) begin
        new_tail = 3'd0;
      end
      else
        new_tail = new_tail + 3'd1;
      size_reg__en = 1'd1;
      new_size = new_size + 4'd1;
      data__en[tail_reg__out] = 1'd1;
      data__in_[tail_reg__out] = allocate__msg;
      pending__en[tail_reg__out] = 1'd1;
      pending__in_[tail_reg__out] = 1'd1;
    end
    head_reg__in_ = new_head;
    tail_reg__in_ = new_tail;
    size_reg__in_ = new_size;
  end

  assign head_reg__clk = clk;
  assign head_reg__reset = reset;
  assign tail_reg__clk = clk;
  assign tail_reg__reset = reset;
  assign size_reg__clk = clk;
  assign size_reg__reset = reset;
  assign pending__clk[0] = clk;
  assign pending__reset[0] = reset;
  assign pending__clk[1] = clk;
  assign pending__reset[1] = reset;
  assign pending__clk[2] = clk;
  assign pending__reset[2] = reset;
  assign pending__clk[3] = clk;
  assign pending__reset[3] = reset;
  assign pending__clk[4] = clk;
  assign pending__reset[4] = reset;
  assign pending__clk[5] = clk;
  assign pending__reset[5] = reset;
  assign pending__clk[6] = clk;
  assign pending__reset[6] = reset;
  assign pending__clk[7] = clk;
  assign pending__reset[7] = reset;
  assign data__clk[0] = clk;
  assign data__reset[0] = reset;
  assign data__clk[1] = clk;
  assign data__reset[1] = reset;
  assign data__clk[2] = clk;
  assign data__reset[2] = reset;
  assign data__clk[3] = clk;
  assign data__reset[3] = reset;
  assign data__clk[4] = clk;
  assign data__reset[4] = reset;
  assign data__clk[5] = clk;
  assign data__reset[5] = reset;
  assign data__clk[6] = clk;
  assign data__reset[6] = reset;
  assign data__clk[7] = clk;
  assign data__reset[7] = reset;
  assign allocate__ret = tail_reg__out;

endmodule


// PyMTL Component CtrlFlowManagerRTL Definition
// Full name: CtrlFlowManagerRTL__num_FUs_4__rob_size_8__max_unresolved_branches_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py

module CtrlFlowManagerRTL__c13a272fbad281f0
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] checkpoint__en  ,
  output logic [0:0] checkpoint__msg  ,
  input logic [2:0] checkpoint__ret  ,
  output logic [0:0] clear_back_end__en  ,
  output ClearBrStruct__ac353fa5f603c6f1 clear_back_end__msg  ,
  output logic [0:0] clear_front_end__en  ,
  output ClearBrStruct__ac353fa5f603c6f1 clear_front_end__msg  ,
  input logic [0:0] commit_head__en  ,
  output logic [0:0] commit_head__rdy  ,
  input logic [0:0] complete_inst__en  ,
  input logic [2:0] complete_inst__msg  ,
  input logic [0:0] get_head__en  ,
  output logic [0:0] get_head__rdy  ,
  output ROBEntry__81cd62f62fe20808 get_head__ret  ,
  input logic [0:0] register_inst__en  ,
  input RegInstStruct__496c286c2dc8d523 register_inst__msg  ,
  output RegInstRetStruct__rob_idx_3__br_idx_1__br_tag_2 register_inst__ret  ,
  output logic [0:0] register_inst__suc  ,
  input logic [0:0] resolve_br_D__en  ,
  input ResolveBranchStruct__7003e9cf5478f896 resolve_br_D__msg  ,
  input logic [0:0] resolve_br_X__en  ,
  input ResolveBranchStruct__7003e9cf5478f896 resolve_br_X__msg  ,
  output logic [0:0] rollback__en  ,
  output RollbackStruct__br_idx_1__ckpt_head_3 rollback__msg  
);
  localparam logic [1:0] __const__csr_x  = 2'd0;
  localparam logic [3:0] __const__br_x  = 4'd0;
  localparam logic [3:0] __const__jal  = 4'd8;
  logic [1:0] br_masks [0:1];
  logic [1:0] curr_br_tag;
  logic [1:0] next_br_tag;
  logic [0:0] restoring_br_tag;
  //-------------------------------------------------------------
  // Component br_table
  //-------------------------------------------------------------

  logic [0:0] br_table__clk;
  logic [0:0] br_table__reset;
  logic [0:0] br_table__allocate__en;
  BrTableEntry__br_tag_2__ckpt_head_3 br_table__allocate__msg;
  logic [0:0] br_table__allocate__rdy;
  logic [0:0] br_table__allocate__ret;
  logic [0:0] br_table__free__en;
  logic [0:0] br_table__free__msg;
  logic [0:0] br_table__get__en;
  logic [0:0] br_table__get__msg;
  BrTableEntry__br_tag_2__ckpt_head_3 br_table__get__ret;
  logic [0:0] br_table__kill_entries__en;
  logic [1:0] br_table__kill_entries__msg;
  logic [0:0] br_table__mask_entries__en;
  logic [1:0] br_table__mask_entries__msg;

  BranchTableRTL__e19387a326f5dc3d br_table
  (
    .clk( br_table__clk ),
    .reset( br_table__reset ),
    .allocate__en( br_table__allocate__en ),
    .allocate__msg( br_table__allocate__msg ),
    .allocate__rdy( br_table__allocate__rdy ),
    .allocate__ret( br_table__allocate__ret ),
    .free__en( br_table__free__en ),
    .free__msg( br_table__free__msg ),
    .get__en( br_table__get__en ),
    .get__msg( br_table__get__msg ),
    .get__ret( br_table__get__ret ),
    .kill_entries__en( br_table__kill_entries__en ),
    .kill_entries__msg( br_table__kill_entries__msg ),
    .mask_entries__en( br_table__mask_entries__en ),
    .mask_entries__msg( br_table__mask_entries__msg )
  );

  //-------------------------------------------------------------
  // End of component br_table
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component clear_back_end_q
  //-------------------------------------------------------------

  logic [0:0] clear_back_end_q__clk;
  logic [0:0] clear_back_end_q__count;
  logic [0:0] clear_back_end_q__reset;
  logic [0:0] clear_back_end_q__deq__en;
  logic [0:0] clear_back_end_q__deq__rdy;
  ClearBrStruct__ac353fa5f603c6f1 clear_back_end_q__deq__ret;
  logic [0:0] clear_back_end_q__enq__en;
  ClearBrStruct__ac353fa5f603c6f1 clear_back_end_q__enq__msg;
  logic [0:0] clear_back_end_q__enq__rdy;

  PipeQueueRTL__cf3ca53535e70b70 clear_back_end_q
  (
    .clk( clear_back_end_q__clk ),
    .count( clear_back_end_q__count ),
    .reset( clear_back_end_q__reset ),
    .deq__en( clear_back_end_q__deq__en ),
    .deq__rdy( clear_back_end_q__deq__rdy ),
    .deq__ret( clear_back_end_q__deq__ret ),
    .enq__en( clear_back_end_q__enq__en ),
    .enq__msg( clear_back_end_q__enq__msg ),
    .enq__rdy( clear_back_end_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component clear_back_end_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component clear_front_end_q
  //-------------------------------------------------------------

  logic [0:0] clear_front_end_q__clk;
  logic [0:0] clear_front_end_q__count;
  logic [0:0] clear_front_end_q__reset;
  logic [0:0] clear_front_end_q__deq__en;
  logic [0:0] clear_front_end_q__deq__rdy;
  ClearBrStruct__ac353fa5f603c6f1 clear_front_end_q__deq__ret;
  logic [0:0] clear_front_end_q__enq__en;
  ClearBrStruct__ac353fa5f603c6f1 clear_front_end_q__enq__msg;
  logic [0:0] clear_front_end_q__enq__rdy;

  PipeQueueRTL__cf3ca53535e70b70 clear_front_end_q
  (
    .clk( clear_front_end_q__clk ),
    .count( clear_front_end_q__count ),
    .reset( clear_front_end_q__reset ),
    .deq__en( clear_front_end_q__deq__en ),
    .deq__rdy( clear_front_end_q__deq__rdy ),
    .deq__ret( clear_front_end_q__deq__ret ),
    .enq__en( clear_front_end_q__enq__en ),
    .enq__msg( clear_front_end_q__enq__msg ),
    .enq__rdy( clear_front_end_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component clear_front_end_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component csr_br_tag_q
  //-------------------------------------------------------------

  logic [0:0] csr_br_tag_q__clk;
  logic [0:0] csr_br_tag_q__reset;
  logic [0:0] csr_br_tag_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 csr_br_tag_q__clear_br__msg;
  logic [0:0] csr_br_tag_q__deq__en;
  logic [0:0] csr_br_tag_q__deq__rdy;
  CSRBrTagEntry__br_tag_2__killed_1 csr_br_tag_q__deq__ret;
  logic [0:0] csr_br_tag_q__enq__en;
  CSRBrTagEntry__br_tag_2__killed_1 csr_br_tag_q__enq__msg;
  logic [0:0] csr_br_tag_q__enq__rdy;

  TaggedNormalQueue1EntryRTL__12efd344bc568fc2 csr_br_tag_q
  (
    .clk( csr_br_tag_q__clk ),
    .reset( csr_br_tag_q__reset ),
    .clear_br__en( csr_br_tag_q__clear_br__en ),
    .clear_br__msg( csr_br_tag_q__clear_br__msg ),
    .deq__en( csr_br_tag_q__deq__en ),
    .deq__rdy( csr_br_tag_q__deq__rdy ),
    .deq__ret( csr_br_tag_q__deq__ret ),
    .enq__en( csr_br_tag_q__enq__en ),
    .enq__msg( csr_br_tag_q__enq__msg ),
    .enq__rdy( csr_br_tag_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component csr_br_tag_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rob
  //-------------------------------------------------------------

  logic [0:0] rob__clk;
  logic [0:0] rob__reset;
  logic [0:0] rob__allocate__en;
  ROBEntry__81cd62f62fe20808 rob__allocate__msg;
  logic [0:0] rob__allocate__rdy;
  logic [2:0] rob__allocate__ret;
  logic [0:0] rob__commit__en;
  logic [0:0] rob__commit__rdy;
  logic [0:0] rob__complete__en;
  logic [2:0] rob__complete__msg;
  logic [0:0] rob__get_head__en;
  logic [0:0] rob__get_head__rdy;
  ROBEntry__81cd62f62fe20808 rob__get_head__ret;
  logic [0:0] rob__rollback__en;
  logic [2:0] rob__rollback__msg;

  ReorderBufferRTL__5a014318295b2d50 rob
  (
    .clk( rob__clk ),
    .reset( rob__reset ),
    .allocate__en( rob__allocate__en ),
    .allocate__msg( rob__allocate__msg ),
    .allocate__rdy( rob__allocate__rdy ),
    .allocate__ret( rob__allocate__ret ),
    .commit__en( rob__commit__en ),
    .commit__rdy( rob__commit__rdy ),
    .complete__en( rob__complete__en ),
    .complete__msg( rob__complete__msg ),
    .get_head__en( rob__get_head__en ),
    .get_head__rdy( rob__get_head__rdy ),
    .get_head__ret( rob__get_head__ret ),
    .rollback__en( rob__rollback__en ),
    .rollback__msg( rob__rollback__msg )
  );

  //-------------------------------------------------------------
  // End of component rob
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py:141
  // @update
  // def clear_br():
  // 
  //   # Braodcast clear_br signal rightaway (if any)
  //   s.clear_front_end.en        @= s.clear_front_end_q.deq.rdy
  //   s.clear_front_end_q.deq.en  @= s.clear_front_end_q.deq.rdy
  //   s.clear_front_end.msg       @= s.clear_front_end_q.deq.ret
  // 
  //   s.clear_back_end.en         @= s.clear_back_end_q.deq.rdy
  //   s.clear_back_end_q.deq.en   @= s.clear_back_end_q.deq.rdy
  //   s.clear_back_end.msg        @= s.clear_back_end_q.deq.ret
  // 
  //   s.br_table.free.en          @= 0
  //   s.br_table.free.msg         @= 0
  //   s.br_table.kill_entries.en  @= 0
  //   s.br_table.kill_entries.msg @= 0
  //   s.br_table.mask_entries.en  @= 0
  //   s.br_table.mask_entries.msg @= 0
  // 
  //   s.rollback.en               @= 0
  //   s.rollback.msg.br_idx       @= 0
  //   s.rollback.msg.ckpt_head    @= 0
  //   s.rob.rollback.en           @= 0
  //   s.rob.rollback.msg          @= 0
  // 
  //   s.csr_br_tag_q.clear_br.en  @= 0
  //   s.csr_br_tag_q.clear_br.msg @= ClearBrStruct()
  // 
  //   # If we're clearing the back-end, we need to (1) clear the
  //   # csr_br_tag_q, clear the br_table, rollback dataflow manager and
  //   # ROB (if kill) and update curr_br_tag
  //   if  s.clear_back_end.en:
  // 
  //     # update csr_br_tag_q
  //     s.csr_br_tag_q.clear_br.en  @= 1
  //     s.csr_br_tag_q.clear_br.msg @= s.clear_back_end_q.deq.ret
  // 
  //     # free the entry of this branch in br_table
  //     s.br_table.free.en  @= 1
  //     s.br_table.free.msg @= s.clear_back_end_q.deq.ret.br_idx
  // 
  //     # kill or clear other branches in the br_table depending on
  //     # whether this branch has been mispredicted
  //     s.br_table.kill_entries.en  @= s.clear_back_end_q.deq.ret.kill
  //     s.br_table.kill_entries.msg @= s.clear_back_end_q.deq.ret.br_mask
  //     s.br_table.mask_entries.en  @= ~s.clear_back_end_q.deq.ret.kill
  //     s.br_table.mask_entries.msg @= s.clear_back_end_q.deq.ret.br_mask
  // 
  //     # if this is a kill, need to rollback dataflow manager
  //     if s.clear_back_end_q.deq.ret.kill:
  // 
  //       s.rollback.en             @= 1
  //       s.rollback.msg.br_idx     @= s.clear_back_end_q.deq.ret.br_idx
  //       s.rollback.msg.ckpt_head  @= s.clear_back_end_q.deq.ret.ckpt_head
  //       s.rob.rollback.en         @= 1
  //       s.rob.rollback.msg        @= s.clear_back_end_q.deq.ret.rob_idx
  
  always_comb begin : clear_br
    clear_front_end__en = clear_front_end_q__deq__rdy;
    clear_front_end_q__deq__en = clear_front_end_q__deq__rdy;
    clear_front_end__msg = clear_front_end_q__deq__ret;
    clear_back_end__en = clear_back_end_q__deq__rdy;
    clear_back_end_q__deq__en = clear_back_end_q__deq__rdy;
    clear_back_end__msg = clear_back_end_q__deq__ret;
    br_table__free__en = 1'd0;
    br_table__free__msg = 1'd0;
    br_table__kill_entries__en = 1'd0;
    br_table__kill_entries__msg = 2'd0;
    br_table__mask_entries__en = 1'd0;
    br_table__mask_entries__msg = 2'd0;
    rollback__en = 1'd0;
    rollback__msg.br_idx = 1'd0;
    rollback__msg.ckpt_head = 3'd0;
    rob__rollback__en = 1'd0;
    rob__rollback__msg = 3'd0;
    csr_br_tag_q__clear_br__en = 1'd0;
    csr_br_tag_q__clear_br__msg = { 1'd0, 2'd0, 32'd0, 1'd0, 3'd0, 3'd0, 2'd0 };
    if ( clear_back_end__en ) begin
      csr_br_tag_q__clear_br__en = 1'd1;
      csr_br_tag_q__clear_br__msg = clear_back_end_q__deq__ret;
      br_table__free__en = 1'd1;
      br_table__free__msg = clear_back_end_q__deq__ret.br_idx;
      br_table__kill_entries__en = clear_back_end_q__deq__ret.kill;
      br_table__kill_entries__msg = clear_back_end_q__deq__ret.br_mask;
      br_table__mask_entries__en = ~clear_back_end_q__deq__ret.kill;
      br_table__mask_entries__msg = clear_back_end_q__deq__ret.br_mask;
      if ( clear_back_end_q__deq__ret.kill ) begin
        rollback__en = 1'd1;
        rollback__msg.br_idx = clear_back_end_q__deq__ret.br_idx;
        rollback__msg.ckpt_head = clear_back_end_q__deq__ret.ckpt_head;
        rob__rollback__en = 1'd1;
        rob__rollback__msg = clear_back_end_q__deq__ret.rob_idx;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py:333
  // @update
  // def commit_inst():
  // 
  //   s.rob.commit.en     @= s.commit_head.en
  //   s.rob.complete.en   @= s.complete_inst.en
  //   s.rob.complete.msg  @= s.complete_inst.msg
  //   s.commit_head.rdy   @= s.rob.commit.rdy
  // 
  //   # process csr_br_tag dequeue
  //   if    s.csr_br_tag_q.deq.rdy & s.csr_br_tag_q.deq.ret.killed:
  //     s.csr_br_tag_q.deq.en @= 1
  //   elif  s.commit_head.en & ( s.rob.get_head.ret.csr_type != csr_x ):
  //     s.csr_br_tag_q.deq.en @= 1
  //   else:
  //     s.csr_br_tag_q.deq.en @= 0
  
  always_comb begin : commit_inst
    rob__commit__en = commit_head__en;
    rob__complete__en = complete_inst__en;
    rob__complete__msg = complete_inst__msg;
    commit_head__rdy = rob__commit__rdy;
    if ( csr_br_tag_q__deq__rdy & csr_br_tag_q__deq__ret.killed ) begin
      csr_br_tag_q__deq__en = 1'd1;
    end
    else if ( commit_head__en & ( rob__get_head__ret.csr_type != 2'( __const__csr_x ) ) ) begin
      csr_br_tag_q__deq__en = 1'd1;
    end
    else
      csr_br_tag_q__deq__en = 1'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py:269
  // @update
  // def register_inst():
  // 
  //   s.checkpoint.en               @= 0
  //   s.br_table.allocate.en        @= 0
  //   s.rob.allocate.en             @= 0
  //   s.register_inst.suc           @= 0
  //   s.csr_br_tag_q.enq.en         @= 0
  //   s.csr_br_tag_q.enq.msg.killed @= 0
  // 
  //   # If there is a clear_br on going, we need to use the up-to-date
  //   # branch tag for any newly registered instruction. Otherwise, we
  //   # should use the current branch tag to avoid a new branch
  //   # instruction while updating the curr_br_tag but getting the
  //   # updated tag
  //   if s.clear_back_end.en:
  //     s.br_table.allocate.msg.br_tag @= s.next_br_tag
  //     s.register_inst.ret.br_tag     @= s.next_br_tag
  //     s.csr_br_tag_q.enq.msg.br_tag  @= s.next_br_tag
  //   else:
  //     s.br_table.allocate.msg.br_tag @= s.curr_br_tag
  //     s.register_inst.ret.br_tag     @= s.curr_br_tag
  //     s.csr_br_tag_q.enq.msg.br_tag  @= s.curr_br_tag
  // 
  //   # register new insts
  //   if  s.register_inst.en & s.rob.allocate.rdy:
  // 
  //     # csr instruction
  //     if  s.register_inst.msg.csr_type != csr_x:
  // 
  //       # since there's no renaming for CSRs, we can only allow
  //       # at most one CSR instruction in the back-end at any time
  //       if  s.csr_br_tag_q.enq.rdy:
  //         s.register_inst.suc   @= 1
  //         s.rob.allocate.en     @= 1
  // 
  //         # enqueue the branch tag of this CSR inst into csr_br_tag_q
  //         s.csr_br_tag_q.enq.en @= 1
  // 
  //     # all branches except jal need to allocate an entry in br_table
  //     elif  ( s.register_inst.msg.br_type != br_x ) & \
  //           ( s.register_inst.msg.br_type != jal ):
  // 
  //       if s.br_table.allocate.rdy:
  //         s.register_inst.suc @= 1
  //         s.rob.allocate.en   @= 1
  // 
  //         # add this branch to br_table
  //         s.br_table.allocate.en @= 1
  // 
  //         # checkpoint rename table and free list
  //         s.checkpoint.en @= 1
  // 
  //     # all other instructions
  //     else:
  //       s.register_inst.suc @= 1
  //       s.rob.allocate.en   @= 1
  
  always_comb begin : register_inst
    checkpoint__en = 1'd0;
    br_table__allocate__en = 1'd0;
    rob__allocate__en = 1'd0;
    register_inst__suc = 1'd0;
    csr_br_tag_q__enq__en = 1'd0;
    csr_br_tag_q__enq__msg.killed = 1'd0;
    if ( clear_back_end__en ) begin
      br_table__allocate__msg.br_tag = next_br_tag;
      register_inst__ret.br_tag = next_br_tag;
      csr_br_tag_q__enq__msg.br_tag = next_br_tag;
    end
    else begin
      br_table__allocate__msg.br_tag = curr_br_tag;
      register_inst__ret.br_tag = curr_br_tag;
      csr_br_tag_q__enq__msg.br_tag = curr_br_tag;
    end
    if ( register_inst__en & rob__allocate__rdy ) begin
      if ( register_inst__msg.csr_type != 2'( __const__csr_x ) ) begin
        if ( csr_br_tag_q__enq__rdy ) begin
          register_inst__suc = 1'd1;
          rob__allocate__en = 1'd1;
          csr_br_tag_q__enq__en = 1'd1;
        end
      end
      else if ( ( register_inst__msg.br_type != 4'( __const__br_x ) ) & ( register_inst__msg.br_type != 4'( __const__jal ) ) ) begin
        if ( br_table__allocate__rdy ) begin
          register_inst__suc = 1'd1;
          rob__allocate__en = 1'd1;
          br_table__allocate__en = 1'd1;
          checkpoint__en = 1'd1;
        end
      end
      else begin
        register_inst__suc = 1'd1;
        rob__allocate__en = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py:204
  // @update
  // def resolve_br():
  // 
  //   s.br_table.get.en           @= 0
  //   s.br_table.get.msg          @= 0
  // 
  //   s.clear_front_end_q.enq.en  @= 0
  //   s.clear_front_end_q.enq.msg @= ClearBrStruct()
  // 
  //   s.clear_back_end_q.enq.en   @= 0
  //   s.clear_back_end_q.enq.msg  @= ClearBrStruct()
  // 
  //   #
  //   # resolve a branch in X
  //   #
  //   if  s.resolve_br_X.en:
  // 
  //     # read br_table
  //     s.br_table.get.en  @= 1
  //     s.br_table.get.msg @= s.resolve_br_X.msg.br_idx
  // 
  //     # if this is a mispredicted branch, we need to kill both front-end
  //     # and back-end
  //     if s.resolve_br_X.msg.mispredicted:
  //       s.clear_front_end_q.enq.en              @= 1
  //       s.clear_front_end_q.enq.msg.kill        @= 1
  //       s.clear_front_end_q.enq.msg.pc_redirect @= s.resolve_br_X.msg.br_target
  // 
  //     # clear back-end
  //     s.clear_back_end_q.enq.en               @= 1
  //     s.clear_back_end_q.enq.msg.kill         @= s.resolve_br_X.msg.mispredicted
  //     s.clear_back_end_q.enq.msg.pc_redirect  @= s.resolve_br_X.msg.br_target
  //     s.clear_back_end_q.enq.msg.br_mask      @= s.br_masks[ s.resolve_br_X.msg.br_idx ]
  //     s.clear_back_end_q.enq.msg.br_idx       @= s.resolve_br_X.msg.br_idx
  //     s.clear_back_end_q.enq.msg.ckpt_head    @= s.br_table.get.ret.ckpt_head
  //     s.clear_back_end_q.enq.msg.rob_idx      @= s.resolve_br_X.msg.rob_idx
  //     s.clear_back_end_q.enq.msg.prev_br_tag  @= s.resolve_br_X.msg.br_tag
  // 
  //   #
  //   # resolve a branch in D only if resolve_br_X has not killed D yet
  //   #
  //   if  s.resolve_br_D.en & \
  //       ~( s.resolve_br_X.en & s.resolve_br_X.msg.mispredicted ) & \
  //       s.resolve_br_D.msg.mispredicted:
  //     s.clear_front_end_q.enq.en               @= 1
  //     s.clear_front_end_q.enq.msg.kill         @= 1
  //     s.clear_front_end_q.enq.msg.pc_redirect  @= s.resolve_br_D.msg.br_target
  
  always_comb begin : resolve_br
    br_table__get__en = 1'd0;
    br_table__get__msg = 1'd0;
    clear_front_end_q__enq__en = 1'd0;
    clear_front_end_q__enq__msg = { 1'd0, 2'd0, 32'd0, 1'd0, 3'd0, 3'd0, 2'd0 };
    clear_back_end_q__enq__en = 1'd0;
    clear_back_end_q__enq__msg = { 1'd0, 2'd0, 32'd0, 1'd0, 3'd0, 3'd0, 2'd0 };
    if ( resolve_br_X__en ) begin
      br_table__get__en = 1'd1;
      br_table__get__msg = resolve_br_X__msg.br_idx;
      if ( resolve_br_X__msg.mispredicted ) begin
        clear_front_end_q__enq__en = 1'd1;
        clear_front_end_q__enq__msg.kill = 1'd1;
        clear_front_end_q__enq__msg.pc_redirect = resolve_br_X__msg.br_target;
      end
      clear_back_end_q__enq__en = 1'd1;
      clear_back_end_q__enq__msg.kill = resolve_br_X__msg.mispredicted;
      clear_back_end_q__enq__msg.pc_redirect = resolve_br_X__msg.br_target;
      clear_back_end_q__enq__msg.br_mask = br_masks[resolve_br_X__msg.br_idx];
      clear_back_end_q__enq__msg.br_idx = resolve_br_X__msg.br_idx;
      clear_back_end_q__enq__msg.ckpt_head = br_table__get__ret.ckpt_head;
      clear_back_end_q__enq__msg.rob_idx = resolve_br_X__msg.rob_idx;
      clear_back_end_q__enq__msg.prev_br_tag = resolve_br_X__msg.br_tag;
    end
    if ( ( resolve_br_D__en & ( ~( resolve_br_X__en & resolve_br_X__msg.mispredicted ) ) ) & resolve_br_D__msg.mispredicted ) begin
      clear_front_end_q__enq__en = 1'd1;
      clear_front_end_q__enq__msg.kill = 1'd1;
      clear_front_end_q__enq__msg.pc_redirect = resolve_br_D__msg.br_target;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py:117
  // @update
  // def up_next_br_tag():
  //   # default
  //   s.next_br_tag @= s.curr_br_tag
  // 
  //   if  s.clear_back_end.en:
  // 
  //     # if this is a kill, we need to rollback the previous branch
  //     # otherwise, just mask off the curr tag with  branch mask
  //     if    s.clear_back_end.msg.kill:
  //       s.next_br_tag @= s.clear_back_end_q.deq.ret.prev_br_tag
  //     else:
  //       s.next_br_tag @= s.curr_br_tag & ( ~s.clear_back_end_q.deq.ret.br_mask )
  // 
  //   # a new branch is registered into the br_table
  //   elif  s.br_table.allocate.en:
  //     s.next_br_tag @= ( s.curr_br_tag | s.br_masks[ s.br_table.allocate.ret ] )
  
  always_comb begin : up_next_br_tag
    next_br_tag = curr_br_tag;
    if ( clear_back_end__en ) begin
      if ( clear_back_end__msg.kill ) begin
        next_br_tag = clear_back_end_q__deq__ret.prev_br_tag;
      end
      else
        next_br_tag = curr_br_tag & ( ~clear_back_end_q__deq__ret.br_mask );
    end
    else if ( br_table__allocate__en ) begin
      next_br_tag = curr_br_tag | br_masks[br_table__allocate__ret];
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/CtrlFlowManagerRTL.py:110
  // @update_ff
  // def up_curr_br_tag():
  //   if    s.reset:
  //     s.curr_br_tag <<= 0
  //   else:
  //     s.curr_br_tag <<= s.next_br_tag
  
  always_ff @(posedge clk) begin : up_curr_br_tag
    if ( reset ) begin
      curr_br_tag <= 2'd0;
    end
    else
      curr_br_tag <= next_br_tag;
  end

  assign clear_front_end_q__clk = clk;
  assign clear_front_end_q__reset = reset;
  assign clear_back_end_q__clk = clk;
  assign clear_back_end_q__reset = reset;
  assign rob__clk = clk;
  assign rob__reset = reset;
  assign br_masks[0] = 2'd1;
  assign br_masks[1] = 2'd2;
  assign br_table__clk = clk;
  assign br_table__reset = reset;
  assign csr_br_tag_q__clk = clk;
  assign csr_br_tag_q__reset = reset;
  assign checkpoint__msg = br_table__allocate__ret;
  assign br_table__allocate__msg.ckpt_head = checkpoint__ret;
  assign rob__allocate__msg.inst_val = register_inst__msg.inst_val;
  assign rob__allocate__msg.pc = register_inst__msg.pc;
  assign rob__allocate__msg.rd_ppreg = register_inst__msg.rd_ppreg;
  assign rob__allocate__msg.rf_wen = register_inst__msg.rd_en;
  assign rob__allocate__msg.csr_type = register_inst__msg.csr_type;
  assign rob__allocate__msg.csr_num = register_inst__msg.csr_num;
  assign register_inst__ret.rob_idx = rob__allocate__ret;
  assign register_inst__ret.br_idx = br_table__allocate__ret;
  assign rob__get_head__en = get_head__en;
  assign get_head__rdy = rob__get_head__rdy;
  assign get_head__ret = rob__get_head__ret;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_64
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd64;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_65
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd65;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_66
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd66;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_67
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd67;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_68
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd68;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_69
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd69;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_70
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd70;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_71
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [6:0] __const__reset_value_at_up_regenrst  = 7'd71;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits4__reset_value_8
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd8;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component FreeListRTL Definition
// Full name: FreeListRTL__num_entries_8__num_aregs_64__num_pregs_72__PRegIdx_Bits7__FreeListIdx_Bits3
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/FreeListRTL.py

module FreeListRTL__4463e5d7cec61762
(
  input  logic [0:0] clk ,
  output logic [2:0] head_idx ,
  input  logic [0:0] reset ,
  input logic [0:0] alloc__en  ,
  output logic [0:0] alloc__rdy  ,
  output logic [6:0] alloc__ret  ,
  input logic [0:0] free__en  ,
  input logic [6:0] free__msg  ,
  input logic [0:0] rollback__en  ,
  input logic [2:0] rollback__msg  
);
  localparam logic [3:0] __const__num_entries_at_up  = 4'd8;
  //-------------------------------------------------------------
  // Component head_reg
  //-------------------------------------------------------------

  logic [0:0] head_reg__clk;
  logic [0:0] head_reg__en;
  logic [2:0] head_reg__in_;
  logic [2:0] head_reg__out;
  logic [0:0] head_reg__reset;

  RegEnRst__Type_Bits3__reset_value_0 head_reg
  (
    .clk( head_reg__clk ),
    .en( head_reg__en ),
    .in_( head_reg__in_ ),
    .out( head_reg__out ),
    .reset( head_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component head_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component regs[0:7]
  //-------------------------------------------------------------

  logic [0:0] regs__clk [0:7];
  logic [0:0] regs__en [0:7];
  logic [6:0] regs__in_ [0:7];
  logic [6:0] regs__out [0:7];
  logic [0:0] regs__reset [0:7];

  RegEnRst__Type_Bits7__reset_value_64 regs__0
  (
    .clk( regs__clk[0] ),
    .en( regs__en[0] ),
    .in_( regs__in_[0] ),
    .out( regs__out[0] ),
    .reset( regs__reset[0] )
  );

  RegEnRst__Type_Bits7__reset_value_65 regs__1
  (
    .clk( regs__clk[1] ),
    .en( regs__en[1] ),
    .in_( regs__in_[1] ),
    .out( regs__out[1] ),
    .reset( regs__reset[1] )
  );

  RegEnRst__Type_Bits7__reset_value_66 regs__2
  (
    .clk( regs__clk[2] ),
    .en( regs__en[2] ),
    .in_( regs__in_[2] ),
    .out( regs__out[2] ),
    .reset( regs__reset[2] )
  );

  RegEnRst__Type_Bits7__reset_value_67 regs__3
  (
    .clk( regs__clk[3] ),
    .en( regs__en[3] ),
    .in_( regs__in_[3] ),
    .out( regs__out[3] ),
    .reset( regs__reset[3] )
  );

  RegEnRst__Type_Bits7__reset_value_68 regs__4
  (
    .clk( regs__clk[4] ),
    .en( regs__en[4] ),
    .in_( regs__in_[4] ),
    .out( regs__out[4] ),
    .reset( regs__reset[4] )
  );

  RegEnRst__Type_Bits7__reset_value_69 regs__5
  (
    .clk( regs__clk[5] ),
    .en( regs__en[5] ),
    .in_( regs__in_[5] ),
    .out( regs__out[5] ),
    .reset( regs__reset[5] )
  );

  RegEnRst__Type_Bits7__reset_value_70 regs__6
  (
    .clk( regs__clk[6] ),
    .en( regs__en[6] ),
    .in_( regs__in_[6] ),
    .out( regs__out[6] ),
    .reset( regs__reset[6] )
  );

  RegEnRst__Type_Bits7__reset_value_71 regs__7
  (
    .clk( regs__clk[7] ),
    .en( regs__en[7] ),
    .in_( regs__in_[7] ),
    .out( regs__out[7] ),
    .reset( regs__reset[7] )
  );

  //-------------------------------------------------------------
  // End of component regs[0:7]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component size_reg
  //-------------------------------------------------------------

  logic [0:0] size_reg__clk;
  logic [0:0] size_reg__en;
  logic [3:0] size_reg__in_;
  logic [3:0] size_reg__out;
  logic [0:0] size_reg__reset;

  RegEnRst__Type_Bits4__reset_value_8 size_reg
  (
    .clk( size_reg__clk ),
    .en( size_reg__en ),
    .in_( size_reg__in_ ),
    .out( size_reg__out ),
    .reset( size_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component size_reg
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tail_reg
  //-------------------------------------------------------------

  logic [0:0] tail_reg__clk;
  logic [0:0] tail_reg__en;
  logic [2:0] tail_reg__in_;
  logic [2:0] tail_reg__out;
  logic [0:0] tail_reg__reset;

  RegEnRst__Type_Bits3__reset_value_0 tail_reg
  (
    .clk( tail_reg__clk ),
    .en( tail_reg__en ),
    .in_( tail_reg__in_ ),
    .out( tail_reg__out ),
    .reset( tail_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component tail_reg
  //-------------------------------------------------------------
  logic [2:0] __tmpvar__up_new_head;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/FreeListRTL.py:59
  // @update
  // def up():
  // 
  //   # default
  //   s.head_idx      @= s.head_reg.out
  //   s.head_reg.en   @= 0
  //   s.head_reg.in_  @= s.head_reg.out
  //   s.tail_reg.en   @= 0
  //   s.tail_reg.in_  @= s.tail_reg.out
  //   s.size_reg.en   @= 0
  //   s.size_reg.in_  @= s.size_reg.out
  // 
  //   for i in range( num_entries ):
  //     s.regs[ i ].en  @= 0
  //     s.regs[ i ].in_ @= s.regs[ i ].out
  // 
  //   s.alloc.rdy @= ~s.rollback.en & ( s.size_reg.out > 0 )
  //   s.alloc.ret @= s.regs[ s.head_reg.out ].out
  // 
  //   #
  //   # rollback
  //   #
  //   if  s.rollback.en:
  //     new_head = s.rollback.msg
  // 
  //     # update head_reg
  //     s.head_reg.en  @= 1
  //     s.head_reg.in_ @= new_head
  // 
  //     # update size_reg
  //     s.size_reg.en @= 1
  //     if s.tail_reg.out <= new_head:
  //       s.size_reg.in_ @= num_entries - zext( new_head - s.tail_reg.out, ListSize )
  //     else:
  //       s.size_reg.in_ @= zext( s.tail_reg.out - new_head, ListSize )
  // 
  //     # update head_idx
  //     s.head_idx @= new_head
  // 
  //   #
  //   # no rollback
  //   #
  //   else:
  // 
  //     # alloc
  //     if  s.alloc.en:
  // 
  //       # update head
  //       s.head_reg.en @= 1
  //       if s.head_reg.out == ( num_entries - 1 ):
  //         s.head_reg.in_ @= 0
  //       else:
  //         s.head_reg.in_ @= s.head_reg.out + 1
  // 
  //       # update head_idx
  //       s.head_idx @= s.head_reg.in_
  // 
  //     # free
  //     if  s.free.en:
  // 
  //       # add preg back to the list
  //       s.regs[ s.tail_reg.out ].en  @= 1
  //       s.regs[ s.tail_reg.out ].in_ @= s.free.msg
  // 
  //       # update tail
  //       s.tail_reg.en @= 1
  //       if s.tail_reg.out == num_entries - 1:
  //         s.tail_reg.in_ @= 0
  //       else:
  //         s.tail_reg.in_ @= s.tail_reg.out + 1
  // 
  //     # update size
  //     if    s.alloc.en & ~s.free.en:
  //       s.size_reg.en   @= 1
  //       s.size_reg.in_  @= s.size_reg.out - 1
  //     elif  s.free.en & ~s.alloc.en:
  //       s.size_reg.en   @= 1
  //       s.size_reg.in_  @= s.size_reg.out + 1
  
  always_comb begin : up
    head_idx = head_reg__out;
    head_reg__en = 1'd0;
    head_reg__in_ = head_reg__out;
    tail_reg__en = 1'd0;
    tail_reg__in_ = tail_reg__out;
    size_reg__en = 1'd0;
    size_reg__in_ = size_reg__out;
    for ( int unsigned i = 1'd0; i < 4'( __const__num_entries_at_up ); i += 1'd1 ) begin
      regs__en[3'(i)] = 1'd0;
      regs__in_[3'(i)] = regs__out[3'(i)];
    end
    alloc__rdy = ( ~rollback__en ) & ( size_reg__out > 4'd0 );
    alloc__ret = regs__out[head_reg__out];
    if ( rollback__en ) begin
      __tmpvar__up_new_head = rollback__msg;
      head_reg__en = 1'd1;
      head_reg__in_ = __tmpvar__up_new_head;
      size_reg__en = 1'd1;
      if ( tail_reg__out <= __tmpvar__up_new_head ) begin
        size_reg__in_ = 4'( __const__num_entries_at_up ) - { { 1 { 1'b0 } }, __tmpvar__up_new_head - tail_reg__out };
      end
      else
        size_reg__in_ = { { 1 { 1'b0 } }, tail_reg__out - __tmpvar__up_new_head };
      head_idx = __tmpvar__up_new_head;
    end
    else begin
      if ( alloc__en ) begin
        head_reg__en = 1'd1;
        if ( head_reg__out == ( 3'( __const__num_entries_at_up ) - 3'd1 ) ) begin
          head_reg__in_ = 3'd0;
        end
        else
          head_reg__in_ = head_reg__out + 3'd1;
        head_idx = head_reg__in_;
      end
      if ( free__en ) begin
        regs__en[tail_reg__out] = 1'd1;
        regs__in_[tail_reg__out] = free__msg;
        tail_reg__en = 1'd1;
        if ( tail_reg__out == ( 3'( __const__num_entries_at_up ) - 3'd1 ) ) begin
          tail_reg__in_ = 3'd0;
        end
        else
          tail_reg__in_ = tail_reg__out + 3'd1;
      end
      if ( alloc__en & ( ~free__en ) ) begin
        size_reg__en = 1'd1;
        size_reg__in_ = size_reg__out - 4'd1;
      end
      else if ( free__en & ( ~alloc__en ) ) begin
        size_reg__en = 1'd1;
        size_reg__in_ = size_reg__out + 4'd1;
      end
    end
  end

  assign regs__clk[0] = clk;
  assign regs__reset[0] = reset;
  assign regs__clk[1] = clk;
  assign regs__reset[1] = reset;
  assign regs__clk[2] = clk;
  assign regs__reset[2] = reset;
  assign regs__clk[3] = clk;
  assign regs__reset[3] = reset;
  assign regs__clk[4] = clk;
  assign regs__reset[4] = reset;
  assign regs__clk[5] = clk;
  assign regs__reset[5] = reset;
  assign regs__clk[6] = clk;
  assign regs__reset[6] = reset;
  assign regs__clk[7] = clk;
  assign regs__reset[7] = reset;
  assign head_reg__clk = clk;
  assign head_reg__reset = reset;
  assign tail_reg__clk = clk;
  assign tail_reg__reset = reset;
  assign size_reg__clk = clk;
  assign size_reg__reset = reset;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_10
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd10;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_11
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd11;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_12
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd12;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_13
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd13;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_14
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd14;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_15
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd15;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_16
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd16;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_17
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd17;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_18
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd18;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_19
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd19;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_20
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd20;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_21
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd21;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_22
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd22;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_23
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd23;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_24
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd24;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_25
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd25;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_26
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd26;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_27
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd27;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_28
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd28;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_29
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd29;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__reset_value_at_up_regenrst  = 2'd2;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_30
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd30;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_31
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [4:0] __const__reset_value_at_up_regenrst  = 5'd31;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_32
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd32;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_33
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd33;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_34
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd34;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_35
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd35;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_36
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd36;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_37
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd37;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_38
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd38;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_39
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd39;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_3
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__reset_value_at_up_regenrst  = 2'd3;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_40
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd40;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_41
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd41;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_42
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd42;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_43
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd43;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_44
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd44;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_45
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd45;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_46
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd46;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_47
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd47;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_48
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd48;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_49
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd49;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__reset_value_at_up_regenrst  = 3'd4;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_50
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd50;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_51
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd51;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_52
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd52;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_53
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd53;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_54
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd54;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_55
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd55;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_56
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd56;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_57
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd57;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_58
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd58;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_59
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd59;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_5
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__reset_value_at_up_regenrst  = 3'd5;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_60
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd60;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_61
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd61;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_62
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd62;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_63
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [5:0] __const__reset_value_at_up_regenrst  = 6'd63;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_6
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__reset_value_at_up_regenrst  = 3'd6;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_7
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__reset_value_at_up_regenrst  = 3'd7;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_8
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd8;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits7__reset_value_9
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__reset_value_at_up_regenrst  = 4'd9;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 7'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_Bits7__ninputs_4
(
  input  logic [0:0] clk ,
  input  logic [6:0] in_ [0:3],
  output logic [6:0] out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_Bits7__ninputs_2
(
  input  logic [0:0] clk ,
  input  logic [6:0] in_ [0:1],
  output logic [6:0] out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEn__Type_Bits7
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [6:0] in_ ,
  output logic [6:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RenameTableRTL Definition
// Full name: RenameTableRTL__num_rd_ports_3__num_aregs_64__num_pregs_72__max_unresolved_branches_2__ARegIdx_Bits6__PRegIdx_Bits7__RegIdxPair_RegIdxPair__areg_idx_6__preg_idx_7__BranchIdx_Bits1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/RenameTableRTL.py

module RenameTableRTL__26107974cb1ca85b
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] checkpoint__en  ,
  input logic [0:0] checkpoint__msg  ,
  input logic [0:0] lookup__en [0:2] ,
  input logic [5:0] lookup__msg [0:2] ,
  output logic [6:0] lookup__ret [0:2] ,
  input logic [0:0] rename__en  ,
  input RegIdxPair__areg_idx_6__preg_idx_7 rename__msg  ,
  input logic [0:0] rollback__en  ,
  input logic [0:0] rollback__msg  
);
  localparam logic [1:0] __const__num_sec_tables_at_comb  = 2'd2;
  localparam logic [1:0] __const__num_rd_ports_at_comb  = 2'd3;
  localparam logic [6:0] __const__num_aregs_at_comb  = 7'd64;
  logic [0:0] pri_table_en;
  logic [0:0] sec_table_en [0:1];
  //-------------------------------------------------------------
  // Component pri_table[0:63]
  //-------------------------------------------------------------

  logic [0:0] pri_table__clk [0:63];
  logic [0:0] pri_table__en [0:63];
  logic [6:0] pri_table__in_ [0:63];
  logic [6:0] pri_table__out [0:63];
  logic [0:0] pri_table__reset [0:63];

  RegEnRst__Type_Bits7__reset_value_0 pri_table__0
  (
    .clk( pri_table__clk[0] ),
    .en( pri_table__en[0] ),
    .in_( pri_table__in_[0] ),
    .out( pri_table__out[0] ),
    .reset( pri_table__reset[0] )
  );

  RegEnRst__Type_Bits7__reset_value_1 pri_table__1
  (
    .clk( pri_table__clk[1] ),
    .en( pri_table__en[1] ),
    .in_( pri_table__in_[1] ),
    .out( pri_table__out[1] ),
    .reset( pri_table__reset[1] )
  );

  RegEnRst__Type_Bits7__reset_value_2 pri_table__2
  (
    .clk( pri_table__clk[2] ),
    .en( pri_table__en[2] ),
    .in_( pri_table__in_[2] ),
    .out( pri_table__out[2] ),
    .reset( pri_table__reset[2] )
  );

  RegEnRst__Type_Bits7__reset_value_3 pri_table__3
  (
    .clk( pri_table__clk[3] ),
    .en( pri_table__en[3] ),
    .in_( pri_table__in_[3] ),
    .out( pri_table__out[3] ),
    .reset( pri_table__reset[3] )
  );

  RegEnRst__Type_Bits7__reset_value_4 pri_table__4
  (
    .clk( pri_table__clk[4] ),
    .en( pri_table__en[4] ),
    .in_( pri_table__in_[4] ),
    .out( pri_table__out[4] ),
    .reset( pri_table__reset[4] )
  );

  RegEnRst__Type_Bits7__reset_value_5 pri_table__5
  (
    .clk( pri_table__clk[5] ),
    .en( pri_table__en[5] ),
    .in_( pri_table__in_[5] ),
    .out( pri_table__out[5] ),
    .reset( pri_table__reset[5] )
  );

  RegEnRst__Type_Bits7__reset_value_6 pri_table__6
  (
    .clk( pri_table__clk[6] ),
    .en( pri_table__en[6] ),
    .in_( pri_table__in_[6] ),
    .out( pri_table__out[6] ),
    .reset( pri_table__reset[6] )
  );

  RegEnRst__Type_Bits7__reset_value_7 pri_table__7
  (
    .clk( pri_table__clk[7] ),
    .en( pri_table__en[7] ),
    .in_( pri_table__in_[7] ),
    .out( pri_table__out[7] ),
    .reset( pri_table__reset[7] )
  );

  RegEnRst__Type_Bits7__reset_value_8 pri_table__8
  (
    .clk( pri_table__clk[8] ),
    .en( pri_table__en[8] ),
    .in_( pri_table__in_[8] ),
    .out( pri_table__out[8] ),
    .reset( pri_table__reset[8] )
  );

  RegEnRst__Type_Bits7__reset_value_9 pri_table__9
  (
    .clk( pri_table__clk[9] ),
    .en( pri_table__en[9] ),
    .in_( pri_table__in_[9] ),
    .out( pri_table__out[9] ),
    .reset( pri_table__reset[9] )
  );

  RegEnRst__Type_Bits7__reset_value_10 pri_table__10
  (
    .clk( pri_table__clk[10] ),
    .en( pri_table__en[10] ),
    .in_( pri_table__in_[10] ),
    .out( pri_table__out[10] ),
    .reset( pri_table__reset[10] )
  );

  RegEnRst__Type_Bits7__reset_value_11 pri_table__11
  (
    .clk( pri_table__clk[11] ),
    .en( pri_table__en[11] ),
    .in_( pri_table__in_[11] ),
    .out( pri_table__out[11] ),
    .reset( pri_table__reset[11] )
  );

  RegEnRst__Type_Bits7__reset_value_12 pri_table__12
  (
    .clk( pri_table__clk[12] ),
    .en( pri_table__en[12] ),
    .in_( pri_table__in_[12] ),
    .out( pri_table__out[12] ),
    .reset( pri_table__reset[12] )
  );

  RegEnRst__Type_Bits7__reset_value_13 pri_table__13
  (
    .clk( pri_table__clk[13] ),
    .en( pri_table__en[13] ),
    .in_( pri_table__in_[13] ),
    .out( pri_table__out[13] ),
    .reset( pri_table__reset[13] )
  );

  RegEnRst__Type_Bits7__reset_value_14 pri_table__14
  (
    .clk( pri_table__clk[14] ),
    .en( pri_table__en[14] ),
    .in_( pri_table__in_[14] ),
    .out( pri_table__out[14] ),
    .reset( pri_table__reset[14] )
  );

  RegEnRst__Type_Bits7__reset_value_15 pri_table__15
  (
    .clk( pri_table__clk[15] ),
    .en( pri_table__en[15] ),
    .in_( pri_table__in_[15] ),
    .out( pri_table__out[15] ),
    .reset( pri_table__reset[15] )
  );

  RegEnRst__Type_Bits7__reset_value_16 pri_table__16
  (
    .clk( pri_table__clk[16] ),
    .en( pri_table__en[16] ),
    .in_( pri_table__in_[16] ),
    .out( pri_table__out[16] ),
    .reset( pri_table__reset[16] )
  );

  RegEnRst__Type_Bits7__reset_value_17 pri_table__17
  (
    .clk( pri_table__clk[17] ),
    .en( pri_table__en[17] ),
    .in_( pri_table__in_[17] ),
    .out( pri_table__out[17] ),
    .reset( pri_table__reset[17] )
  );

  RegEnRst__Type_Bits7__reset_value_18 pri_table__18
  (
    .clk( pri_table__clk[18] ),
    .en( pri_table__en[18] ),
    .in_( pri_table__in_[18] ),
    .out( pri_table__out[18] ),
    .reset( pri_table__reset[18] )
  );

  RegEnRst__Type_Bits7__reset_value_19 pri_table__19
  (
    .clk( pri_table__clk[19] ),
    .en( pri_table__en[19] ),
    .in_( pri_table__in_[19] ),
    .out( pri_table__out[19] ),
    .reset( pri_table__reset[19] )
  );

  RegEnRst__Type_Bits7__reset_value_20 pri_table__20
  (
    .clk( pri_table__clk[20] ),
    .en( pri_table__en[20] ),
    .in_( pri_table__in_[20] ),
    .out( pri_table__out[20] ),
    .reset( pri_table__reset[20] )
  );

  RegEnRst__Type_Bits7__reset_value_21 pri_table__21
  (
    .clk( pri_table__clk[21] ),
    .en( pri_table__en[21] ),
    .in_( pri_table__in_[21] ),
    .out( pri_table__out[21] ),
    .reset( pri_table__reset[21] )
  );

  RegEnRst__Type_Bits7__reset_value_22 pri_table__22
  (
    .clk( pri_table__clk[22] ),
    .en( pri_table__en[22] ),
    .in_( pri_table__in_[22] ),
    .out( pri_table__out[22] ),
    .reset( pri_table__reset[22] )
  );

  RegEnRst__Type_Bits7__reset_value_23 pri_table__23
  (
    .clk( pri_table__clk[23] ),
    .en( pri_table__en[23] ),
    .in_( pri_table__in_[23] ),
    .out( pri_table__out[23] ),
    .reset( pri_table__reset[23] )
  );

  RegEnRst__Type_Bits7__reset_value_24 pri_table__24
  (
    .clk( pri_table__clk[24] ),
    .en( pri_table__en[24] ),
    .in_( pri_table__in_[24] ),
    .out( pri_table__out[24] ),
    .reset( pri_table__reset[24] )
  );

  RegEnRst__Type_Bits7__reset_value_25 pri_table__25
  (
    .clk( pri_table__clk[25] ),
    .en( pri_table__en[25] ),
    .in_( pri_table__in_[25] ),
    .out( pri_table__out[25] ),
    .reset( pri_table__reset[25] )
  );

  RegEnRst__Type_Bits7__reset_value_26 pri_table__26
  (
    .clk( pri_table__clk[26] ),
    .en( pri_table__en[26] ),
    .in_( pri_table__in_[26] ),
    .out( pri_table__out[26] ),
    .reset( pri_table__reset[26] )
  );

  RegEnRst__Type_Bits7__reset_value_27 pri_table__27
  (
    .clk( pri_table__clk[27] ),
    .en( pri_table__en[27] ),
    .in_( pri_table__in_[27] ),
    .out( pri_table__out[27] ),
    .reset( pri_table__reset[27] )
  );

  RegEnRst__Type_Bits7__reset_value_28 pri_table__28
  (
    .clk( pri_table__clk[28] ),
    .en( pri_table__en[28] ),
    .in_( pri_table__in_[28] ),
    .out( pri_table__out[28] ),
    .reset( pri_table__reset[28] )
  );

  RegEnRst__Type_Bits7__reset_value_29 pri_table__29
  (
    .clk( pri_table__clk[29] ),
    .en( pri_table__en[29] ),
    .in_( pri_table__in_[29] ),
    .out( pri_table__out[29] ),
    .reset( pri_table__reset[29] )
  );

  RegEnRst__Type_Bits7__reset_value_30 pri_table__30
  (
    .clk( pri_table__clk[30] ),
    .en( pri_table__en[30] ),
    .in_( pri_table__in_[30] ),
    .out( pri_table__out[30] ),
    .reset( pri_table__reset[30] )
  );

  RegEnRst__Type_Bits7__reset_value_31 pri_table__31
  (
    .clk( pri_table__clk[31] ),
    .en( pri_table__en[31] ),
    .in_( pri_table__in_[31] ),
    .out( pri_table__out[31] ),
    .reset( pri_table__reset[31] )
  );

  RegEnRst__Type_Bits7__reset_value_32 pri_table__32
  (
    .clk( pri_table__clk[32] ),
    .en( pri_table__en[32] ),
    .in_( pri_table__in_[32] ),
    .out( pri_table__out[32] ),
    .reset( pri_table__reset[32] )
  );

  RegEnRst__Type_Bits7__reset_value_33 pri_table__33
  (
    .clk( pri_table__clk[33] ),
    .en( pri_table__en[33] ),
    .in_( pri_table__in_[33] ),
    .out( pri_table__out[33] ),
    .reset( pri_table__reset[33] )
  );

  RegEnRst__Type_Bits7__reset_value_34 pri_table__34
  (
    .clk( pri_table__clk[34] ),
    .en( pri_table__en[34] ),
    .in_( pri_table__in_[34] ),
    .out( pri_table__out[34] ),
    .reset( pri_table__reset[34] )
  );

  RegEnRst__Type_Bits7__reset_value_35 pri_table__35
  (
    .clk( pri_table__clk[35] ),
    .en( pri_table__en[35] ),
    .in_( pri_table__in_[35] ),
    .out( pri_table__out[35] ),
    .reset( pri_table__reset[35] )
  );

  RegEnRst__Type_Bits7__reset_value_36 pri_table__36
  (
    .clk( pri_table__clk[36] ),
    .en( pri_table__en[36] ),
    .in_( pri_table__in_[36] ),
    .out( pri_table__out[36] ),
    .reset( pri_table__reset[36] )
  );

  RegEnRst__Type_Bits7__reset_value_37 pri_table__37
  (
    .clk( pri_table__clk[37] ),
    .en( pri_table__en[37] ),
    .in_( pri_table__in_[37] ),
    .out( pri_table__out[37] ),
    .reset( pri_table__reset[37] )
  );

  RegEnRst__Type_Bits7__reset_value_38 pri_table__38
  (
    .clk( pri_table__clk[38] ),
    .en( pri_table__en[38] ),
    .in_( pri_table__in_[38] ),
    .out( pri_table__out[38] ),
    .reset( pri_table__reset[38] )
  );

  RegEnRst__Type_Bits7__reset_value_39 pri_table__39
  (
    .clk( pri_table__clk[39] ),
    .en( pri_table__en[39] ),
    .in_( pri_table__in_[39] ),
    .out( pri_table__out[39] ),
    .reset( pri_table__reset[39] )
  );

  RegEnRst__Type_Bits7__reset_value_40 pri_table__40
  (
    .clk( pri_table__clk[40] ),
    .en( pri_table__en[40] ),
    .in_( pri_table__in_[40] ),
    .out( pri_table__out[40] ),
    .reset( pri_table__reset[40] )
  );

  RegEnRst__Type_Bits7__reset_value_41 pri_table__41
  (
    .clk( pri_table__clk[41] ),
    .en( pri_table__en[41] ),
    .in_( pri_table__in_[41] ),
    .out( pri_table__out[41] ),
    .reset( pri_table__reset[41] )
  );

  RegEnRst__Type_Bits7__reset_value_42 pri_table__42
  (
    .clk( pri_table__clk[42] ),
    .en( pri_table__en[42] ),
    .in_( pri_table__in_[42] ),
    .out( pri_table__out[42] ),
    .reset( pri_table__reset[42] )
  );

  RegEnRst__Type_Bits7__reset_value_43 pri_table__43
  (
    .clk( pri_table__clk[43] ),
    .en( pri_table__en[43] ),
    .in_( pri_table__in_[43] ),
    .out( pri_table__out[43] ),
    .reset( pri_table__reset[43] )
  );

  RegEnRst__Type_Bits7__reset_value_44 pri_table__44
  (
    .clk( pri_table__clk[44] ),
    .en( pri_table__en[44] ),
    .in_( pri_table__in_[44] ),
    .out( pri_table__out[44] ),
    .reset( pri_table__reset[44] )
  );

  RegEnRst__Type_Bits7__reset_value_45 pri_table__45
  (
    .clk( pri_table__clk[45] ),
    .en( pri_table__en[45] ),
    .in_( pri_table__in_[45] ),
    .out( pri_table__out[45] ),
    .reset( pri_table__reset[45] )
  );

  RegEnRst__Type_Bits7__reset_value_46 pri_table__46
  (
    .clk( pri_table__clk[46] ),
    .en( pri_table__en[46] ),
    .in_( pri_table__in_[46] ),
    .out( pri_table__out[46] ),
    .reset( pri_table__reset[46] )
  );

  RegEnRst__Type_Bits7__reset_value_47 pri_table__47
  (
    .clk( pri_table__clk[47] ),
    .en( pri_table__en[47] ),
    .in_( pri_table__in_[47] ),
    .out( pri_table__out[47] ),
    .reset( pri_table__reset[47] )
  );

  RegEnRst__Type_Bits7__reset_value_48 pri_table__48
  (
    .clk( pri_table__clk[48] ),
    .en( pri_table__en[48] ),
    .in_( pri_table__in_[48] ),
    .out( pri_table__out[48] ),
    .reset( pri_table__reset[48] )
  );

  RegEnRst__Type_Bits7__reset_value_49 pri_table__49
  (
    .clk( pri_table__clk[49] ),
    .en( pri_table__en[49] ),
    .in_( pri_table__in_[49] ),
    .out( pri_table__out[49] ),
    .reset( pri_table__reset[49] )
  );

  RegEnRst__Type_Bits7__reset_value_50 pri_table__50
  (
    .clk( pri_table__clk[50] ),
    .en( pri_table__en[50] ),
    .in_( pri_table__in_[50] ),
    .out( pri_table__out[50] ),
    .reset( pri_table__reset[50] )
  );

  RegEnRst__Type_Bits7__reset_value_51 pri_table__51
  (
    .clk( pri_table__clk[51] ),
    .en( pri_table__en[51] ),
    .in_( pri_table__in_[51] ),
    .out( pri_table__out[51] ),
    .reset( pri_table__reset[51] )
  );

  RegEnRst__Type_Bits7__reset_value_52 pri_table__52
  (
    .clk( pri_table__clk[52] ),
    .en( pri_table__en[52] ),
    .in_( pri_table__in_[52] ),
    .out( pri_table__out[52] ),
    .reset( pri_table__reset[52] )
  );

  RegEnRst__Type_Bits7__reset_value_53 pri_table__53
  (
    .clk( pri_table__clk[53] ),
    .en( pri_table__en[53] ),
    .in_( pri_table__in_[53] ),
    .out( pri_table__out[53] ),
    .reset( pri_table__reset[53] )
  );

  RegEnRst__Type_Bits7__reset_value_54 pri_table__54
  (
    .clk( pri_table__clk[54] ),
    .en( pri_table__en[54] ),
    .in_( pri_table__in_[54] ),
    .out( pri_table__out[54] ),
    .reset( pri_table__reset[54] )
  );

  RegEnRst__Type_Bits7__reset_value_55 pri_table__55
  (
    .clk( pri_table__clk[55] ),
    .en( pri_table__en[55] ),
    .in_( pri_table__in_[55] ),
    .out( pri_table__out[55] ),
    .reset( pri_table__reset[55] )
  );

  RegEnRst__Type_Bits7__reset_value_56 pri_table__56
  (
    .clk( pri_table__clk[56] ),
    .en( pri_table__en[56] ),
    .in_( pri_table__in_[56] ),
    .out( pri_table__out[56] ),
    .reset( pri_table__reset[56] )
  );

  RegEnRst__Type_Bits7__reset_value_57 pri_table__57
  (
    .clk( pri_table__clk[57] ),
    .en( pri_table__en[57] ),
    .in_( pri_table__in_[57] ),
    .out( pri_table__out[57] ),
    .reset( pri_table__reset[57] )
  );

  RegEnRst__Type_Bits7__reset_value_58 pri_table__58
  (
    .clk( pri_table__clk[58] ),
    .en( pri_table__en[58] ),
    .in_( pri_table__in_[58] ),
    .out( pri_table__out[58] ),
    .reset( pri_table__reset[58] )
  );

  RegEnRst__Type_Bits7__reset_value_59 pri_table__59
  (
    .clk( pri_table__clk[59] ),
    .en( pri_table__en[59] ),
    .in_( pri_table__in_[59] ),
    .out( pri_table__out[59] ),
    .reset( pri_table__reset[59] )
  );

  RegEnRst__Type_Bits7__reset_value_60 pri_table__60
  (
    .clk( pri_table__clk[60] ),
    .en( pri_table__en[60] ),
    .in_( pri_table__in_[60] ),
    .out( pri_table__out[60] ),
    .reset( pri_table__reset[60] )
  );

  RegEnRst__Type_Bits7__reset_value_61 pri_table__61
  (
    .clk( pri_table__clk[61] ),
    .en( pri_table__en[61] ),
    .in_( pri_table__in_[61] ),
    .out( pri_table__out[61] ),
    .reset( pri_table__reset[61] )
  );

  RegEnRst__Type_Bits7__reset_value_62 pri_table__62
  (
    .clk( pri_table__clk[62] ),
    .en( pri_table__en[62] ),
    .in_( pri_table__in_[62] ),
    .out( pri_table__out[62] ),
    .reset( pri_table__reset[62] )
  );

  RegEnRst__Type_Bits7__reset_value_63 pri_table__63
  (
    .clk( pri_table__clk[63] ),
    .en( pri_table__en[63] ),
    .in_( pri_table__in_[63] ),
    .out( pri_table__out[63] ),
    .reset( pri_table__reset[63] )
  );

  //-------------------------------------------------------------
  // End of component pri_table[0:63]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pri_table_muxes[0:63]
  //-------------------------------------------------------------

  logic [0:0] pri_table_muxes__clk [0:63];
  logic [6:0] pri_table_muxes__in_ [0:63][0:3];
  logic [6:0] pri_table_muxes__out [0:63];
  logic [0:0] pri_table_muxes__reset [0:63];
  logic [1:0] pri_table_muxes__sel [0:63];

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__0
  (
    .clk( pri_table_muxes__clk[0] ),
    .in_( pri_table_muxes__in_[0] ),
    .out( pri_table_muxes__out[0] ),
    .reset( pri_table_muxes__reset[0] ),
    .sel( pri_table_muxes__sel[0] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__1
  (
    .clk( pri_table_muxes__clk[1] ),
    .in_( pri_table_muxes__in_[1] ),
    .out( pri_table_muxes__out[1] ),
    .reset( pri_table_muxes__reset[1] ),
    .sel( pri_table_muxes__sel[1] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__2
  (
    .clk( pri_table_muxes__clk[2] ),
    .in_( pri_table_muxes__in_[2] ),
    .out( pri_table_muxes__out[2] ),
    .reset( pri_table_muxes__reset[2] ),
    .sel( pri_table_muxes__sel[2] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__3
  (
    .clk( pri_table_muxes__clk[3] ),
    .in_( pri_table_muxes__in_[3] ),
    .out( pri_table_muxes__out[3] ),
    .reset( pri_table_muxes__reset[3] ),
    .sel( pri_table_muxes__sel[3] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__4
  (
    .clk( pri_table_muxes__clk[4] ),
    .in_( pri_table_muxes__in_[4] ),
    .out( pri_table_muxes__out[4] ),
    .reset( pri_table_muxes__reset[4] ),
    .sel( pri_table_muxes__sel[4] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__5
  (
    .clk( pri_table_muxes__clk[5] ),
    .in_( pri_table_muxes__in_[5] ),
    .out( pri_table_muxes__out[5] ),
    .reset( pri_table_muxes__reset[5] ),
    .sel( pri_table_muxes__sel[5] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__6
  (
    .clk( pri_table_muxes__clk[6] ),
    .in_( pri_table_muxes__in_[6] ),
    .out( pri_table_muxes__out[6] ),
    .reset( pri_table_muxes__reset[6] ),
    .sel( pri_table_muxes__sel[6] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__7
  (
    .clk( pri_table_muxes__clk[7] ),
    .in_( pri_table_muxes__in_[7] ),
    .out( pri_table_muxes__out[7] ),
    .reset( pri_table_muxes__reset[7] ),
    .sel( pri_table_muxes__sel[7] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__8
  (
    .clk( pri_table_muxes__clk[8] ),
    .in_( pri_table_muxes__in_[8] ),
    .out( pri_table_muxes__out[8] ),
    .reset( pri_table_muxes__reset[8] ),
    .sel( pri_table_muxes__sel[8] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__9
  (
    .clk( pri_table_muxes__clk[9] ),
    .in_( pri_table_muxes__in_[9] ),
    .out( pri_table_muxes__out[9] ),
    .reset( pri_table_muxes__reset[9] ),
    .sel( pri_table_muxes__sel[9] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__10
  (
    .clk( pri_table_muxes__clk[10] ),
    .in_( pri_table_muxes__in_[10] ),
    .out( pri_table_muxes__out[10] ),
    .reset( pri_table_muxes__reset[10] ),
    .sel( pri_table_muxes__sel[10] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__11
  (
    .clk( pri_table_muxes__clk[11] ),
    .in_( pri_table_muxes__in_[11] ),
    .out( pri_table_muxes__out[11] ),
    .reset( pri_table_muxes__reset[11] ),
    .sel( pri_table_muxes__sel[11] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__12
  (
    .clk( pri_table_muxes__clk[12] ),
    .in_( pri_table_muxes__in_[12] ),
    .out( pri_table_muxes__out[12] ),
    .reset( pri_table_muxes__reset[12] ),
    .sel( pri_table_muxes__sel[12] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__13
  (
    .clk( pri_table_muxes__clk[13] ),
    .in_( pri_table_muxes__in_[13] ),
    .out( pri_table_muxes__out[13] ),
    .reset( pri_table_muxes__reset[13] ),
    .sel( pri_table_muxes__sel[13] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__14
  (
    .clk( pri_table_muxes__clk[14] ),
    .in_( pri_table_muxes__in_[14] ),
    .out( pri_table_muxes__out[14] ),
    .reset( pri_table_muxes__reset[14] ),
    .sel( pri_table_muxes__sel[14] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__15
  (
    .clk( pri_table_muxes__clk[15] ),
    .in_( pri_table_muxes__in_[15] ),
    .out( pri_table_muxes__out[15] ),
    .reset( pri_table_muxes__reset[15] ),
    .sel( pri_table_muxes__sel[15] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__16
  (
    .clk( pri_table_muxes__clk[16] ),
    .in_( pri_table_muxes__in_[16] ),
    .out( pri_table_muxes__out[16] ),
    .reset( pri_table_muxes__reset[16] ),
    .sel( pri_table_muxes__sel[16] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__17
  (
    .clk( pri_table_muxes__clk[17] ),
    .in_( pri_table_muxes__in_[17] ),
    .out( pri_table_muxes__out[17] ),
    .reset( pri_table_muxes__reset[17] ),
    .sel( pri_table_muxes__sel[17] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__18
  (
    .clk( pri_table_muxes__clk[18] ),
    .in_( pri_table_muxes__in_[18] ),
    .out( pri_table_muxes__out[18] ),
    .reset( pri_table_muxes__reset[18] ),
    .sel( pri_table_muxes__sel[18] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__19
  (
    .clk( pri_table_muxes__clk[19] ),
    .in_( pri_table_muxes__in_[19] ),
    .out( pri_table_muxes__out[19] ),
    .reset( pri_table_muxes__reset[19] ),
    .sel( pri_table_muxes__sel[19] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__20
  (
    .clk( pri_table_muxes__clk[20] ),
    .in_( pri_table_muxes__in_[20] ),
    .out( pri_table_muxes__out[20] ),
    .reset( pri_table_muxes__reset[20] ),
    .sel( pri_table_muxes__sel[20] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__21
  (
    .clk( pri_table_muxes__clk[21] ),
    .in_( pri_table_muxes__in_[21] ),
    .out( pri_table_muxes__out[21] ),
    .reset( pri_table_muxes__reset[21] ),
    .sel( pri_table_muxes__sel[21] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__22
  (
    .clk( pri_table_muxes__clk[22] ),
    .in_( pri_table_muxes__in_[22] ),
    .out( pri_table_muxes__out[22] ),
    .reset( pri_table_muxes__reset[22] ),
    .sel( pri_table_muxes__sel[22] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__23
  (
    .clk( pri_table_muxes__clk[23] ),
    .in_( pri_table_muxes__in_[23] ),
    .out( pri_table_muxes__out[23] ),
    .reset( pri_table_muxes__reset[23] ),
    .sel( pri_table_muxes__sel[23] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__24
  (
    .clk( pri_table_muxes__clk[24] ),
    .in_( pri_table_muxes__in_[24] ),
    .out( pri_table_muxes__out[24] ),
    .reset( pri_table_muxes__reset[24] ),
    .sel( pri_table_muxes__sel[24] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__25
  (
    .clk( pri_table_muxes__clk[25] ),
    .in_( pri_table_muxes__in_[25] ),
    .out( pri_table_muxes__out[25] ),
    .reset( pri_table_muxes__reset[25] ),
    .sel( pri_table_muxes__sel[25] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__26
  (
    .clk( pri_table_muxes__clk[26] ),
    .in_( pri_table_muxes__in_[26] ),
    .out( pri_table_muxes__out[26] ),
    .reset( pri_table_muxes__reset[26] ),
    .sel( pri_table_muxes__sel[26] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__27
  (
    .clk( pri_table_muxes__clk[27] ),
    .in_( pri_table_muxes__in_[27] ),
    .out( pri_table_muxes__out[27] ),
    .reset( pri_table_muxes__reset[27] ),
    .sel( pri_table_muxes__sel[27] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__28
  (
    .clk( pri_table_muxes__clk[28] ),
    .in_( pri_table_muxes__in_[28] ),
    .out( pri_table_muxes__out[28] ),
    .reset( pri_table_muxes__reset[28] ),
    .sel( pri_table_muxes__sel[28] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__29
  (
    .clk( pri_table_muxes__clk[29] ),
    .in_( pri_table_muxes__in_[29] ),
    .out( pri_table_muxes__out[29] ),
    .reset( pri_table_muxes__reset[29] ),
    .sel( pri_table_muxes__sel[29] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__30
  (
    .clk( pri_table_muxes__clk[30] ),
    .in_( pri_table_muxes__in_[30] ),
    .out( pri_table_muxes__out[30] ),
    .reset( pri_table_muxes__reset[30] ),
    .sel( pri_table_muxes__sel[30] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__31
  (
    .clk( pri_table_muxes__clk[31] ),
    .in_( pri_table_muxes__in_[31] ),
    .out( pri_table_muxes__out[31] ),
    .reset( pri_table_muxes__reset[31] ),
    .sel( pri_table_muxes__sel[31] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__32
  (
    .clk( pri_table_muxes__clk[32] ),
    .in_( pri_table_muxes__in_[32] ),
    .out( pri_table_muxes__out[32] ),
    .reset( pri_table_muxes__reset[32] ),
    .sel( pri_table_muxes__sel[32] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__33
  (
    .clk( pri_table_muxes__clk[33] ),
    .in_( pri_table_muxes__in_[33] ),
    .out( pri_table_muxes__out[33] ),
    .reset( pri_table_muxes__reset[33] ),
    .sel( pri_table_muxes__sel[33] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__34
  (
    .clk( pri_table_muxes__clk[34] ),
    .in_( pri_table_muxes__in_[34] ),
    .out( pri_table_muxes__out[34] ),
    .reset( pri_table_muxes__reset[34] ),
    .sel( pri_table_muxes__sel[34] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__35
  (
    .clk( pri_table_muxes__clk[35] ),
    .in_( pri_table_muxes__in_[35] ),
    .out( pri_table_muxes__out[35] ),
    .reset( pri_table_muxes__reset[35] ),
    .sel( pri_table_muxes__sel[35] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__36
  (
    .clk( pri_table_muxes__clk[36] ),
    .in_( pri_table_muxes__in_[36] ),
    .out( pri_table_muxes__out[36] ),
    .reset( pri_table_muxes__reset[36] ),
    .sel( pri_table_muxes__sel[36] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__37
  (
    .clk( pri_table_muxes__clk[37] ),
    .in_( pri_table_muxes__in_[37] ),
    .out( pri_table_muxes__out[37] ),
    .reset( pri_table_muxes__reset[37] ),
    .sel( pri_table_muxes__sel[37] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__38
  (
    .clk( pri_table_muxes__clk[38] ),
    .in_( pri_table_muxes__in_[38] ),
    .out( pri_table_muxes__out[38] ),
    .reset( pri_table_muxes__reset[38] ),
    .sel( pri_table_muxes__sel[38] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__39
  (
    .clk( pri_table_muxes__clk[39] ),
    .in_( pri_table_muxes__in_[39] ),
    .out( pri_table_muxes__out[39] ),
    .reset( pri_table_muxes__reset[39] ),
    .sel( pri_table_muxes__sel[39] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__40
  (
    .clk( pri_table_muxes__clk[40] ),
    .in_( pri_table_muxes__in_[40] ),
    .out( pri_table_muxes__out[40] ),
    .reset( pri_table_muxes__reset[40] ),
    .sel( pri_table_muxes__sel[40] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__41
  (
    .clk( pri_table_muxes__clk[41] ),
    .in_( pri_table_muxes__in_[41] ),
    .out( pri_table_muxes__out[41] ),
    .reset( pri_table_muxes__reset[41] ),
    .sel( pri_table_muxes__sel[41] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__42
  (
    .clk( pri_table_muxes__clk[42] ),
    .in_( pri_table_muxes__in_[42] ),
    .out( pri_table_muxes__out[42] ),
    .reset( pri_table_muxes__reset[42] ),
    .sel( pri_table_muxes__sel[42] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__43
  (
    .clk( pri_table_muxes__clk[43] ),
    .in_( pri_table_muxes__in_[43] ),
    .out( pri_table_muxes__out[43] ),
    .reset( pri_table_muxes__reset[43] ),
    .sel( pri_table_muxes__sel[43] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__44
  (
    .clk( pri_table_muxes__clk[44] ),
    .in_( pri_table_muxes__in_[44] ),
    .out( pri_table_muxes__out[44] ),
    .reset( pri_table_muxes__reset[44] ),
    .sel( pri_table_muxes__sel[44] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__45
  (
    .clk( pri_table_muxes__clk[45] ),
    .in_( pri_table_muxes__in_[45] ),
    .out( pri_table_muxes__out[45] ),
    .reset( pri_table_muxes__reset[45] ),
    .sel( pri_table_muxes__sel[45] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__46
  (
    .clk( pri_table_muxes__clk[46] ),
    .in_( pri_table_muxes__in_[46] ),
    .out( pri_table_muxes__out[46] ),
    .reset( pri_table_muxes__reset[46] ),
    .sel( pri_table_muxes__sel[46] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__47
  (
    .clk( pri_table_muxes__clk[47] ),
    .in_( pri_table_muxes__in_[47] ),
    .out( pri_table_muxes__out[47] ),
    .reset( pri_table_muxes__reset[47] ),
    .sel( pri_table_muxes__sel[47] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__48
  (
    .clk( pri_table_muxes__clk[48] ),
    .in_( pri_table_muxes__in_[48] ),
    .out( pri_table_muxes__out[48] ),
    .reset( pri_table_muxes__reset[48] ),
    .sel( pri_table_muxes__sel[48] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__49
  (
    .clk( pri_table_muxes__clk[49] ),
    .in_( pri_table_muxes__in_[49] ),
    .out( pri_table_muxes__out[49] ),
    .reset( pri_table_muxes__reset[49] ),
    .sel( pri_table_muxes__sel[49] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__50
  (
    .clk( pri_table_muxes__clk[50] ),
    .in_( pri_table_muxes__in_[50] ),
    .out( pri_table_muxes__out[50] ),
    .reset( pri_table_muxes__reset[50] ),
    .sel( pri_table_muxes__sel[50] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__51
  (
    .clk( pri_table_muxes__clk[51] ),
    .in_( pri_table_muxes__in_[51] ),
    .out( pri_table_muxes__out[51] ),
    .reset( pri_table_muxes__reset[51] ),
    .sel( pri_table_muxes__sel[51] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__52
  (
    .clk( pri_table_muxes__clk[52] ),
    .in_( pri_table_muxes__in_[52] ),
    .out( pri_table_muxes__out[52] ),
    .reset( pri_table_muxes__reset[52] ),
    .sel( pri_table_muxes__sel[52] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__53
  (
    .clk( pri_table_muxes__clk[53] ),
    .in_( pri_table_muxes__in_[53] ),
    .out( pri_table_muxes__out[53] ),
    .reset( pri_table_muxes__reset[53] ),
    .sel( pri_table_muxes__sel[53] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__54
  (
    .clk( pri_table_muxes__clk[54] ),
    .in_( pri_table_muxes__in_[54] ),
    .out( pri_table_muxes__out[54] ),
    .reset( pri_table_muxes__reset[54] ),
    .sel( pri_table_muxes__sel[54] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__55
  (
    .clk( pri_table_muxes__clk[55] ),
    .in_( pri_table_muxes__in_[55] ),
    .out( pri_table_muxes__out[55] ),
    .reset( pri_table_muxes__reset[55] ),
    .sel( pri_table_muxes__sel[55] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__56
  (
    .clk( pri_table_muxes__clk[56] ),
    .in_( pri_table_muxes__in_[56] ),
    .out( pri_table_muxes__out[56] ),
    .reset( pri_table_muxes__reset[56] ),
    .sel( pri_table_muxes__sel[56] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__57
  (
    .clk( pri_table_muxes__clk[57] ),
    .in_( pri_table_muxes__in_[57] ),
    .out( pri_table_muxes__out[57] ),
    .reset( pri_table_muxes__reset[57] ),
    .sel( pri_table_muxes__sel[57] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__58
  (
    .clk( pri_table_muxes__clk[58] ),
    .in_( pri_table_muxes__in_[58] ),
    .out( pri_table_muxes__out[58] ),
    .reset( pri_table_muxes__reset[58] ),
    .sel( pri_table_muxes__sel[58] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__59
  (
    .clk( pri_table_muxes__clk[59] ),
    .in_( pri_table_muxes__in_[59] ),
    .out( pri_table_muxes__out[59] ),
    .reset( pri_table_muxes__reset[59] ),
    .sel( pri_table_muxes__sel[59] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__60
  (
    .clk( pri_table_muxes__clk[60] ),
    .in_( pri_table_muxes__in_[60] ),
    .out( pri_table_muxes__out[60] ),
    .reset( pri_table_muxes__reset[60] ),
    .sel( pri_table_muxes__sel[60] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__61
  (
    .clk( pri_table_muxes__clk[61] ),
    .in_( pri_table_muxes__in_[61] ),
    .out( pri_table_muxes__out[61] ),
    .reset( pri_table_muxes__reset[61] ),
    .sel( pri_table_muxes__sel[61] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__62
  (
    .clk( pri_table_muxes__clk[62] ),
    .in_( pri_table_muxes__in_[62] ),
    .out( pri_table_muxes__out[62] ),
    .reset( pri_table_muxes__reset[62] ),
    .sel( pri_table_muxes__sel[62] )
  );

  Mux__Type_Bits7__ninputs_4 pri_table_muxes__63
  (
    .clk( pri_table_muxes__clk[63] ),
    .in_( pri_table_muxes__in_[63] ),
    .out( pri_table_muxes__out[63] ),
    .reset( pri_table_muxes__reset[63] ),
    .sel( pri_table_muxes__sel[63] )
  );

  //-------------------------------------------------------------
  // End of component pri_table_muxes[0:63]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component sec_table_muxes[0:1][0:63]
  //-------------------------------------------------------------

  logic [0:0] sec_table_muxes__clk [0:1][0:63];
  logic [6:0] sec_table_muxes__in_ [0:1][0:63][0:1];
  logic [6:0] sec_table_muxes__out [0:1][0:63];
  logic [0:0] sec_table_muxes__reset [0:1][0:63];
  logic [0:0] sec_table_muxes__sel [0:1][0:63];

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__0
  (
    .clk( sec_table_muxes__clk[0][0] ),
    .in_( sec_table_muxes__in_[0][0] ),
    .out( sec_table_muxes__out[0][0] ),
    .reset( sec_table_muxes__reset[0][0] ),
    .sel( sec_table_muxes__sel[0][0] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__1
  (
    .clk( sec_table_muxes__clk[0][1] ),
    .in_( sec_table_muxes__in_[0][1] ),
    .out( sec_table_muxes__out[0][1] ),
    .reset( sec_table_muxes__reset[0][1] ),
    .sel( sec_table_muxes__sel[0][1] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__2
  (
    .clk( sec_table_muxes__clk[0][2] ),
    .in_( sec_table_muxes__in_[0][2] ),
    .out( sec_table_muxes__out[0][2] ),
    .reset( sec_table_muxes__reset[0][2] ),
    .sel( sec_table_muxes__sel[0][2] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__3
  (
    .clk( sec_table_muxes__clk[0][3] ),
    .in_( sec_table_muxes__in_[0][3] ),
    .out( sec_table_muxes__out[0][3] ),
    .reset( sec_table_muxes__reset[0][3] ),
    .sel( sec_table_muxes__sel[0][3] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__4
  (
    .clk( sec_table_muxes__clk[0][4] ),
    .in_( sec_table_muxes__in_[0][4] ),
    .out( sec_table_muxes__out[0][4] ),
    .reset( sec_table_muxes__reset[0][4] ),
    .sel( sec_table_muxes__sel[0][4] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__5
  (
    .clk( sec_table_muxes__clk[0][5] ),
    .in_( sec_table_muxes__in_[0][5] ),
    .out( sec_table_muxes__out[0][5] ),
    .reset( sec_table_muxes__reset[0][5] ),
    .sel( sec_table_muxes__sel[0][5] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__6
  (
    .clk( sec_table_muxes__clk[0][6] ),
    .in_( sec_table_muxes__in_[0][6] ),
    .out( sec_table_muxes__out[0][6] ),
    .reset( sec_table_muxes__reset[0][6] ),
    .sel( sec_table_muxes__sel[0][6] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__7
  (
    .clk( sec_table_muxes__clk[0][7] ),
    .in_( sec_table_muxes__in_[0][7] ),
    .out( sec_table_muxes__out[0][7] ),
    .reset( sec_table_muxes__reset[0][7] ),
    .sel( sec_table_muxes__sel[0][7] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__8
  (
    .clk( sec_table_muxes__clk[0][8] ),
    .in_( sec_table_muxes__in_[0][8] ),
    .out( sec_table_muxes__out[0][8] ),
    .reset( sec_table_muxes__reset[0][8] ),
    .sel( sec_table_muxes__sel[0][8] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__9
  (
    .clk( sec_table_muxes__clk[0][9] ),
    .in_( sec_table_muxes__in_[0][9] ),
    .out( sec_table_muxes__out[0][9] ),
    .reset( sec_table_muxes__reset[0][9] ),
    .sel( sec_table_muxes__sel[0][9] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__10
  (
    .clk( sec_table_muxes__clk[0][10] ),
    .in_( sec_table_muxes__in_[0][10] ),
    .out( sec_table_muxes__out[0][10] ),
    .reset( sec_table_muxes__reset[0][10] ),
    .sel( sec_table_muxes__sel[0][10] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__11
  (
    .clk( sec_table_muxes__clk[0][11] ),
    .in_( sec_table_muxes__in_[0][11] ),
    .out( sec_table_muxes__out[0][11] ),
    .reset( sec_table_muxes__reset[0][11] ),
    .sel( sec_table_muxes__sel[0][11] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__12
  (
    .clk( sec_table_muxes__clk[0][12] ),
    .in_( sec_table_muxes__in_[0][12] ),
    .out( sec_table_muxes__out[0][12] ),
    .reset( sec_table_muxes__reset[0][12] ),
    .sel( sec_table_muxes__sel[0][12] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__13
  (
    .clk( sec_table_muxes__clk[0][13] ),
    .in_( sec_table_muxes__in_[0][13] ),
    .out( sec_table_muxes__out[0][13] ),
    .reset( sec_table_muxes__reset[0][13] ),
    .sel( sec_table_muxes__sel[0][13] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__14
  (
    .clk( sec_table_muxes__clk[0][14] ),
    .in_( sec_table_muxes__in_[0][14] ),
    .out( sec_table_muxes__out[0][14] ),
    .reset( sec_table_muxes__reset[0][14] ),
    .sel( sec_table_muxes__sel[0][14] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__15
  (
    .clk( sec_table_muxes__clk[0][15] ),
    .in_( sec_table_muxes__in_[0][15] ),
    .out( sec_table_muxes__out[0][15] ),
    .reset( sec_table_muxes__reset[0][15] ),
    .sel( sec_table_muxes__sel[0][15] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__16
  (
    .clk( sec_table_muxes__clk[0][16] ),
    .in_( sec_table_muxes__in_[0][16] ),
    .out( sec_table_muxes__out[0][16] ),
    .reset( sec_table_muxes__reset[0][16] ),
    .sel( sec_table_muxes__sel[0][16] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__17
  (
    .clk( sec_table_muxes__clk[0][17] ),
    .in_( sec_table_muxes__in_[0][17] ),
    .out( sec_table_muxes__out[0][17] ),
    .reset( sec_table_muxes__reset[0][17] ),
    .sel( sec_table_muxes__sel[0][17] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__18
  (
    .clk( sec_table_muxes__clk[0][18] ),
    .in_( sec_table_muxes__in_[0][18] ),
    .out( sec_table_muxes__out[0][18] ),
    .reset( sec_table_muxes__reset[0][18] ),
    .sel( sec_table_muxes__sel[0][18] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__19
  (
    .clk( sec_table_muxes__clk[0][19] ),
    .in_( sec_table_muxes__in_[0][19] ),
    .out( sec_table_muxes__out[0][19] ),
    .reset( sec_table_muxes__reset[0][19] ),
    .sel( sec_table_muxes__sel[0][19] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__20
  (
    .clk( sec_table_muxes__clk[0][20] ),
    .in_( sec_table_muxes__in_[0][20] ),
    .out( sec_table_muxes__out[0][20] ),
    .reset( sec_table_muxes__reset[0][20] ),
    .sel( sec_table_muxes__sel[0][20] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__21
  (
    .clk( sec_table_muxes__clk[0][21] ),
    .in_( sec_table_muxes__in_[0][21] ),
    .out( sec_table_muxes__out[0][21] ),
    .reset( sec_table_muxes__reset[0][21] ),
    .sel( sec_table_muxes__sel[0][21] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__22
  (
    .clk( sec_table_muxes__clk[0][22] ),
    .in_( sec_table_muxes__in_[0][22] ),
    .out( sec_table_muxes__out[0][22] ),
    .reset( sec_table_muxes__reset[0][22] ),
    .sel( sec_table_muxes__sel[0][22] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__23
  (
    .clk( sec_table_muxes__clk[0][23] ),
    .in_( sec_table_muxes__in_[0][23] ),
    .out( sec_table_muxes__out[0][23] ),
    .reset( sec_table_muxes__reset[0][23] ),
    .sel( sec_table_muxes__sel[0][23] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__24
  (
    .clk( sec_table_muxes__clk[0][24] ),
    .in_( sec_table_muxes__in_[0][24] ),
    .out( sec_table_muxes__out[0][24] ),
    .reset( sec_table_muxes__reset[0][24] ),
    .sel( sec_table_muxes__sel[0][24] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__25
  (
    .clk( sec_table_muxes__clk[0][25] ),
    .in_( sec_table_muxes__in_[0][25] ),
    .out( sec_table_muxes__out[0][25] ),
    .reset( sec_table_muxes__reset[0][25] ),
    .sel( sec_table_muxes__sel[0][25] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__26
  (
    .clk( sec_table_muxes__clk[0][26] ),
    .in_( sec_table_muxes__in_[0][26] ),
    .out( sec_table_muxes__out[0][26] ),
    .reset( sec_table_muxes__reset[0][26] ),
    .sel( sec_table_muxes__sel[0][26] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__27
  (
    .clk( sec_table_muxes__clk[0][27] ),
    .in_( sec_table_muxes__in_[0][27] ),
    .out( sec_table_muxes__out[0][27] ),
    .reset( sec_table_muxes__reset[0][27] ),
    .sel( sec_table_muxes__sel[0][27] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__28
  (
    .clk( sec_table_muxes__clk[0][28] ),
    .in_( sec_table_muxes__in_[0][28] ),
    .out( sec_table_muxes__out[0][28] ),
    .reset( sec_table_muxes__reset[0][28] ),
    .sel( sec_table_muxes__sel[0][28] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__29
  (
    .clk( sec_table_muxes__clk[0][29] ),
    .in_( sec_table_muxes__in_[0][29] ),
    .out( sec_table_muxes__out[0][29] ),
    .reset( sec_table_muxes__reset[0][29] ),
    .sel( sec_table_muxes__sel[0][29] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__30
  (
    .clk( sec_table_muxes__clk[0][30] ),
    .in_( sec_table_muxes__in_[0][30] ),
    .out( sec_table_muxes__out[0][30] ),
    .reset( sec_table_muxes__reset[0][30] ),
    .sel( sec_table_muxes__sel[0][30] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__31
  (
    .clk( sec_table_muxes__clk[0][31] ),
    .in_( sec_table_muxes__in_[0][31] ),
    .out( sec_table_muxes__out[0][31] ),
    .reset( sec_table_muxes__reset[0][31] ),
    .sel( sec_table_muxes__sel[0][31] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__32
  (
    .clk( sec_table_muxes__clk[0][32] ),
    .in_( sec_table_muxes__in_[0][32] ),
    .out( sec_table_muxes__out[0][32] ),
    .reset( sec_table_muxes__reset[0][32] ),
    .sel( sec_table_muxes__sel[0][32] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__33
  (
    .clk( sec_table_muxes__clk[0][33] ),
    .in_( sec_table_muxes__in_[0][33] ),
    .out( sec_table_muxes__out[0][33] ),
    .reset( sec_table_muxes__reset[0][33] ),
    .sel( sec_table_muxes__sel[0][33] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__34
  (
    .clk( sec_table_muxes__clk[0][34] ),
    .in_( sec_table_muxes__in_[0][34] ),
    .out( sec_table_muxes__out[0][34] ),
    .reset( sec_table_muxes__reset[0][34] ),
    .sel( sec_table_muxes__sel[0][34] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__35
  (
    .clk( sec_table_muxes__clk[0][35] ),
    .in_( sec_table_muxes__in_[0][35] ),
    .out( sec_table_muxes__out[0][35] ),
    .reset( sec_table_muxes__reset[0][35] ),
    .sel( sec_table_muxes__sel[0][35] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__36
  (
    .clk( sec_table_muxes__clk[0][36] ),
    .in_( sec_table_muxes__in_[0][36] ),
    .out( sec_table_muxes__out[0][36] ),
    .reset( sec_table_muxes__reset[0][36] ),
    .sel( sec_table_muxes__sel[0][36] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__37
  (
    .clk( sec_table_muxes__clk[0][37] ),
    .in_( sec_table_muxes__in_[0][37] ),
    .out( sec_table_muxes__out[0][37] ),
    .reset( sec_table_muxes__reset[0][37] ),
    .sel( sec_table_muxes__sel[0][37] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__38
  (
    .clk( sec_table_muxes__clk[0][38] ),
    .in_( sec_table_muxes__in_[0][38] ),
    .out( sec_table_muxes__out[0][38] ),
    .reset( sec_table_muxes__reset[0][38] ),
    .sel( sec_table_muxes__sel[0][38] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__39
  (
    .clk( sec_table_muxes__clk[0][39] ),
    .in_( sec_table_muxes__in_[0][39] ),
    .out( sec_table_muxes__out[0][39] ),
    .reset( sec_table_muxes__reset[0][39] ),
    .sel( sec_table_muxes__sel[0][39] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__40
  (
    .clk( sec_table_muxes__clk[0][40] ),
    .in_( sec_table_muxes__in_[0][40] ),
    .out( sec_table_muxes__out[0][40] ),
    .reset( sec_table_muxes__reset[0][40] ),
    .sel( sec_table_muxes__sel[0][40] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__41
  (
    .clk( sec_table_muxes__clk[0][41] ),
    .in_( sec_table_muxes__in_[0][41] ),
    .out( sec_table_muxes__out[0][41] ),
    .reset( sec_table_muxes__reset[0][41] ),
    .sel( sec_table_muxes__sel[0][41] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__42
  (
    .clk( sec_table_muxes__clk[0][42] ),
    .in_( sec_table_muxes__in_[0][42] ),
    .out( sec_table_muxes__out[0][42] ),
    .reset( sec_table_muxes__reset[0][42] ),
    .sel( sec_table_muxes__sel[0][42] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__43
  (
    .clk( sec_table_muxes__clk[0][43] ),
    .in_( sec_table_muxes__in_[0][43] ),
    .out( sec_table_muxes__out[0][43] ),
    .reset( sec_table_muxes__reset[0][43] ),
    .sel( sec_table_muxes__sel[0][43] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__44
  (
    .clk( sec_table_muxes__clk[0][44] ),
    .in_( sec_table_muxes__in_[0][44] ),
    .out( sec_table_muxes__out[0][44] ),
    .reset( sec_table_muxes__reset[0][44] ),
    .sel( sec_table_muxes__sel[0][44] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__45
  (
    .clk( sec_table_muxes__clk[0][45] ),
    .in_( sec_table_muxes__in_[0][45] ),
    .out( sec_table_muxes__out[0][45] ),
    .reset( sec_table_muxes__reset[0][45] ),
    .sel( sec_table_muxes__sel[0][45] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__46
  (
    .clk( sec_table_muxes__clk[0][46] ),
    .in_( sec_table_muxes__in_[0][46] ),
    .out( sec_table_muxes__out[0][46] ),
    .reset( sec_table_muxes__reset[0][46] ),
    .sel( sec_table_muxes__sel[0][46] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__47
  (
    .clk( sec_table_muxes__clk[0][47] ),
    .in_( sec_table_muxes__in_[0][47] ),
    .out( sec_table_muxes__out[0][47] ),
    .reset( sec_table_muxes__reset[0][47] ),
    .sel( sec_table_muxes__sel[0][47] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__48
  (
    .clk( sec_table_muxes__clk[0][48] ),
    .in_( sec_table_muxes__in_[0][48] ),
    .out( sec_table_muxes__out[0][48] ),
    .reset( sec_table_muxes__reset[0][48] ),
    .sel( sec_table_muxes__sel[0][48] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__49
  (
    .clk( sec_table_muxes__clk[0][49] ),
    .in_( sec_table_muxes__in_[0][49] ),
    .out( sec_table_muxes__out[0][49] ),
    .reset( sec_table_muxes__reset[0][49] ),
    .sel( sec_table_muxes__sel[0][49] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__50
  (
    .clk( sec_table_muxes__clk[0][50] ),
    .in_( sec_table_muxes__in_[0][50] ),
    .out( sec_table_muxes__out[0][50] ),
    .reset( sec_table_muxes__reset[0][50] ),
    .sel( sec_table_muxes__sel[0][50] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__51
  (
    .clk( sec_table_muxes__clk[0][51] ),
    .in_( sec_table_muxes__in_[0][51] ),
    .out( sec_table_muxes__out[0][51] ),
    .reset( sec_table_muxes__reset[0][51] ),
    .sel( sec_table_muxes__sel[0][51] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__52
  (
    .clk( sec_table_muxes__clk[0][52] ),
    .in_( sec_table_muxes__in_[0][52] ),
    .out( sec_table_muxes__out[0][52] ),
    .reset( sec_table_muxes__reset[0][52] ),
    .sel( sec_table_muxes__sel[0][52] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__53
  (
    .clk( sec_table_muxes__clk[0][53] ),
    .in_( sec_table_muxes__in_[0][53] ),
    .out( sec_table_muxes__out[0][53] ),
    .reset( sec_table_muxes__reset[0][53] ),
    .sel( sec_table_muxes__sel[0][53] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__54
  (
    .clk( sec_table_muxes__clk[0][54] ),
    .in_( sec_table_muxes__in_[0][54] ),
    .out( sec_table_muxes__out[0][54] ),
    .reset( sec_table_muxes__reset[0][54] ),
    .sel( sec_table_muxes__sel[0][54] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__55
  (
    .clk( sec_table_muxes__clk[0][55] ),
    .in_( sec_table_muxes__in_[0][55] ),
    .out( sec_table_muxes__out[0][55] ),
    .reset( sec_table_muxes__reset[0][55] ),
    .sel( sec_table_muxes__sel[0][55] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__56
  (
    .clk( sec_table_muxes__clk[0][56] ),
    .in_( sec_table_muxes__in_[0][56] ),
    .out( sec_table_muxes__out[0][56] ),
    .reset( sec_table_muxes__reset[0][56] ),
    .sel( sec_table_muxes__sel[0][56] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__57
  (
    .clk( sec_table_muxes__clk[0][57] ),
    .in_( sec_table_muxes__in_[0][57] ),
    .out( sec_table_muxes__out[0][57] ),
    .reset( sec_table_muxes__reset[0][57] ),
    .sel( sec_table_muxes__sel[0][57] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__58
  (
    .clk( sec_table_muxes__clk[0][58] ),
    .in_( sec_table_muxes__in_[0][58] ),
    .out( sec_table_muxes__out[0][58] ),
    .reset( sec_table_muxes__reset[0][58] ),
    .sel( sec_table_muxes__sel[0][58] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__59
  (
    .clk( sec_table_muxes__clk[0][59] ),
    .in_( sec_table_muxes__in_[0][59] ),
    .out( sec_table_muxes__out[0][59] ),
    .reset( sec_table_muxes__reset[0][59] ),
    .sel( sec_table_muxes__sel[0][59] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__60
  (
    .clk( sec_table_muxes__clk[0][60] ),
    .in_( sec_table_muxes__in_[0][60] ),
    .out( sec_table_muxes__out[0][60] ),
    .reset( sec_table_muxes__reset[0][60] ),
    .sel( sec_table_muxes__sel[0][60] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__61
  (
    .clk( sec_table_muxes__clk[0][61] ),
    .in_( sec_table_muxes__in_[0][61] ),
    .out( sec_table_muxes__out[0][61] ),
    .reset( sec_table_muxes__reset[0][61] ),
    .sel( sec_table_muxes__sel[0][61] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__62
  (
    .clk( sec_table_muxes__clk[0][62] ),
    .in_( sec_table_muxes__in_[0][62] ),
    .out( sec_table_muxes__out[0][62] ),
    .reset( sec_table_muxes__reset[0][62] ),
    .sel( sec_table_muxes__sel[0][62] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__0__63
  (
    .clk( sec_table_muxes__clk[0][63] ),
    .in_( sec_table_muxes__in_[0][63] ),
    .out( sec_table_muxes__out[0][63] ),
    .reset( sec_table_muxes__reset[0][63] ),
    .sel( sec_table_muxes__sel[0][63] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__0
  (
    .clk( sec_table_muxes__clk[1][0] ),
    .in_( sec_table_muxes__in_[1][0] ),
    .out( sec_table_muxes__out[1][0] ),
    .reset( sec_table_muxes__reset[1][0] ),
    .sel( sec_table_muxes__sel[1][0] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__1
  (
    .clk( sec_table_muxes__clk[1][1] ),
    .in_( sec_table_muxes__in_[1][1] ),
    .out( sec_table_muxes__out[1][1] ),
    .reset( sec_table_muxes__reset[1][1] ),
    .sel( sec_table_muxes__sel[1][1] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__2
  (
    .clk( sec_table_muxes__clk[1][2] ),
    .in_( sec_table_muxes__in_[1][2] ),
    .out( sec_table_muxes__out[1][2] ),
    .reset( sec_table_muxes__reset[1][2] ),
    .sel( sec_table_muxes__sel[1][2] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__3
  (
    .clk( sec_table_muxes__clk[1][3] ),
    .in_( sec_table_muxes__in_[1][3] ),
    .out( sec_table_muxes__out[1][3] ),
    .reset( sec_table_muxes__reset[1][3] ),
    .sel( sec_table_muxes__sel[1][3] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__4
  (
    .clk( sec_table_muxes__clk[1][4] ),
    .in_( sec_table_muxes__in_[1][4] ),
    .out( sec_table_muxes__out[1][4] ),
    .reset( sec_table_muxes__reset[1][4] ),
    .sel( sec_table_muxes__sel[1][4] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__5
  (
    .clk( sec_table_muxes__clk[1][5] ),
    .in_( sec_table_muxes__in_[1][5] ),
    .out( sec_table_muxes__out[1][5] ),
    .reset( sec_table_muxes__reset[1][5] ),
    .sel( sec_table_muxes__sel[1][5] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__6
  (
    .clk( sec_table_muxes__clk[1][6] ),
    .in_( sec_table_muxes__in_[1][6] ),
    .out( sec_table_muxes__out[1][6] ),
    .reset( sec_table_muxes__reset[1][6] ),
    .sel( sec_table_muxes__sel[1][6] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__7
  (
    .clk( sec_table_muxes__clk[1][7] ),
    .in_( sec_table_muxes__in_[1][7] ),
    .out( sec_table_muxes__out[1][7] ),
    .reset( sec_table_muxes__reset[1][7] ),
    .sel( sec_table_muxes__sel[1][7] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__8
  (
    .clk( sec_table_muxes__clk[1][8] ),
    .in_( sec_table_muxes__in_[1][8] ),
    .out( sec_table_muxes__out[1][8] ),
    .reset( sec_table_muxes__reset[1][8] ),
    .sel( sec_table_muxes__sel[1][8] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__9
  (
    .clk( sec_table_muxes__clk[1][9] ),
    .in_( sec_table_muxes__in_[1][9] ),
    .out( sec_table_muxes__out[1][9] ),
    .reset( sec_table_muxes__reset[1][9] ),
    .sel( sec_table_muxes__sel[1][9] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__10
  (
    .clk( sec_table_muxes__clk[1][10] ),
    .in_( sec_table_muxes__in_[1][10] ),
    .out( sec_table_muxes__out[1][10] ),
    .reset( sec_table_muxes__reset[1][10] ),
    .sel( sec_table_muxes__sel[1][10] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__11
  (
    .clk( sec_table_muxes__clk[1][11] ),
    .in_( sec_table_muxes__in_[1][11] ),
    .out( sec_table_muxes__out[1][11] ),
    .reset( sec_table_muxes__reset[1][11] ),
    .sel( sec_table_muxes__sel[1][11] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__12
  (
    .clk( sec_table_muxes__clk[1][12] ),
    .in_( sec_table_muxes__in_[1][12] ),
    .out( sec_table_muxes__out[1][12] ),
    .reset( sec_table_muxes__reset[1][12] ),
    .sel( sec_table_muxes__sel[1][12] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__13
  (
    .clk( sec_table_muxes__clk[1][13] ),
    .in_( sec_table_muxes__in_[1][13] ),
    .out( sec_table_muxes__out[1][13] ),
    .reset( sec_table_muxes__reset[1][13] ),
    .sel( sec_table_muxes__sel[1][13] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__14
  (
    .clk( sec_table_muxes__clk[1][14] ),
    .in_( sec_table_muxes__in_[1][14] ),
    .out( sec_table_muxes__out[1][14] ),
    .reset( sec_table_muxes__reset[1][14] ),
    .sel( sec_table_muxes__sel[1][14] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__15
  (
    .clk( sec_table_muxes__clk[1][15] ),
    .in_( sec_table_muxes__in_[1][15] ),
    .out( sec_table_muxes__out[1][15] ),
    .reset( sec_table_muxes__reset[1][15] ),
    .sel( sec_table_muxes__sel[1][15] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__16
  (
    .clk( sec_table_muxes__clk[1][16] ),
    .in_( sec_table_muxes__in_[1][16] ),
    .out( sec_table_muxes__out[1][16] ),
    .reset( sec_table_muxes__reset[1][16] ),
    .sel( sec_table_muxes__sel[1][16] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__17
  (
    .clk( sec_table_muxes__clk[1][17] ),
    .in_( sec_table_muxes__in_[1][17] ),
    .out( sec_table_muxes__out[1][17] ),
    .reset( sec_table_muxes__reset[1][17] ),
    .sel( sec_table_muxes__sel[1][17] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__18
  (
    .clk( sec_table_muxes__clk[1][18] ),
    .in_( sec_table_muxes__in_[1][18] ),
    .out( sec_table_muxes__out[1][18] ),
    .reset( sec_table_muxes__reset[1][18] ),
    .sel( sec_table_muxes__sel[1][18] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__19
  (
    .clk( sec_table_muxes__clk[1][19] ),
    .in_( sec_table_muxes__in_[1][19] ),
    .out( sec_table_muxes__out[1][19] ),
    .reset( sec_table_muxes__reset[1][19] ),
    .sel( sec_table_muxes__sel[1][19] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__20
  (
    .clk( sec_table_muxes__clk[1][20] ),
    .in_( sec_table_muxes__in_[1][20] ),
    .out( sec_table_muxes__out[1][20] ),
    .reset( sec_table_muxes__reset[1][20] ),
    .sel( sec_table_muxes__sel[1][20] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__21
  (
    .clk( sec_table_muxes__clk[1][21] ),
    .in_( sec_table_muxes__in_[1][21] ),
    .out( sec_table_muxes__out[1][21] ),
    .reset( sec_table_muxes__reset[1][21] ),
    .sel( sec_table_muxes__sel[1][21] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__22
  (
    .clk( sec_table_muxes__clk[1][22] ),
    .in_( sec_table_muxes__in_[1][22] ),
    .out( sec_table_muxes__out[1][22] ),
    .reset( sec_table_muxes__reset[1][22] ),
    .sel( sec_table_muxes__sel[1][22] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__23
  (
    .clk( sec_table_muxes__clk[1][23] ),
    .in_( sec_table_muxes__in_[1][23] ),
    .out( sec_table_muxes__out[1][23] ),
    .reset( sec_table_muxes__reset[1][23] ),
    .sel( sec_table_muxes__sel[1][23] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__24
  (
    .clk( sec_table_muxes__clk[1][24] ),
    .in_( sec_table_muxes__in_[1][24] ),
    .out( sec_table_muxes__out[1][24] ),
    .reset( sec_table_muxes__reset[1][24] ),
    .sel( sec_table_muxes__sel[1][24] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__25
  (
    .clk( sec_table_muxes__clk[1][25] ),
    .in_( sec_table_muxes__in_[1][25] ),
    .out( sec_table_muxes__out[1][25] ),
    .reset( sec_table_muxes__reset[1][25] ),
    .sel( sec_table_muxes__sel[1][25] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__26
  (
    .clk( sec_table_muxes__clk[1][26] ),
    .in_( sec_table_muxes__in_[1][26] ),
    .out( sec_table_muxes__out[1][26] ),
    .reset( sec_table_muxes__reset[1][26] ),
    .sel( sec_table_muxes__sel[1][26] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__27
  (
    .clk( sec_table_muxes__clk[1][27] ),
    .in_( sec_table_muxes__in_[1][27] ),
    .out( sec_table_muxes__out[1][27] ),
    .reset( sec_table_muxes__reset[1][27] ),
    .sel( sec_table_muxes__sel[1][27] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__28
  (
    .clk( sec_table_muxes__clk[1][28] ),
    .in_( sec_table_muxes__in_[1][28] ),
    .out( sec_table_muxes__out[1][28] ),
    .reset( sec_table_muxes__reset[1][28] ),
    .sel( sec_table_muxes__sel[1][28] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__29
  (
    .clk( sec_table_muxes__clk[1][29] ),
    .in_( sec_table_muxes__in_[1][29] ),
    .out( sec_table_muxes__out[1][29] ),
    .reset( sec_table_muxes__reset[1][29] ),
    .sel( sec_table_muxes__sel[1][29] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__30
  (
    .clk( sec_table_muxes__clk[1][30] ),
    .in_( sec_table_muxes__in_[1][30] ),
    .out( sec_table_muxes__out[1][30] ),
    .reset( sec_table_muxes__reset[1][30] ),
    .sel( sec_table_muxes__sel[1][30] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__31
  (
    .clk( sec_table_muxes__clk[1][31] ),
    .in_( sec_table_muxes__in_[1][31] ),
    .out( sec_table_muxes__out[1][31] ),
    .reset( sec_table_muxes__reset[1][31] ),
    .sel( sec_table_muxes__sel[1][31] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__32
  (
    .clk( sec_table_muxes__clk[1][32] ),
    .in_( sec_table_muxes__in_[1][32] ),
    .out( sec_table_muxes__out[1][32] ),
    .reset( sec_table_muxes__reset[1][32] ),
    .sel( sec_table_muxes__sel[1][32] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__33
  (
    .clk( sec_table_muxes__clk[1][33] ),
    .in_( sec_table_muxes__in_[1][33] ),
    .out( sec_table_muxes__out[1][33] ),
    .reset( sec_table_muxes__reset[1][33] ),
    .sel( sec_table_muxes__sel[1][33] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__34
  (
    .clk( sec_table_muxes__clk[1][34] ),
    .in_( sec_table_muxes__in_[1][34] ),
    .out( sec_table_muxes__out[1][34] ),
    .reset( sec_table_muxes__reset[1][34] ),
    .sel( sec_table_muxes__sel[1][34] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__35
  (
    .clk( sec_table_muxes__clk[1][35] ),
    .in_( sec_table_muxes__in_[1][35] ),
    .out( sec_table_muxes__out[1][35] ),
    .reset( sec_table_muxes__reset[1][35] ),
    .sel( sec_table_muxes__sel[1][35] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__36
  (
    .clk( sec_table_muxes__clk[1][36] ),
    .in_( sec_table_muxes__in_[1][36] ),
    .out( sec_table_muxes__out[1][36] ),
    .reset( sec_table_muxes__reset[1][36] ),
    .sel( sec_table_muxes__sel[1][36] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__37
  (
    .clk( sec_table_muxes__clk[1][37] ),
    .in_( sec_table_muxes__in_[1][37] ),
    .out( sec_table_muxes__out[1][37] ),
    .reset( sec_table_muxes__reset[1][37] ),
    .sel( sec_table_muxes__sel[1][37] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__38
  (
    .clk( sec_table_muxes__clk[1][38] ),
    .in_( sec_table_muxes__in_[1][38] ),
    .out( sec_table_muxes__out[1][38] ),
    .reset( sec_table_muxes__reset[1][38] ),
    .sel( sec_table_muxes__sel[1][38] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__39
  (
    .clk( sec_table_muxes__clk[1][39] ),
    .in_( sec_table_muxes__in_[1][39] ),
    .out( sec_table_muxes__out[1][39] ),
    .reset( sec_table_muxes__reset[1][39] ),
    .sel( sec_table_muxes__sel[1][39] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__40
  (
    .clk( sec_table_muxes__clk[1][40] ),
    .in_( sec_table_muxes__in_[1][40] ),
    .out( sec_table_muxes__out[1][40] ),
    .reset( sec_table_muxes__reset[1][40] ),
    .sel( sec_table_muxes__sel[1][40] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__41
  (
    .clk( sec_table_muxes__clk[1][41] ),
    .in_( sec_table_muxes__in_[1][41] ),
    .out( sec_table_muxes__out[1][41] ),
    .reset( sec_table_muxes__reset[1][41] ),
    .sel( sec_table_muxes__sel[1][41] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__42
  (
    .clk( sec_table_muxes__clk[1][42] ),
    .in_( sec_table_muxes__in_[1][42] ),
    .out( sec_table_muxes__out[1][42] ),
    .reset( sec_table_muxes__reset[1][42] ),
    .sel( sec_table_muxes__sel[1][42] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__43
  (
    .clk( sec_table_muxes__clk[1][43] ),
    .in_( sec_table_muxes__in_[1][43] ),
    .out( sec_table_muxes__out[1][43] ),
    .reset( sec_table_muxes__reset[1][43] ),
    .sel( sec_table_muxes__sel[1][43] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__44
  (
    .clk( sec_table_muxes__clk[1][44] ),
    .in_( sec_table_muxes__in_[1][44] ),
    .out( sec_table_muxes__out[1][44] ),
    .reset( sec_table_muxes__reset[1][44] ),
    .sel( sec_table_muxes__sel[1][44] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__45
  (
    .clk( sec_table_muxes__clk[1][45] ),
    .in_( sec_table_muxes__in_[1][45] ),
    .out( sec_table_muxes__out[1][45] ),
    .reset( sec_table_muxes__reset[1][45] ),
    .sel( sec_table_muxes__sel[1][45] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__46
  (
    .clk( sec_table_muxes__clk[1][46] ),
    .in_( sec_table_muxes__in_[1][46] ),
    .out( sec_table_muxes__out[1][46] ),
    .reset( sec_table_muxes__reset[1][46] ),
    .sel( sec_table_muxes__sel[1][46] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__47
  (
    .clk( sec_table_muxes__clk[1][47] ),
    .in_( sec_table_muxes__in_[1][47] ),
    .out( sec_table_muxes__out[1][47] ),
    .reset( sec_table_muxes__reset[1][47] ),
    .sel( sec_table_muxes__sel[1][47] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__48
  (
    .clk( sec_table_muxes__clk[1][48] ),
    .in_( sec_table_muxes__in_[1][48] ),
    .out( sec_table_muxes__out[1][48] ),
    .reset( sec_table_muxes__reset[1][48] ),
    .sel( sec_table_muxes__sel[1][48] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__49
  (
    .clk( sec_table_muxes__clk[1][49] ),
    .in_( sec_table_muxes__in_[1][49] ),
    .out( sec_table_muxes__out[1][49] ),
    .reset( sec_table_muxes__reset[1][49] ),
    .sel( sec_table_muxes__sel[1][49] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__50
  (
    .clk( sec_table_muxes__clk[1][50] ),
    .in_( sec_table_muxes__in_[1][50] ),
    .out( sec_table_muxes__out[1][50] ),
    .reset( sec_table_muxes__reset[1][50] ),
    .sel( sec_table_muxes__sel[1][50] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__51
  (
    .clk( sec_table_muxes__clk[1][51] ),
    .in_( sec_table_muxes__in_[1][51] ),
    .out( sec_table_muxes__out[1][51] ),
    .reset( sec_table_muxes__reset[1][51] ),
    .sel( sec_table_muxes__sel[1][51] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__52
  (
    .clk( sec_table_muxes__clk[1][52] ),
    .in_( sec_table_muxes__in_[1][52] ),
    .out( sec_table_muxes__out[1][52] ),
    .reset( sec_table_muxes__reset[1][52] ),
    .sel( sec_table_muxes__sel[1][52] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__53
  (
    .clk( sec_table_muxes__clk[1][53] ),
    .in_( sec_table_muxes__in_[1][53] ),
    .out( sec_table_muxes__out[1][53] ),
    .reset( sec_table_muxes__reset[1][53] ),
    .sel( sec_table_muxes__sel[1][53] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__54
  (
    .clk( sec_table_muxes__clk[1][54] ),
    .in_( sec_table_muxes__in_[1][54] ),
    .out( sec_table_muxes__out[1][54] ),
    .reset( sec_table_muxes__reset[1][54] ),
    .sel( sec_table_muxes__sel[1][54] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__55
  (
    .clk( sec_table_muxes__clk[1][55] ),
    .in_( sec_table_muxes__in_[1][55] ),
    .out( sec_table_muxes__out[1][55] ),
    .reset( sec_table_muxes__reset[1][55] ),
    .sel( sec_table_muxes__sel[1][55] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__56
  (
    .clk( sec_table_muxes__clk[1][56] ),
    .in_( sec_table_muxes__in_[1][56] ),
    .out( sec_table_muxes__out[1][56] ),
    .reset( sec_table_muxes__reset[1][56] ),
    .sel( sec_table_muxes__sel[1][56] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__57
  (
    .clk( sec_table_muxes__clk[1][57] ),
    .in_( sec_table_muxes__in_[1][57] ),
    .out( sec_table_muxes__out[1][57] ),
    .reset( sec_table_muxes__reset[1][57] ),
    .sel( sec_table_muxes__sel[1][57] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__58
  (
    .clk( sec_table_muxes__clk[1][58] ),
    .in_( sec_table_muxes__in_[1][58] ),
    .out( sec_table_muxes__out[1][58] ),
    .reset( sec_table_muxes__reset[1][58] ),
    .sel( sec_table_muxes__sel[1][58] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__59
  (
    .clk( sec_table_muxes__clk[1][59] ),
    .in_( sec_table_muxes__in_[1][59] ),
    .out( sec_table_muxes__out[1][59] ),
    .reset( sec_table_muxes__reset[1][59] ),
    .sel( sec_table_muxes__sel[1][59] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__60
  (
    .clk( sec_table_muxes__clk[1][60] ),
    .in_( sec_table_muxes__in_[1][60] ),
    .out( sec_table_muxes__out[1][60] ),
    .reset( sec_table_muxes__reset[1][60] ),
    .sel( sec_table_muxes__sel[1][60] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__61
  (
    .clk( sec_table_muxes__clk[1][61] ),
    .in_( sec_table_muxes__in_[1][61] ),
    .out( sec_table_muxes__out[1][61] ),
    .reset( sec_table_muxes__reset[1][61] ),
    .sel( sec_table_muxes__sel[1][61] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__62
  (
    .clk( sec_table_muxes__clk[1][62] ),
    .in_( sec_table_muxes__in_[1][62] ),
    .out( sec_table_muxes__out[1][62] ),
    .reset( sec_table_muxes__reset[1][62] ),
    .sel( sec_table_muxes__sel[1][62] )
  );

  Mux__Type_Bits7__ninputs_2 sec_table_muxes__1__63
  (
    .clk( sec_table_muxes__clk[1][63] ),
    .in_( sec_table_muxes__in_[1][63] ),
    .out( sec_table_muxes__out[1][63] ),
    .reset( sec_table_muxes__reset[1][63] ),
    .sel( sec_table_muxes__sel[1][63] )
  );

  //-------------------------------------------------------------
  // End of component sec_table_muxes[0:1][0:63]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component sec_tables[0:1][0:63]
  //-------------------------------------------------------------

  logic [0:0] sec_tables__clk [0:1][0:63];
  logic [0:0] sec_tables__en [0:1][0:63];
  logic [6:0] sec_tables__in_ [0:1][0:63];
  logic [6:0] sec_tables__out [0:1][0:63];
  logic [0:0] sec_tables__reset [0:1][0:63];

  RegEn__Type_Bits7 sec_tables__0__0
  (
    .clk( sec_tables__clk[0][0] ),
    .en( sec_tables__en[0][0] ),
    .in_( sec_tables__in_[0][0] ),
    .out( sec_tables__out[0][0] ),
    .reset( sec_tables__reset[0][0] )
  );

  RegEn__Type_Bits7 sec_tables__0__1
  (
    .clk( sec_tables__clk[0][1] ),
    .en( sec_tables__en[0][1] ),
    .in_( sec_tables__in_[0][1] ),
    .out( sec_tables__out[0][1] ),
    .reset( sec_tables__reset[0][1] )
  );

  RegEn__Type_Bits7 sec_tables__0__2
  (
    .clk( sec_tables__clk[0][2] ),
    .en( sec_tables__en[0][2] ),
    .in_( sec_tables__in_[0][2] ),
    .out( sec_tables__out[0][2] ),
    .reset( sec_tables__reset[0][2] )
  );

  RegEn__Type_Bits7 sec_tables__0__3
  (
    .clk( sec_tables__clk[0][3] ),
    .en( sec_tables__en[0][3] ),
    .in_( sec_tables__in_[0][3] ),
    .out( sec_tables__out[0][3] ),
    .reset( sec_tables__reset[0][3] )
  );

  RegEn__Type_Bits7 sec_tables__0__4
  (
    .clk( sec_tables__clk[0][4] ),
    .en( sec_tables__en[0][4] ),
    .in_( sec_tables__in_[0][4] ),
    .out( sec_tables__out[0][4] ),
    .reset( sec_tables__reset[0][4] )
  );

  RegEn__Type_Bits7 sec_tables__0__5
  (
    .clk( sec_tables__clk[0][5] ),
    .en( sec_tables__en[0][5] ),
    .in_( sec_tables__in_[0][5] ),
    .out( sec_tables__out[0][5] ),
    .reset( sec_tables__reset[0][5] )
  );

  RegEn__Type_Bits7 sec_tables__0__6
  (
    .clk( sec_tables__clk[0][6] ),
    .en( sec_tables__en[0][6] ),
    .in_( sec_tables__in_[0][6] ),
    .out( sec_tables__out[0][6] ),
    .reset( sec_tables__reset[0][6] )
  );

  RegEn__Type_Bits7 sec_tables__0__7
  (
    .clk( sec_tables__clk[0][7] ),
    .en( sec_tables__en[0][7] ),
    .in_( sec_tables__in_[0][7] ),
    .out( sec_tables__out[0][7] ),
    .reset( sec_tables__reset[0][7] )
  );

  RegEn__Type_Bits7 sec_tables__0__8
  (
    .clk( sec_tables__clk[0][8] ),
    .en( sec_tables__en[0][8] ),
    .in_( sec_tables__in_[0][8] ),
    .out( sec_tables__out[0][8] ),
    .reset( sec_tables__reset[0][8] )
  );

  RegEn__Type_Bits7 sec_tables__0__9
  (
    .clk( sec_tables__clk[0][9] ),
    .en( sec_tables__en[0][9] ),
    .in_( sec_tables__in_[0][9] ),
    .out( sec_tables__out[0][9] ),
    .reset( sec_tables__reset[0][9] )
  );

  RegEn__Type_Bits7 sec_tables__0__10
  (
    .clk( sec_tables__clk[0][10] ),
    .en( sec_tables__en[0][10] ),
    .in_( sec_tables__in_[0][10] ),
    .out( sec_tables__out[0][10] ),
    .reset( sec_tables__reset[0][10] )
  );

  RegEn__Type_Bits7 sec_tables__0__11
  (
    .clk( sec_tables__clk[0][11] ),
    .en( sec_tables__en[0][11] ),
    .in_( sec_tables__in_[0][11] ),
    .out( sec_tables__out[0][11] ),
    .reset( sec_tables__reset[0][11] )
  );

  RegEn__Type_Bits7 sec_tables__0__12
  (
    .clk( sec_tables__clk[0][12] ),
    .en( sec_tables__en[0][12] ),
    .in_( sec_tables__in_[0][12] ),
    .out( sec_tables__out[0][12] ),
    .reset( sec_tables__reset[0][12] )
  );

  RegEn__Type_Bits7 sec_tables__0__13
  (
    .clk( sec_tables__clk[0][13] ),
    .en( sec_tables__en[0][13] ),
    .in_( sec_tables__in_[0][13] ),
    .out( sec_tables__out[0][13] ),
    .reset( sec_tables__reset[0][13] )
  );

  RegEn__Type_Bits7 sec_tables__0__14
  (
    .clk( sec_tables__clk[0][14] ),
    .en( sec_tables__en[0][14] ),
    .in_( sec_tables__in_[0][14] ),
    .out( sec_tables__out[0][14] ),
    .reset( sec_tables__reset[0][14] )
  );

  RegEn__Type_Bits7 sec_tables__0__15
  (
    .clk( sec_tables__clk[0][15] ),
    .en( sec_tables__en[0][15] ),
    .in_( sec_tables__in_[0][15] ),
    .out( sec_tables__out[0][15] ),
    .reset( sec_tables__reset[0][15] )
  );

  RegEn__Type_Bits7 sec_tables__0__16
  (
    .clk( sec_tables__clk[0][16] ),
    .en( sec_tables__en[0][16] ),
    .in_( sec_tables__in_[0][16] ),
    .out( sec_tables__out[0][16] ),
    .reset( sec_tables__reset[0][16] )
  );

  RegEn__Type_Bits7 sec_tables__0__17
  (
    .clk( sec_tables__clk[0][17] ),
    .en( sec_tables__en[0][17] ),
    .in_( sec_tables__in_[0][17] ),
    .out( sec_tables__out[0][17] ),
    .reset( sec_tables__reset[0][17] )
  );

  RegEn__Type_Bits7 sec_tables__0__18
  (
    .clk( sec_tables__clk[0][18] ),
    .en( sec_tables__en[0][18] ),
    .in_( sec_tables__in_[0][18] ),
    .out( sec_tables__out[0][18] ),
    .reset( sec_tables__reset[0][18] )
  );

  RegEn__Type_Bits7 sec_tables__0__19
  (
    .clk( sec_tables__clk[0][19] ),
    .en( sec_tables__en[0][19] ),
    .in_( sec_tables__in_[0][19] ),
    .out( sec_tables__out[0][19] ),
    .reset( sec_tables__reset[0][19] )
  );

  RegEn__Type_Bits7 sec_tables__0__20
  (
    .clk( sec_tables__clk[0][20] ),
    .en( sec_tables__en[0][20] ),
    .in_( sec_tables__in_[0][20] ),
    .out( sec_tables__out[0][20] ),
    .reset( sec_tables__reset[0][20] )
  );

  RegEn__Type_Bits7 sec_tables__0__21
  (
    .clk( sec_tables__clk[0][21] ),
    .en( sec_tables__en[0][21] ),
    .in_( sec_tables__in_[0][21] ),
    .out( sec_tables__out[0][21] ),
    .reset( sec_tables__reset[0][21] )
  );

  RegEn__Type_Bits7 sec_tables__0__22
  (
    .clk( sec_tables__clk[0][22] ),
    .en( sec_tables__en[0][22] ),
    .in_( sec_tables__in_[0][22] ),
    .out( sec_tables__out[0][22] ),
    .reset( sec_tables__reset[0][22] )
  );

  RegEn__Type_Bits7 sec_tables__0__23
  (
    .clk( sec_tables__clk[0][23] ),
    .en( sec_tables__en[0][23] ),
    .in_( sec_tables__in_[0][23] ),
    .out( sec_tables__out[0][23] ),
    .reset( sec_tables__reset[0][23] )
  );

  RegEn__Type_Bits7 sec_tables__0__24
  (
    .clk( sec_tables__clk[0][24] ),
    .en( sec_tables__en[0][24] ),
    .in_( sec_tables__in_[0][24] ),
    .out( sec_tables__out[0][24] ),
    .reset( sec_tables__reset[0][24] )
  );

  RegEn__Type_Bits7 sec_tables__0__25
  (
    .clk( sec_tables__clk[0][25] ),
    .en( sec_tables__en[0][25] ),
    .in_( sec_tables__in_[0][25] ),
    .out( sec_tables__out[0][25] ),
    .reset( sec_tables__reset[0][25] )
  );

  RegEn__Type_Bits7 sec_tables__0__26
  (
    .clk( sec_tables__clk[0][26] ),
    .en( sec_tables__en[0][26] ),
    .in_( sec_tables__in_[0][26] ),
    .out( sec_tables__out[0][26] ),
    .reset( sec_tables__reset[0][26] )
  );

  RegEn__Type_Bits7 sec_tables__0__27
  (
    .clk( sec_tables__clk[0][27] ),
    .en( sec_tables__en[0][27] ),
    .in_( sec_tables__in_[0][27] ),
    .out( sec_tables__out[0][27] ),
    .reset( sec_tables__reset[0][27] )
  );

  RegEn__Type_Bits7 sec_tables__0__28
  (
    .clk( sec_tables__clk[0][28] ),
    .en( sec_tables__en[0][28] ),
    .in_( sec_tables__in_[0][28] ),
    .out( sec_tables__out[0][28] ),
    .reset( sec_tables__reset[0][28] )
  );

  RegEn__Type_Bits7 sec_tables__0__29
  (
    .clk( sec_tables__clk[0][29] ),
    .en( sec_tables__en[0][29] ),
    .in_( sec_tables__in_[0][29] ),
    .out( sec_tables__out[0][29] ),
    .reset( sec_tables__reset[0][29] )
  );

  RegEn__Type_Bits7 sec_tables__0__30
  (
    .clk( sec_tables__clk[0][30] ),
    .en( sec_tables__en[0][30] ),
    .in_( sec_tables__in_[0][30] ),
    .out( sec_tables__out[0][30] ),
    .reset( sec_tables__reset[0][30] )
  );

  RegEn__Type_Bits7 sec_tables__0__31
  (
    .clk( sec_tables__clk[0][31] ),
    .en( sec_tables__en[0][31] ),
    .in_( sec_tables__in_[0][31] ),
    .out( sec_tables__out[0][31] ),
    .reset( sec_tables__reset[0][31] )
  );

  RegEn__Type_Bits7 sec_tables__0__32
  (
    .clk( sec_tables__clk[0][32] ),
    .en( sec_tables__en[0][32] ),
    .in_( sec_tables__in_[0][32] ),
    .out( sec_tables__out[0][32] ),
    .reset( sec_tables__reset[0][32] )
  );

  RegEn__Type_Bits7 sec_tables__0__33
  (
    .clk( sec_tables__clk[0][33] ),
    .en( sec_tables__en[0][33] ),
    .in_( sec_tables__in_[0][33] ),
    .out( sec_tables__out[0][33] ),
    .reset( sec_tables__reset[0][33] )
  );

  RegEn__Type_Bits7 sec_tables__0__34
  (
    .clk( sec_tables__clk[0][34] ),
    .en( sec_tables__en[0][34] ),
    .in_( sec_tables__in_[0][34] ),
    .out( sec_tables__out[0][34] ),
    .reset( sec_tables__reset[0][34] )
  );

  RegEn__Type_Bits7 sec_tables__0__35
  (
    .clk( sec_tables__clk[0][35] ),
    .en( sec_tables__en[0][35] ),
    .in_( sec_tables__in_[0][35] ),
    .out( sec_tables__out[0][35] ),
    .reset( sec_tables__reset[0][35] )
  );

  RegEn__Type_Bits7 sec_tables__0__36
  (
    .clk( sec_tables__clk[0][36] ),
    .en( sec_tables__en[0][36] ),
    .in_( sec_tables__in_[0][36] ),
    .out( sec_tables__out[0][36] ),
    .reset( sec_tables__reset[0][36] )
  );

  RegEn__Type_Bits7 sec_tables__0__37
  (
    .clk( sec_tables__clk[0][37] ),
    .en( sec_tables__en[0][37] ),
    .in_( sec_tables__in_[0][37] ),
    .out( sec_tables__out[0][37] ),
    .reset( sec_tables__reset[0][37] )
  );

  RegEn__Type_Bits7 sec_tables__0__38
  (
    .clk( sec_tables__clk[0][38] ),
    .en( sec_tables__en[0][38] ),
    .in_( sec_tables__in_[0][38] ),
    .out( sec_tables__out[0][38] ),
    .reset( sec_tables__reset[0][38] )
  );

  RegEn__Type_Bits7 sec_tables__0__39
  (
    .clk( sec_tables__clk[0][39] ),
    .en( sec_tables__en[0][39] ),
    .in_( sec_tables__in_[0][39] ),
    .out( sec_tables__out[0][39] ),
    .reset( sec_tables__reset[0][39] )
  );

  RegEn__Type_Bits7 sec_tables__0__40
  (
    .clk( sec_tables__clk[0][40] ),
    .en( sec_tables__en[0][40] ),
    .in_( sec_tables__in_[0][40] ),
    .out( sec_tables__out[0][40] ),
    .reset( sec_tables__reset[0][40] )
  );

  RegEn__Type_Bits7 sec_tables__0__41
  (
    .clk( sec_tables__clk[0][41] ),
    .en( sec_tables__en[0][41] ),
    .in_( sec_tables__in_[0][41] ),
    .out( sec_tables__out[0][41] ),
    .reset( sec_tables__reset[0][41] )
  );

  RegEn__Type_Bits7 sec_tables__0__42
  (
    .clk( sec_tables__clk[0][42] ),
    .en( sec_tables__en[0][42] ),
    .in_( sec_tables__in_[0][42] ),
    .out( sec_tables__out[0][42] ),
    .reset( sec_tables__reset[0][42] )
  );

  RegEn__Type_Bits7 sec_tables__0__43
  (
    .clk( sec_tables__clk[0][43] ),
    .en( sec_tables__en[0][43] ),
    .in_( sec_tables__in_[0][43] ),
    .out( sec_tables__out[0][43] ),
    .reset( sec_tables__reset[0][43] )
  );

  RegEn__Type_Bits7 sec_tables__0__44
  (
    .clk( sec_tables__clk[0][44] ),
    .en( sec_tables__en[0][44] ),
    .in_( sec_tables__in_[0][44] ),
    .out( sec_tables__out[0][44] ),
    .reset( sec_tables__reset[0][44] )
  );

  RegEn__Type_Bits7 sec_tables__0__45
  (
    .clk( sec_tables__clk[0][45] ),
    .en( sec_tables__en[0][45] ),
    .in_( sec_tables__in_[0][45] ),
    .out( sec_tables__out[0][45] ),
    .reset( sec_tables__reset[0][45] )
  );

  RegEn__Type_Bits7 sec_tables__0__46
  (
    .clk( sec_tables__clk[0][46] ),
    .en( sec_tables__en[0][46] ),
    .in_( sec_tables__in_[0][46] ),
    .out( sec_tables__out[0][46] ),
    .reset( sec_tables__reset[0][46] )
  );

  RegEn__Type_Bits7 sec_tables__0__47
  (
    .clk( sec_tables__clk[0][47] ),
    .en( sec_tables__en[0][47] ),
    .in_( sec_tables__in_[0][47] ),
    .out( sec_tables__out[0][47] ),
    .reset( sec_tables__reset[0][47] )
  );

  RegEn__Type_Bits7 sec_tables__0__48
  (
    .clk( sec_tables__clk[0][48] ),
    .en( sec_tables__en[0][48] ),
    .in_( sec_tables__in_[0][48] ),
    .out( sec_tables__out[0][48] ),
    .reset( sec_tables__reset[0][48] )
  );

  RegEn__Type_Bits7 sec_tables__0__49
  (
    .clk( sec_tables__clk[0][49] ),
    .en( sec_tables__en[0][49] ),
    .in_( sec_tables__in_[0][49] ),
    .out( sec_tables__out[0][49] ),
    .reset( sec_tables__reset[0][49] )
  );

  RegEn__Type_Bits7 sec_tables__0__50
  (
    .clk( sec_tables__clk[0][50] ),
    .en( sec_tables__en[0][50] ),
    .in_( sec_tables__in_[0][50] ),
    .out( sec_tables__out[0][50] ),
    .reset( sec_tables__reset[0][50] )
  );

  RegEn__Type_Bits7 sec_tables__0__51
  (
    .clk( sec_tables__clk[0][51] ),
    .en( sec_tables__en[0][51] ),
    .in_( sec_tables__in_[0][51] ),
    .out( sec_tables__out[0][51] ),
    .reset( sec_tables__reset[0][51] )
  );

  RegEn__Type_Bits7 sec_tables__0__52
  (
    .clk( sec_tables__clk[0][52] ),
    .en( sec_tables__en[0][52] ),
    .in_( sec_tables__in_[0][52] ),
    .out( sec_tables__out[0][52] ),
    .reset( sec_tables__reset[0][52] )
  );

  RegEn__Type_Bits7 sec_tables__0__53
  (
    .clk( sec_tables__clk[0][53] ),
    .en( sec_tables__en[0][53] ),
    .in_( sec_tables__in_[0][53] ),
    .out( sec_tables__out[0][53] ),
    .reset( sec_tables__reset[0][53] )
  );

  RegEn__Type_Bits7 sec_tables__0__54
  (
    .clk( sec_tables__clk[0][54] ),
    .en( sec_tables__en[0][54] ),
    .in_( sec_tables__in_[0][54] ),
    .out( sec_tables__out[0][54] ),
    .reset( sec_tables__reset[0][54] )
  );

  RegEn__Type_Bits7 sec_tables__0__55
  (
    .clk( sec_tables__clk[0][55] ),
    .en( sec_tables__en[0][55] ),
    .in_( sec_tables__in_[0][55] ),
    .out( sec_tables__out[0][55] ),
    .reset( sec_tables__reset[0][55] )
  );

  RegEn__Type_Bits7 sec_tables__0__56
  (
    .clk( sec_tables__clk[0][56] ),
    .en( sec_tables__en[0][56] ),
    .in_( sec_tables__in_[0][56] ),
    .out( sec_tables__out[0][56] ),
    .reset( sec_tables__reset[0][56] )
  );

  RegEn__Type_Bits7 sec_tables__0__57
  (
    .clk( sec_tables__clk[0][57] ),
    .en( sec_tables__en[0][57] ),
    .in_( sec_tables__in_[0][57] ),
    .out( sec_tables__out[0][57] ),
    .reset( sec_tables__reset[0][57] )
  );

  RegEn__Type_Bits7 sec_tables__0__58
  (
    .clk( sec_tables__clk[0][58] ),
    .en( sec_tables__en[0][58] ),
    .in_( sec_tables__in_[0][58] ),
    .out( sec_tables__out[0][58] ),
    .reset( sec_tables__reset[0][58] )
  );

  RegEn__Type_Bits7 sec_tables__0__59
  (
    .clk( sec_tables__clk[0][59] ),
    .en( sec_tables__en[0][59] ),
    .in_( sec_tables__in_[0][59] ),
    .out( sec_tables__out[0][59] ),
    .reset( sec_tables__reset[0][59] )
  );

  RegEn__Type_Bits7 sec_tables__0__60
  (
    .clk( sec_tables__clk[0][60] ),
    .en( sec_tables__en[0][60] ),
    .in_( sec_tables__in_[0][60] ),
    .out( sec_tables__out[0][60] ),
    .reset( sec_tables__reset[0][60] )
  );

  RegEn__Type_Bits7 sec_tables__0__61
  (
    .clk( sec_tables__clk[0][61] ),
    .en( sec_tables__en[0][61] ),
    .in_( sec_tables__in_[0][61] ),
    .out( sec_tables__out[0][61] ),
    .reset( sec_tables__reset[0][61] )
  );

  RegEn__Type_Bits7 sec_tables__0__62
  (
    .clk( sec_tables__clk[0][62] ),
    .en( sec_tables__en[0][62] ),
    .in_( sec_tables__in_[0][62] ),
    .out( sec_tables__out[0][62] ),
    .reset( sec_tables__reset[0][62] )
  );

  RegEn__Type_Bits7 sec_tables__0__63
  (
    .clk( sec_tables__clk[0][63] ),
    .en( sec_tables__en[0][63] ),
    .in_( sec_tables__in_[0][63] ),
    .out( sec_tables__out[0][63] ),
    .reset( sec_tables__reset[0][63] )
  );

  RegEn__Type_Bits7 sec_tables__1__0
  (
    .clk( sec_tables__clk[1][0] ),
    .en( sec_tables__en[1][0] ),
    .in_( sec_tables__in_[1][0] ),
    .out( sec_tables__out[1][0] ),
    .reset( sec_tables__reset[1][0] )
  );

  RegEn__Type_Bits7 sec_tables__1__1
  (
    .clk( sec_tables__clk[1][1] ),
    .en( sec_tables__en[1][1] ),
    .in_( sec_tables__in_[1][1] ),
    .out( sec_tables__out[1][1] ),
    .reset( sec_tables__reset[1][1] )
  );

  RegEn__Type_Bits7 sec_tables__1__2
  (
    .clk( sec_tables__clk[1][2] ),
    .en( sec_tables__en[1][2] ),
    .in_( sec_tables__in_[1][2] ),
    .out( sec_tables__out[1][2] ),
    .reset( sec_tables__reset[1][2] )
  );

  RegEn__Type_Bits7 sec_tables__1__3
  (
    .clk( sec_tables__clk[1][3] ),
    .en( sec_tables__en[1][3] ),
    .in_( sec_tables__in_[1][3] ),
    .out( sec_tables__out[1][3] ),
    .reset( sec_tables__reset[1][3] )
  );

  RegEn__Type_Bits7 sec_tables__1__4
  (
    .clk( sec_tables__clk[1][4] ),
    .en( sec_tables__en[1][4] ),
    .in_( sec_tables__in_[1][4] ),
    .out( sec_tables__out[1][4] ),
    .reset( sec_tables__reset[1][4] )
  );

  RegEn__Type_Bits7 sec_tables__1__5
  (
    .clk( sec_tables__clk[1][5] ),
    .en( sec_tables__en[1][5] ),
    .in_( sec_tables__in_[1][5] ),
    .out( sec_tables__out[1][5] ),
    .reset( sec_tables__reset[1][5] )
  );

  RegEn__Type_Bits7 sec_tables__1__6
  (
    .clk( sec_tables__clk[1][6] ),
    .en( sec_tables__en[1][6] ),
    .in_( sec_tables__in_[1][6] ),
    .out( sec_tables__out[1][6] ),
    .reset( sec_tables__reset[1][6] )
  );

  RegEn__Type_Bits7 sec_tables__1__7
  (
    .clk( sec_tables__clk[1][7] ),
    .en( sec_tables__en[1][7] ),
    .in_( sec_tables__in_[1][7] ),
    .out( sec_tables__out[1][7] ),
    .reset( sec_tables__reset[1][7] )
  );

  RegEn__Type_Bits7 sec_tables__1__8
  (
    .clk( sec_tables__clk[1][8] ),
    .en( sec_tables__en[1][8] ),
    .in_( sec_tables__in_[1][8] ),
    .out( sec_tables__out[1][8] ),
    .reset( sec_tables__reset[1][8] )
  );

  RegEn__Type_Bits7 sec_tables__1__9
  (
    .clk( sec_tables__clk[1][9] ),
    .en( sec_tables__en[1][9] ),
    .in_( sec_tables__in_[1][9] ),
    .out( sec_tables__out[1][9] ),
    .reset( sec_tables__reset[1][9] )
  );

  RegEn__Type_Bits7 sec_tables__1__10
  (
    .clk( sec_tables__clk[1][10] ),
    .en( sec_tables__en[1][10] ),
    .in_( sec_tables__in_[1][10] ),
    .out( sec_tables__out[1][10] ),
    .reset( sec_tables__reset[1][10] )
  );

  RegEn__Type_Bits7 sec_tables__1__11
  (
    .clk( sec_tables__clk[1][11] ),
    .en( sec_tables__en[1][11] ),
    .in_( sec_tables__in_[1][11] ),
    .out( sec_tables__out[1][11] ),
    .reset( sec_tables__reset[1][11] )
  );

  RegEn__Type_Bits7 sec_tables__1__12
  (
    .clk( sec_tables__clk[1][12] ),
    .en( sec_tables__en[1][12] ),
    .in_( sec_tables__in_[1][12] ),
    .out( sec_tables__out[1][12] ),
    .reset( sec_tables__reset[1][12] )
  );

  RegEn__Type_Bits7 sec_tables__1__13
  (
    .clk( sec_tables__clk[1][13] ),
    .en( sec_tables__en[1][13] ),
    .in_( sec_tables__in_[1][13] ),
    .out( sec_tables__out[1][13] ),
    .reset( sec_tables__reset[1][13] )
  );

  RegEn__Type_Bits7 sec_tables__1__14
  (
    .clk( sec_tables__clk[1][14] ),
    .en( sec_tables__en[1][14] ),
    .in_( sec_tables__in_[1][14] ),
    .out( sec_tables__out[1][14] ),
    .reset( sec_tables__reset[1][14] )
  );

  RegEn__Type_Bits7 sec_tables__1__15
  (
    .clk( sec_tables__clk[1][15] ),
    .en( sec_tables__en[1][15] ),
    .in_( sec_tables__in_[1][15] ),
    .out( sec_tables__out[1][15] ),
    .reset( sec_tables__reset[1][15] )
  );

  RegEn__Type_Bits7 sec_tables__1__16
  (
    .clk( sec_tables__clk[1][16] ),
    .en( sec_tables__en[1][16] ),
    .in_( sec_tables__in_[1][16] ),
    .out( sec_tables__out[1][16] ),
    .reset( sec_tables__reset[1][16] )
  );

  RegEn__Type_Bits7 sec_tables__1__17
  (
    .clk( sec_tables__clk[1][17] ),
    .en( sec_tables__en[1][17] ),
    .in_( sec_tables__in_[1][17] ),
    .out( sec_tables__out[1][17] ),
    .reset( sec_tables__reset[1][17] )
  );

  RegEn__Type_Bits7 sec_tables__1__18
  (
    .clk( sec_tables__clk[1][18] ),
    .en( sec_tables__en[1][18] ),
    .in_( sec_tables__in_[1][18] ),
    .out( sec_tables__out[1][18] ),
    .reset( sec_tables__reset[1][18] )
  );

  RegEn__Type_Bits7 sec_tables__1__19
  (
    .clk( sec_tables__clk[1][19] ),
    .en( sec_tables__en[1][19] ),
    .in_( sec_tables__in_[1][19] ),
    .out( sec_tables__out[1][19] ),
    .reset( sec_tables__reset[1][19] )
  );

  RegEn__Type_Bits7 sec_tables__1__20
  (
    .clk( sec_tables__clk[1][20] ),
    .en( sec_tables__en[1][20] ),
    .in_( sec_tables__in_[1][20] ),
    .out( sec_tables__out[1][20] ),
    .reset( sec_tables__reset[1][20] )
  );

  RegEn__Type_Bits7 sec_tables__1__21
  (
    .clk( sec_tables__clk[1][21] ),
    .en( sec_tables__en[1][21] ),
    .in_( sec_tables__in_[1][21] ),
    .out( sec_tables__out[1][21] ),
    .reset( sec_tables__reset[1][21] )
  );

  RegEn__Type_Bits7 sec_tables__1__22
  (
    .clk( sec_tables__clk[1][22] ),
    .en( sec_tables__en[1][22] ),
    .in_( sec_tables__in_[1][22] ),
    .out( sec_tables__out[1][22] ),
    .reset( sec_tables__reset[1][22] )
  );

  RegEn__Type_Bits7 sec_tables__1__23
  (
    .clk( sec_tables__clk[1][23] ),
    .en( sec_tables__en[1][23] ),
    .in_( sec_tables__in_[1][23] ),
    .out( sec_tables__out[1][23] ),
    .reset( sec_tables__reset[1][23] )
  );

  RegEn__Type_Bits7 sec_tables__1__24
  (
    .clk( sec_tables__clk[1][24] ),
    .en( sec_tables__en[1][24] ),
    .in_( sec_tables__in_[1][24] ),
    .out( sec_tables__out[1][24] ),
    .reset( sec_tables__reset[1][24] )
  );

  RegEn__Type_Bits7 sec_tables__1__25
  (
    .clk( sec_tables__clk[1][25] ),
    .en( sec_tables__en[1][25] ),
    .in_( sec_tables__in_[1][25] ),
    .out( sec_tables__out[1][25] ),
    .reset( sec_tables__reset[1][25] )
  );

  RegEn__Type_Bits7 sec_tables__1__26
  (
    .clk( sec_tables__clk[1][26] ),
    .en( sec_tables__en[1][26] ),
    .in_( sec_tables__in_[1][26] ),
    .out( sec_tables__out[1][26] ),
    .reset( sec_tables__reset[1][26] )
  );

  RegEn__Type_Bits7 sec_tables__1__27
  (
    .clk( sec_tables__clk[1][27] ),
    .en( sec_tables__en[1][27] ),
    .in_( sec_tables__in_[1][27] ),
    .out( sec_tables__out[1][27] ),
    .reset( sec_tables__reset[1][27] )
  );

  RegEn__Type_Bits7 sec_tables__1__28
  (
    .clk( sec_tables__clk[1][28] ),
    .en( sec_tables__en[1][28] ),
    .in_( sec_tables__in_[1][28] ),
    .out( sec_tables__out[1][28] ),
    .reset( sec_tables__reset[1][28] )
  );

  RegEn__Type_Bits7 sec_tables__1__29
  (
    .clk( sec_tables__clk[1][29] ),
    .en( sec_tables__en[1][29] ),
    .in_( sec_tables__in_[1][29] ),
    .out( sec_tables__out[1][29] ),
    .reset( sec_tables__reset[1][29] )
  );

  RegEn__Type_Bits7 sec_tables__1__30
  (
    .clk( sec_tables__clk[1][30] ),
    .en( sec_tables__en[1][30] ),
    .in_( sec_tables__in_[1][30] ),
    .out( sec_tables__out[1][30] ),
    .reset( sec_tables__reset[1][30] )
  );

  RegEn__Type_Bits7 sec_tables__1__31
  (
    .clk( sec_tables__clk[1][31] ),
    .en( sec_tables__en[1][31] ),
    .in_( sec_tables__in_[1][31] ),
    .out( sec_tables__out[1][31] ),
    .reset( sec_tables__reset[1][31] )
  );

  RegEn__Type_Bits7 sec_tables__1__32
  (
    .clk( sec_tables__clk[1][32] ),
    .en( sec_tables__en[1][32] ),
    .in_( sec_tables__in_[1][32] ),
    .out( sec_tables__out[1][32] ),
    .reset( sec_tables__reset[1][32] )
  );

  RegEn__Type_Bits7 sec_tables__1__33
  (
    .clk( sec_tables__clk[1][33] ),
    .en( sec_tables__en[1][33] ),
    .in_( sec_tables__in_[1][33] ),
    .out( sec_tables__out[1][33] ),
    .reset( sec_tables__reset[1][33] )
  );

  RegEn__Type_Bits7 sec_tables__1__34
  (
    .clk( sec_tables__clk[1][34] ),
    .en( sec_tables__en[1][34] ),
    .in_( sec_tables__in_[1][34] ),
    .out( sec_tables__out[1][34] ),
    .reset( sec_tables__reset[1][34] )
  );

  RegEn__Type_Bits7 sec_tables__1__35
  (
    .clk( sec_tables__clk[1][35] ),
    .en( sec_tables__en[1][35] ),
    .in_( sec_tables__in_[1][35] ),
    .out( sec_tables__out[1][35] ),
    .reset( sec_tables__reset[1][35] )
  );

  RegEn__Type_Bits7 sec_tables__1__36
  (
    .clk( sec_tables__clk[1][36] ),
    .en( sec_tables__en[1][36] ),
    .in_( sec_tables__in_[1][36] ),
    .out( sec_tables__out[1][36] ),
    .reset( sec_tables__reset[1][36] )
  );

  RegEn__Type_Bits7 sec_tables__1__37
  (
    .clk( sec_tables__clk[1][37] ),
    .en( sec_tables__en[1][37] ),
    .in_( sec_tables__in_[1][37] ),
    .out( sec_tables__out[1][37] ),
    .reset( sec_tables__reset[1][37] )
  );

  RegEn__Type_Bits7 sec_tables__1__38
  (
    .clk( sec_tables__clk[1][38] ),
    .en( sec_tables__en[1][38] ),
    .in_( sec_tables__in_[1][38] ),
    .out( sec_tables__out[1][38] ),
    .reset( sec_tables__reset[1][38] )
  );

  RegEn__Type_Bits7 sec_tables__1__39
  (
    .clk( sec_tables__clk[1][39] ),
    .en( sec_tables__en[1][39] ),
    .in_( sec_tables__in_[1][39] ),
    .out( sec_tables__out[1][39] ),
    .reset( sec_tables__reset[1][39] )
  );

  RegEn__Type_Bits7 sec_tables__1__40
  (
    .clk( sec_tables__clk[1][40] ),
    .en( sec_tables__en[1][40] ),
    .in_( sec_tables__in_[1][40] ),
    .out( sec_tables__out[1][40] ),
    .reset( sec_tables__reset[1][40] )
  );

  RegEn__Type_Bits7 sec_tables__1__41
  (
    .clk( sec_tables__clk[1][41] ),
    .en( sec_tables__en[1][41] ),
    .in_( sec_tables__in_[1][41] ),
    .out( sec_tables__out[1][41] ),
    .reset( sec_tables__reset[1][41] )
  );

  RegEn__Type_Bits7 sec_tables__1__42
  (
    .clk( sec_tables__clk[1][42] ),
    .en( sec_tables__en[1][42] ),
    .in_( sec_tables__in_[1][42] ),
    .out( sec_tables__out[1][42] ),
    .reset( sec_tables__reset[1][42] )
  );

  RegEn__Type_Bits7 sec_tables__1__43
  (
    .clk( sec_tables__clk[1][43] ),
    .en( sec_tables__en[1][43] ),
    .in_( sec_tables__in_[1][43] ),
    .out( sec_tables__out[1][43] ),
    .reset( sec_tables__reset[1][43] )
  );

  RegEn__Type_Bits7 sec_tables__1__44
  (
    .clk( sec_tables__clk[1][44] ),
    .en( sec_tables__en[1][44] ),
    .in_( sec_tables__in_[1][44] ),
    .out( sec_tables__out[1][44] ),
    .reset( sec_tables__reset[1][44] )
  );

  RegEn__Type_Bits7 sec_tables__1__45
  (
    .clk( sec_tables__clk[1][45] ),
    .en( sec_tables__en[1][45] ),
    .in_( sec_tables__in_[1][45] ),
    .out( sec_tables__out[1][45] ),
    .reset( sec_tables__reset[1][45] )
  );

  RegEn__Type_Bits7 sec_tables__1__46
  (
    .clk( sec_tables__clk[1][46] ),
    .en( sec_tables__en[1][46] ),
    .in_( sec_tables__in_[1][46] ),
    .out( sec_tables__out[1][46] ),
    .reset( sec_tables__reset[1][46] )
  );

  RegEn__Type_Bits7 sec_tables__1__47
  (
    .clk( sec_tables__clk[1][47] ),
    .en( sec_tables__en[1][47] ),
    .in_( sec_tables__in_[1][47] ),
    .out( sec_tables__out[1][47] ),
    .reset( sec_tables__reset[1][47] )
  );

  RegEn__Type_Bits7 sec_tables__1__48
  (
    .clk( sec_tables__clk[1][48] ),
    .en( sec_tables__en[1][48] ),
    .in_( sec_tables__in_[1][48] ),
    .out( sec_tables__out[1][48] ),
    .reset( sec_tables__reset[1][48] )
  );

  RegEn__Type_Bits7 sec_tables__1__49
  (
    .clk( sec_tables__clk[1][49] ),
    .en( sec_tables__en[1][49] ),
    .in_( sec_tables__in_[1][49] ),
    .out( sec_tables__out[1][49] ),
    .reset( sec_tables__reset[1][49] )
  );

  RegEn__Type_Bits7 sec_tables__1__50
  (
    .clk( sec_tables__clk[1][50] ),
    .en( sec_tables__en[1][50] ),
    .in_( sec_tables__in_[1][50] ),
    .out( sec_tables__out[1][50] ),
    .reset( sec_tables__reset[1][50] )
  );

  RegEn__Type_Bits7 sec_tables__1__51
  (
    .clk( sec_tables__clk[1][51] ),
    .en( sec_tables__en[1][51] ),
    .in_( sec_tables__in_[1][51] ),
    .out( sec_tables__out[1][51] ),
    .reset( sec_tables__reset[1][51] )
  );

  RegEn__Type_Bits7 sec_tables__1__52
  (
    .clk( sec_tables__clk[1][52] ),
    .en( sec_tables__en[1][52] ),
    .in_( sec_tables__in_[1][52] ),
    .out( sec_tables__out[1][52] ),
    .reset( sec_tables__reset[1][52] )
  );

  RegEn__Type_Bits7 sec_tables__1__53
  (
    .clk( sec_tables__clk[1][53] ),
    .en( sec_tables__en[1][53] ),
    .in_( sec_tables__in_[1][53] ),
    .out( sec_tables__out[1][53] ),
    .reset( sec_tables__reset[1][53] )
  );

  RegEn__Type_Bits7 sec_tables__1__54
  (
    .clk( sec_tables__clk[1][54] ),
    .en( sec_tables__en[1][54] ),
    .in_( sec_tables__in_[1][54] ),
    .out( sec_tables__out[1][54] ),
    .reset( sec_tables__reset[1][54] )
  );

  RegEn__Type_Bits7 sec_tables__1__55
  (
    .clk( sec_tables__clk[1][55] ),
    .en( sec_tables__en[1][55] ),
    .in_( sec_tables__in_[1][55] ),
    .out( sec_tables__out[1][55] ),
    .reset( sec_tables__reset[1][55] )
  );

  RegEn__Type_Bits7 sec_tables__1__56
  (
    .clk( sec_tables__clk[1][56] ),
    .en( sec_tables__en[1][56] ),
    .in_( sec_tables__in_[1][56] ),
    .out( sec_tables__out[1][56] ),
    .reset( sec_tables__reset[1][56] )
  );

  RegEn__Type_Bits7 sec_tables__1__57
  (
    .clk( sec_tables__clk[1][57] ),
    .en( sec_tables__en[1][57] ),
    .in_( sec_tables__in_[1][57] ),
    .out( sec_tables__out[1][57] ),
    .reset( sec_tables__reset[1][57] )
  );

  RegEn__Type_Bits7 sec_tables__1__58
  (
    .clk( sec_tables__clk[1][58] ),
    .en( sec_tables__en[1][58] ),
    .in_( sec_tables__in_[1][58] ),
    .out( sec_tables__out[1][58] ),
    .reset( sec_tables__reset[1][58] )
  );

  RegEn__Type_Bits7 sec_tables__1__59
  (
    .clk( sec_tables__clk[1][59] ),
    .en( sec_tables__en[1][59] ),
    .in_( sec_tables__in_[1][59] ),
    .out( sec_tables__out[1][59] ),
    .reset( sec_tables__reset[1][59] )
  );

  RegEn__Type_Bits7 sec_tables__1__60
  (
    .clk( sec_tables__clk[1][60] ),
    .en( sec_tables__en[1][60] ),
    .in_( sec_tables__in_[1][60] ),
    .out( sec_tables__out[1][60] ),
    .reset( sec_tables__reset[1][60] )
  );

  RegEn__Type_Bits7 sec_tables__1__61
  (
    .clk( sec_tables__clk[1][61] ),
    .en( sec_tables__en[1][61] ),
    .in_( sec_tables__in_[1][61] ),
    .out( sec_tables__out[1][61] ),
    .reset( sec_tables__reset[1][61] )
  );

  RegEn__Type_Bits7 sec_tables__1__62
  (
    .clk( sec_tables__clk[1][62] ),
    .en( sec_tables__en[1][62] ),
    .in_( sec_tables__in_[1][62] ),
    .out( sec_tables__out[1][62] ),
    .reset( sec_tables__reset[1][62] )
  );

  RegEn__Type_Bits7 sec_tables__1__63
  (
    .clk( sec_tables__clk[1][63] ),
    .en( sec_tables__en[1][63] ),
    .in_( sec_tables__in_[1][63] ),
    .out( sec_tables__out[1][63] ),
    .reset( sec_tables__reset[1][63] )
  );

  //-------------------------------------------------------------
  // End of component sec_tables[0:1][0:63]
  //-------------------------------------------------------------
  logic [5:0] __tmpvar__comb_lookup_idx;
  logic [0:0] __tmpvar__comb_branch_idx;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/RenameTableRTL.py:130
  // @update
  // def comb():
  //   # default
  //   s.pri_table_en @= 0
  // 
  //   for tid in range( num_sec_tables ):
  //     s.sec_table_en[ tid ] @= 0
  // 
  //   for i in range( num_rd_ports ):
  //     s.lookup[ i ].ret @= 0
  // 
  //   for eid in range( num_aregs ):
  //     s.pri_table_muxes[ eid ].sel @= 0
  // 
  //   for tid in range( num_sec_tables ):
  //     for eid in range( num_aregs ):
  //       s.sec_table_muxes[ tid ][ eid ].sel @= 0
  // 
  //   # NOTE: @Tuan: rollback is assumed not to happen in the same cycle
  //   # with other calls including lookup, rename, checkpoint
  // 
  //   #
  //   # rollback
  //   #
  //   if s.rollback.en:
  //     s.pri_table_en @= 1
  //     for eid in range( num_aregs ):
  //       s.pri_table_muxes[ eid ].sel @= zext( s.rollback.msg, PriTableMuxSelT )
  // 
  //   #
  //   # not in rollback
  //   #
  //   else:
  //     #
  //     # lookup
  //     #
  //     for i in range( num_rd_ports ):
  //       if s.lookup[ i ].en:
  //         lookup_idx = s.lookup[ i ].msg
  //         s.lookup[ i ].ret @= s.pri_table[ lookup_idx ].out
  // 
  //     #
  //     # rename
  //     #
  //     if s.rename.en:
  //       # Update primary table
  //       s.pri_table_en @= 1
  // 
  //       for eid in range( num_aregs ):
  //         if s.rename.msg.areg_idx == eid:
  //           # choose s.rename.msg.preg_idx
  //           s.pri_table_muxes[ eid ].sel @= num_sec_tables
  //         else:
  //           # choose s.pri_table[ eid ].out
  //           s.pri_table_muxes[ eid ].sel @= num_sec_tables + 1
  // 
  //     #
  //     # checkpoint
  //     #
  //     if s.checkpoint.en:
  //       # idx of the branch is checkpointing the rename table
  //       branch_idx = s.checkpoint.msg
  // 
  //       # enable writing to s.sec_tables[ s.free_sec_table_idx ]
  //       s.sec_table_en[ branch_idx ] @= 1
  // 
  //       # if any rename is happening, we need to copy the new rename value
  //       # to the sec_table as well
  //       for eid in range( num_aregs ):
  //         if  s.rename.en & \
  //             ( s.rename.msg.areg_idx == eid ):
  //           # choose s.rename.msg.preg_idx
  //           s.sec_table_muxes[ branch_idx ][ eid ].sel @= 1
  //         else:
  //           # choose s.pri_table[ eid ].out
  //           s.sec_table_muxes[ branch_idx ][ eid ].sel @= 0
  
  always_comb begin : comb
    pri_table_en = 1'd0;
    for ( int unsigned tid = 1'd0; tid < 2'( __const__num_sec_tables_at_comb ); tid += 1'd1 )
      sec_table_en[1'(tid)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_ports_at_comb ); i += 1'd1 )
      lookup__ret[2'(i)] = 7'd0;
    for ( int unsigned eid = 1'd0; eid < 7'( __const__num_aregs_at_comb ); eid += 1'd1 )
      pri_table_muxes__sel[6'(eid)] = 2'd0;
    for ( int unsigned tid = 1'd0; tid < 2'( __const__num_sec_tables_at_comb ); tid += 1'd1 )
      for ( int unsigned eid = 1'd0; eid < 7'( __const__num_aregs_at_comb ); eid += 1'd1 )
        sec_table_muxes__sel[1'(tid)][6'(eid)] = 1'd0;
    if ( rollback__en ) begin
      pri_table_en = 1'd1;
      for ( int unsigned eid = 1'd0; eid < 7'( __const__num_aregs_at_comb ); eid += 1'd1 )
        pri_table_muxes__sel[6'(eid)] = { { 1 { 1'b0 } }, rollback__msg };
    end
    else begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_ports_at_comb ); i += 1'd1 )
        if ( lookup__en[2'(i)] ) begin
          __tmpvar__comb_lookup_idx = lookup__msg[2'(i)];
          lookup__ret[2'(i)] = pri_table__out[__tmpvar__comb_lookup_idx];
        end
      if ( rename__en ) begin
        pri_table_en = 1'd1;
        for ( int unsigned eid = 1'd0; eid < 7'( __const__num_aregs_at_comb ); eid += 1'd1 )
          if ( rename__msg.areg_idx == 6'(eid) ) begin
            pri_table_muxes__sel[6'(eid)] = 2'( __const__num_sec_tables_at_comb );
          end
          else
            pri_table_muxes__sel[6'(eid)] = 2'( __const__num_sec_tables_at_comb ) + 2'd1;
      end
      if ( checkpoint__en ) begin
        __tmpvar__comb_branch_idx = checkpoint__msg;
        sec_table_en[__tmpvar__comb_branch_idx] = 1'd1;
        for ( int unsigned eid = 1'd0; eid < 7'( __const__num_aregs_at_comb ); eid += 1'd1 )
          if ( rename__en & ( rename__msg.areg_idx == 6'(eid) ) ) begin
            sec_table_muxes__sel[__tmpvar__comb_branch_idx][6'(eid)] = 1'd1;
          end
          else
            sec_table_muxes__sel[__tmpvar__comb_branch_idx][6'(eid)] = 1'd0;
      end
    end
  end

  assign pri_table__clk[0] = clk;
  assign pri_table__reset[0] = reset;
  assign pri_table__clk[1] = clk;
  assign pri_table__reset[1] = reset;
  assign pri_table__clk[2] = clk;
  assign pri_table__reset[2] = reset;
  assign pri_table__clk[3] = clk;
  assign pri_table__reset[3] = reset;
  assign pri_table__clk[4] = clk;
  assign pri_table__reset[4] = reset;
  assign pri_table__clk[5] = clk;
  assign pri_table__reset[5] = reset;
  assign pri_table__clk[6] = clk;
  assign pri_table__reset[6] = reset;
  assign pri_table__clk[7] = clk;
  assign pri_table__reset[7] = reset;
  assign pri_table__clk[8] = clk;
  assign pri_table__reset[8] = reset;
  assign pri_table__clk[9] = clk;
  assign pri_table__reset[9] = reset;
  assign pri_table__clk[10] = clk;
  assign pri_table__reset[10] = reset;
  assign pri_table__clk[11] = clk;
  assign pri_table__reset[11] = reset;
  assign pri_table__clk[12] = clk;
  assign pri_table__reset[12] = reset;
  assign pri_table__clk[13] = clk;
  assign pri_table__reset[13] = reset;
  assign pri_table__clk[14] = clk;
  assign pri_table__reset[14] = reset;
  assign pri_table__clk[15] = clk;
  assign pri_table__reset[15] = reset;
  assign pri_table__clk[16] = clk;
  assign pri_table__reset[16] = reset;
  assign pri_table__clk[17] = clk;
  assign pri_table__reset[17] = reset;
  assign pri_table__clk[18] = clk;
  assign pri_table__reset[18] = reset;
  assign pri_table__clk[19] = clk;
  assign pri_table__reset[19] = reset;
  assign pri_table__clk[20] = clk;
  assign pri_table__reset[20] = reset;
  assign pri_table__clk[21] = clk;
  assign pri_table__reset[21] = reset;
  assign pri_table__clk[22] = clk;
  assign pri_table__reset[22] = reset;
  assign pri_table__clk[23] = clk;
  assign pri_table__reset[23] = reset;
  assign pri_table__clk[24] = clk;
  assign pri_table__reset[24] = reset;
  assign pri_table__clk[25] = clk;
  assign pri_table__reset[25] = reset;
  assign pri_table__clk[26] = clk;
  assign pri_table__reset[26] = reset;
  assign pri_table__clk[27] = clk;
  assign pri_table__reset[27] = reset;
  assign pri_table__clk[28] = clk;
  assign pri_table__reset[28] = reset;
  assign pri_table__clk[29] = clk;
  assign pri_table__reset[29] = reset;
  assign pri_table__clk[30] = clk;
  assign pri_table__reset[30] = reset;
  assign pri_table__clk[31] = clk;
  assign pri_table__reset[31] = reset;
  assign pri_table__clk[32] = clk;
  assign pri_table__reset[32] = reset;
  assign pri_table__clk[33] = clk;
  assign pri_table__reset[33] = reset;
  assign pri_table__clk[34] = clk;
  assign pri_table__reset[34] = reset;
  assign pri_table__clk[35] = clk;
  assign pri_table__reset[35] = reset;
  assign pri_table__clk[36] = clk;
  assign pri_table__reset[36] = reset;
  assign pri_table__clk[37] = clk;
  assign pri_table__reset[37] = reset;
  assign pri_table__clk[38] = clk;
  assign pri_table__reset[38] = reset;
  assign pri_table__clk[39] = clk;
  assign pri_table__reset[39] = reset;
  assign pri_table__clk[40] = clk;
  assign pri_table__reset[40] = reset;
  assign pri_table__clk[41] = clk;
  assign pri_table__reset[41] = reset;
  assign pri_table__clk[42] = clk;
  assign pri_table__reset[42] = reset;
  assign pri_table__clk[43] = clk;
  assign pri_table__reset[43] = reset;
  assign pri_table__clk[44] = clk;
  assign pri_table__reset[44] = reset;
  assign pri_table__clk[45] = clk;
  assign pri_table__reset[45] = reset;
  assign pri_table__clk[46] = clk;
  assign pri_table__reset[46] = reset;
  assign pri_table__clk[47] = clk;
  assign pri_table__reset[47] = reset;
  assign pri_table__clk[48] = clk;
  assign pri_table__reset[48] = reset;
  assign pri_table__clk[49] = clk;
  assign pri_table__reset[49] = reset;
  assign pri_table__clk[50] = clk;
  assign pri_table__reset[50] = reset;
  assign pri_table__clk[51] = clk;
  assign pri_table__reset[51] = reset;
  assign pri_table__clk[52] = clk;
  assign pri_table__reset[52] = reset;
  assign pri_table__clk[53] = clk;
  assign pri_table__reset[53] = reset;
  assign pri_table__clk[54] = clk;
  assign pri_table__reset[54] = reset;
  assign pri_table__clk[55] = clk;
  assign pri_table__reset[55] = reset;
  assign pri_table__clk[56] = clk;
  assign pri_table__reset[56] = reset;
  assign pri_table__clk[57] = clk;
  assign pri_table__reset[57] = reset;
  assign pri_table__clk[58] = clk;
  assign pri_table__reset[58] = reset;
  assign pri_table__clk[59] = clk;
  assign pri_table__reset[59] = reset;
  assign pri_table__clk[60] = clk;
  assign pri_table__reset[60] = reset;
  assign pri_table__clk[61] = clk;
  assign pri_table__reset[61] = reset;
  assign pri_table__clk[62] = clk;
  assign pri_table__reset[62] = reset;
  assign pri_table__clk[63] = clk;
  assign pri_table__reset[63] = reset;
  assign pri_table__en[0] = pri_table_en;
  assign pri_table__en[1] = pri_table_en;
  assign pri_table__en[2] = pri_table_en;
  assign pri_table__en[3] = pri_table_en;
  assign pri_table__en[4] = pri_table_en;
  assign pri_table__en[5] = pri_table_en;
  assign pri_table__en[6] = pri_table_en;
  assign pri_table__en[7] = pri_table_en;
  assign pri_table__en[8] = pri_table_en;
  assign pri_table__en[9] = pri_table_en;
  assign pri_table__en[10] = pri_table_en;
  assign pri_table__en[11] = pri_table_en;
  assign pri_table__en[12] = pri_table_en;
  assign pri_table__en[13] = pri_table_en;
  assign pri_table__en[14] = pri_table_en;
  assign pri_table__en[15] = pri_table_en;
  assign pri_table__en[16] = pri_table_en;
  assign pri_table__en[17] = pri_table_en;
  assign pri_table__en[18] = pri_table_en;
  assign pri_table__en[19] = pri_table_en;
  assign pri_table__en[20] = pri_table_en;
  assign pri_table__en[21] = pri_table_en;
  assign pri_table__en[22] = pri_table_en;
  assign pri_table__en[23] = pri_table_en;
  assign pri_table__en[24] = pri_table_en;
  assign pri_table__en[25] = pri_table_en;
  assign pri_table__en[26] = pri_table_en;
  assign pri_table__en[27] = pri_table_en;
  assign pri_table__en[28] = pri_table_en;
  assign pri_table__en[29] = pri_table_en;
  assign pri_table__en[30] = pri_table_en;
  assign pri_table__en[31] = pri_table_en;
  assign pri_table__en[32] = pri_table_en;
  assign pri_table__en[33] = pri_table_en;
  assign pri_table__en[34] = pri_table_en;
  assign pri_table__en[35] = pri_table_en;
  assign pri_table__en[36] = pri_table_en;
  assign pri_table__en[37] = pri_table_en;
  assign pri_table__en[38] = pri_table_en;
  assign pri_table__en[39] = pri_table_en;
  assign pri_table__en[40] = pri_table_en;
  assign pri_table__en[41] = pri_table_en;
  assign pri_table__en[42] = pri_table_en;
  assign pri_table__en[43] = pri_table_en;
  assign pri_table__en[44] = pri_table_en;
  assign pri_table__en[45] = pri_table_en;
  assign pri_table__en[46] = pri_table_en;
  assign pri_table__en[47] = pri_table_en;
  assign pri_table__en[48] = pri_table_en;
  assign pri_table__en[49] = pri_table_en;
  assign pri_table__en[50] = pri_table_en;
  assign pri_table__en[51] = pri_table_en;
  assign pri_table__en[52] = pri_table_en;
  assign pri_table__en[53] = pri_table_en;
  assign pri_table__en[54] = pri_table_en;
  assign pri_table__en[55] = pri_table_en;
  assign pri_table__en[56] = pri_table_en;
  assign pri_table__en[57] = pri_table_en;
  assign pri_table__en[58] = pri_table_en;
  assign pri_table__en[59] = pri_table_en;
  assign pri_table__en[60] = pri_table_en;
  assign pri_table__en[61] = pri_table_en;
  assign pri_table__en[62] = pri_table_en;
  assign pri_table__en[63] = pri_table_en;
  assign sec_tables__clk[0][0] = clk;
  assign sec_tables__reset[0][0] = reset;
  assign sec_tables__clk[0][1] = clk;
  assign sec_tables__reset[0][1] = reset;
  assign sec_tables__clk[0][2] = clk;
  assign sec_tables__reset[0][2] = reset;
  assign sec_tables__clk[0][3] = clk;
  assign sec_tables__reset[0][3] = reset;
  assign sec_tables__clk[0][4] = clk;
  assign sec_tables__reset[0][4] = reset;
  assign sec_tables__clk[0][5] = clk;
  assign sec_tables__reset[0][5] = reset;
  assign sec_tables__clk[0][6] = clk;
  assign sec_tables__reset[0][6] = reset;
  assign sec_tables__clk[0][7] = clk;
  assign sec_tables__reset[0][7] = reset;
  assign sec_tables__clk[0][8] = clk;
  assign sec_tables__reset[0][8] = reset;
  assign sec_tables__clk[0][9] = clk;
  assign sec_tables__reset[0][9] = reset;
  assign sec_tables__clk[0][10] = clk;
  assign sec_tables__reset[0][10] = reset;
  assign sec_tables__clk[0][11] = clk;
  assign sec_tables__reset[0][11] = reset;
  assign sec_tables__clk[0][12] = clk;
  assign sec_tables__reset[0][12] = reset;
  assign sec_tables__clk[0][13] = clk;
  assign sec_tables__reset[0][13] = reset;
  assign sec_tables__clk[0][14] = clk;
  assign sec_tables__reset[0][14] = reset;
  assign sec_tables__clk[0][15] = clk;
  assign sec_tables__reset[0][15] = reset;
  assign sec_tables__clk[0][16] = clk;
  assign sec_tables__reset[0][16] = reset;
  assign sec_tables__clk[0][17] = clk;
  assign sec_tables__reset[0][17] = reset;
  assign sec_tables__clk[0][18] = clk;
  assign sec_tables__reset[0][18] = reset;
  assign sec_tables__clk[0][19] = clk;
  assign sec_tables__reset[0][19] = reset;
  assign sec_tables__clk[0][20] = clk;
  assign sec_tables__reset[0][20] = reset;
  assign sec_tables__clk[0][21] = clk;
  assign sec_tables__reset[0][21] = reset;
  assign sec_tables__clk[0][22] = clk;
  assign sec_tables__reset[0][22] = reset;
  assign sec_tables__clk[0][23] = clk;
  assign sec_tables__reset[0][23] = reset;
  assign sec_tables__clk[0][24] = clk;
  assign sec_tables__reset[0][24] = reset;
  assign sec_tables__clk[0][25] = clk;
  assign sec_tables__reset[0][25] = reset;
  assign sec_tables__clk[0][26] = clk;
  assign sec_tables__reset[0][26] = reset;
  assign sec_tables__clk[0][27] = clk;
  assign sec_tables__reset[0][27] = reset;
  assign sec_tables__clk[0][28] = clk;
  assign sec_tables__reset[0][28] = reset;
  assign sec_tables__clk[0][29] = clk;
  assign sec_tables__reset[0][29] = reset;
  assign sec_tables__clk[0][30] = clk;
  assign sec_tables__reset[0][30] = reset;
  assign sec_tables__clk[0][31] = clk;
  assign sec_tables__reset[0][31] = reset;
  assign sec_tables__clk[0][32] = clk;
  assign sec_tables__reset[0][32] = reset;
  assign sec_tables__clk[0][33] = clk;
  assign sec_tables__reset[0][33] = reset;
  assign sec_tables__clk[0][34] = clk;
  assign sec_tables__reset[0][34] = reset;
  assign sec_tables__clk[0][35] = clk;
  assign sec_tables__reset[0][35] = reset;
  assign sec_tables__clk[0][36] = clk;
  assign sec_tables__reset[0][36] = reset;
  assign sec_tables__clk[0][37] = clk;
  assign sec_tables__reset[0][37] = reset;
  assign sec_tables__clk[0][38] = clk;
  assign sec_tables__reset[0][38] = reset;
  assign sec_tables__clk[0][39] = clk;
  assign sec_tables__reset[0][39] = reset;
  assign sec_tables__clk[0][40] = clk;
  assign sec_tables__reset[0][40] = reset;
  assign sec_tables__clk[0][41] = clk;
  assign sec_tables__reset[0][41] = reset;
  assign sec_tables__clk[0][42] = clk;
  assign sec_tables__reset[0][42] = reset;
  assign sec_tables__clk[0][43] = clk;
  assign sec_tables__reset[0][43] = reset;
  assign sec_tables__clk[0][44] = clk;
  assign sec_tables__reset[0][44] = reset;
  assign sec_tables__clk[0][45] = clk;
  assign sec_tables__reset[0][45] = reset;
  assign sec_tables__clk[0][46] = clk;
  assign sec_tables__reset[0][46] = reset;
  assign sec_tables__clk[0][47] = clk;
  assign sec_tables__reset[0][47] = reset;
  assign sec_tables__clk[0][48] = clk;
  assign sec_tables__reset[0][48] = reset;
  assign sec_tables__clk[0][49] = clk;
  assign sec_tables__reset[0][49] = reset;
  assign sec_tables__clk[0][50] = clk;
  assign sec_tables__reset[0][50] = reset;
  assign sec_tables__clk[0][51] = clk;
  assign sec_tables__reset[0][51] = reset;
  assign sec_tables__clk[0][52] = clk;
  assign sec_tables__reset[0][52] = reset;
  assign sec_tables__clk[0][53] = clk;
  assign sec_tables__reset[0][53] = reset;
  assign sec_tables__clk[0][54] = clk;
  assign sec_tables__reset[0][54] = reset;
  assign sec_tables__clk[0][55] = clk;
  assign sec_tables__reset[0][55] = reset;
  assign sec_tables__clk[0][56] = clk;
  assign sec_tables__reset[0][56] = reset;
  assign sec_tables__clk[0][57] = clk;
  assign sec_tables__reset[0][57] = reset;
  assign sec_tables__clk[0][58] = clk;
  assign sec_tables__reset[0][58] = reset;
  assign sec_tables__clk[0][59] = clk;
  assign sec_tables__reset[0][59] = reset;
  assign sec_tables__clk[0][60] = clk;
  assign sec_tables__reset[0][60] = reset;
  assign sec_tables__clk[0][61] = clk;
  assign sec_tables__reset[0][61] = reset;
  assign sec_tables__clk[0][62] = clk;
  assign sec_tables__reset[0][62] = reset;
  assign sec_tables__clk[0][63] = clk;
  assign sec_tables__reset[0][63] = reset;
  assign sec_tables__clk[1][0] = clk;
  assign sec_tables__reset[1][0] = reset;
  assign sec_tables__clk[1][1] = clk;
  assign sec_tables__reset[1][1] = reset;
  assign sec_tables__clk[1][2] = clk;
  assign sec_tables__reset[1][2] = reset;
  assign sec_tables__clk[1][3] = clk;
  assign sec_tables__reset[1][3] = reset;
  assign sec_tables__clk[1][4] = clk;
  assign sec_tables__reset[1][4] = reset;
  assign sec_tables__clk[1][5] = clk;
  assign sec_tables__reset[1][5] = reset;
  assign sec_tables__clk[1][6] = clk;
  assign sec_tables__reset[1][6] = reset;
  assign sec_tables__clk[1][7] = clk;
  assign sec_tables__reset[1][7] = reset;
  assign sec_tables__clk[1][8] = clk;
  assign sec_tables__reset[1][8] = reset;
  assign sec_tables__clk[1][9] = clk;
  assign sec_tables__reset[1][9] = reset;
  assign sec_tables__clk[1][10] = clk;
  assign sec_tables__reset[1][10] = reset;
  assign sec_tables__clk[1][11] = clk;
  assign sec_tables__reset[1][11] = reset;
  assign sec_tables__clk[1][12] = clk;
  assign sec_tables__reset[1][12] = reset;
  assign sec_tables__clk[1][13] = clk;
  assign sec_tables__reset[1][13] = reset;
  assign sec_tables__clk[1][14] = clk;
  assign sec_tables__reset[1][14] = reset;
  assign sec_tables__clk[1][15] = clk;
  assign sec_tables__reset[1][15] = reset;
  assign sec_tables__clk[1][16] = clk;
  assign sec_tables__reset[1][16] = reset;
  assign sec_tables__clk[1][17] = clk;
  assign sec_tables__reset[1][17] = reset;
  assign sec_tables__clk[1][18] = clk;
  assign sec_tables__reset[1][18] = reset;
  assign sec_tables__clk[1][19] = clk;
  assign sec_tables__reset[1][19] = reset;
  assign sec_tables__clk[1][20] = clk;
  assign sec_tables__reset[1][20] = reset;
  assign sec_tables__clk[1][21] = clk;
  assign sec_tables__reset[1][21] = reset;
  assign sec_tables__clk[1][22] = clk;
  assign sec_tables__reset[1][22] = reset;
  assign sec_tables__clk[1][23] = clk;
  assign sec_tables__reset[1][23] = reset;
  assign sec_tables__clk[1][24] = clk;
  assign sec_tables__reset[1][24] = reset;
  assign sec_tables__clk[1][25] = clk;
  assign sec_tables__reset[1][25] = reset;
  assign sec_tables__clk[1][26] = clk;
  assign sec_tables__reset[1][26] = reset;
  assign sec_tables__clk[1][27] = clk;
  assign sec_tables__reset[1][27] = reset;
  assign sec_tables__clk[1][28] = clk;
  assign sec_tables__reset[1][28] = reset;
  assign sec_tables__clk[1][29] = clk;
  assign sec_tables__reset[1][29] = reset;
  assign sec_tables__clk[1][30] = clk;
  assign sec_tables__reset[1][30] = reset;
  assign sec_tables__clk[1][31] = clk;
  assign sec_tables__reset[1][31] = reset;
  assign sec_tables__clk[1][32] = clk;
  assign sec_tables__reset[1][32] = reset;
  assign sec_tables__clk[1][33] = clk;
  assign sec_tables__reset[1][33] = reset;
  assign sec_tables__clk[1][34] = clk;
  assign sec_tables__reset[1][34] = reset;
  assign sec_tables__clk[1][35] = clk;
  assign sec_tables__reset[1][35] = reset;
  assign sec_tables__clk[1][36] = clk;
  assign sec_tables__reset[1][36] = reset;
  assign sec_tables__clk[1][37] = clk;
  assign sec_tables__reset[1][37] = reset;
  assign sec_tables__clk[1][38] = clk;
  assign sec_tables__reset[1][38] = reset;
  assign sec_tables__clk[1][39] = clk;
  assign sec_tables__reset[1][39] = reset;
  assign sec_tables__clk[1][40] = clk;
  assign sec_tables__reset[1][40] = reset;
  assign sec_tables__clk[1][41] = clk;
  assign sec_tables__reset[1][41] = reset;
  assign sec_tables__clk[1][42] = clk;
  assign sec_tables__reset[1][42] = reset;
  assign sec_tables__clk[1][43] = clk;
  assign sec_tables__reset[1][43] = reset;
  assign sec_tables__clk[1][44] = clk;
  assign sec_tables__reset[1][44] = reset;
  assign sec_tables__clk[1][45] = clk;
  assign sec_tables__reset[1][45] = reset;
  assign sec_tables__clk[1][46] = clk;
  assign sec_tables__reset[1][46] = reset;
  assign sec_tables__clk[1][47] = clk;
  assign sec_tables__reset[1][47] = reset;
  assign sec_tables__clk[1][48] = clk;
  assign sec_tables__reset[1][48] = reset;
  assign sec_tables__clk[1][49] = clk;
  assign sec_tables__reset[1][49] = reset;
  assign sec_tables__clk[1][50] = clk;
  assign sec_tables__reset[1][50] = reset;
  assign sec_tables__clk[1][51] = clk;
  assign sec_tables__reset[1][51] = reset;
  assign sec_tables__clk[1][52] = clk;
  assign sec_tables__reset[1][52] = reset;
  assign sec_tables__clk[1][53] = clk;
  assign sec_tables__reset[1][53] = reset;
  assign sec_tables__clk[1][54] = clk;
  assign sec_tables__reset[1][54] = reset;
  assign sec_tables__clk[1][55] = clk;
  assign sec_tables__reset[1][55] = reset;
  assign sec_tables__clk[1][56] = clk;
  assign sec_tables__reset[1][56] = reset;
  assign sec_tables__clk[1][57] = clk;
  assign sec_tables__reset[1][57] = reset;
  assign sec_tables__clk[1][58] = clk;
  assign sec_tables__reset[1][58] = reset;
  assign sec_tables__clk[1][59] = clk;
  assign sec_tables__reset[1][59] = reset;
  assign sec_tables__clk[1][60] = clk;
  assign sec_tables__reset[1][60] = reset;
  assign sec_tables__clk[1][61] = clk;
  assign sec_tables__reset[1][61] = reset;
  assign sec_tables__clk[1][62] = clk;
  assign sec_tables__reset[1][62] = reset;
  assign sec_tables__clk[1][63] = clk;
  assign sec_tables__reset[1][63] = reset;
  assign sec_tables__en[0][0] = sec_table_en[0];
  assign sec_tables__en[0][1] = sec_table_en[0];
  assign sec_tables__en[0][2] = sec_table_en[0];
  assign sec_tables__en[0][3] = sec_table_en[0];
  assign sec_tables__en[0][4] = sec_table_en[0];
  assign sec_tables__en[0][5] = sec_table_en[0];
  assign sec_tables__en[0][6] = sec_table_en[0];
  assign sec_tables__en[0][7] = sec_table_en[0];
  assign sec_tables__en[0][8] = sec_table_en[0];
  assign sec_tables__en[0][9] = sec_table_en[0];
  assign sec_tables__en[0][10] = sec_table_en[0];
  assign sec_tables__en[0][11] = sec_table_en[0];
  assign sec_tables__en[0][12] = sec_table_en[0];
  assign sec_tables__en[0][13] = sec_table_en[0];
  assign sec_tables__en[0][14] = sec_table_en[0];
  assign sec_tables__en[0][15] = sec_table_en[0];
  assign sec_tables__en[0][16] = sec_table_en[0];
  assign sec_tables__en[0][17] = sec_table_en[0];
  assign sec_tables__en[0][18] = sec_table_en[0];
  assign sec_tables__en[0][19] = sec_table_en[0];
  assign sec_tables__en[0][20] = sec_table_en[0];
  assign sec_tables__en[0][21] = sec_table_en[0];
  assign sec_tables__en[0][22] = sec_table_en[0];
  assign sec_tables__en[0][23] = sec_table_en[0];
  assign sec_tables__en[0][24] = sec_table_en[0];
  assign sec_tables__en[0][25] = sec_table_en[0];
  assign sec_tables__en[0][26] = sec_table_en[0];
  assign sec_tables__en[0][27] = sec_table_en[0];
  assign sec_tables__en[0][28] = sec_table_en[0];
  assign sec_tables__en[0][29] = sec_table_en[0];
  assign sec_tables__en[0][30] = sec_table_en[0];
  assign sec_tables__en[0][31] = sec_table_en[0];
  assign sec_tables__en[0][32] = sec_table_en[0];
  assign sec_tables__en[0][33] = sec_table_en[0];
  assign sec_tables__en[0][34] = sec_table_en[0];
  assign sec_tables__en[0][35] = sec_table_en[0];
  assign sec_tables__en[0][36] = sec_table_en[0];
  assign sec_tables__en[0][37] = sec_table_en[0];
  assign sec_tables__en[0][38] = sec_table_en[0];
  assign sec_tables__en[0][39] = sec_table_en[0];
  assign sec_tables__en[0][40] = sec_table_en[0];
  assign sec_tables__en[0][41] = sec_table_en[0];
  assign sec_tables__en[0][42] = sec_table_en[0];
  assign sec_tables__en[0][43] = sec_table_en[0];
  assign sec_tables__en[0][44] = sec_table_en[0];
  assign sec_tables__en[0][45] = sec_table_en[0];
  assign sec_tables__en[0][46] = sec_table_en[0];
  assign sec_tables__en[0][47] = sec_table_en[0];
  assign sec_tables__en[0][48] = sec_table_en[0];
  assign sec_tables__en[0][49] = sec_table_en[0];
  assign sec_tables__en[0][50] = sec_table_en[0];
  assign sec_tables__en[0][51] = sec_table_en[0];
  assign sec_tables__en[0][52] = sec_table_en[0];
  assign sec_tables__en[0][53] = sec_table_en[0];
  assign sec_tables__en[0][54] = sec_table_en[0];
  assign sec_tables__en[0][55] = sec_table_en[0];
  assign sec_tables__en[0][56] = sec_table_en[0];
  assign sec_tables__en[0][57] = sec_table_en[0];
  assign sec_tables__en[0][58] = sec_table_en[0];
  assign sec_tables__en[0][59] = sec_table_en[0];
  assign sec_tables__en[0][60] = sec_table_en[0];
  assign sec_tables__en[0][61] = sec_table_en[0];
  assign sec_tables__en[0][62] = sec_table_en[0];
  assign sec_tables__en[0][63] = sec_table_en[0];
  assign sec_tables__en[1][0] = sec_table_en[1];
  assign sec_tables__en[1][1] = sec_table_en[1];
  assign sec_tables__en[1][2] = sec_table_en[1];
  assign sec_tables__en[1][3] = sec_table_en[1];
  assign sec_tables__en[1][4] = sec_table_en[1];
  assign sec_tables__en[1][5] = sec_table_en[1];
  assign sec_tables__en[1][6] = sec_table_en[1];
  assign sec_tables__en[1][7] = sec_table_en[1];
  assign sec_tables__en[1][8] = sec_table_en[1];
  assign sec_tables__en[1][9] = sec_table_en[1];
  assign sec_tables__en[1][10] = sec_table_en[1];
  assign sec_tables__en[1][11] = sec_table_en[1];
  assign sec_tables__en[1][12] = sec_table_en[1];
  assign sec_tables__en[1][13] = sec_table_en[1];
  assign sec_tables__en[1][14] = sec_table_en[1];
  assign sec_tables__en[1][15] = sec_table_en[1];
  assign sec_tables__en[1][16] = sec_table_en[1];
  assign sec_tables__en[1][17] = sec_table_en[1];
  assign sec_tables__en[1][18] = sec_table_en[1];
  assign sec_tables__en[1][19] = sec_table_en[1];
  assign sec_tables__en[1][20] = sec_table_en[1];
  assign sec_tables__en[1][21] = sec_table_en[1];
  assign sec_tables__en[1][22] = sec_table_en[1];
  assign sec_tables__en[1][23] = sec_table_en[1];
  assign sec_tables__en[1][24] = sec_table_en[1];
  assign sec_tables__en[1][25] = sec_table_en[1];
  assign sec_tables__en[1][26] = sec_table_en[1];
  assign sec_tables__en[1][27] = sec_table_en[1];
  assign sec_tables__en[1][28] = sec_table_en[1];
  assign sec_tables__en[1][29] = sec_table_en[1];
  assign sec_tables__en[1][30] = sec_table_en[1];
  assign sec_tables__en[1][31] = sec_table_en[1];
  assign sec_tables__en[1][32] = sec_table_en[1];
  assign sec_tables__en[1][33] = sec_table_en[1];
  assign sec_tables__en[1][34] = sec_table_en[1];
  assign sec_tables__en[1][35] = sec_table_en[1];
  assign sec_tables__en[1][36] = sec_table_en[1];
  assign sec_tables__en[1][37] = sec_table_en[1];
  assign sec_tables__en[1][38] = sec_table_en[1];
  assign sec_tables__en[1][39] = sec_table_en[1];
  assign sec_tables__en[1][40] = sec_table_en[1];
  assign sec_tables__en[1][41] = sec_table_en[1];
  assign sec_tables__en[1][42] = sec_table_en[1];
  assign sec_tables__en[1][43] = sec_table_en[1];
  assign sec_tables__en[1][44] = sec_table_en[1];
  assign sec_tables__en[1][45] = sec_table_en[1];
  assign sec_tables__en[1][46] = sec_table_en[1];
  assign sec_tables__en[1][47] = sec_table_en[1];
  assign sec_tables__en[1][48] = sec_table_en[1];
  assign sec_tables__en[1][49] = sec_table_en[1];
  assign sec_tables__en[1][50] = sec_table_en[1];
  assign sec_tables__en[1][51] = sec_table_en[1];
  assign sec_tables__en[1][52] = sec_table_en[1];
  assign sec_tables__en[1][53] = sec_table_en[1];
  assign sec_tables__en[1][54] = sec_table_en[1];
  assign sec_tables__en[1][55] = sec_table_en[1];
  assign sec_tables__en[1][56] = sec_table_en[1];
  assign sec_tables__en[1][57] = sec_table_en[1];
  assign sec_tables__en[1][58] = sec_table_en[1];
  assign sec_tables__en[1][59] = sec_table_en[1];
  assign sec_tables__en[1][60] = sec_table_en[1];
  assign sec_tables__en[1][61] = sec_table_en[1];
  assign sec_tables__en[1][62] = sec_table_en[1];
  assign sec_tables__en[1][63] = sec_table_en[1];
  assign pri_table_muxes__clk[0] = clk;
  assign pri_table_muxes__reset[0] = reset;
  assign pri_table_muxes__clk[1] = clk;
  assign pri_table_muxes__reset[1] = reset;
  assign pri_table_muxes__clk[2] = clk;
  assign pri_table_muxes__reset[2] = reset;
  assign pri_table_muxes__clk[3] = clk;
  assign pri_table_muxes__reset[3] = reset;
  assign pri_table_muxes__clk[4] = clk;
  assign pri_table_muxes__reset[4] = reset;
  assign pri_table_muxes__clk[5] = clk;
  assign pri_table_muxes__reset[5] = reset;
  assign pri_table_muxes__clk[6] = clk;
  assign pri_table_muxes__reset[6] = reset;
  assign pri_table_muxes__clk[7] = clk;
  assign pri_table_muxes__reset[7] = reset;
  assign pri_table_muxes__clk[8] = clk;
  assign pri_table_muxes__reset[8] = reset;
  assign pri_table_muxes__clk[9] = clk;
  assign pri_table_muxes__reset[9] = reset;
  assign pri_table_muxes__clk[10] = clk;
  assign pri_table_muxes__reset[10] = reset;
  assign pri_table_muxes__clk[11] = clk;
  assign pri_table_muxes__reset[11] = reset;
  assign pri_table_muxes__clk[12] = clk;
  assign pri_table_muxes__reset[12] = reset;
  assign pri_table_muxes__clk[13] = clk;
  assign pri_table_muxes__reset[13] = reset;
  assign pri_table_muxes__clk[14] = clk;
  assign pri_table_muxes__reset[14] = reset;
  assign pri_table_muxes__clk[15] = clk;
  assign pri_table_muxes__reset[15] = reset;
  assign pri_table_muxes__clk[16] = clk;
  assign pri_table_muxes__reset[16] = reset;
  assign pri_table_muxes__clk[17] = clk;
  assign pri_table_muxes__reset[17] = reset;
  assign pri_table_muxes__clk[18] = clk;
  assign pri_table_muxes__reset[18] = reset;
  assign pri_table_muxes__clk[19] = clk;
  assign pri_table_muxes__reset[19] = reset;
  assign pri_table_muxes__clk[20] = clk;
  assign pri_table_muxes__reset[20] = reset;
  assign pri_table_muxes__clk[21] = clk;
  assign pri_table_muxes__reset[21] = reset;
  assign pri_table_muxes__clk[22] = clk;
  assign pri_table_muxes__reset[22] = reset;
  assign pri_table_muxes__clk[23] = clk;
  assign pri_table_muxes__reset[23] = reset;
  assign pri_table_muxes__clk[24] = clk;
  assign pri_table_muxes__reset[24] = reset;
  assign pri_table_muxes__clk[25] = clk;
  assign pri_table_muxes__reset[25] = reset;
  assign pri_table_muxes__clk[26] = clk;
  assign pri_table_muxes__reset[26] = reset;
  assign pri_table_muxes__clk[27] = clk;
  assign pri_table_muxes__reset[27] = reset;
  assign pri_table_muxes__clk[28] = clk;
  assign pri_table_muxes__reset[28] = reset;
  assign pri_table_muxes__clk[29] = clk;
  assign pri_table_muxes__reset[29] = reset;
  assign pri_table_muxes__clk[30] = clk;
  assign pri_table_muxes__reset[30] = reset;
  assign pri_table_muxes__clk[31] = clk;
  assign pri_table_muxes__reset[31] = reset;
  assign pri_table_muxes__clk[32] = clk;
  assign pri_table_muxes__reset[32] = reset;
  assign pri_table_muxes__clk[33] = clk;
  assign pri_table_muxes__reset[33] = reset;
  assign pri_table_muxes__clk[34] = clk;
  assign pri_table_muxes__reset[34] = reset;
  assign pri_table_muxes__clk[35] = clk;
  assign pri_table_muxes__reset[35] = reset;
  assign pri_table_muxes__clk[36] = clk;
  assign pri_table_muxes__reset[36] = reset;
  assign pri_table_muxes__clk[37] = clk;
  assign pri_table_muxes__reset[37] = reset;
  assign pri_table_muxes__clk[38] = clk;
  assign pri_table_muxes__reset[38] = reset;
  assign pri_table_muxes__clk[39] = clk;
  assign pri_table_muxes__reset[39] = reset;
  assign pri_table_muxes__clk[40] = clk;
  assign pri_table_muxes__reset[40] = reset;
  assign pri_table_muxes__clk[41] = clk;
  assign pri_table_muxes__reset[41] = reset;
  assign pri_table_muxes__clk[42] = clk;
  assign pri_table_muxes__reset[42] = reset;
  assign pri_table_muxes__clk[43] = clk;
  assign pri_table_muxes__reset[43] = reset;
  assign pri_table_muxes__clk[44] = clk;
  assign pri_table_muxes__reset[44] = reset;
  assign pri_table_muxes__clk[45] = clk;
  assign pri_table_muxes__reset[45] = reset;
  assign pri_table_muxes__clk[46] = clk;
  assign pri_table_muxes__reset[46] = reset;
  assign pri_table_muxes__clk[47] = clk;
  assign pri_table_muxes__reset[47] = reset;
  assign pri_table_muxes__clk[48] = clk;
  assign pri_table_muxes__reset[48] = reset;
  assign pri_table_muxes__clk[49] = clk;
  assign pri_table_muxes__reset[49] = reset;
  assign pri_table_muxes__clk[50] = clk;
  assign pri_table_muxes__reset[50] = reset;
  assign pri_table_muxes__clk[51] = clk;
  assign pri_table_muxes__reset[51] = reset;
  assign pri_table_muxes__clk[52] = clk;
  assign pri_table_muxes__reset[52] = reset;
  assign pri_table_muxes__clk[53] = clk;
  assign pri_table_muxes__reset[53] = reset;
  assign pri_table_muxes__clk[54] = clk;
  assign pri_table_muxes__reset[54] = reset;
  assign pri_table_muxes__clk[55] = clk;
  assign pri_table_muxes__reset[55] = reset;
  assign pri_table_muxes__clk[56] = clk;
  assign pri_table_muxes__reset[56] = reset;
  assign pri_table_muxes__clk[57] = clk;
  assign pri_table_muxes__reset[57] = reset;
  assign pri_table_muxes__clk[58] = clk;
  assign pri_table_muxes__reset[58] = reset;
  assign pri_table_muxes__clk[59] = clk;
  assign pri_table_muxes__reset[59] = reset;
  assign pri_table_muxes__clk[60] = clk;
  assign pri_table_muxes__reset[60] = reset;
  assign pri_table_muxes__clk[61] = clk;
  assign pri_table_muxes__reset[61] = reset;
  assign pri_table_muxes__clk[62] = clk;
  assign pri_table_muxes__reset[62] = reset;
  assign pri_table_muxes__clk[63] = clk;
  assign pri_table_muxes__reset[63] = reset;
  assign pri_table_muxes__in_[0][0] = sec_tables__out[0][0];
  assign pri_table_muxes__in_[0][1] = sec_tables__out[1][0];
  assign pri_table__in_[0] = pri_table_muxes__out[0];
  assign pri_table_muxes__in_[0][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[0][3] = pri_table__out[0];
  assign pri_table_muxes__in_[1][0] = sec_tables__out[0][1];
  assign pri_table_muxes__in_[1][1] = sec_tables__out[1][1];
  assign pri_table__in_[1] = pri_table_muxes__out[1];
  assign pri_table_muxes__in_[1][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[1][3] = pri_table__out[1];
  assign pri_table_muxes__in_[2][0] = sec_tables__out[0][2];
  assign pri_table_muxes__in_[2][1] = sec_tables__out[1][2];
  assign pri_table__in_[2] = pri_table_muxes__out[2];
  assign pri_table_muxes__in_[2][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[2][3] = pri_table__out[2];
  assign pri_table_muxes__in_[3][0] = sec_tables__out[0][3];
  assign pri_table_muxes__in_[3][1] = sec_tables__out[1][3];
  assign pri_table__in_[3] = pri_table_muxes__out[3];
  assign pri_table_muxes__in_[3][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[3][3] = pri_table__out[3];
  assign pri_table_muxes__in_[4][0] = sec_tables__out[0][4];
  assign pri_table_muxes__in_[4][1] = sec_tables__out[1][4];
  assign pri_table__in_[4] = pri_table_muxes__out[4];
  assign pri_table_muxes__in_[4][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[4][3] = pri_table__out[4];
  assign pri_table_muxes__in_[5][0] = sec_tables__out[0][5];
  assign pri_table_muxes__in_[5][1] = sec_tables__out[1][5];
  assign pri_table__in_[5] = pri_table_muxes__out[5];
  assign pri_table_muxes__in_[5][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[5][3] = pri_table__out[5];
  assign pri_table_muxes__in_[6][0] = sec_tables__out[0][6];
  assign pri_table_muxes__in_[6][1] = sec_tables__out[1][6];
  assign pri_table__in_[6] = pri_table_muxes__out[6];
  assign pri_table_muxes__in_[6][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[6][3] = pri_table__out[6];
  assign pri_table_muxes__in_[7][0] = sec_tables__out[0][7];
  assign pri_table_muxes__in_[7][1] = sec_tables__out[1][7];
  assign pri_table__in_[7] = pri_table_muxes__out[7];
  assign pri_table_muxes__in_[7][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[7][3] = pri_table__out[7];
  assign pri_table_muxes__in_[8][0] = sec_tables__out[0][8];
  assign pri_table_muxes__in_[8][1] = sec_tables__out[1][8];
  assign pri_table__in_[8] = pri_table_muxes__out[8];
  assign pri_table_muxes__in_[8][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[8][3] = pri_table__out[8];
  assign pri_table_muxes__in_[9][0] = sec_tables__out[0][9];
  assign pri_table_muxes__in_[9][1] = sec_tables__out[1][9];
  assign pri_table__in_[9] = pri_table_muxes__out[9];
  assign pri_table_muxes__in_[9][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[9][3] = pri_table__out[9];
  assign pri_table_muxes__in_[10][0] = sec_tables__out[0][10];
  assign pri_table_muxes__in_[10][1] = sec_tables__out[1][10];
  assign pri_table__in_[10] = pri_table_muxes__out[10];
  assign pri_table_muxes__in_[10][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[10][3] = pri_table__out[10];
  assign pri_table_muxes__in_[11][0] = sec_tables__out[0][11];
  assign pri_table_muxes__in_[11][1] = sec_tables__out[1][11];
  assign pri_table__in_[11] = pri_table_muxes__out[11];
  assign pri_table_muxes__in_[11][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[11][3] = pri_table__out[11];
  assign pri_table_muxes__in_[12][0] = sec_tables__out[0][12];
  assign pri_table_muxes__in_[12][1] = sec_tables__out[1][12];
  assign pri_table__in_[12] = pri_table_muxes__out[12];
  assign pri_table_muxes__in_[12][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[12][3] = pri_table__out[12];
  assign pri_table_muxes__in_[13][0] = sec_tables__out[0][13];
  assign pri_table_muxes__in_[13][1] = sec_tables__out[1][13];
  assign pri_table__in_[13] = pri_table_muxes__out[13];
  assign pri_table_muxes__in_[13][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[13][3] = pri_table__out[13];
  assign pri_table_muxes__in_[14][0] = sec_tables__out[0][14];
  assign pri_table_muxes__in_[14][1] = sec_tables__out[1][14];
  assign pri_table__in_[14] = pri_table_muxes__out[14];
  assign pri_table_muxes__in_[14][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[14][3] = pri_table__out[14];
  assign pri_table_muxes__in_[15][0] = sec_tables__out[0][15];
  assign pri_table_muxes__in_[15][1] = sec_tables__out[1][15];
  assign pri_table__in_[15] = pri_table_muxes__out[15];
  assign pri_table_muxes__in_[15][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[15][3] = pri_table__out[15];
  assign pri_table_muxes__in_[16][0] = sec_tables__out[0][16];
  assign pri_table_muxes__in_[16][1] = sec_tables__out[1][16];
  assign pri_table__in_[16] = pri_table_muxes__out[16];
  assign pri_table_muxes__in_[16][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[16][3] = pri_table__out[16];
  assign pri_table_muxes__in_[17][0] = sec_tables__out[0][17];
  assign pri_table_muxes__in_[17][1] = sec_tables__out[1][17];
  assign pri_table__in_[17] = pri_table_muxes__out[17];
  assign pri_table_muxes__in_[17][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[17][3] = pri_table__out[17];
  assign pri_table_muxes__in_[18][0] = sec_tables__out[0][18];
  assign pri_table_muxes__in_[18][1] = sec_tables__out[1][18];
  assign pri_table__in_[18] = pri_table_muxes__out[18];
  assign pri_table_muxes__in_[18][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[18][3] = pri_table__out[18];
  assign pri_table_muxes__in_[19][0] = sec_tables__out[0][19];
  assign pri_table_muxes__in_[19][1] = sec_tables__out[1][19];
  assign pri_table__in_[19] = pri_table_muxes__out[19];
  assign pri_table_muxes__in_[19][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[19][3] = pri_table__out[19];
  assign pri_table_muxes__in_[20][0] = sec_tables__out[0][20];
  assign pri_table_muxes__in_[20][1] = sec_tables__out[1][20];
  assign pri_table__in_[20] = pri_table_muxes__out[20];
  assign pri_table_muxes__in_[20][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[20][3] = pri_table__out[20];
  assign pri_table_muxes__in_[21][0] = sec_tables__out[0][21];
  assign pri_table_muxes__in_[21][1] = sec_tables__out[1][21];
  assign pri_table__in_[21] = pri_table_muxes__out[21];
  assign pri_table_muxes__in_[21][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[21][3] = pri_table__out[21];
  assign pri_table_muxes__in_[22][0] = sec_tables__out[0][22];
  assign pri_table_muxes__in_[22][1] = sec_tables__out[1][22];
  assign pri_table__in_[22] = pri_table_muxes__out[22];
  assign pri_table_muxes__in_[22][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[22][3] = pri_table__out[22];
  assign pri_table_muxes__in_[23][0] = sec_tables__out[0][23];
  assign pri_table_muxes__in_[23][1] = sec_tables__out[1][23];
  assign pri_table__in_[23] = pri_table_muxes__out[23];
  assign pri_table_muxes__in_[23][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[23][3] = pri_table__out[23];
  assign pri_table_muxes__in_[24][0] = sec_tables__out[0][24];
  assign pri_table_muxes__in_[24][1] = sec_tables__out[1][24];
  assign pri_table__in_[24] = pri_table_muxes__out[24];
  assign pri_table_muxes__in_[24][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[24][3] = pri_table__out[24];
  assign pri_table_muxes__in_[25][0] = sec_tables__out[0][25];
  assign pri_table_muxes__in_[25][1] = sec_tables__out[1][25];
  assign pri_table__in_[25] = pri_table_muxes__out[25];
  assign pri_table_muxes__in_[25][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[25][3] = pri_table__out[25];
  assign pri_table_muxes__in_[26][0] = sec_tables__out[0][26];
  assign pri_table_muxes__in_[26][1] = sec_tables__out[1][26];
  assign pri_table__in_[26] = pri_table_muxes__out[26];
  assign pri_table_muxes__in_[26][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[26][3] = pri_table__out[26];
  assign pri_table_muxes__in_[27][0] = sec_tables__out[0][27];
  assign pri_table_muxes__in_[27][1] = sec_tables__out[1][27];
  assign pri_table__in_[27] = pri_table_muxes__out[27];
  assign pri_table_muxes__in_[27][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[27][3] = pri_table__out[27];
  assign pri_table_muxes__in_[28][0] = sec_tables__out[0][28];
  assign pri_table_muxes__in_[28][1] = sec_tables__out[1][28];
  assign pri_table__in_[28] = pri_table_muxes__out[28];
  assign pri_table_muxes__in_[28][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[28][3] = pri_table__out[28];
  assign pri_table_muxes__in_[29][0] = sec_tables__out[0][29];
  assign pri_table_muxes__in_[29][1] = sec_tables__out[1][29];
  assign pri_table__in_[29] = pri_table_muxes__out[29];
  assign pri_table_muxes__in_[29][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[29][3] = pri_table__out[29];
  assign pri_table_muxes__in_[30][0] = sec_tables__out[0][30];
  assign pri_table_muxes__in_[30][1] = sec_tables__out[1][30];
  assign pri_table__in_[30] = pri_table_muxes__out[30];
  assign pri_table_muxes__in_[30][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[30][3] = pri_table__out[30];
  assign pri_table_muxes__in_[31][0] = sec_tables__out[0][31];
  assign pri_table_muxes__in_[31][1] = sec_tables__out[1][31];
  assign pri_table__in_[31] = pri_table_muxes__out[31];
  assign pri_table_muxes__in_[31][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[31][3] = pri_table__out[31];
  assign pri_table_muxes__in_[32][0] = sec_tables__out[0][32];
  assign pri_table_muxes__in_[32][1] = sec_tables__out[1][32];
  assign pri_table__in_[32] = pri_table_muxes__out[32];
  assign pri_table_muxes__in_[32][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[32][3] = pri_table__out[32];
  assign pri_table_muxes__in_[33][0] = sec_tables__out[0][33];
  assign pri_table_muxes__in_[33][1] = sec_tables__out[1][33];
  assign pri_table__in_[33] = pri_table_muxes__out[33];
  assign pri_table_muxes__in_[33][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[33][3] = pri_table__out[33];
  assign pri_table_muxes__in_[34][0] = sec_tables__out[0][34];
  assign pri_table_muxes__in_[34][1] = sec_tables__out[1][34];
  assign pri_table__in_[34] = pri_table_muxes__out[34];
  assign pri_table_muxes__in_[34][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[34][3] = pri_table__out[34];
  assign pri_table_muxes__in_[35][0] = sec_tables__out[0][35];
  assign pri_table_muxes__in_[35][1] = sec_tables__out[1][35];
  assign pri_table__in_[35] = pri_table_muxes__out[35];
  assign pri_table_muxes__in_[35][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[35][3] = pri_table__out[35];
  assign pri_table_muxes__in_[36][0] = sec_tables__out[0][36];
  assign pri_table_muxes__in_[36][1] = sec_tables__out[1][36];
  assign pri_table__in_[36] = pri_table_muxes__out[36];
  assign pri_table_muxes__in_[36][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[36][3] = pri_table__out[36];
  assign pri_table_muxes__in_[37][0] = sec_tables__out[0][37];
  assign pri_table_muxes__in_[37][1] = sec_tables__out[1][37];
  assign pri_table__in_[37] = pri_table_muxes__out[37];
  assign pri_table_muxes__in_[37][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[37][3] = pri_table__out[37];
  assign pri_table_muxes__in_[38][0] = sec_tables__out[0][38];
  assign pri_table_muxes__in_[38][1] = sec_tables__out[1][38];
  assign pri_table__in_[38] = pri_table_muxes__out[38];
  assign pri_table_muxes__in_[38][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[38][3] = pri_table__out[38];
  assign pri_table_muxes__in_[39][0] = sec_tables__out[0][39];
  assign pri_table_muxes__in_[39][1] = sec_tables__out[1][39];
  assign pri_table__in_[39] = pri_table_muxes__out[39];
  assign pri_table_muxes__in_[39][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[39][3] = pri_table__out[39];
  assign pri_table_muxes__in_[40][0] = sec_tables__out[0][40];
  assign pri_table_muxes__in_[40][1] = sec_tables__out[1][40];
  assign pri_table__in_[40] = pri_table_muxes__out[40];
  assign pri_table_muxes__in_[40][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[40][3] = pri_table__out[40];
  assign pri_table_muxes__in_[41][0] = sec_tables__out[0][41];
  assign pri_table_muxes__in_[41][1] = sec_tables__out[1][41];
  assign pri_table__in_[41] = pri_table_muxes__out[41];
  assign pri_table_muxes__in_[41][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[41][3] = pri_table__out[41];
  assign pri_table_muxes__in_[42][0] = sec_tables__out[0][42];
  assign pri_table_muxes__in_[42][1] = sec_tables__out[1][42];
  assign pri_table__in_[42] = pri_table_muxes__out[42];
  assign pri_table_muxes__in_[42][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[42][3] = pri_table__out[42];
  assign pri_table_muxes__in_[43][0] = sec_tables__out[0][43];
  assign pri_table_muxes__in_[43][1] = sec_tables__out[1][43];
  assign pri_table__in_[43] = pri_table_muxes__out[43];
  assign pri_table_muxes__in_[43][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[43][3] = pri_table__out[43];
  assign pri_table_muxes__in_[44][0] = sec_tables__out[0][44];
  assign pri_table_muxes__in_[44][1] = sec_tables__out[1][44];
  assign pri_table__in_[44] = pri_table_muxes__out[44];
  assign pri_table_muxes__in_[44][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[44][3] = pri_table__out[44];
  assign pri_table_muxes__in_[45][0] = sec_tables__out[0][45];
  assign pri_table_muxes__in_[45][1] = sec_tables__out[1][45];
  assign pri_table__in_[45] = pri_table_muxes__out[45];
  assign pri_table_muxes__in_[45][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[45][3] = pri_table__out[45];
  assign pri_table_muxes__in_[46][0] = sec_tables__out[0][46];
  assign pri_table_muxes__in_[46][1] = sec_tables__out[1][46];
  assign pri_table__in_[46] = pri_table_muxes__out[46];
  assign pri_table_muxes__in_[46][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[46][3] = pri_table__out[46];
  assign pri_table_muxes__in_[47][0] = sec_tables__out[0][47];
  assign pri_table_muxes__in_[47][1] = sec_tables__out[1][47];
  assign pri_table__in_[47] = pri_table_muxes__out[47];
  assign pri_table_muxes__in_[47][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[47][3] = pri_table__out[47];
  assign pri_table_muxes__in_[48][0] = sec_tables__out[0][48];
  assign pri_table_muxes__in_[48][1] = sec_tables__out[1][48];
  assign pri_table__in_[48] = pri_table_muxes__out[48];
  assign pri_table_muxes__in_[48][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[48][3] = pri_table__out[48];
  assign pri_table_muxes__in_[49][0] = sec_tables__out[0][49];
  assign pri_table_muxes__in_[49][1] = sec_tables__out[1][49];
  assign pri_table__in_[49] = pri_table_muxes__out[49];
  assign pri_table_muxes__in_[49][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[49][3] = pri_table__out[49];
  assign pri_table_muxes__in_[50][0] = sec_tables__out[0][50];
  assign pri_table_muxes__in_[50][1] = sec_tables__out[1][50];
  assign pri_table__in_[50] = pri_table_muxes__out[50];
  assign pri_table_muxes__in_[50][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[50][3] = pri_table__out[50];
  assign pri_table_muxes__in_[51][0] = sec_tables__out[0][51];
  assign pri_table_muxes__in_[51][1] = sec_tables__out[1][51];
  assign pri_table__in_[51] = pri_table_muxes__out[51];
  assign pri_table_muxes__in_[51][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[51][3] = pri_table__out[51];
  assign pri_table_muxes__in_[52][0] = sec_tables__out[0][52];
  assign pri_table_muxes__in_[52][1] = sec_tables__out[1][52];
  assign pri_table__in_[52] = pri_table_muxes__out[52];
  assign pri_table_muxes__in_[52][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[52][3] = pri_table__out[52];
  assign pri_table_muxes__in_[53][0] = sec_tables__out[0][53];
  assign pri_table_muxes__in_[53][1] = sec_tables__out[1][53];
  assign pri_table__in_[53] = pri_table_muxes__out[53];
  assign pri_table_muxes__in_[53][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[53][3] = pri_table__out[53];
  assign pri_table_muxes__in_[54][0] = sec_tables__out[0][54];
  assign pri_table_muxes__in_[54][1] = sec_tables__out[1][54];
  assign pri_table__in_[54] = pri_table_muxes__out[54];
  assign pri_table_muxes__in_[54][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[54][3] = pri_table__out[54];
  assign pri_table_muxes__in_[55][0] = sec_tables__out[0][55];
  assign pri_table_muxes__in_[55][1] = sec_tables__out[1][55];
  assign pri_table__in_[55] = pri_table_muxes__out[55];
  assign pri_table_muxes__in_[55][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[55][3] = pri_table__out[55];
  assign pri_table_muxes__in_[56][0] = sec_tables__out[0][56];
  assign pri_table_muxes__in_[56][1] = sec_tables__out[1][56];
  assign pri_table__in_[56] = pri_table_muxes__out[56];
  assign pri_table_muxes__in_[56][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[56][3] = pri_table__out[56];
  assign pri_table_muxes__in_[57][0] = sec_tables__out[0][57];
  assign pri_table_muxes__in_[57][1] = sec_tables__out[1][57];
  assign pri_table__in_[57] = pri_table_muxes__out[57];
  assign pri_table_muxes__in_[57][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[57][3] = pri_table__out[57];
  assign pri_table_muxes__in_[58][0] = sec_tables__out[0][58];
  assign pri_table_muxes__in_[58][1] = sec_tables__out[1][58];
  assign pri_table__in_[58] = pri_table_muxes__out[58];
  assign pri_table_muxes__in_[58][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[58][3] = pri_table__out[58];
  assign pri_table_muxes__in_[59][0] = sec_tables__out[0][59];
  assign pri_table_muxes__in_[59][1] = sec_tables__out[1][59];
  assign pri_table__in_[59] = pri_table_muxes__out[59];
  assign pri_table_muxes__in_[59][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[59][3] = pri_table__out[59];
  assign pri_table_muxes__in_[60][0] = sec_tables__out[0][60];
  assign pri_table_muxes__in_[60][1] = sec_tables__out[1][60];
  assign pri_table__in_[60] = pri_table_muxes__out[60];
  assign pri_table_muxes__in_[60][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[60][3] = pri_table__out[60];
  assign pri_table_muxes__in_[61][0] = sec_tables__out[0][61];
  assign pri_table_muxes__in_[61][1] = sec_tables__out[1][61];
  assign pri_table__in_[61] = pri_table_muxes__out[61];
  assign pri_table_muxes__in_[61][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[61][3] = pri_table__out[61];
  assign pri_table_muxes__in_[62][0] = sec_tables__out[0][62];
  assign pri_table_muxes__in_[62][1] = sec_tables__out[1][62];
  assign pri_table__in_[62] = pri_table_muxes__out[62];
  assign pri_table_muxes__in_[62][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[62][3] = pri_table__out[62];
  assign pri_table_muxes__in_[63][0] = sec_tables__out[0][63];
  assign pri_table_muxes__in_[63][1] = sec_tables__out[1][63];
  assign pri_table__in_[63] = pri_table_muxes__out[63];
  assign pri_table_muxes__in_[63][2] = rename__msg.preg_idx;
  assign pri_table_muxes__in_[63][3] = pri_table__out[63];
  assign sec_table_muxes__clk[0][0] = clk;
  assign sec_table_muxes__reset[0][0] = reset;
  assign sec_table_muxes__clk[0][1] = clk;
  assign sec_table_muxes__reset[0][1] = reset;
  assign sec_table_muxes__clk[0][2] = clk;
  assign sec_table_muxes__reset[0][2] = reset;
  assign sec_table_muxes__clk[0][3] = clk;
  assign sec_table_muxes__reset[0][3] = reset;
  assign sec_table_muxes__clk[0][4] = clk;
  assign sec_table_muxes__reset[0][4] = reset;
  assign sec_table_muxes__clk[0][5] = clk;
  assign sec_table_muxes__reset[0][5] = reset;
  assign sec_table_muxes__clk[0][6] = clk;
  assign sec_table_muxes__reset[0][6] = reset;
  assign sec_table_muxes__clk[0][7] = clk;
  assign sec_table_muxes__reset[0][7] = reset;
  assign sec_table_muxes__clk[0][8] = clk;
  assign sec_table_muxes__reset[0][8] = reset;
  assign sec_table_muxes__clk[0][9] = clk;
  assign sec_table_muxes__reset[0][9] = reset;
  assign sec_table_muxes__clk[0][10] = clk;
  assign sec_table_muxes__reset[0][10] = reset;
  assign sec_table_muxes__clk[0][11] = clk;
  assign sec_table_muxes__reset[0][11] = reset;
  assign sec_table_muxes__clk[0][12] = clk;
  assign sec_table_muxes__reset[0][12] = reset;
  assign sec_table_muxes__clk[0][13] = clk;
  assign sec_table_muxes__reset[0][13] = reset;
  assign sec_table_muxes__clk[0][14] = clk;
  assign sec_table_muxes__reset[0][14] = reset;
  assign sec_table_muxes__clk[0][15] = clk;
  assign sec_table_muxes__reset[0][15] = reset;
  assign sec_table_muxes__clk[0][16] = clk;
  assign sec_table_muxes__reset[0][16] = reset;
  assign sec_table_muxes__clk[0][17] = clk;
  assign sec_table_muxes__reset[0][17] = reset;
  assign sec_table_muxes__clk[0][18] = clk;
  assign sec_table_muxes__reset[0][18] = reset;
  assign sec_table_muxes__clk[0][19] = clk;
  assign sec_table_muxes__reset[0][19] = reset;
  assign sec_table_muxes__clk[0][20] = clk;
  assign sec_table_muxes__reset[0][20] = reset;
  assign sec_table_muxes__clk[0][21] = clk;
  assign sec_table_muxes__reset[0][21] = reset;
  assign sec_table_muxes__clk[0][22] = clk;
  assign sec_table_muxes__reset[0][22] = reset;
  assign sec_table_muxes__clk[0][23] = clk;
  assign sec_table_muxes__reset[0][23] = reset;
  assign sec_table_muxes__clk[0][24] = clk;
  assign sec_table_muxes__reset[0][24] = reset;
  assign sec_table_muxes__clk[0][25] = clk;
  assign sec_table_muxes__reset[0][25] = reset;
  assign sec_table_muxes__clk[0][26] = clk;
  assign sec_table_muxes__reset[0][26] = reset;
  assign sec_table_muxes__clk[0][27] = clk;
  assign sec_table_muxes__reset[0][27] = reset;
  assign sec_table_muxes__clk[0][28] = clk;
  assign sec_table_muxes__reset[0][28] = reset;
  assign sec_table_muxes__clk[0][29] = clk;
  assign sec_table_muxes__reset[0][29] = reset;
  assign sec_table_muxes__clk[0][30] = clk;
  assign sec_table_muxes__reset[0][30] = reset;
  assign sec_table_muxes__clk[0][31] = clk;
  assign sec_table_muxes__reset[0][31] = reset;
  assign sec_table_muxes__clk[0][32] = clk;
  assign sec_table_muxes__reset[0][32] = reset;
  assign sec_table_muxes__clk[0][33] = clk;
  assign sec_table_muxes__reset[0][33] = reset;
  assign sec_table_muxes__clk[0][34] = clk;
  assign sec_table_muxes__reset[0][34] = reset;
  assign sec_table_muxes__clk[0][35] = clk;
  assign sec_table_muxes__reset[0][35] = reset;
  assign sec_table_muxes__clk[0][36] = clk;
  assign sec_table_muxes__reset[0][36] = reset;
  assign sec_table_muxes__clk[0][37] = clk;
  assign sec_table_muxes__reset[0][37] = reset;
  assign sec_table_muxes__clk[0][38] = clk;
  assign sec_table_muxes__reset[0][38] = reset;
  assign sec_table_muxes__clk[0][39] = clk;
  assign sec_table_muxes__reset[0][39] = reset;
  assign sec_table_muxes__clk[0][40] = clk;
  assign sec_table_muxes__reset[0][40] = reset;
  assign sec_table_muxes__clk[0][41] = clk;
  assign sec_table_muxes__reset[0][41] = reset;
  assign sec_table_muxes__clk[0][42] = clk;
  assign sec_table_muxes__reset[0][42] = reset;
  assign sec_table_muxes__clk[0][43] = clk;
  assign sec_table_muxes__reset[0][43] = reset;
  assign sec_table_muxes__clk[0][44] = clk;
  assign sec_table_muxes__reset[0][44] = reset;
  assign sec_table_muxes__clk[0][45] = clk;
  assign sec_table_muxes__reset[0][45] = reset;
  assign sec_table_muxes__clk[0][46] = clk;
  assign sec_table_muxes__reset[0][46] = reset;
  assign sec_table_muxes__clk[0][47] = clk;
  assign sec_table_muxes__reset[0][47] = reset;
  assign sec_table_muxes__clk[0][48] = clk;
  assign sec_table_muxes__reset[0][48] = reset;
  assign sec_table_muxes__clk[0][49] = clk;
  assign sec_table_muxes__reset[0][49] = reset;
  assign sec_table_muxes__clk[0][50] = clk;
  assign sec_table_muxes__reset[0][50] = reset;
  assign sec_table_muxes__clk[0][51] = clk;
  assign sec_table_muxes__reset[0][51] = reset;
  assign sec_table_muxes__clk[0][52] = clk;
  assign sec_table_muxes__reset[0][52] = reset;
  assign sec_table_muxes__clk[0][53] = clk;
  assign sec_table_muxes__reset[0][53] = reset;
  assign sec_table_muxes__clk[0][54] = clk;
  assign sec_table_muxes__reset[0][54] = reset;
  assign sec_table_muxes__clk[0][55] = clk;
  assign sec_table_muxes__reset[0][55] = reset;
  assign sec_table_muxes__clk[0][56] = clk;
  assign sec_table_muxes__reset[0][56] = reset;
  assign sec_table_muxes__clk[0][57] = clk;
  assign sec_table_muxes__reset[0][57] = reset;
  assign sec_table_muxes__clk[0][58] = clk;
  assign sec_table_muxes__reset[0][58] = reset;
  assign sec_table_muxes__clk[0][59] = clk;
  assign sec_table_muxes__reset[0][59] = reset;
  assign sec_table_muxes__clk[0][60] = clk;
  assign sec_table_muxes__reset[0][60] = reset;
  assign sec_table_muxes__clk[0][61] = clk;
  assign sec_table_muxes__reset[0][61] = reset;
  assign sec_table_muxes__clk[0][62] = clk;
  assign sec_table_muxes__reset[0][62] = reset;
  assign sec_table_muxes__clk[0][63] = clk;
  assign sec_table_muxes__reset[0][63] = reset;
  assign sec_table_muxes__clk[1][0] = clk;
  assign sec_table_muxes__reset[1][0] = reset;
  assign sec_table_muxes__clk[1][1] = clk;
  assign sec_table_muxes__reset[1][1] = reset;
  assign sec_table_muxes__clk[1][2] = clk;
  assign sec_table_muxes__reset[1][2] = reset;
  assign sec_table_muxes__clk[1][3] = clk;
  assign sec_table_muxes__reset[1][3] = reset;
  assign sec_table_muxes__clk[1][4] = clk;
  assign sec_table_muxes__reset[1][4] = reset;
  assign sec_table_muxes__clk[1][5] = clk;
  assign sec_table_muxes__reset[1][5] = reset;
  assign sec_table_muxes__clk[1][6] = clk;
  assign sec_table_muxes__reset[1][6] = reset;
  assign sec_table_muxes__clk[1][7] = clk;
  assign sec_table_muxes__reset[1][7] = reset;
  assign sec_table_muxes__clk[1][8] = clk;
  assign sec_table_muxes__reset[1][8] = reset;
  assign sec_table_muxes__clk[1][9] = clk;
  assign sec_table_muxes__reset[1][9] = reset;
  assign sec_table_muxes__clk[1][10] = clk;
  assign sec_table_muxes__reset[1][10] = reset;
  assign sec_table_muxes__clk[1][11] = clk;
  assign sec_table_muxes__reset[1][11] = reset;
  assign sec_table_muxes__clk[1][12] = clk;
  assign sec_table_muxes__reset[1][12] = reset;
  assign sec_table_muxes__clk[1][13] = clk;
  assign sec_table_muxes__reset[1][13] = reset;
  assign sec_table_muxes__clk[1][14] = clk;
  assign sec_table_muxes__reset[1][14] = reset;
  assign sec_table_muxes__clk[1][15] = clk;
  assign sec_table_muxes__reset[1][15] = reset;
  assign sec_table_muxes__clk[1][16] = clk;
  assign sec_table_muxes__reset[1][16] = reset;
  assign sec_table_muxes__clk[1][17] = clk;
  assign sec_table_muxes__reset[1][17] = reset;
  assign sec_table_muxes__clk[1][18] = clk;
  assign sec_table_muxes__reset[1][18] = reset;
  assign sec_table_muxes__clk[1][19] = clk;
  assign sec_table_muxes__reset[1][19] = reset;
  assign sec_table_muxes__clk[1][20] = clk;
  assign sec_table_muxes__reset[1][20] = reset;
  assign sec_table_muxes__clk[1][21] = clk;
  assign sec_table_muxes__reset[1][21] = reset;
  assign sec_table_muxes__clk[1][22] = clk;
  assign sec_table_muxes__reset[1][22] = reset;
  assign sec_table_muxes__clk[1][23] = clk;
  assign sec_table_muxes__reset[1][23] = reset;
  assign sec_table_muxes__clk[1][24] = clk;
  assign sec_table_muxes__reset[1][24] = reset;
  assign sec_table_muxes__clk[1][25] = clk;
  assign sec_table_muxes__reset[1][25] = reset;
  assign sec_table_muxes__clk[1][26] = clk;
  assign sec_table_muxes__reset[1][26] = reset;
  assign sec_table_muxes__clk[1][27] = clk;
  assign sec_table_muxes__reset[1][27] = reset;
  assign sec_table_muxes__clk[1][28] = clk;
  assign sec_table_muxes__reset[1][28] = reset;
  assign sec_table_muxes__clk[1][29] = clk;
  assign sec_table_muxes__reset[1][29] = reset;
  assign sec_table_muxes__clk[1][30] = clk;
  assign sec_table_muxes__reset[1][30] = reset;
  assign sec_table_muxes__clk[1][31] = clk;
  assign sec_table_muxes__reset[1][31] = reset;
  assign sec_table_muxes__clk[1][32] = clk;
  assign sec_table_muxes__reset[1][32] = reset;
  assign sec_table_muxes__clk[1][33] = clk;
  assign sec_table_muxes__reset[1][33] = reset;
  assign sec_table_muxes__clk[1][34] = clk;
  assign sec_table_muxes__reset[1][34] = reset;
  assign sec_table_muxes__clk[1][35] = clk;
  assign sec_table_muxes__reset[1][35] = reset;
  assign sec_table_muxes__clk[1][36] = clk;
  assign sec_table_muxes__reset[1][36] = reset;
  assign sec_table_muxes__clk[1][37] = clk;
  assign sec_table_muxes__reset[1][37] = reset;
  assign sec_table_muxes__clk[1][38] = clk;
  assign sec_table_muxes__reset[1][38] = reset;
  assign sec_table_muxes__clk[1][39] = clk;
  assign sec_table_muxes__reset[1][39] = reset;
  assign sec_table_muxes__clk[1][40] = clk;
  assign sec_table_muxes__reset[1][40] = reset;
  assign sec_table_muxes__clk[1][41] = clk;
  assign sec_table_muxes__reset[1][41] = reset;
  assign sec_table_muxes__clk[1][42] = clk;
  assign sec_table_muxes__reset[1][42] = reset;
  assign sec_table_muxes__clk[1][43] = clk;
  assign sec_table_muxes__reset[1][43] = reset;
  assign sec_table_muxes__clk[1][44] = clk;
  assign sec_table_muxes__reset[1][44] = reset;
  assign sec_table_muxes__clk[1][45] = clk;
  assign sec_table_muxes__reset[1][45] = reset;
  assign sec_table_muxes__clk[1][46] = clk;
  assign sec_table_muxes__reset[1][46] = reset;
  assign sec_table_muxes__clk[1][47] = clk;
  assign sec_table_muxes__reset[1][47] = reset;
  assign sec_table_muxes__clk[1][48] = clk;
  assign sec_table_muxes__reset[1][48] = reset;
  assign sec_table_muxes__clk[1][49] = clk;
  assign sec_table_muxes__reset[1][49] = reset;
  assign sec_table_muxes__clk[1][50] = clk;
  assign sec_table_muxes__reset[1][50] = reset;
  assign sec_table_muxes__clk[1][51] = clk;
  assign sec_table_muxes__reset[1][51] = reset;
  assign sec_table_muxes__clk[1][52] = clk;
  assign sec_table_muxes__reset[1][52] = reset;
  assign sec_table_muxes__clk[1][53] = clk;
  assign sec_table_muxes__reset[1][53] = reset;
  assign sec_table_muxes__clk[1][54] = clk;
  assign sec_table_muxes__reset[1][54] = reset;
  assign sec_table_muxes__clk[1][55] = clk;
  assign sec_table_muxes__reset[1][55] = reset;
  assign sec_table_muxes__clk[1][56] = clk;
  assign sec_table_muxes__reset[1][56] = reset;
  assign sec_table_muxes__clk[1][57] = clk;
  assign sec_table_muxes__reset[1][57] = reset;
  assign sec_table_muxes__clk[1][58] = clk;
  assign sec_table_muxes__reset[1][58] = reset;
  assign sec_table_muxes__clk[1][59] = clk;
  assign sec_table_muxes__reset[1][59] = reset;
  assign sec_table_muxes__clk[1][60] = clk;
  assign sec_table_muxes__reset[1][60] = reset;
  assign sec_table_muxes__clk[1][61] = clk;
  assign sec_table_muxes__reset[1][61] = reset;
  assign sec_table_muxes__clk[1][62] = clk;
  assign sec_table_muxes__reset[1][62] = reset;
  assign sec_table_muxes__clk[1][63] = clk;
  assign sec_table_muxes__reset[1][63] = reset;
  assign sec_tables__in_[0][0] = sec_table_muxes__out[0][0];
  assign sec_table_muxes__in_[0][0][0] = pri_table__out[0];
  assign sec_table_muxes__in_[0][0][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][1] = sec_table_muxes__out[0][1];
  assign sec_table_muxes__in_[0][1][0] = pri_table__out[1];
  assign sec_table_muxes__in_[0][1][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][2] = sec_table_muxes__out[0][2];
  assign sec_table_muxes__in_[0][2][0] = pri_table__out[2];
  assign sec_table_muxes__in_[0][2][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][3] = sec_table_muxes__out[0][3];
  assign sec_table_muxes__in_[0][3][0] = pri_table__out[3];
  assign sec_table_muxes__in_[0][3][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][4] = sec_table_muxes__out[0][4];
  assign sec_table_muxes__in_[0][4][0] = pri_table__out[4];
  assign sec_table_muxes__in_[0][4][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][5] = sec_table_muxes__out[0][5];
  assign sec_table_muxes__in_[0][5][0] = pri_table__out[5];
  assign sec_table_muxes__in_[0][5][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][6] = sec_table_muxes__out[0][6];
  assign sec_table_muxes__in_[0][6][0] = pri_table__out[6];
  assign sec_table_muxes__in_[0][6][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][7] = sec_table_muxes__out[0][7];
  assign sec_table_muxes__in_[0][7][0] = pri_table__out[7];
  assign sec_table_muxes__in_[0][7][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][8] = sec_table_muxes__out[0][8];
  assign sec_table_muxes__in_[0][8][0] = pri_table__out[8];
  assign sec_table_muxes__in_[0][8][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][9] = sec_table_muxes__out[0][9];
  assign sec_table_muxes__in_[0][9][0] = pri_table__out[9];
  assign sec_table_muxes__in_[0][9][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][10] = sec_table_muxes__out[0][10];
  assign sec_table_muxes__in_[0][10][0] = pri_table__out[10];
  assign sec_table_muxes__in_[0][10][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][11] = sec_table_muxes__out[0][11];
  assign sec_table_muxes__in_[0][11][0] = pri_table__out[11];
  assign sec_table_muxes__in_[0][11][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][12] = sec_table_muxes__out[0][12];
  assign sec_table_muxes__in_[0][12][0] = pri_table__out[12];
  assign sec_table_muxes__in_[0][12][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][13] = sec_table_muxes__out[0][13];
  assign sec_table_muxes__in_[0][13][0] = pri_table__out[13];
  assign sec_table_muxes__in_[0][13][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][14] = sec_table_muxes__out[0][14];
  assign sec_table_muxes__in_[0][14][0] = pri_table__out[14];
  assign sec_table_muxes__in_[0][14][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][15] = sec_table_muxes__out[0][15];
  assign sec_table_muxes__in_[0][15][0] = pri_table__out[15];
  assign sec_table_muxes__in_[0][15][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][16] = sec_table_muxes__out[0][16];
  assign sec_table_muxes__in_[0][16][0] = pri_table__out[16];
  assign sec_table_muxes__in_[0][16][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][17] = sec_table_muxes__out[0][17];
  assign sec_table_muxes__in_[0][17][0] = pri_table__out[17];
  assign sec_table_muxes__in_[0][17][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][18] = sec_table_muxes__out[0][18];
  assign sec_table_muxes__in_[0][18][0] = pri_table__out[18];
  assign sec_table_muxes__in_[0][18][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][19] = sec_table_muxes__out[0][19];
  assign sec_table_muxes__in_[0][19][0] = pri_table__out[19];
  assign sec_table_muxes__in_[0][19][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][20] = sec_table_muxes__out[0][20];
  assign sec_table_muxes__in_[0][20][0] = pri_table__out[20];
  assign sec_table_muxes__in_[0][20][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][21] = sec_table_muxes__out[0][21];
  assign sec_table_muxes__in_[0][21][0] = pri_table__out[21];
  assign sec_table_muxes__in_[0][21][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][22] = sec_table_muxes__out[0][22];
  assign sec_table_muxes__in_[0][22][0] = pri_table__out[22];
  assign sec_table_muxes__in_[0][22][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][23] = sec_table_muxes__out[0][23];
  assign sec_table_muxes__in_[0][23][0] = pri_table__out[23];
  assign sec_table_muxes__in_[0][23][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][24] = sec_table_muxes__out[0][24];
  assign sec_table_muxes__in_[0][24][0] = pri_table__out[24];
  assign sec_table_muxes__in_[0][24][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][25] = sec_table_muxes__out[0][25];
  assign sec_table_muxes__in_[0][25][0] = pri_table__out[25];
  assign sec_table_muxes__in_[0][25][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][26] = sec_table_muxes__out[0][26];
  assign sec_table_muxes__in_[0][26][0] = pri_table__out[26];
  assign sec_table_muxes__in_[0][26][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][27] = sec_table_muxes__out[0][27];
  assign sec_table_muxes__in_[0][27][0] = pri_table__out[27];
  assign sec_table_muxes__in_[0][27][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][28] = sec_table_muxes__out[0][28];
  assign sec_table_muxes__in_[0][28][0] = pri_table__out[28];
  assign sec_table_muxes__in_[0][28][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][29] = sec_table_muxes__out[0][29];
  assign sec_table_muxes__in_[0][29][0] = pri_table__out[29];
  assign sec_table_muxes__in_[0][29][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][30] = sec_table_muxes__out[0][30];
  assign sec_table_muxes__in_[0][30][0] = pri_table__out[30];
  assign sec_table_muxes__in_[0][30][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][31] = sec_table_muxes__out[0][31];
  assign sec_table_muxes__in_[0][31][0] = pri_table__out[31];
  assign sec_table_muxes__in_[0][31][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][32] = sec_table_muxes__out[0][32];
  assign sec_table_muxes__in_[0][32][0] = pri_table__out[32];
  assign sec_table_muxes__in_[0][32][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][33] = sec_table_muxes__out[0][33];
  assign sec_table_muxes__in_[0][33][0] = pri_table__out[33];
  assign sec_table_muxes__in_[0][33][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][34] = sec_table_muxes__out[0][34];
  assign sec_table_muxes__in_[0][34][0] = pri_table__out[34];
  assign sec_table_muxes__in_[0][34][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][35] = sec_table_muxes__out[0][35];
  assign sec_table_muxes__in_[0][35][0] = pri_table__out[35];
  assign sec_table_muxes__in_[0][35][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][36] = sec_table_muxes__out[0][36];
  assign sec_table_muxes__in_[0][36][0] = pri_table__out[36];
  assign sec_table_muxes__in_[0][36][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][37] = sec_table_muxes__out[0][37];
  assign sec_table_muxes__in_[0][37][0] = pri_table__out[37];
  assign sec_table_muxes__in_[0][37][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][38] = sec_table_muxes__out[0][38];
  assign sec_table_muxes__in_[0][38][0] = pri_table__out[38];
  assign sec_table_muxes__in_[0][38][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][39] = sec_table_muxes__out[0][39];
  assign sec_table_muxes__in_[0][39][0] = pri_table__out[39];
  assign sec_table_muxes__in_[0][39][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][40] = sec_table_muxes__out[0][40];
  assign sec_table_muxes__in_[0][40][0] = pri_table__out[40];
  assign sec_table_muxes__in_[0][40][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][41] = sec_table_muxes__out[0][41];
  assign sec_table_muxes__in_[0][41][0] = pri_table__out[41];
  assign sec_table_muxes__in_[0][41][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][42] = sec_table_muxes__out[0][42];
  assign sec_table_muxes__in_[0][42][0] = pri_table__out[42];
  assign sec_table_muxes__in_[0][42][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][43] = sec_table_muxes__out[0][43];
  assign sec_table_muxes__in_[0][43][0] = pri_table__out[43];
  assign sec_table_muxes__in_[0][43][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][44] = sec_table_muxes__out[0][44];
  assign sec_table_muxes__in_[0][44][0] = pri_table__out[44];
  assign sec_table_muxes__in_[0][44][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][45] = sec_table_muxes__out[0][45];
  assign sec_table_muxes__in_[0][45][0] = pri_table__out[45];
  assign sec_table_muxes__in_[0][45][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][46] = sec_table_muxes__out[0][46];
  assign sec_table_muxes__in_[0][46][0] = pri_table__out[46];
  assign sec_table_muxes__in_[0][46][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][47] = sec_table_muxes__out[0][47];
  assign sec_table_muxes__in_[0][47][0] = pri_table__out[47];
  assign sec_table_muxes__in_[0][47][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][48] = sec_table_muxes__out[0][48];
  assign sec_table_muxes__in_[0][48][0] = pri_table__out[48];
  assign sec_table_muxes__in_[0][48][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][49] = sec_table_muxes__out[0][49];
  assign sec_table_muxes__in_[0][49][0] = pri_table__out[49];
  assign sec_table_muxes__in_[0][49][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][50] = sec_table_muxes__out[0][50];
  assign sec_table_muxes__in_[0][50][0] = pri_table__out[50];
  assign sec_table_muxes__in_[0][50][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][51] = sec_table_muxes__out[0][51];
  assign sec_table_muxes__in_[0][51][0] = pri_table__out[51];
  assign sec_table_muxes__in_[0][51][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][52] = sec_table_muxes__out[0][52];
  assign sec_table_muxes__in_[0][52][0] = pri_table__out[52];
  assign sec_table_muxes__in_[0][52][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][53] = sec_table_muxes__out[0][53];
  assign sec_table_muxes__in_[0][53][0] = pri_table__out[53];
  assign sec_table_muxes__in_[0][53][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][54] = sec_table_muxes__out[0][54];
  assign sec_table_muxes__in_[0][54][0] = pri_table__out[54];
  assign sec_table_muxes__in_[0][54][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][55] = sec_table_muxes__out[0][55];
  assign sec_table_muxes__in_[0][55][0] = pri_table__out[55];
  assign sec_table_muxes__in_[0][55][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][56] = sec_table_muxes__out[0][56];
  assign sec_table_muxes__in_[0][56][0] = pri_table__out[56];
  assign sec_table_muxes__in_[0][56][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][57] = sec_table_muxes__out[0][57];
  assign sec_table_muxes__in_[0][57][0] = pri_table__out[57];
  assign sec_table_muxes__in_[0][57][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][58] = sec_table_muxes__out[0][58];
  assign sec_table_muxes__in_[0][58][0] = pri_table__out[58];
  assign sec_table_muxes__in_[0][58][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][59] = sec_table_muxes__out[0][59];
  assign sec_table_muxes__in_[0][59][0] = pri_table__out[59];
  assign sec_table_muxes__in_[0][59][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][60] = sec_table_muxes__out[0][60];
  assign sec_table_muxes__in_[0][60][0] = pri_table__out[60];
  assign sec_table_muxes__in_[0][60][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][61] = sec_table_muxes__out[0][61];
  assign sec_table_muxes__in_[0][61][0] = pri_table__out[61];
  assign sec_table_muxes__in_[0][61][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][62] = sec_table_muxes__out[0][62];
  assign sec_table_muxes__in_[0][62][0] = pri_table__out[62];
  assign sec_table_muxes__in_[0][62][1] = rename__msg.preg_idx;
  assign sec_tables__in_[0][63] = sec_table_muxes__out[0][63];
  assign sec_table_muxes__in_[0][63][0] = pri_table__out[63];
  assign sec_table_muxes__in_[0][63][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][0] = sec_table_muxes__out[1][0];
  assign sec_table_muxes__in_[1][0][0] = pri_table__out[0];
  assign sec_table_muxes__in_[1][0][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][1] = sec_table_muxes__out[1][1];
  assign sec_table_muxes__in_[1][1][0] = pri_table__out[1];
  assign sec_table_muxes__in_[1][1][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][2] = sec_table_muxes__out[1][2];
  assign sec_table_muxes__in_[1][2][0] = pri_table__out[2];
  assign sec_table_muxes__in_[1][2][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][3] = sec_table_muxes__out[1][3];
  assign sec_table_muxes__in_[1][3][0] = pri_table__out[3];
  assign sec_table_muxes__in_[1][3][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][4] = sec_table_muxes__out[1][4];
  assign sec_table_muxes__in_[1][4][0] = pri_table__out[4];
  assign sec_table_muxes__in_[1][4][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][5] = sec_table_muxes__out[1][5];
  assign sec_table_muxes__in_[1][5][0] = pri_table__out[5];
  assign sec_table_muxes__in_[1][5][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][6] = sec_table_muxes__out[1][6];
  assign sec_table_muxes__in_[1][6][0] = pri_table__out[6];
  assign sec_table_muxes__in_[1][6][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][7] = sec_table_muxes__out[1][7];
  assign sec_table_muxes__in_[1][7][0] = pri_table__out[7];
  assign sec_table_muxes__in_[1][7][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][8] = sec_table_muxes__out[1][8];
  assign sec_table_muxes__in_[1][8][0] = pri_table__out[8];
  assign sec_table_muxes__in_[1][8][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][9] = sec_table_muxes__out[1][9];
  assign sec_table_muxes__in_[1][9][0] = pri_table__out[9];
  assign sec_table_muxes__in_[1][9][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][10] = sec_table_muxes__out[1][10];
  assign sec_table_muxes__in_[1][10][0] = pri_table__out[10];
  assign sec_table_muxes__in_[1][10][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][11] = sec_table_muxes__out[1][11];
  assign sec_table_muxes__in_[1][11][0] = pri_table__out[11];
  assign sec_table_muxes__in_[1][11][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][12] = sec_table_muxes__out[1][12];
  assign sec_table_muxes__in_[1][12][0] = pri_table__out[12];
  assign sec_table_muxes__in_[1][12][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][13] = sec_table_muxes__out[1][13];
  assign sec_table_muxes__in_[1][13][0] = pri_table__out[13];
  assign sec_table_muxes__in_[1][13][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][14] = sec_table_muxes__out[1][14];
  assign sec_table_muxes__in_[1][14][0] = pri_table__out[14];
  assign sec_table_muxes__in_[1][14][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][15] = sec_table_muxes__out[1][15];
  assign sec_table_muxes__in_[1][15][0] = pri_table__out[15];
  assign sec_table_muxes__in_[1][15][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][16] = sec_table_muxes__out[1][16];
  assign sec_table_muxes__in_[1][16][0] = pri_table__out[16];
  assign sec_table_muxes__in_[1][16][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][17] = sec_table_muxes__out[1][17];
  assign sec_table_muxes__in_[1][17][0] = pri_table__out[17];
  assign sec_table_muxes__in_[1][17][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][18] = sec_table_muxes__out[1][18];
  assign sec_table_muxes__in_[1][18][0] = pri_table__out[18];
  assign sec_table_muxes__in_[1][18][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][19] = sec_table_muxes__out[1][19];
  assign sec_table_muxes__in_[1][19][0] = pri_table__out[19];
  assign sec_table_muxes__in_[1][19][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][20] = sec_table_muxes__out[1][20];
  assign sec_table_muxes__in_[1][20][0] = pri_table__out[20];
  assign sec_table_muxes__in_[1][20][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][21] = sec_table_muxes__out[1][21];
  assign sec_table_muxes__in_[1][21][0] = pri_table__out[21];
  assign sec_table_muxes__in_[1][21][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][22] = sec_table_muxes__out[1][22];
  assign sec_table_muxes__in_[1][22][0] = pri_table__out[22];
  assign sec_table_muxes__in_[1][22][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][23] = sec_table_muxes__out[1][23];
  assign sec_table_muxes__in_[1][23][0] = pri_table__out[23];
  assign sec_table_muxes__in_[1][23][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][24] = sec_table_muxes__out[1][24];
  assign sec_table_muxes__in_[1][24][0] = pri_table__out[24];
  assign sec_table_muxes__in_[1][24][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][25] = sec_table_muxes__out[1][25];
  assign sec_table_muxes__in_[1][25][0] = pri_table__out[25];
  assign sec_table_muxes__in_[1][25][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][26] = sec_table_muxes__out[1][26];
  assign sec_table_muxes__in_[1][26][0] = pri_table__out[26];
  assign sec_table_muxes__in_[1][26][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][27] = sec_table_muxes__out[1][27];
  assign sec_table_muxes__in_[1][27][0] = pri_table__out[27];
  assign sec_table_muxes__in_[1][27][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][28] = sec_table_muxes__out[1][28];
  assign sec_table_muxes__in_[1][28][0] = pri_table__out[28];
  assign sec_table_muxes__in_[1][28][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][29] = sec_table_muxes__out[1][29];
  assign sec_table_muxes__in_[1][29][0] = pri_table__out[29];
  assign sec_table_muxes__in_[1][29][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][30] = sec_table_muxes__out[1][30];
  assign sec_table_muxes__in_[1][30][0] = pri_table__out[30];
  assign sec_table_muxes__in_[1][30][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][31] = sec_table_muxes__out[1][31];
  assign sec_table_muxes__in_[1][31][0] = pri_table__out[31];
  assign sec_table_muxes__in_[1][31][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][32] = sec_table_muxes__out[1][32];
  assign sec_table_muxes__in_[1][32][0] = pri_table__out[32];
  assign sec_table_muxes__in_[1][32][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][33] = sec_table_muxes__out[1][33];
  assign sec_table_muxes__in_[1][33][0] = pri_table__out[33];
  assign sec_table_muxes__in_[1][33][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][34] = sec_table_muxes__out[1][34];
  assign sec_table_muxes__in_[1][34][0] = pri_table__out[34];
  assign sec_table_muxes__in_[1][34][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][35] = sec_table_muxes__out[1][35];
  assign sec_table_muxes__in_[1][35][0] = pri_table__out[35];
  assign sec_table_muxes__in_[1][35][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][36] = sec_table_muxes__out[1][36];
  assign sec_table_muxes__in_[1][36][0] = pri_table__out[36];
  assign sec_table_muxes__in_[1][36][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][37] = sec_table_muxes__out[1][37];
  assign sec_table_muxes__in_[1][37][0] = pri_table__out[37];
  assign sec_table_muxes__in_[1][37][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][38] = sec_table_muxes__out[1][38];
  assign sec_table_muxes__in_[1][38][0] = pri_table__out[38];
  assign sec_table_muxes__in_[1][38][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][39] = sec_table_muxes__out[1][39];
  assign sec_table_muxes__in_[1][39][0] = pri_table__out[39];
  assign sec_table_muxes__in_[1][39][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][40] = sec_table_muxes__out[1][40];
  assign sec_table_muxes__in_[1][40][0] = pri_table__out[40];
  assign sec_table_muxes__in_[1][40][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][41] = sec_table_muxes__out[1][41];
  assign sec_table_muxes__in_[1][41][0] = pri_table__out[41];
  assign sec_table_muxes__in_[1][41][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][42] = sec_table_muxes__out[1][42];
  assign sec_table_muxes__in_[1][42][0] = pri_table__out[42];
  assign sec_table_muxes__in_[1][42][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][43] = sec_table_muxes__out[1][43];
  assign sec_table_muxes__in_[1][43][0] = pri_table__out[43];
  assign sec_table_muxes__in_[1][43][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][44] = sec_table_muxes__out[1][44];
  assign sec_table_muxes__in_[1][44][0] = pri_table__out[44];
  assign sec_table_muxes__in_[1][44][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][45] = sec_table_muxes__out[1][45];
  assign sec_table_muxes__in_[1][45][0] = pri_table__out[45];
  assign sec_table_muxes__in_[1][45][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][46] = sec_table_muxes__out[1][46];
  assign sec_table_muxes__in_[1][46][0] = pri_table__out[46];
  assign sec_table_muxes__in_[1][46][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][47] = sec_table_muxes__out[1][47];
  assign sec_table_muxes__in_[1][47][0] = pri_table__out[47];
  assign sec_table_muxes__in_[1][47][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][48] = sec_table_muxes__out[1][48];
  assign sec_table_muxes__in_[1][48][0] = pri_table__out[48];
  assign sec_table_muxes__in_[1][48][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][49] = sec_table_muxes__out[1][49];
  assign sec_table_muxes__in_[1][49][0] = pri_table__out[49];
  assign sec_table_muxes__in_[1][49][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][50] = sec_table_muxes__out[1][50];
  assign sec_table_muxes__in_[1][50][0] = pri_table__out[50];
  assign sec_table_muxes__in_[1][50][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][51] = sec_table_muxes__out[1][51];
  assign sec_table_muxes__in_[1][51][0] = pri_table__out[51];
  assign sec_table_muxes__in_[1][51][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][52] = sec_table_muxes__out[1][52];
  assign sec_table_muxes__in_[1][52][0] = pri_table__out[52];
  assign sec_table_muxes__in_[1][52][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][53] = sec_table_muxes__out[1][53];
  assign sec_table_muxes__in_[1][53][0] = pri_table__out[53];
  assign sec_table_muxes__in_[1][53][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][54] = sec_table_muxes__out[1][54];
  assign sec_table_muxes__in_[1][54][0] = pri_table__out[54];
  assign sec_table_muxes__in_[1][54][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][55] = sec_table_muxes__out[1][55];
  assign sec_table_muxes__in_[1][55][0] = pri_table__out[55];
  assign sec_table_muxes__in_[1][55][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][56] = sec_table_muxes__out[1][56];
  assign sec_table_muxes__in_[1][56][0] = pri_table__out[56];
  assign sec_table_muxes__in_[1][56][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][57] = sec_table_muxes__out[1][57];
  assign sec_table_muxes__in_[1][57][0] = pri_table__out[57];
  assign sec_table_muxes__in_[1][57][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][58] = sec_table_muxes__out[1][58];
  assign sec_table_muxes__in_[1][58][0] = pri_table__out[58];
  assign sec_table_muxes__in_[1][58][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][59] = sec_table_muxes__out[1][59];
  assign sec_table_muxes__in_[1][59][0] = pri_table__out[59];
  assign sec_table_muxes__in_[1][59][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][60] = sec_table_muxes__out[1][60];
  assign sec_table_muxes__in_[1][60][0] = pri_table__out[60];
  assign sec_table_muxes__in_[1][60][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][61] = sec_table_muxes__out[1][61];
  assign sec_table_muxes__in_[1][61][0] = pri_table__out[61];
  assign sec_table_muxes__in_[1][61][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][62] = sec_table_muxes__out[1][62];
  assign sec_table_muxes__in_[1][62][0] = pri_table__out[62];
  assign sec_table_muxes__in_[1][62][1] = rename__msg.preg_idx;
  assign sec_tables__in_[1][63] = sec_table_muxes__out[1][63];
  assign sec_table_muxes__in_[1][63][0] = pri_table__out[63];
  assign sec_table_muxes__in_[1][63][1] = rename__msg.preg_idx;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_Bits32__nregs_72__rd_ports_2__wr_ports_1__const_zero_True
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__4a0e65843341fb09
(
  input  logic [0:0] clk ,
  input  logic [6:0] raddr [0:1],
  output logic [31:0] rdata [0:1],
  input  logic [0:0] reset ,
  input  logic [6:0] waddr [0:0],
  input  logic [31:0] wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [1:0] __const__rd_ports_at_up_rf_read  = 2'd2;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write_constzero  = 1'd1;
  logic [31:0] regs [0:71];

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 2'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:26
  // @update_ff
  // def up_rf_write_constzero():
  //   for i in range( wr_ports ):
  //     if s.wen[i] & (s.waddr[i] != 0):
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write_constzero
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write_constzero ); i += 1'd1 )
      if ( wen[1'(i)] & ( waddr[1'(i)] != 7'd0 ) ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component DataFlowManagerRTL Definition
// Full name: DataFlowManagerRTL__num_reg_rd_ports_2__num_reg_wr_ports_1__num_lookup_ports_3__num_FUs_4__num_aregs_64__num_pregs_72__max_unresolved_branches_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/DataFlowManagerRTL.py

module DataFlowManagerRTL__849fb2bb88e036ca
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] bypass_W__en [0:3] ,
  input RegWrStruct__preg_idx_7__data_32 bypass_W__msg [0:3] ,
  input logic [0:0] bypass_X__en [0:3] ,
  input RegWrStruct__preg_idx_7__data_32 bypass_X__msg [0:3] ,
  input logic [0:0] checkpoint__en  ,
  input logic [0:0] checkpoint__msg  ,
  output logic [2:0] checkpoint__ret  ,
  input logic [0:0] free_reg__en  ,
  input logic [6:0] free_reg__msg  ,
  output logic [0:0] free_reg__rdy  ,
  input logic [0:0] lookup__en [0:2] ,
  input logic [5:0] lookup__msg [0:2] ,
  output logic [6:0] lookup__ret [0:2] ,
  input logic [0:0] rd_reg__en [0:1] ,
  input logic [6:0] rd_reg__msg [0:1] ,
  output logic [31:0] rd_reg__ret [0:1] ,
  output logic [0:0] rd_reg__suc [0:1] ,
  input logic [0:0] rename__en  ,
  input logic [5:0] rename__msg  ,
  output logic [0:0] rename__rdy  ,
  output logic [6:0] rename__ret  ,
  input logic [0:0] rollback__en  ,
  input RollbackStruct__br_idx_1__ckpt_head_3 rollback__msg  ,
  input logic [0:0] set_reg__en  ,
  input logic [6:0] set_reg__msg  ,
  input logic [0:0] wr_reg__en [0:0] ,
  input RegWrStruct__preg_idx_7__data_32 wr_reg__msg [0:0] 
);
  localparam logic [6:0] __const__num_pregs_at_up_scoreboard  = 7'd72;
  localparam logic [0:0] __const__num_reg_wr_ports_at_up_scoreboard  = 1'd1;
  localparam logic [1:0] __const__num_reg_rd_ports_at_comb_rd_wr_reg  = 2'd2;
  localparam logic [2:0] __const__num_FUs_at_comb_rd_wr_reg  = 3'd4;
  localparam logic [0:0] __const__num_reg_wr_ports_at_comb_rd_wr_reg  = 1'd1;
  logic [0:0] scoreboard [0:71];
  //-------------------------------------------------------------
  // Component free_reg_list
  //-------------------------------------------------------------

  logic [0:0] free_reg_list__clk;
  logic [2:0] free_reg_list__head_idx;
  logic [0:0] free_reg_list__reset;
  logic [0:0] free_reg_list__alloc__en;
  logic [0:0] free_reg_list__alloc__rdy;
  logic [6:0] free_reg_list__alloc__ret;
  logic [0:0] free_reg_list__free__en;
  logic [6:0] free_reg_list__free__msg;
  logic [0:0] free_reg_list__rollback__en;
  logic [2:0] free_reg_list__rollback__msg;

  FreeListRTL__4463e5d7cec61762 free_reg_list
  (
    .clk( free_reg_list__clk ),
    .head_idx( free_reg_list__head_idx ),
    .reset( free_reg_list__reset ),
    .alloc__en( free_reg_list__alloc__en ),
    .alloc__rdy( free_reg_list__alloc__rdy ),
    .alloc__ret( free_reg_list__alloc__ret ),
    .free__en( free_reg_list__free__en ),
    .free__msg( free_reg_list__free__msg ),
    .rollback__en( free_reg_list__rollback__en ),
    .rollback__msg( free_reg_list__rollback__msg )
  );

  //-------------------------------------------------------------
  // End of component free_reg_list
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rename_table
  //-------------------------------------------------------------

  logic [0:0] rename_table__clk;
  logic [0:0] rename_table__reset;
  logic [0:0] rename_table__checkpoint__en;
  logic [0:0] rename_table__checkpoint__msg;
  logic [0:0] rename_table__lookup__en [0:2];
  logic [5:0] rename_table__lookup__msg [0:2];
  logic [6:0] rename_table__lookup__ret [0:2];
  logic [0:0] rename_table__rename__en;
  RegIdxPair__areg_idx_6__preg_idx_7 rename_table__rename__msg;
  logic [0:0] rename_table__rollback__en;
  logic [0:0] rename_table__rollback__msg;

  RenameTableRTL__26107974cb1ca85b rename_table
  (
    .clk( rename_table__clk ),
    .reset( rename_table__reset ),
    .checkpoint__en( rename_table__checkpoint__en ),
    .checkpoint__msg( rename_table__checkpoint__msg ),
    .lookup__en( rename_table__lookup__en ),
    .lookup__msg( rename_table__lookup__msg ),
    .lookup__ret( rename_table__lookup__ret ),
    .rename__en( rename_table__rename__en ),
    .rename__msg( rename_table__rename__msg ),
    .rollback__en( rename_table__rollback__en ),
    .rollback__msg( rename_table__rollback__msg )
  );

  //-------------------------------------------------------------
  // End of component rename_table
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component rf
  //-------------------------------------------------------------

  logic [0:0] rf__clk;
  logic [6:0] rf__raddr [0:1];
  logic [31:0] rf__rdata [0:1];
  logic [0:0] rf__reset;
  logic [6:0] rf__waddr [0:0];
  logic [31:0] rf__wdata [0:0];
  logic [0:0] rf__wen [0:0];

  RegisterFile__4a0e65843341fb09 rf
  (
    .clk( rf__clk ),
    .raddr( rf__raddr ),
    .rdata( rf__rdata ),
    .reset( rf__reset ),
    .waddr( rf__waddr ),
    .wdata( rf__wdata ),
    .wen( rf__wen )
  );

  //-------------------------------------------------------------
  // End of component rf
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/DataFlowManagerRTL.py:178
  // @update
  // def comb_rd_wr_reg():
  // 
  //   # read regs
  //   for i in range( num_reg_rd_ports ):
  //     # default
  //     s.rd_reg[ i ].suc @= 0
  //     s.rd_reg[ i ].ret @= 0
  // 
  //     if s.rd_reg[ i ].en:
  //       #
  //       # reading const_zero reg
  //       #
  //       if  s.rd_reg[ i ].msg == 0:
  //         s.rd_reg[ i ].suc @= 1
  //         s.rd_reg[ i ].ret @= 0
  // 
  //       #
  //       # preg is pending -> check bypass signals
  //       #
  //       elif  s.scoreboard[ s.rd_reg[ i ].msg ]:
  //         for fu_id in range( num_FUs ):
  //           if  s.bypass_W[ fu_id ].en & \
  //               ( s.bypass_W[ fu_id ].msg.preg_idx == s.rd_reg[ i ].msg ):
  //             s.rd_reg[ i ].suc @= 1
  //             s.rd_reg[ i ].ret @= s.bypass_W[ fu_id ].msg.data
  // 
  //         for fu_id in range( num_FUs ):
  //           if  s.bypass_X[ fu_id ].en & \
  //               ( s.bypass_X[ fu_id ].msg.preg_idx == s.rd_reg[ i ].msg ):
  //             s.rd_reg[ i ].suc @= 1
  //             s.rd_reg[ i ].ret @= s.bypass_X[ fu_id ].msg.data
  // 
  //       #
  //       # preg is not pending -> read from RF
  //       #
  //       else:
  //         s.rd_reg[ i ].suc @= 1
  //         s.rd_reg[ i ].ret @= s.rf.rdata[ i ]
  // 
  //   # write regs
  //   for i in range( num_reg_wr_ports ):
  //     # default
  //     s.rf.wen[ i ] @= 0
  // 
  //     # don't write to const_zero reg
  //     if  s.wr_reg[ i ].en & ( s.wr_reg[ i ].msg.preg_idx != 0 ):
  //       s.rf.wen[ i ] @= 1
  
  always_comb begin : comb_rd_wr_reg
    for ( int unsigned i = 1'd0; i < 2'( __const__num_reg_rd_ports_at_comb_rd_wr_reg ); i += 1'd1 ) begin
      rd_reg__suc[1'(i)] = 1'd0;
      rd_reg__ret[1'(i)] = 32'd0;
      if ( rd_reg__en[1'(i)] ) begin
        if ( rd_reg__msg[1'(i)] == 7'd0 ) begin
          rd_reg__suc[1'(i)] = 1'd1;
          rd_reg__ret[1'(i)] = 32'd0;
        end
        else if ( scoreboard[rd_reg__msg[1'(i)]] ) begin
          for ( int unsigned fu_id = 1'd0; fu_id < 3'( __const__num_FUs_at_comb_rd_wr_reg ); fu_id += 1'd1 )
            if ( bypass_W__en[2'(fu_id)] & ( bypass_W__msg[2'(fu_id)].preg_idx == rd_reg__msg[1'(i)] ) ) begin
              rd_reg__suc[1'(i)] = 1'd1;
              rd_reg__ret[1'(i)] = bypass_W__msg[2'(fu_id)].data;
            end
          for ( int unsigned fu_id = 1'd0; fu_id < 3'( __const__num_FUs_at_comb_rd_wr_reg ); fu_id += 1'd1 )
            if ( bypass_X__en[2'(fu_id)] & ( bypass_X__msg[2'(fu_id)].preg_idx == rd_reg__msg[1'(i)] ) ) begin
              rd_reg__suc[1'(i)] = 1'd1;
              rd_reg__ret[1'(i)] = bypass_X__msg[2'(fu_id)].data;
            end
        end
        else begin
          rd_reg__suc[1'(i)] = 1'd1;
          rd_reg__ret[1'(i)] = rf__rdata[1'(i)];
        end
      end
    end
    for ( int unsigned i = 1'd0; i < 1'( __const__num_reg_wr_ports_at_comb_rd_wr_reg ); i += 1'd1 ) begin
      rf__wen[1'(i)] = 1'd0;
      if ( wr_reg__en[1'(i)] & ( wr_reg__msg[1'(i)].preg_idx != 7'd0 ) ) begin
        rf__wen[1'(i)] = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/DataFlowManagerRTL.py:135
  // @update
  // def comb_rename():
  // 
  //   # default
  //   s.rename.rdy                  @= 0
  //   s.rename.ret                  @= 0
  //   s.free_reg_list.alloc.en      @= 0
  //   s.free_reg_list.free.en       @= 0
  //   s.free_reg_list.rollback.en   @= 0
  //   s.rename_table.rename.en      @= 0
  //   s.rename_table.checkpoint.en  @= 0
  //   s.rename_table.rollback.en    @= 0
  //   s.free_reg.rdy                @= 0
  // 
  //   # rollback
  //   if s.rollback.en:
  //     s.rename_table.rollback.en  @= 1
  //     s.free_reg_list.rollback.en @= 1
  // 
  //   # no rollback
  //   else:
  //     # checkpoint
  //     s.rename_table.checkpoint.en @= s.checkpoint.en
  // 
  //     s.rename.rdy @= s.free_reg_list.alloc.rdy
  // 
  //     # rename: areg 0 is always mapped to preg 0
  //     if s.rename.en & ( s.rename.msg == 0 ):
  //       s.rename.ret @= 0
  //     elif s.rename.en:
  //       s.free_reg_list.alloc.en  @= 1
  //       s.rename_table.rename.en  @= 1
  //       s.rename.ret              @= s.free_reg_list.alloc.ret
  // 
  //     # free reg: preg 0 is never freed
  //     s.free_reg.rdy @= 1
  //     if s.free_reg.en & ( s.free_reg.msg != 0 ):
  //       s.free_reg_list.free.en @= s.free_reg.en
  
  always_comb begin : comb_rename
    rename__rdy = 1'd0;
    rename__ret = 7'd0;
    free_reg_list__alloc__en = 1'd0;
    free_reg_list__free__en = 1'd0;
    free_reg_list__rollback__en = 1'd0;
    rename_table__rename__en = 1'd0;
    rename_table__checkpoint__en = 1'd0;
    rename_table__rollback__en = 1'd0;
    free_reg__rdy = 1'd0;
    if ( rollback__en ) begin
      rename_table__rollback__en = 1'd1;
      free_reg_list__rollback__en = 1'd1;
    end
    else begin
      rename_table__checkpoint__en = checkpoint__en;
      rename__rdy = free_reg_list__alloc__rdy;
      if ( rename__en & ( rename__msg == 6'd0 ) ) begin
        rename__ret = 7'd0;
      end
      else if ( rename__en ) begin
        free_reg_list__alloc__en = 1'd1;
        rename_table__rename__en = 1'd1;
        rename__ret = free_reg_list__alloc__ret;
      end
      free_reg__rdy = 1'd1;
      if ( free_reg__en & ( free_reg__msg != 7'd0 ) ) begin
        free_reg_list__free__en = free_reg__en;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/DataFlowManagerRTL.py:100
  // @update_ff
  // def up_scoreboard():
  //   # reset
  //   if    s.reset:
  //     for i in range( num_pregs ):
  //       s.scoreboard[ i ] <<= 0
  // 
  //   # no reset
  //   else:
  //     # set reg
  //     if s.set_reg.en:
  //       s.scoreboard[ s.set_reg.msg ] <<= 1
  // 
  //     # unset reg
  //     for i in range( num_reg_wr_ports ):
  //       if s.wr_reg[ i ].en:
  //         s.scoreboard[ s.wr_reg[ i ].msg.preg_idx ] <<= 0
  
  always_ff @(posedge clk) begin : up_scoreboard
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 7'( __const__num_pregs_at_up_scoreboard ); i += 1'd1 )
        scoreboard[7'(i)] <= 1'd0;
    end
    else begin
      if ( set_reg__en ) begin
        scoreboard[set_reg__msg] <= 1'd1;
      end
      for ( int unsigned i = 1'd0; i < 1'( __const__num_reg_wr_ports_at_up_scoreboard ); i += 1'd1 )
        if ( wr_reg__en[1'(i)] ) begin
          scoreboard[wr_reg__msg[1'(i)].preg_idx] <= 1'd0;
        end
    end
  end

  assign rename_table__clk = clk;
  assign rename_table__reset = reset;
  assign free_reg_list__clk = clk;
  assign free_reg_list__reset = reset;
  assign rf__clk = clk;
  assign rf__reset = reset;
  assign rf__raddr[0] = rd_reg__msg[0];
  assign rf__raddr[1] = rd_reg__msg[1];
  assign rf__waddr[0] = wr_reg__msg[0].preg_idx;
  assign rf__wdata[0] = wr_reg__msg[0].data;
  assign rename_table__lookup__en[0] = lookup__en[0];
  assign rename_table__lookup__msg[0] = lookup__msg[0];
  assign lookup__ret[0] = rename_table__lookup__ret[0];
  assign rename_table__lookup__en[1] = lookup__en[1];
  assign rename_table__lookup__msg[1] = lookup__msg[1];
  assign lookup__ret[1] = rename_table__lookup__ret[1];
  assign rename_table__lookup__en[2] = lookup__en[2];
  assign rename_table__lookup__msg[2] = lookup__msg[2];
  assign lookup__ret[2] = rename_table__lookup__ret[2];
  assign free_reg_list__free__msg = free_reg__msg;
  assign rename_table__checkpoint__msg = checkpoint__msg;
  assign checkpoint__ret = free_reg_list__head_idx;
  assign rename_table__rollback__msg = rollback__msg.br_idx;
  assign free_reg_list__rollback__msg = rollback__msg.ckpt_head;
  assign rename_table__rename__msg.areg_idx = rename__msg;
  assign rename_table__rename__msg.preg_idx = free_reg_list__alloc__ret;

endmodule


// PyMTL Component RiscvDecoder Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/isa/RiscvDecode.py

module RiscvDecoder__xlen_64
(
  input  logic [0:0] clk ,
  output logic [11:0] csr ,
  output logic [0:0] fls ,
  input  logic [31:0] in_ ,
  output logic [0:0] inv ,
  output DecoderStruct__20424510df2ec9a8 out ,
  output logic [5:0] rd ,
  input  logic [0:0] reset ,
  output logic [5:0] rs1 ,
  output logic [5:0] rs2 
);
  localparam logic [7:0] __const__ZERO  = 8'd72;
  localparam logic [7:0] __const__NOP  = 8'd0;
  localparam logic [7:0] __const__ADD  = 8'd15;
  localparam logic [7:0] __const__SLL  = 8'd9;
  localparam logic [7:0] __const__SLT  = 8'd26;
  localparam logic [7:0] __const__SLTU  = 8'd28;
  localparam logic [7:0] __const__XOR  = 8'd20;
  localparam logic [7:0] __const__SRL  = 8'd11;
  localparam logic [7:0] __const__OR  = 8'd22;
  localparam logic [7:0] __const__AND  = 8'd24;
  localparam logic [7:0] __const__SUB  = 8'd17;
  localparam logic [7:0] __const__SRA  = 8'd13;
  localparam logic [7:0] __const__MUL  = 8'd38;
  localparam logic [7:0] __const__MULH  = 8'd39;
  localparam logic [7:0] __const__MULHSU  = 8'd40;
  localparam logic [7:0] __const__MULHU  = 8'd41;
  localparam logic [7:0] __const__DIV  = 8'd42;
  localparam logic [7:0] __const__DIVU  = 8'd43;
  localparam logic [7:0] __const__REM  = 8'd44;
  localparam logic [7:0] __const__REMU  = 8'd45;
  localparam logic [7:0] __const__ADDI  = 8'd16;
  localparam logic [7:0] __const__SLTI  = 8'd27;
  localparam logic [7:0] __const__SLTIU  = 8'd29;
  localparam logic [7:0] __const__XORI  = 8'd21;
  localparam logic [7:0] __const__ORI  = 8'd23;
  localparam logic [7:0] __const__ANDI  = 8'd25;
  localparam logic [7:0] __const__SLLI  = 8'd10;
  localparam logic [7:0] __const__SRLI  = 8'd12;
  localparam logic [7:0] __const__SRAI  = 8'd14;
  localparam logic [7:0] __const__SB  = 8'd6;
  localparam logic [7:0] __const__SH  = 8'd7;
  localparam logic [7:0] __const__SW  = 8'd8;
  localparam logic [6:0] __const__xlen_at_up_inst_type  = 7'd64;
  localparam logic [7:0] __const__SD  = 8'd78;
  localparam logic [7:0] __const__LB  = 8'd1;
  localparam logic [7:0] __const__LH  = 8'd2;
  localparam logic [7:0] __const__LW  = 8'd3;
  localparam logic [7:0] __const__LBU  = 8'd4;
  localparam logic [7:0] __const__LHU  = 8'd5;
  localparam logic [7:0] __const__LWU  = 8'd76;
  localparam logic [7:0] __const__LD  = 8'd77;
  localparam logic [7:0] __const__FENCE  = 8'd74;
  localparam logic [7:0] __const__FENCEI  = 8'd75;
  localparam logic [7:0] __const__BEQ  = 8'd30;
  localparam logic [7:0] __const__BNE  = 8'd31;
  localparam logic [7:0] __const__BLT  = 8'd32;
  localparam logic [7:0] __const__BGE  = 8'd33;
  localparam logic [7:0] __const__BLTU  = 8'd34;
  localparam logic [7:0] __const__BGEU  = 8'd35;
  localparam logic [7:0] __const__LUI  = 8'd18;
  localparam logic [7:0] __const__AUIPC  = 8'd19;
  localparam logic [7:0] __const__JAL  = 8'd36;
  localparam logic [7:0] __const__JALR  = 8'd37;
  localparam logic [7:0] __const__CSRW  = 8'd71;
  localparam logic [7:0] __const__CSRRX  = 8'd73;
  localparam logic [7:0] __const__CSRR  = 8'd70;
  localparam logic [7:0] __const__AMOSWAP  = 8'd46;
  localparam logic [7:0] __const__AMOADD  = 8'd47;
  localparam logic [7:0] __const__AMOXOR  = 8'd48;
  localparam logic [7:0] __const__AMOOR  = 8'd49;
  localparam logic [7:0] __const__AMOAND  = 8'd50;
  localparam logic [7:0] __const__AMOMIN  = 8'd51;
  localparam logic [7:0] __const__AMOMAX  = 8'd52;
  localparam logic [7:0] __const__AMOMINU  = 8'd53;
  localparam logic [7:0] __const__AMOMAXU  = 8'd54;
  localparam logic [7:0] __const__FLW  = 8'd55;
  localparam logic [7:0] __const__FSW  = 8'd56;
  localparam logic [7:0] __const__FADDS  = 8'd57;
  localparam logic [7:0] __const__FSUBS  = 8'd58;
  localparam logic [7:0] __const__FMULS  = 8'd59;
  localparam logic [7:0] __const__FDIVS  = 8'd60;
  localparam logic [7:0] __const__FMINS  = 8'd61;
  localparam logic [7:0] __const__FMAXS  = 8'd62;
  localparam logic [7:0] __const__FCVTWS  = 8'd63;
  localparam logic [7:0] __const__FMVXW  = 8'd64;
  localparam logic [7:0] __const__FEQS  = 8'd65;
  localparam logic [7:0] __const__FLTS  = 8'd66;
  localparam logic [7:0] __const__FLES  = 8'd67;
  localparam logic [7:0] __const__FCVTSW  = 8'd68;
  localparam logic [7:0] __const__FMVWX  = 8'd69;
  localparam logic [7:0] __const__ADDIW  = 8'd79;
  localparam logic [7:0] __const__SLLIW  = 8'd80;
  localparam logic [7:0] __const__SRLIW  = 8'd81;
  localparam logic [7:0] __const__ADDW  = 8'd83;
  localparam logic [7:0] __const__SUBW  = 8'd84;
  localparam logic [7:0] __const__MULW  = 8'd88;
  localparam logic [7:0] __const__SLLW  = 8'd85;
  localparam logic [7:0] __const__DIVW  = 8'd89;
  localparam logic [7:0] __const__SRLW  = 8'd86;
  localparam logic [7:0] __const__SRAW  = 8'd87;
  localparam logic [7:0] __const__DIVUW  = 8'd90;
  localparam logic [7:0] __const__REMW  = 8'd91;
  localparam logic [7:0] __const__REMUW  = 8'd92;
  localparam logic [0:0] __const__y  = 1'd1;
  localparam logic [2:0] __const__imm_x  = 3'd0;
  localparam logic [3:0] __const__br_x  = 4'd0;
  localparam logic [3:0] __const__alu_x  = 4'd0;
  localparam logic [3:0] __const__md_x  = 4'd0;
  localparam logic [3:0] __const__mem_x  = 4'd0;
  localparam logic [1:0] __const__mlen_x  = 2'd0;
  localparam logic [0:0] __const__xe  = 1'd0;
  localparam logic [1:0] __const__csr_x  = 2'd0;
  localparam logic [3:0] __const__fp_x  = 4'd11;
  localparam logic [0:0] __const__n  = 1'd0;
  localparam logic [0:0] __const__am_x  = 1'd0;
  localparam logic [1:0] __const__bm_x  = 2'd0;
  localparam logic [2:0] __const__imm_i  = 3'd0;
  localparam logic [3:0] __const__alu_cp1  = 4'd13;
  localparam logic [1:0] __const__csr_rd  = 2'd1;
  localparam logic [1:0] __const__bm_csr  = 2'd2;
  localparam logic [3:0] __const__alu_cp0  = 4'd12;
  localparam logic [1:0] __const__csr_wr  = 2'd2;
  localparam logic [0:0] __const__am_rf  = 1'd0;
  localparam logic [1:0] __const__bm_rf  = 2'd0;
  localparam logic [3:0] __const__alu_add  = 4'd1;
  localparam logic [3:0] __const__alu_sub  = 4'd2;
  localparam logic [3:0] __const__alu_sll  = 4'd3;
  localparam logic [3:0] __const__alu_lt  = 4'd5;
  localparam logic [3:0] __const__alu_ltu  = 4'd6;
  localparam logic [3:0] __const__alu_xor  = 4'd8;
  localparam logic [3:0] __const__alu_srl  = 4'd10;
  localparam logic [3:0] __const__alu_sra  = 4'd11;
  localparam logic [3:0] __const__alu_or  = 4'd4;
  localparam logic [3:0] __const__alu_and  = 4'd7;
  localparam logic [1:0] __const__bm_imm  = 2'd1;
  localparam logic [2:0] __const__imm_u  = 3'd3;
  localparam logic [0:0] __const__am_pc  = 1'd1;
  localparam logic [3:0] __const__mem_ld  = 4'd1;
  localparam logic [1:0] __const__mlen_b  = 2'd1;
  localparam logic [0:0] __const__se  = 1'd0;
  localparam logic [1:0] __const__mlen_h  = 2'd2;
  localparam logic [0:0] __const__ze  = 1'd1;
  localparam logic [1:0] __const__mlen_w  = 2'd0;
  localparam logic [2:0] __const__imm_s  = 3'd1;
  localparam logic [3:0] __const__mem_st  = 4'd2;
  localparam logic [3:0] __const__mem_f  = 4'd12;
  localparam logic [2:0] __const__imm_b  = 3'd2;
  localparam logic [3:0] __const__br_eq  = 4'd4;
  localparam logic [3:0] __const__br_ne  = 4'd1;
  localparam logic [3:0] __const__br_lt  = 4'd2;
  localparam logic [3:0] __const__br_ge  = 4'd5;
  localparam logic [3:0] __const__br_lu  = 4'd3;
  localparam logic [3:0] __const__br_gu  = 4'd6;
  localparam logic [2:0] __const__imm_j  = 3'd4;
  localparam logic [3:0] __const__jal  = 4'd8;
  localparam logic [3:0] __const__jalr  = 4'd7;
  localparam logic [3:0] __const__alu_adz  = 4'd14;
  localparam logic [3:0] __const__md_mul  = 4'd1;
  localparam logic [3:0] __const__md_mh  = 4'd2;
  localparam logic [3:0] __const__md_mhsu  = 4'd3;
  localparam logic [3:0] __const__md_mhu  = 4'd4;
  localparam logic [3:0] __const__md_div  = 4'd5;
  localparam logic [3:0] __const__md_divu  = 4'd6;
  localparam logic [3:0] __const__md_rem  = 4'd7;
  localparam logic [3:0] __const__md_remu  = 4'd8;
  localparam logic [3:0] __const__mem_add  = 4'd3;
  localparam logic [3:0] __const__mem_and  = 4'd4;
  localparam logic [3:0] __const__mem_max  = 4'd9;
  localparam logic [3:0] __const__mem_maxu  = 4'd10;
  localparam logic [3:0] __const__mem_min  = 4'd7;
  localparam logic [3:0] __const__mem_minu  = 4'd8;
  localparam logic [3:0] __const__mem_or  = 4'd5;
  localparam logic [3:0] __const__mem_swp  = 4'd6;
  localparam logic [3:0] __const__mem_xor  = 4'd11;
  localparam logic [3:0] __const__fp_add  = 4'd1;
  localparam logic [3:0] __const__fp_sub  = 4'd2;
  localparam logic [3:0] __const__fp_mul  = 4'd0;
  localparam logic [3:0] __const__fp_div  = 4'd3;
  localparam logic [3:0] __const__fp_min  = 4'd4;
  localparam logic [3:0] __const__fp_max  = 4'd5;
  localparam logic [3:0] __const__fp_ceq  = 4'd8;
  localparam logic [3:0] __const__fp_clt  = 4'd9;
  localparam logic [3:0] __const__fp_cle  = 4'd10;
  localparam logic [3:0] __const__fp_f2i  = 4'd7;
  localparam logic [3:0] __const__fp_i2f  = 4'd6;
  localparam logic [6:0] __const__xlen_at_up_outputs  = 7'd64;
  localparam logic [1:0] __const__mlen_wzx  = 2'd3;
  localparam logic [7:0] __const__SRAIW  = 8'd82;
  logic [37:0] cs;
  logic [7:0] inst_type;
  logic [7:0] __tmpvar__up_outputs_inst;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/isa/RiscvDecode.py:85
  // @update
  // def up_inst_type():
  // 
  //   s.inst_type @= ZERO
  // 
  //   if   s.in_ == 0b10011:                 s.inst_type @= NOP
  //   elif s.in_[OPCODE] == 0b0110011:
  //     if   s.in_[FUNCT7] == 0b0000000:
  //       if   s.in_[FUNCT3] == 0b000:       s.inst_type @= ADD
  //       elif s.in_[FUNCT3] == 0b001:       s.inst_type @= SLL
  //       elif s.in_[FUNCT3] == 0b010:       s.inst_type @= SLT
  //       elif s.in_[FUNCT3] == 0b011:       s.inst_type @= SLTU
  //       elif s.in_[FUNCT3] == 0b100:       s.inst_type @= XOR
  //       elif s.in_[FUNCT3] == 0b101:       s.inst_type @= SRL
  //       elif s.in_[FUNCT3] == 0b110:       s.inst_type @= OR
  //       elif s.in_[FUNCT3] == 0b111:       s.inst_type @= AND
  //     elif s.in_[FUNCT7] == 0b0100000:
  //       if   s.in_[FUNCT3] == 0b000:       s.inst_type @= SUB
  //       elif s.in_[FUNCT3] == 0b101:       s.inst_type @= SRA
  //     elif s.in_[FUNCT7] == 0b0000001:
  //       if   s.in_[FUNCT3] == 0b000:       s.inst_type @= MUL
  //       elif s.in_[FUNCT3] == 0b001:       s.inst_type @= MULH
  //       elif s.in_[FUNCT3] == 0b010:       s.inst_type @= MULHSU
  //       elif s.in_[FUNCT3] == 0b011:       s.inst_type @= MULHU
  //       elif s.in_[FUNCT3] == 0b100:       s.inst_type @= DIV
  //       elif s.in_[FUNCT3] == 0b101:       s.inst_type @= DIVU
  //       elif s.in_[FUNCT3] == 0b110:       s.inst_type @= REM
  //       elif s.in_[FUNCT3] == 0b111:       s.inst_type @= REMU
  // 
  //   elif s.in_[OPCODE] == 0b0010011:
  //     if   s.in_[FUNCT3] == 0b000:         s.inst_type @= ADDI
  //     elif s.in_[FUNCT3] == 0b010:         s.inst_type @= SLTI
  //     elif s.in_[FUNCT3] == 0b011:         s.inst_type @= SLTIU
  //     elif s.in_[FUNCT3] == 0b100:         s.inst_type @= XORI
  //     elif s.in_[FUNCT3] == 0b110:         s.inst_type @= ORI
  //     elif s.in_[FUNCT3] == 0b111:         s.inst_type @= ANDI
  //     elif s.in_[FUNCT3] == 0b001:         s.inst_type @= SLLI
  //     elif s.in_[FUNCT3] == 0b101:
  //       if   s.in_[FUNCT7] == 0b0000000:   s.inst_type @= SRLI
  //       elif s.in_[FUNCT7] == 0b0100000:   s.inst_type @= SRAI
  // 
  //   elif s.in_[OPCODE] == 0b0100011:
  //     if                   s.in_[FUNCT3] == 0b000:  s.inst_type @= SB
  //     elif                 s.in_[FUNCT3] == 0b001:  s.inst_type @= SH
  //     elif                 s.in_[FUNCT3] == 0b010:  s.inst_type @= SW
  //     elif (xlen == 64) & (s.in_[FUNCT3] == 0b011): s.inst_type @= SD
  // 
  //   elif s.in_[OPCODE] == 0b0000011:
  //     if                   s.in_[FUNCT3] == 0b000:  s.inst_type @= LB
  //     elif                 s.in_[FUNCT3] == 0b001:  s.inst_type @= LH
  //     elif                 s.in_[FUNCT3] == 0b010:  s.inst_type @= LW
  //     elif                 s.in_[FUNCT3] == 0b100:  s.inst_type @= LBU
  //     elif                 s.in_[FUNCT3] == 0b101:  s.inst_type @= LHU
  //     elif (xlen == 64) & (s.in_[FUNCT3] == 0b110): s.inst_type @= LWU
  //     elif (xlen == 64) & (s.in_[FUNCT3] == 0b011): s.inst_type @= LD
  // 
  //   elif s.in_[OPCODE] == 0b0001111:
  //     if   s.in_[FUNCT3] == 0b000:         s.inst_type @= FENCE
  //     elif s.in_[FUNCT3] == 0b001:         s.inst_type @= FENCEI
  // 
  //   elif s.in_[OPCODE] == 0b1100011:
  //     if   s.in_[FUNCT3] == 0b000:         s.inst_type @= BEQ
  //     elif s.in_[FUNCT3] == 0b001:         s.inst_type @= BNE
  //     elif s.in_[FUNCT3] == 0b100:         s.inst_type @= BLT
  //     elif s.in_[FUNCT3] == 0b101:         s.inst_type @= BGE
  //     elif s.in_[FUNCT3] == 0b110:         s.inst_type @= BLTU
  //     elif s.in_[FUNCT3] == 0b111:         s.inst_type @= BGEU
  // 
  //   elif s.in_[OPCODE] == 0b0110111:       s.inst_type @= LUI
  // 
  //   elif s.in_[OPCODE] == 0b0010111:       s.inst_type @= AUIPC
  // 
  //   elif s.in_[OPCODE] == 0b1101111:       s.inst_type @= JAL
  // 
  //   elif s.in_[OPCODE] == 0b1100111:       s.inst_type @= JALR
  // 
  //   elif s.in_[OPCODE] == 0b1110011:
  //     if   s.in_[FUNCT3] == 0b001:         s.inst_type @= CSRW
  //     elif s.in_[FUNCT3] == 0b010:
  //       if s.in_[FUNCT7] == 0b0111111:     s.inst_type @= CSRRX
  //       else:                              s.inst_type @= CSRR
  // 
  //   elif s.in_[OPCODE] == 0b0101111:
  //     if   s.in_[FUNCT3] == 0b010:
  //       if   s.in_[FUNCT5] == 0b00001:     s.inst_type @= AMOSWAP
  //       elif s.in_[FUNCT5] == 0b00000:     s.inst_type @= AMOADD
  //       elif s.in_[FUNCT5] == 0b00100:     s.inst_type @= AMOXOR
  //       elif s.in_[FUNCT5] == 0b01000:     s.inst_type @= AMOOR
  //       elif s.in_[FUNCT5] == 0b01100:     s.inst_type @= AMOAND
  //       elif s.in_[FUNCT5] == 0b10000:     s.inst_type @= AMOMIN
  //       elif s.in_[FUNCT5] == 0b10100:     s.inst_type @= AMOMAX
  //       elif s.in_[FUNCT5] == 0b11000:     s.inst_type @= AMOMINU
  //       elif s.in_[FUNCT5] == 0b11100:     s.inst_type @= AMOMAXU
  // 
  //   elif s.in_[OPCODE] == 0b0000111:
  //     if   s.in_[FUNCT3] == 0b010:         s.inst_type @= FLW
  // 
  //   elif s.in_[OPCODE] == 0b0100111:
  //     if   s.in_[FUNCT3] == 0b010:         s.inst_type @= FSW
  // 
  //   elif s.in_[OPCODE] == 0b1010011:
  //     if   s.in_[FUNCT7] == 0b0000000:     s.inst_type @= FADDS
  //     elif s.in_[FUNCT7] == 0b0000100:     s.inst_type @= FSUBS
  //     elif s.in_[FUNCT7] == 0b0001000:     s.inst_type @= FMULS
  //     elif s.in_[FUNCT7] == 0b0001100:     s.inst_type @= FDIVS
  //     elif s.in_[FUNCT7] == 0b0010100:
  //       if   s.in_[FUNCT3] == 0b000:       s.inst_type @= FMINS
  //       elif s.in_[FUNCT3] == 0b001:       s.inst_type @= FMAXS
  //     elif s.in_[FUNCT7] == 0b1100000:
  //       if   s.in_[RS2] == 0b00000:        s.inst_type @= FCVTWS
  //     elif s.in_[FUNCT7] == 0b1110000:
  //       if   s.in_[RS2] == 0b00000:
  //         if   s.in_[FUNCT3] == 0b000:     s.inst_type @= FMVXW
  //     elif s.in_[FUNCT7] == 0b1010000:
  //       if   s.in_[FUNCT3] == 0b010:       s.inst_type @= FEQS
  //       elif s.in_[FUNCT3] == 0b001:       s.inst_type @= FLTS
  //       elif s.in_[FUNCT3] == 0b000:       s.inst_type @= FLES
  //     elif s.in_[FUNCT7] == 0b1101000:
  //       if   s.in_[RS2] == 0b00000:        s.inst_type @= FCVTSW
  //     elif s.in_[FUNCT7] == 0b1111000:
  //       if   s.in_[RS2] == 0b00000:
  //         if   s.in_[FUNCT3] == 0b000:     s.inst_type @= FMVWX
  // 
  //   elif (xlen == 64) & (s.in_[OPCODE] == 0b0011011):
  //     if    s.in_[FUNCT3] == 0b000:         s.inst_type @= ADDIW
  //     elif  s.in_[FUNCT3] == 0b001:         s.inst_type @= SLLIW
  //     elif  s.in_[FUNCT3] == 0b101:
  //       if    s.in_[FUNCT7] == 0b0000000:   s.inst_type @= SRLIW
  //       elif  s.in_[FUNCT7] == 0b0100000:   s.inst_type @= SRLIW
  // 
  //   elif (xlen == 64) & (s.in_[OPCODE] == 0b0111011):
  //     if    s.in_[FUNCT3] == 0b000:
  //       if    s.in_[FUNCT7] == 0b0000000:   s.inst_type @= ADDW
  //       elif  s.in_[FUNCT7] == 0b0100000:   s.inst_type @= SUBW
  //       elif  s.in_[FUNCT7] == 0b0000001:   s.inst_type @= MULW
  //     elif  s.in_[FUNCT3] == 0b001:
  //       if    s.in_[FUNCT7] == 0b0000000:   s.inst_type @= SLLW
  //     elif  s.in_[FUNCT3] == 0b100:
  //       if    s.in_[FUNCT7] == 0b0000001:   s.inst_type @= DIVW
  //     elif  s.in_[FUNCT3] == 0b101:
  //       if    s.in_[FUNCT7] == 0b0000000:   s.inst_type @= SRLW
  //       elif  s.in_[FUNCT7] == 0b0100000:   s.inst_type @= SRAW
  //       elif  s.in_[FUNCT7] == 0b0000001:   s.inst_type @= DIVUW
  //     elif  s.in_[FUNCT3] == 0b110:
  //       if    s.in_[FUNCT7] == 0b0000001:   s.inst_type @= REMW
  //     elif  s.in_[FUNCT3] == 0b111:
  //       if    s.in_[FUNCT7] == 0b0000001:   s.inst_type @= REMUW
  
  always_comb begin : up_inst_type
    inst_type = 8'( __const__ZERO );
    if ( in_ == 32'd19 ) begin
      inst_type = 8'( __const__NOP );
    end
    else if ( in_[5'd6:5'd0] == 7'd51 ) begin
      if ( in_[5'd31:5'd25] == 7'd0 ) begin
        if ( in_[5'd14:5'd12] == 3'd0 ) begin
          inst_type = 8'( __const__ADD );
        end
        else if ( in_[5'd14:5'd12] == 3'd1 ) begin
          inst_type = 8'( __const__SLL );
        end
        else if ( in_[5'd14:5'd12] == 3'd2 ) begin
          inst_type = 8'( __const__SLT );
        end
        else if ( in_[5'd14:5'd12] == 3'd3 ) begin
          inst_type = 8'( __const__SLTU );
        end
        else if ( in_[5'd14:5'd12] == 3'd4 ) begin
          inst_type = 8'( __const__XOR );
        end
        else if ( in_[5'd14:5'd12] == 3'd5 ) begin
          inst_type = 8'( __const__SRL );
        end
        else if ( in_[5'd14:5'd12] == 3'd6 ) begin
          inst_type = 8'( __const__OR );
        end
        else if ( in_[5'd14:5'd12] == 3'd7 ) begin
          inst_type = 8'( __const__AND );
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd32 ) begin
        if ( in_[5'd14:5'd12] == 3'd0 ) begin
          inst_type = 8'( __const__SUB );
        end
        else if ( in_[5'd14:5'd12] == 3'd5 ) begin
          inst_type = 8'( __const__SRA );
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd1 ) begin
        if ( in_[5'd14:5'd12] == 3'd0 ) begin
          inst_type = 8'( __const__MUL );
        end
        else if ( in_[5'd14:5'd12] == 3'd1 ) begin
          inst_type = 8'( __const__MULH );
        end
        else if ( in_[5'd14:5'd12] == 3'd2 ) begin
          inst_type = 8'( __const__MULHSU );
        end
        else if ( in_[5'd14:5'd12] == 3'd3 ) begin
          inst_type = 8'( __const__MULHU );
        end
        else if ( in_[5'd14:5'd12] == 3'd4 ) begin
          inst_type = 8'( __const__DIV );
        end
        else if ( in_[5'd14:5'd12] == 3'd5 ) begin
          inst_type = 8'( __const__DIVU );
        end
        else if ( in_[5'd14:5'd12] == 3'd6 ) begin
          inst_type = 8'( __const__REM );
        end
        else if ( in_[5'd14:5'd12] == 3'd7 ) begin
          inst_type = 8'( __const__REMU );
        end
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd19 ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        inst_type = 8'( __const__ADDI );
      end
      else if ( in_[5'd14:5'd12] == 3'd2 ) begin
        inst_type = 8'( __const__SLTI );
      end
      else if ( in_[5'd14:5'd12] == 3'd3 ) begin
        inst_type = 8'( __const__SLTIU );
      end
      else if ( in_[5'd14:5'd12] == 3'd4 ) begin
        inst_type = 8'( __const__XORI );
      end
      else if ( in_[5'd14:5'd12] == 3'd6 ) begin
        inst_type = 8'( __const__ORI );
      end
      else if ( in_[5'd14:5'd12] == 3'd7 ) begin
        inst_type = 8'( __const__ANDI );
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__SLLI );
      end
      else if ( in_[5'd14:5'd12] == 3'd5 ) begin
        if ( in_[5'd31:5'd25] == 7'd0 ) begin
          inst_type = 8'( __const__SRLI );
        end
        else if ( in_[5'd31:5'd25] == 7'd32 ) begin
          inst_type = 8'( __const__SRAI );
        end
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd35 ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        inst_type = 8'( __const__SB );
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__SH );
      end
      else if ( in_[5'd14:5'd12] == 3'd2 ) begin
        inst_type = 8'( __const__SW );
      end
      else if ( ( 7'( __const__xlen_at_up_inst_type ) == 7'd64 ) & ( in_[5'd14:5'd12] == 3'd3 ) ) begin
        inst_type = 8'( __const__SD );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd3 ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        inst_type = 8'( __const__LB );
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__LH );
      end
      else if ( in_[5'd14:5'd12] == 3'd2 ) begin
        inst_type = 8'( __const__LW );
      end
      else if ( in_[5'd14:5'd12] == 3'd4 ) begin
        inst_type = 8'( __const__LBU );
      end
      else if ( in_[5'd14:5'd12] == 3'd5 ) begin
        inst_type = 8'( __const__LHU );
      end
      else if ( ( 7'( __const__xlen_at_up_inst_type ) == 7'd64 ) & ( in_[5'd14:5'd12] == 3'd6 ) ) begin
        inst_type = 8'( __const__LWU );
      end
      else if ( ( 7'( __const__xlen_at_up_inst_type ) == 7'd64 ) & ( in_[5'd14:5'd12] == 3'd3 ) ) begin
        inst_type = 8'( __const__LD );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd15 ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        inst_type = 8'( __const__FENCE );
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__FENCEI );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd99 ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        inst_type = 8'( __const__BEQ );
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__BNE );
      end
      else if ( in_[5'd14:5'd12] == 3'd4 ) begin
        inst_type = 8'( __const__BLT );
      end
      else if ( in_[5'd14:5'd12] == 3'd5 ) begin
        inst_type = 8'( __const__BGE );
      end
      else if ( in_[5'd14:5'd12] == 3'd6 ) begin
        inst_type = 8'( __const__BLTU );
      end
      else if ( in_[5'd14:5'd12] == 3'd7 ) begin
        inst_type = 8'( __const__BGEU );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd55 ) begin
      inst_type = 8'( __const__LUI );
    end
    else if ( in_[5'd6:5'd0] == 7'd23 ) begin
      inst_type = 8'( __const__AUIPC );
    end
    else if ( in_[5'd6:5'd0] == 7'd111 ) begin
      inst_type = 8'( __const__JAL );
    end
    else if ( in_[5'd6:5'd0] == 7'd103 ) begin
      inst_type = 8'( __const__JALR );
    end
    else if ( in_[5'd6:5'd0] == 7'd115 ) begin
      if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__CSRW );
      end
      else if ( in_[5'd14:5'd12] == 3'd2 ) begin
        if ( in_[5'd31:5'd25] == 7'd63 ) begin
          inst_type = 8'( __const__CSRRX );
        end
        else
          inst_type = 8'( __const__CSRR );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd47 ) begin
      if ( in_[5'd14:5'd12] == 3'd2 ) begin
        if ( in_[5'd31:5'd27] == 5'd1 ) begin
          inst_type = 8'( __const__AMOSWAP );
        end
        else if ( in_[5'd31:5'd27] == 5'd0 ) begin
          inst_type = 8'( __const__AMOADD );
        end
        else if ( in_[5'd31:5'd27] == 5'd4 ) begin
          inst_type = 8'( __const__AMOXOR );
        end
        else if ( in_[5'd31:5'd27] == 5'd8 ) begin
          inst_type = 8'( __const__AMOOR );
        end
        else if ( in_[5'd31:5'd27] == 5'd12 ) begin
          inst_type = 8'( __const__AMOAND );
        end
        else if ( in_[5'd31:5'd27] == 5'd16 ) begin
          inst_type = 8'( __const__AMOMIN );
        end
        else if ( in_[5'd31:5'd27] == 5'd20 ) begin
          inst_type = 8'( __const__AMOMAX );
        end
        else if ( in_[5'd31:5'd27] == 5'd24 ) begin
          inst_type = 8'( __const__AMOMINU );
        end
        else if ( in_[5'd31:5'd27] == 5'd28 ) begin
          inst_type = 8'( __const__AMOMAXU );
        end
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd7 ) begin
      if ( in_[5'd14:5'd12] == 3'd2 ) begin
        inst_type = 8'( __const__FLW );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd39 ) begin
      if ( in_[5'd14:5'd12] == 3'd2 ) begin
        inst_type = 8'( __const__FSW );
      end
    end
    else if ( in_[5'd6:5'd0] == 7'd83 ) begin
      if ( in_[5'd31:5'd25] == 7'd0 ) begin
        inst_type = 8'( __const__FADDS );
      end
      else if ( in_[5'd31:5'd25] == 7'd4 ) begin
        inst_type = 8'( __const__FSUBS );
      end
      else if ( in_[5'd31:5'd25] == 7'd8 ) begin
        inst_type = 8'( __const__FMULS );
      end
      else if ( in_[5'd31:5'd25] == 7'd12 ) begin
        inst_type = 8'( __const__FDIVS );
      end
      else if ( in_[5'd31:5'd25] == 7'd20 ) begin
        if ( in_[5'd14:5'd12] == 3'd0 ) begin
          inst_type = 8'( __const__FMINS );
        end
        else if ( in_[5'd14:5'd12] == 3'd1 ) begin
          inst_type = 8'( __const__FMAXS );
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd96 ) begin
        if ( in_[5'd24:5'd20] == 5'd0 ) begin
          inst_type = 8'( __const__FCVTWS );
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd112 ) begin
        if ( in_[5'd24:5'd20] == 5'd0 ) begin
          if ( in_[5'd14:5'd12] == 3'd0 ) begin
            inst_type = 8'( __const__FMVXW );
          end
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd80 ) begin
        if ( in_[5'd14:5'd12] == 3'd2 ) begin
          inst_type = 8'( __const__FEQS );
        end
        else if ( in_[5'd14:5'd12] == 3'd1 ) begin
          inst_type = 8'( __const__FLTS );
        end
        else if ( in_[5'd14:5'd12] == 3'd0 ) begin
          inst_type = 8'( __const__FLES );
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd104 ) begin
        if ( in_[5'd24:5'd20] == 5'd0 ) begin
          inst_type = 8'( __const__FCVTSW );
        end
      end
      else if ( in_[5'd31:5'd25] == 7'd120 ) begin
        if ( in_[5'd24:5'd20] == 5'd0 ) begin
          if ( in_[5'd14:5'd12] == 3'd0 ) begin
            inst_type = 8'( __const__FMVWX );
          end
        end
      end
    end
    else if ( ( 7'( __const__xlen_at_up_inst_type ) == 7'd64 ) & ( in_[5'd6:5'd0] == 7'd27 ) ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        inst_type = 8'( __const__ADDIW );
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        inst_type = 8'( __const__SLLIW );
      end
      else if ( in_[5'd14:5'd12] == 3'd5 ) begin
        if ( in_[5'd31:5'd25] == 7'd0 ) begin
          inst_type = 8'( __const__SRLIW );
        end
        else if ( in_[5'd31:5'd25] == 7'd32 ) begin
          inst_type = 8'( __const__SRLIW );
        end
      end
    end
    else if ( ( 7'( __const__xlen_at_up_inst_type ) == 7'd64 ) & ( in_[5'd6:5'd0] == 7'd59 ) ) begin
      if ( in_[5'd14:5'd12] == 3'd0 ) begin
        if ( in_[5'd31:5'd25] == 7'd0 ) begin
          inst_type = 8'( __const__ADDW );
        end
        else if ( in_[5'd31:5'd25] == 7'd32 ) begin
          inst_type = 8'( __const__SUBW );
        end
        else if ( in_[5'd31:5'd25] == 7'd1 ) begin
          inst_type = 8'( __const__MULW );
        end
      end
      else if ( in_[5'd14:5'd12] == 3'd1 ) begin
        if ( in_[5'd31:5'd25] == 7'd0 ) begin
          inst_type = 8'( __const__SLLW );
        end
      end
      else if ( in_[5'd14:5'd12] == 3'd4 ) begin
        if ( in_[5'd31:5'd25] == 7'd1 ) begin
          inst_type = 8'( __const__DIVW );
        end
      end
      else if ( in_[5'd14:5'd12] == 3'd5 ) begin
        if ( in_[5'd31:5'd25] == 7'd0 ) begin
          inst_type = 8'( __const__SRLW );
        end
        else if ( in_[5'd31:5'd25] == 7'd32 ) begin
          inst_type = 8'( __const__SRAW );
        end
        else if ( in_[5'd31:5'd25] == 7'd1 ) begin
          inst_type = 8'( __const__DIVUW );
        end
      end
      else if ( in_[5'd14:5'd12] == 3'd6 ) begin
        if ( in_[5'd31:5'd25] == 7'd1 ) begin
          inst_type = 8'( __const__REMW );
        end
      end
      else if ( in_[5'd14:5'd12] == 3'd7 ) begin
        if ( in_[5'd31:5'd25] == 7'd1 ) begin
          inst_type = 8'( __const__REMUW );
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/isa/RiscvDecode.py:239
  // @update
  // def up_outputs():
  //   inst = s.inst_type
  // 
  //   # NOTE: This instruction decoding table contains both RV32 and RV64
  //   # instructions. However, due to the 32-bit pipeline and registers
  //   # RV64 instructions are implemented to operate on 32-bit data, so this
  //   # is not a complete implementation of RV64 ISA.
  // 
  //   #                                      inst    imm   br       alu       mdu         mem       mem    mem    csr  fpu    rs1  rs2  rd   op1    op2    frs1 frs2 frd
  //   #                                       val    type  type    type      type        type       len    ext   type  type    en   en  en   sel    sel
  //   if   inst == NOP      : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   n, am_x,  bm_x,     n,    n,  n )
  //   # *** RV32/64I ***
  //   # csr
  //   elif inst == CSRR     : s.cs @= concat(  y,  imm_i,  br_x,  alu_cp1,   md_x,     mem_x,    mlen_x,   xe, csr_rd, fp_x,   n,   n,   y, am_x,  bm_csr,   n,    n,  n )
  //   elif inst == CSRW     : s.cs @= concat(  y,  imm_i,  br_x,  alu_cp0,   md_x,     mem_x,    mlen_x,   xe, csr_wr, fp_x,   y,   n,   n, am_rf, bm_rf,    n,    n,  n )
  //   # reg-reg
  //   elif inst == ADD      : s.cs @= concat(  y,  imm_x,  br_x,  alu_add,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == SUB      : s.cs @= concat(  y,  imm_x,  br_x,  alu_sub,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == SLL      : s.cs @= concat(  y,  imm_x,  br_x,  alu_sll,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == SLT      : s.cs @= concat(  y,  imm_x,  br_x,  alu_lt,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == SLTU     : s.cs @= concat(  y,  imm_x,  br_x,  alu_ltu,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == XOR      : s.cs @= concat(  y,  imm_x,  br_x,  alu_xor,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == SRL      : s.cs @= concat(  y,  imm_x,  br_x,  alu_srl,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == SRA      : s.cs @= concat(  y,  imm_x,  br_x,  alu_sra,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == OR       : s.cs @= concat(  y,  imm_x,  br_x,  alu_or,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == AND      : s.cs @= concat(  y,  imm_x,  br_x,  alu_and,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   # reg-imm
  //   elif inst == ADDI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_add,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SLTI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_lt,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SLTIU    : s.cs @= concat(  y,  imm_i,  br_x,  alu_ltu,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == XORI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_xor,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == ORI      : s.cs @= concat(  y,  imm_i,  br_x,  alu_or,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == ANDI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_and,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SLLI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_sll,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SRLI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_srl,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SRAI     : s.cs @= concat(  y,  imm_i,  br_x,  alu_sra,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   # others
  //   elif inst == LUI      : s.cs @= concat(  y,  imm_u,  br_x,  alu_cp1,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   y, am_x,  bm_imm,   n,    n,  n )
  //   elif inst == AUIPC    : s.cs @= concat(  y,  imm_u,  br_x,  alu_add,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   y, am_pc, bm_imm,   n,    n,  n )
  //   elif inst == FENCEI   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   n, am_x,  bm_x,     n,    n,  n ) # essentially no-op
  //   # mem
  //   elif inst == LB       : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_b,   se, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == LH       : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_h,   se, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == LBU      : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_b,   ze, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == LHU      : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_h,   ze, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == LW       : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_w,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SB       : s.cs @= concat(  y,  imm_s,  br_x,  alu_x,     md_x,     mem_st,   mlen_b,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SH       : s.cs @= concat(  y,  imm_s,  br_x,  alu_x,     md_x,     mem_st,   mlen_h,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == SW       : s.cs @= concat(  y,  imm_s,  br_x,  alu_x,     md_x,     mem_st,   mlen_w,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == FENCE    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_f,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   n, am_x,  bm_x,     n,    n,  n )
  //   # branch
  //   elif inst == BEQ      : s.cs @= concat(  y,  imm_b,  br_eq, alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == BNE      : s.cs @= concat(  y,  imm_b,  br_ne, alu_lt,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == BLT      : s.cs @= concat(  y,  imm_b,  br_lt, alu_lt,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == BGE      : s.cs @= concat(  y,  imm_b,  br_ge, alu_lt,    md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == BLTU     : s.cs @= concat(  y,  imm_b,  br_lu, alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == BGEU     : s.cs @= concat(  y,  imm_b,  br_gu, alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_rf,    n,    n,  n )
  //   # jump
  //   elif inst == JAL      : s.cs @= concat(  y,  imm_j,  jal,   alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   y, am_x,  bm_x,     n,    n,  n )
  //   elif inst == JALR     : s.cs @= concat(  y,  imm_i,  jalr,  alu_adz,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )
  // 
  //   #                                      inst    imm   br       alu       mdu         mem       mem    mem    csr  fpu    rs1  rs2  rd   op1    op2    frs1 frs2 frd
  //   #                                       val    type  type    type      type        type       len    ext   type  type    en   en  en   sel    sel
  // 
  //   # *** RV32/64M ***
  //   elif inst == MUL      : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_mul,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == MULH     : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_mh,    mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == MULHSU   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_mhsu,  mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == MULHU    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_mhu,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == DIV      : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_div,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == DIVU     : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_divu,  mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == REM      : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_rem,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   elif inst == REMU     : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_remu,  mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )
  //   # *** RV32/64A ***
  //   elif inst == AMOADD   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_add,  mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOAND   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_and,  mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOMAX   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_max,  mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOMAXU  : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_maxu, mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOMIN   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_min,  mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOMINU  : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_minu, mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOOR    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_or,   mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOSWAP  : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_swp,  mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   elif inst == AMOXOR   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_xor,  mlen_w,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_imm,   n,    n,  n )
  //   # *** RV32/64F ***
  //   elif inst == FLW      : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_w,   xe, csr_x,   fp_x,  y,   n,   y, am_rf, bm_imm,   n,    n,  y )
  //   elif inst == FSW      : s.cs @= concat(  y,  imm_s,  br_x,  alu_x,     md_x,     mem_st,   mlen_w,   xe, csr_x,   fp_x,  y,   y,   n, am_rf, bm_imm,   n,    y,  n )
  //   elif inst == FMVXW    : s.cs @= concat(  y,  imm_x,  br_x,  alu_cp0,   md_x,     mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   n,   y, am_rf, bm_rf,    y,    n,  n ) # mv fp  -> int
  //   elif inst == FMVWX    : s.cs @= concat(  y,  imm_x,  br_x,  alu_cp0,   md_x,     mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   n,   y, am_rf, bm_rf,    n,    n,  y ) # mv int -> fp
  //   elif inst == FADDS    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_add,  y,   y,   y, am_rf, bm_rf,    y,    y,  y )
  //   elif inst == FSUBS    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_sub,  y,   y,   y, am_rf, bm_rf,    y,    y,  y )
  //   elif inst == FMULS    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_mul,  y,   y,   y, am_rf, bm_rf,    y,    y,  y )
  //   elif inst == FDIVS    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_div,  y,   y,   y, am_rf, bm_rf,    y,    y,  y )
  //   elif inst == FMINS    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_min,  y,   y,   y, am_rf, bm_rf,    y,    y,  y )
  //   elif inst == FMAXS    : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_max,  y,   y,   y, am_rf, bm_rf,    y,    y,  y )
  //   elif inst == FEQS     : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_ceq,  y,   y,   y, am_rf, bm_rf,    y,    y,  n )
  //   elif inst == FLTS     : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_clt,  y,   y,   y, am_rf, bm_rf,    y,    y,  n )
  //   elif inst == FLES     : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_cle,  y,   y,   y, am_rf, bm_rf,    y,    y,  n )
  //   elif inst == FCVTWS   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_f2i,  y,   n,   y, am_rf, bm_rf,    y,    n,  n ) # cvt fp -> int
  //   elif inst == FCVTSW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x, fp_i2f,  y,   n,   y, am_rf, bm_rf,    n,    n,  y ) # cvt int -> fp
  // 
  //   elif xlen == 64:
  //     #                                    inst    imm   br       alu       mdu         mem       mem    mem    csr  fpu    rs1  rs2  rd   op1    op2    frs1 frs2 frd
  //     #                                     val    type  type    type      type        type       len    ext   type  type    en   en  en   sel    sel
  // 
  //     # *** RV64I ***
  //     if   inst == LWU    : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_w,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )  # same as LW
  //     elif inst == LD     : s.cs @= concat(  y,  imm_i,  br_x,  alu_x,     md_x,     mem_ld,   mlen_w,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )  # same as LW
  //     elif inst == SD     : s.cs @= concat(  y,  imm_s,  br_x,  alu_x,     md_x,     mem_st,   mlen_wzx, xe, csr_x,  fp_x,   y,   y,   n, am_rf, bm_imm,   n,    n,  n )  # similar to SW, but zero-extending stored value
  //     elif inst == ADDIW  : s.cs @= concat(  y,  imm_i,  br_x,  alu_add,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )  # same as ADDI
  //     elif inst == SLLIW  : s.cs @= concat(  y,  imm_i,  br_x,  alu_sll,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )  # same as SLLI
  //     elif inst == SRLIW  : s.cs @= concat(  y,  imm_i,  br_x,  alu_srl,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )  # same as SRLI
  //     elif inst == SRAIW  : s.cs @= concat(  y,  imm_i,  br_x,  alu_sra,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   n,   y, am_rf, bm_imm,   n,    n,  n )  # same as SRAI
  //     elif inst == ADDW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_add,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as ADD
  //     elif inst == SUBW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_sub,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as SUB
  //     elif inst == SLLW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_sll,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as SLL
  //     elif inst == SRLW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_srl,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as SRL
  //     elif inst == SRAW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_sra,   md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as SRA
  // 
  //     # *** RV64M ***
  //     elif inst == MULW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_mul,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as MUL
  //     elif inst == DIVW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_div,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as DIV
  //     elif inst == DIVUW  : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_divu,  mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as DIVU
  //     elif inst == REMW   : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_rem,   mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as REM
  //     elif inst == REMUW  : s.cs @= concat(  y,  imm_x,  br_x,  alu_x,     md_remu,  mem_x,    mlen_x,   xe, csr_x,   fp_x,  y,   y,   y, am_rf, bm_rf,    n,    n,  n )  # same as REMU
  // 
  //     # *** INVALID RV64 ***
  //     else                : s.cs @= concat(  n,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   n, am_x,  bm_x,     n,    n,  n )
  // 
  //   # *** INVALID RV32 ***
  //   else                  : s.cs @= concat(  n,  imm_x,  br_x,  alu_x,     md_x,     mem_x,    mlen_x,   xe, csr_x,  fp_x,   n,   n,   n, am_x,  bm_x,     n,    n,  n )
  // 
  //   # rs1, rs2, rd
  //   s.rs1 @= 0
  //   s.rs2 @= 0
  //   s.rd  @= 0
  // 
  //   if  s.out.rs1_en:
  //     if s.out.fp_rs1:
  //       s.rs1 @= zext( s.in_[ RS1 ], areg_idx_nbits ) + ARegIdx( 32 )
  //     else:
  //       s.rs1 @= zext( s.in_[ RS1 ], areg_idx_nbits )
  // 
  //   if  s.out.rs2_en:
  //     if s.out.fp_rs2:
  //       s.rs2 @= zext( s.in_[ RS2 ], areg_idx_nbits ) + ARegIdx( 32 )
  //     else:
  //       s.rs2 @= zext( s.in_[ RS2 ], areg_idx_nbits )
  // 
  //   if  s.out.rd_en:
  //     if s.out.fp_rd:
  //       s.rd @= zext( s.in_[ RD0 ], areg_idx_nbits ) + ARegIdx( 32 )
  //     else:
  //       s.rd @= zext( s.in_[ RD0 ], areg_idx_nbits )
  // 
  //   # CSR
  //   s.csr @= 0
  // 
  //   if  s.out.csr_type != csr_x:
  //     s.csr @= s.in_[ CSRNUM ]
  // 
  //   # fence
  //   s.fls @= 0
  //   s.inv @= 0
  // 
  //   if inst == FENCE:
  //     # Flush if PRED = XXRW, SUC = XXXW
  //     if  ( ( s.in_[ PRED ] & 0b0011 ) == 0b0011 ) & \
  //         ( ( s.in_[ SUCC ] & 0b0001 ) == 0b0001 ):
  //       s.fls @= 1
  // 
  //     # Invalidate if PRED = XXRX, SUC = XXRW
  //     if  ( ( s.in_[ PRED ] & 0b0010 ) == 0b0010 ) & \
  //         ( ( s.in_[ SUCC ] & 0b0011 ) == 0b0011 ):
  //       s.inv @= 1
  // 
  //     # if neither fls nor inv is set, set both
  //     if  ~s.fls | ~s.inv:
  //       s.inv @= 1
  //       s.fls @= 1
  
  always_comb begin : up_outputs
    __tmpvar__up_outputs_inst = inst_type;
    if ( __tmpvar__up_outputs_inst == 8'( __const__NOP ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ), 1'( __const__am_x ), 2'( __const__bm_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__CSRR ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_cp1 ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_rd ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_x ), 2'( __const__bm_csr ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__CSRW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_cp0 ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_wr ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__ADD ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_add ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SUB ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_sub ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SLL ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_sll ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SLT ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_lt ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SLTU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_ltu ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__XOR ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_xor ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SRL ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_srl ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SRA ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_sra ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__OR ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_or ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AND ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_and ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__ADDI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_add ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SLTI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_lt ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SLTIU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_ltu ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__XORI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_xor ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__ORI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_or ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__ANDI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_and ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SLLI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_sll ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SRLI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_srl ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SRAI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_sra ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__LUI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_u ), 4'( __const__br_x ), 4'( __const__alu_cp1 ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_x ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AUIPC ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_u ), 4'( __const__br_x ), 4'( __const__alu_add ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_pc ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FENCEI ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ), 1'( __const__am_x ), 2'( __const__bm_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__LB ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_b ), 1'( __const__se ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__LH ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_h ), 1'( __const__se ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__LBU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_b ), 1'( __const__ze ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__LHU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_h ), 1'( __const__ze ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__LW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SB ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_s ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_st ), 2'( __const__mlen_b ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SH ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_s ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_st ), 2'( __const__mlen_h ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__SW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_s ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_st ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FENCE ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_f ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ), 1'( __const__am_x ), 2'( __const__bm_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__BEQ ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_b ), 4'( __const__br_eq ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__BNE ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_b ), 4'( __const__br_ne ), 4'( __const__alu_lt ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__BLT ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_b ), 4'( __const__br_lt ), 4'( __const__alu_lt ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__BGE ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_b ), 4'( __const__br_ge ), 4'( __const__alu_lt ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__BLTU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_b ), 4'( __const__br_lu ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__BGEU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_b ), 4'( __const__br_gu ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__JAL ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_j ), 4'( __const__jal ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_x ), 2'( __const__bm_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__JALR ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__jalr ), 4'( __const__alu_adz ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__MUL ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_mul ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__MULH ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_mh ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__MULHSU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_mhsu ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__MULHU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_mhu ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__DIV ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_div ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__DIVU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_divu ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__REM ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_rem ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__REMU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_remu ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOADD ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_add ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOAND ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_and ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOMAX ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_max ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOMAXU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_maxu ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOMIN ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_min ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOMINU ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_minu ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOOR ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_or ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOSWAP ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_swp ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__AMOXOR ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_xor ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FLW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FSW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_s ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_st ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__y ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FMVXW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_cp0 ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FMVWX ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_cp0 ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FADDS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_add ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FSUBS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_sub ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FMULS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_mul ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FDIVS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_div ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FMINS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_min ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FMAXS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_max ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FEQS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_ceq ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FLTS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_clt ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FLES ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_cle ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FCVTWS ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_f2i ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__y ), 1'( __const__n ), 1'( __const__n ) };
    end
    else if ( __tmpvar__up_outputs_inst == 8'( __const__FCVTSW ) ) begin
      cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_i2f ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__y ) };
    end
    else if ( 7'( __const__xlen_at_up_outputs ) == 7'd64 ) begin
      if ( __tmpvar__up_outputs_inst == 8'( __const__LWU ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__LD ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_ld ), 2'( __const__mlen_w ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SD ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_s ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_st ), 2'( __const__mlen_wzx ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__n ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__ADDIW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_add ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SLLIW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_sll ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SRLIW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_srl ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SRAIW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_i ), 4'( __const__br_x ), 4'( __const__alu_sra ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__n ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_imm ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__ADDW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_add ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SUBW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_sub ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SLLW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_sll ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SRLW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_srl ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__SRAW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_sra ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__MULW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_mul ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__DIVW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_div ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__DIVUW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_divu ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__REMW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_rem ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else if ( __tmpvar__up_outputs_inst == 8'( __const__REMUW ) ) begin
        cs = { 1'( __const__y ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_remu ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__y ), 1'( __const__y ), 1'( __const__y ), 1'( __const__am_rf ), 2'( __const__bm_rf ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
      end
      else
        cs = { 1'( __const__n ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ), 1'( __const__am_x ), 2'( __const__bm_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    end
    else
      cs = { 1'( __const__n ), 3'( __const__imm_x ), 4'( __const__br_x ), 4'( __const__alu_x ), 4'( __const__md_x ), 4'( __const__mem_x ), 2'( __const__mlen_x ), 1'( __const__xe ), 2'( __const__csr_x ), 4'( __const__fp_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ), 1'( __const__am_x ), 2'( __const__bm_x ), 1'( __const__n ), 1'( __const__n ), 1'( __const__n ) };
    rs1 = 6'd0;
    rs2 = 6'd0;
    rd = 6'd0;
    if ( out.rs1_en ) begin
      if ( out.fp_rs1 ) begin
        rs1 = { { 1 { 1'b0 } }, in_[5'd19:5'd15] } + 6'd32;
      end
      else
        rs1 = { { 1 { 1'b0 } }, in_[5'd19:5'd15] };
    end
    if ( out.rs2_en ) begin
      if ( out.fp_rs2 ) begin
        rs2 = { { 1 { 1'b0 } }, in_[5'd24:5'd20] } + 6'd32;
      end
      else
        rs2 = { { 1 { 1'b0 } }, in_[5'd24:5'd20] };
    end
    if ( out.rd_en ) begin
      if ( out.fp_rd ) begin
        rd = { { 1 { 1'b0 } }, in_[5'd11:5'd7] } + 6'd32;
      end
      else
        rd = { { 1 { 1'b0 } }, in_[5'd11:5'd7] };
    end
    csr = 12'd0;
    if ( out.csr_type != 2'( __const__csr_x ) ) begin
      csr = in_[5'd31:5'd20];
    end
    fls = 1'd0;
    inv = 1'd0;
    if ( __tmpvar__up_outputs_inst == 8'( __const__FENCE ) ) begin
      if ( ( ( in_[5'd27:5'd24] & 4'd3 ) == 4'd3 ) & ( ( in_[5'd23:5'd20] & 4'd1 ) == 4'd1 ) ) begin
        fls = 1'd1;
      end
      if ( ( ( in_[5'd27:5'd24] & 4'd2 ) == 4'd2 ) & ( ( in_[5'd23:5'd20] & 4'd3 ) == 4'd3 ) ) begin
        inv = 1'd1;
      end
      if ( ( ~fls ) | ( ~inv ) ) begin
        inv = 1'd1;
        fls = 1'd1;
      end
    end
  end

  assign out.fp_rd = cs[0:0];
  assign out.fp_rs2 = cs[1:1];
  assign out.fp_rs1 = cs[2:2];
  assign out.op2_sel = cs[4:3];
  assign out.op1_sel = cs[5:5];
  assign out.rd_en = cs[6:6];
  assign out.rs2_en = cs[7:7];
  assign out.rs1_en = cs[8:8];
  assign out.fpu_type = cs[12:9];
  assign out.csr_type = cs[14:13];
  assign out.mem_ext = cs[15:15];
  assign out.mem_len = cs[17:16];
  assign out.mem_type = cs[21:18];
  assign out.mdu_type = cs[25:22];
  assign out.alu_type = cs[29:26];
  assign out.br_type = cs[33:30];
  assign out.imm_type = cs[36:34];
  assign out.inst_val = cs[37:37];

endmodule


// PyMTL Component ImmGenRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/MiscRTL.py

module ImmGenRTL_noparam
(
  input  logic [0:0] clk ,
  output logic [31:0] imm ,
  input  logic [2:0] imm_type ,
  input  logic [31:0] inst ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__imm_i  = 3'd0;
  localparam logic [2:0] __const__imm_b  = 3'd2;
  localparam logic [2:0] __const__imm_s  = 3'd1;
  localparam logic [2:0] __const__imm_u  = 3'd3;
  localparam logic [2:0] __const__imm_j  = 3'd4;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/MiscRTL.py:31
  // @update
  // def up_immgen():
  //   s.imm @= 0
  // 
  //   # Always sext!
  //   if   s.imm_type == imm_i: # I-type
  //     s.imm @= concat( sext( s.inst[ I_IMM ], 32 ) )
  // 
  //   elif s.imm_type == imm_b: # B-type
  //     s.imm @= concat( sext( s.inst[ B_IMM3 ], 20 ),
  //                      s.inst[ B_IMM2 ],
  //                      s.inst[ B_IMM1 ],
  //                      s.inst[ B_IMM0 ],
  //                      b1( 0 ) )
  // 
  //   elif s.imm_type == imm_s: # S-type
  //     s.imm @= concat( sext( s.inst[ S_IMM1 ], 27 ), s.inst[ S_IMM0 ] )
  // 
  //   elif s.imm_type == imm_u: # U-type
  //     s.imm @= concat( s.inst[ U_IMM ], b12( 0 ) )
  // 
  //   elif s.imm_type == imm_j: # J-type
  //     s.imm @= concat( sext( s.inst[ J_IMM3 ], 12 ),
  //                      s.inst[ J_IMM2 ],
  //                      s.inst[ J_IMM1 ],
  //                      s.inst[ J_IMM0 ],
  //                      b1( 0 ) )
  
  always_comb begin : up_immgen
    imm = 32'd0;
    if ( imm_type == 3'( __const__imm_i ) ) begin
      imm = { { { 20 { inst[5'd31] } }, inst[5'd31:5'd20] } };
    end
    else if ( imm_type == 3'( __const__imm_b ) ) begin
      imm = { { { 19 { inst[5'd31:5'd31] } }, inst[5'd31:5'd31] }, inst[5'd7:5'd7], inst[5'd30:5'd25], inst[5'd11:5'd8], 1'd0 };
    end
    else if ( imm_type == 3'( __const__imm_s ) ) begin
      imm = { { { 20 { inst[5'd31] } }, inst[5'd31:5'd25] }, inst[5'd11:5'd7] };
    end
    else if ( imm_type == 3'( __const__imm_u ) ) begin
      imm = { inst[5'd31:5'd12], 12'd0 };
    end
    else if ( imm_type == 3'( __const__imm_j ) ) begin
      imm = { { { 11 { inst[5'd31:5'd31] } }, inst[5'd31:5'd31] }, inst[5'd19:5'd12], inst[5'd20:5'd20], inst[5'd30:5'd21], 1'd0 };
    end
  end

endmodule


// PyMTL Component Adder Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Adder__Type_Bits32
(
  input  logic [0:0] clk ,
  input  logic [31:0] in0 ,
  input  logic [31:0] in1 ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:84
  // @update
  // def up_adder():
  //   s.out @= s.in0 + s.in1
  
  always_comb begin : up_adder
    out = in0 + in1;
  end

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__EntryType_F_InstStruct__pc_32__inst_32
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output F_InstStruct__pc_32__inst_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input F_InstStruct__pc_32__inst_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  F_InstStruct__pc_32__inst_32 entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_procs_0__decode_recv_q_q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_procs_0__decode_recv_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// Full name: PipeQueueRTL__EntryType_F_InstStruct__pc_32__inst_32__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__2f87cea22eb5431d
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output F_InstStruct__pc_32__inst_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input F_InstStruct__pc_32__inst_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  F_InstStruct__pc_32__inst_32 q__deq__ret;
  logic [0:0] q__enq__en;
  F_InstStruct__pc_32__inst_32 q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__EntryType_F_InstStruct__pc_32__inst_32 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component DecodeUnitRTL Definition
// Full name: DecodeUnitRTL__isa_decoder_s.procs[0].decode.decoder
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/DecodeUnitRTL.py

module DecodeUnitRTL__bee45fa5195f09f5
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  output logic [0:0] lookup_rd__en  ,
  output logic [5:0] lookup_rd__msg  ,
  input logic [6:0] lookup_rd__ret  ,
  output logic [0:0] lookup_rs1__en  ,
  output logic [5:0] lookup_rs1__msg  ,
  input logic [6:0] lookup_rs1__ret  ,
  output logic [0:0] lookup_rs2__en  ,
  output logic [5:0] lookup_rs2__msg  ,
  input logic [6:0] lookup_rs2__ret  ,
  input logic [0:0] recv_inst__en  ,
  input F_InstStruct__pc_32__inst_32 recv_inst__msg  ,
  output logic [0:0] recv_inst__rdy  ,
  output logic [0:0] register_inst__en  ,
  output RegInstStruct__496c286c2dc8d523 register_inst__msg  ,
  input RegInstRetStruct__rob_idx_3__br_idx_1__br_tag_2 register_inst__ret  ,
  input logic [0:0] register_inst__suc  ,
  output logic [0:0] rename_rd__en  ,
  output logic [5:0] rename_rd__msg  ,
  input logic [0:0] rename_rd__rdy  ,
  input logic [6:0] rename_rd__ret  ,
  output logic [0:0] resolve_br__en  ,
  output ResolveBranchStruct__7003e9cf5478f896 resolve_br__msg  ,
  output logic [0:0] send_inst__en  ,
  output D_InstStruct__e597a7f7aebd8fbc send_inst__msg  ,
  input logic [0:0] send_inst__rdy  
);
  localparam logic [3:0] __const__jal  = 4'd8;
  F_InstStruct__pc_32__inst_32 in_msg;
  //-------------------------------------------------------------
  // Component decoder
  //-------------------------------------------------------------

  logic [0:0] decoder__clk;
  logic [11:0] decoder__csr;
  logic [0:0] decoder__fls;
  logic [31:0] decoder__in_;
  logic [0:0] decoder__inv;
  DecoderStruct__20424510df2ec9a8 decoder__out;
  logic [5:0] decoder__rd;
  logic [0:0] decoder__reset;
  logic [5:0] decoder__rs1;
  logic [5:0] decoder__rs2;

  RiscvDecoder__xlen_64 decoder
  (
    .clk( decoder__clk ),
    .csr( decoder__csr ),
    .fls( decoder__fls ),
    .in_( decoder__in_ ),
    .inv( decoder__inv ),
    .out( decoder__out ),
    .rd( decoder__rd ),
    .reset( decoder__reset ),
    .rs1( decoder__rs1 ),
    .rs2( decoder__rs2 )
  );

  //-------------------------------------------------------------
  // End of component decoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component immgen
  //-------------------------------------------------------------

  logic [0:0] immgen__clk;
  logic [31:0] immgen__imm;
  logic [2:0] immgen__imm_type;
  logic [31:0] immgen__inst;
  logic [0:0] immgen__reset;

  ImmGenRTL_noparam immgen
  (
    .clk( immgen__clk ),
    .imm( immgen__imm ),
    .imm_type( immgen__imm_type ),
    .inst( immgen__inst ),
    .reset( immgen__reset )
  );

  //-------------------------------------------------------------
  // End of component immgen
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pc_plus_imm
  //-------------------------------------------------------------

  logic [0:0] pc_plus_imm__clk;
  logic [31:0] pc_plus_imm__in0;
  logic [31:0] pc_plus_imm__in1;
  logic [31:0] pc_plus_imm__out;
  logic [0:0] pc_plus_imm__reset;

  Adder__Type_Bits32 pc_plus_imm
  (
    .clk( pc_plus_imm__clk ),
    .in0( pc_plus_imm__in0 ),
    .in1( pc_plus_imm__in1 ),
    .out( pc_plus_imm__out ),
    .reset( pc_plus_imm__reset )
  );

  //-------------------------------------------------------------
  // End of component pc_plus_imm
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__count;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  F_InstStruct__pc_32__inst_32 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  F_InstStruct__pc_32__inst_32 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  PipeQueueRTL__2f87cea22eb5431d recv_q
  (
    .clk( recv_q__clk ),
    .count( recv_q__count ),
    .reset( recv_q__reset ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/DecodeUnitRTL.py:135
  // @update
  // def decode_comb():
  //   # default
  //   s.recv_q.deq.en     @= 0
  //   s.send_inst.en      @= 0
  //   s.lookup_rs1.en     @= 0
  //   s.lookup_rs2.en     @= 0
  //   s.lookup_rd.en      @= 0
  //   s.rename_rd.en      @= 0
  //   s.register_inst.en  @= 0
  //   s.resolve_br.en     @= 0
  // 
  //   #
  //   # being killed
  //   #
  //   if s.clear_br.en & s.clear_br.msg.kill:
  // 
  //     # simply drop the input inst if any
  //     s.recv_q.deq.en @= s.recv_q.deq.rdy
  // 
  //   #
  //   # no kill
  //   #
  //   elif s.recv_q.deq.rdy & s.send_inst.rdy:
  // 
  //     # proceed only if rd (if enabled) can be renamed
  //     if  ~s.decoder.out.rd_en | s.rename_rd.rdy:
  // 
  //       # proceed only if inst can be registered
  //       s.register_inst.en @= 1
  // 
  //       if s.register_inst.suc:
  //         # rename rd
  //         s.rename_rd.en  @= s.decoder.out.rd_en
  //         # dequeue inst
  //         s.recv_q.deq.en @= 1
  //         # lookup pregs for rs1, rs2 and rd
  //         s.lookup_rs1.en @= s.decoder.out.rs1_en
  //         s.lookup_rs2.en @= s.decoder.out.rs2_en
  //         s.lookup_rd.en  @= s.decoder.out.rd_en
  //         # send inst to I
  //         s.send_inst.en  @= 1
  //         # resolve JAL
  //         s.resolve_br.en @= ( s.decoder.out.br_type == jal )
  
  always_comb begin : decode_comb
    recv_q__deq__en = 1'd0;
    send_inst__en = 1'd0;
    lookup_rs1__en = 1'd0;
    lookup_rs2__en = 1'd0;
    lookup_rd__en = 1'd0;
    rename_rd__en = 1'd0;
    register_inst__en = 1'd0;
    resolve_br__en = 1'd0;
    if ( clear_br__en & clear_br__msg.kill ) begin
      recv_q__deq__en = recv_q__deq__rdy;
    end
    else if ( recv_q__deq__rdy & send_inst__rdy ) begin
      if ( ( ~decoder__out.rd_en ) | rename_rd__rdy ) begin
        register_inst__en = 1'd1;
        if ( register_inst__suc ) begin
          rename_rd__en = decoder__out.rd_en;
          recv_q__deq__en = 1'd1;
          lookup_rs1__en = decoder__out.rs1_en;
          lookup_rs2__en = decoder__out.rs2_en;
          lookup_rd__en = decoder__out.rd_en;
          send_inst__en = 1'd1;
          resolve_br__en = decoder__out.br_type == 4'( __const__jal );
        end
      end
    end
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = recv_inst__en;
  assign recv_q__enq__msg = recv_inst__msg;
  assign recv_inst__rdy = recv_q__enq__rdy;
  assign in_msg = recv_q__deq__ret;
  assign decoder__clk = clk;
  assign decoder__reset = reset;
  assign decoder__in_ = in_msg.inst;
  assign immgen__clk = clk;
  assign immgen__reset = reset;
  assign immgen__imm_type = decoder__out.imm_type;
  assign immgen__inst = in_msg.inst;
  assign pc_plus_imm__clk = clk;
  assign pc_plus_imm__reset = reset;
  assign pc_plus_imm__in0 = in_msg.pc;
  assign pc_plus_imm__in1 = immgen__imm;
  assign lookup_rs1__msg = decoder__rs1;
  assign lookup_rs2__msg = decoder__rs2;
  assign lookup_rd__msg = decoder__rd;
  assign rename_rd__msg = decoder__rd;
  assign resolve_br__msg.mispredicted = 1'd1;
  assign resolve_br__msg.br_idx = 1'd0;
  assign resolve_br__msg.br_tag = 2'd0;
  assign resolve_br__msg.br_target = pc_plus_imm__out;
  assign resolve_br__msg.rob_idx = 3'd0;
  assign register_inst__msg.inst_val = decoder__out.inst_val;
  assign register_inst__msg.pc = in_msg.pc;
  assign register_inst__msg.br_type = decoder__out.br_type;
  assign register_inst__msg.csr_type = decoder__out.csr_type;
  assign register_inst__msg.mem_type = decoder__out.mem_type;
  assign register_inst__msg.rd_en = decoder__out.rd_en;
  assign register_inst__msg.rd_ppreg = lookup_rd__ret;
  assign register_inst__msg.csr_num = in_msg.inst[31:20];
  assign send_inst__msg.pc = in_msg.pc;
  assign send_inst__msg.inst_val = decoder__out.inst_val;
  assign send_inst__msg.br_type = decoder__out.br_type;
  assign send_inst__msg.alu_type = decoder__out.alu_type;
  assign send_inst__msg.mdu_type = decoder__out.mdu_type;
  assign send_inst__msg.mem_type = decoder__out.mem_type;
  assign send_inst__msg.mem_len = decoder__out.mem_len;
  assign send_inst__msg.mem_ext = decoder__out.mem_ext;
  assign send_inst__msg.csr_type = decoder__out.csr_type;
  assign send_inst__msg.fpu_type = decoder__out.fpu_type;
  assign send_inst__msg.br_tag = register_inst__ret.br_tag;
  assign send_inst__msg.br_idx = register_inst__ret.br_idx;
  assign send_inst__msg.br_target = pc_plus_imm__out;
  assign send_inst__msg.rob_idx = register_inst__ret.rob_idx;
  assign send_inst__msg.rs1_en = decoder__out.rs1_en;
  assign send_inst__msg.rs2_en = decoder__out.rs2_en;
  assign send_inst__msg.rd_en = decoder__out.rd_en;
  assign send_inst__msg.rs1_preg = lookup_rs1__ret;
  assign send_inst__msg.rs2_preg = lookup_rs2__ret;
  assign send_inst__msg.rd_preg = rename_rd__ret;
  assign send_inst__msg.csr_num = decoder__csr;
  assign send_inst__msg.imm_val = immgen__imm;
  assign send_inst__msg.op1_sel = decoder__out.op1_sel;
  assign send_inst__msg.op2_sel = decoder__out.op2_sel;
  assign send_inst__msg.fls = decoder__fls;
  assign send_inst__msg.inv = decoder__inv;
  assign send_inst__msg.killed = 1'd0;

endmodule


// PyMTL Component PipeQueue1EntryRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueue1EntryRTL__EntryType_Bits32
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output logic [31:0] deq__ret  ,
  input logic [0:0] enq__en  ,
  input logic [31:0] enq__msg  ,
  output logic [0:0] enq__rdy  
);
  logic [31:0] entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:490
  // s.deq.rdy //= lambda: s.full & ~s.reset
  
  always_comb begin : _lambda__s_procs_0__fetch_pc_redirect_q_q_deq_rdy
    deq__rdy = full & ( ~reset );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:489
  // s.enq.rdy //= lambda: ~s.reset & ( ~s.full | s.deq.en )
  
  always_comb begin : _lambda__s_procs_0__fetch_pc_redirect_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ( ~full ) | deq__en );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:492
  // @update_ff
  // def ff_pipe1():
  //   s.full <<= ~s.reset & ( s.enq.en | s.full & ~s.deq.en )
  // 
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_pipe1
    full <= ( ~reset ) & ( enq__en | ( full & ( ~deq__en ) ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component PipeQueueRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module PipeQueueRTL__EntryType_Bits32__num_entries_1
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output logic [31:0] deq__ret  ,
  input logic [0:0] enq__en  ,
  input logic [31:0] enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  logic [31:0] q__deq__ret;
  logic [0:0] q__enq__en;
  logic [31:0] q__enq__msg;
  logic [0:0] q__enq__rdy;

  PipeQueue1EntryRTL__EntryType_Bits32 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component IFetchQueueRTL Definition
// Full name: IFetchQueueRTL__num_entries_2__EntryType_IFetchReq__val_1__pc_32__EntryIdx_Bits1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/IFetchQueueRTL.py

module IFetchQueueRTL__21b809c101ecf043
(
  input  logic [0:0] clk ,
  input  logic [0:0] kill_all ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate__en  ,
  input IFetchReq__val_1__pc_32 allocate__msg  ,
  output logic [0:0] allocate__rdy  ,
  output logic [0:0] allocate__ret  ,
  input logic [0:0] complete__en  ,
  input logic [0:0] complete__msg  ,
  output logic [0:0] complete__rdy  ,
  output IFetchReq__val_1__pc_32 complete__ret  
);
  localparam logic [1:0] __const__num_entries_at_up_ff  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_comb  = 2'd2;
  IFetchReq__val_1__pc_32 entry [0:1];
  IFetchReq__val_1__pc_32 next_entry [0:1];
  //-------------------------------------------------------------
  // Component entry_alloc
  //-------------------------------------------------------------

  logic [0:0] entry_alloc__clk;
  logic [0:0] entry_alloc__empty;
  logic [0:0] entry_alloc__free [0:1];
  logic [0:0] entry_alloc__reset;
  logic [0:0] entry_alloc__allocate__en;
  logic [0:0] entry_alloc__allocate__rdy;
  logic [0:0] entry_alloc__allocate__ret;

  EntryAllocatorRTL__num_entries_2__EntryIdx_Bits1 entry_alloc
  (
    .clk( entry_alloc__clk ),
    .empty( entry_alloc__empty ),
    .free( entry_alloc__free ),
    .reset( entry_alloc__reset ),
    .allocate__en( entry_alloc__allocate__en ),
    .allocate__rdy( entry_alloc__allocate__rdy ),
    .allocate__ret( entry_alloc__allocate__ret )
  );

  //-------------------------------------------------------------
  // End of component entry_alloc
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__up_comb_idx;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/IFetchQueueRTL.py:57
  // s.complete.rdy //= lambda: ~s.kill_all & ~s.entry_alloc.empty
  
  always_comb begin : _lambda__s_procs_0__fetch_req_q_complete_rdy
    complete__rdy = ( ~kill_all ) & ( ~entry_alloc__empty );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/IFetchQueueRTL.py:69
  // @update
  // def up_comb():
  // 
  //   # default
  //   s.complete.ret @= s.entry[ 0 ]
  // 
  //   for i in range( num_entries ):
  //     s.next_entry[ i ]       @= s.entry[ i ]
  //     s.entry_alloc.free[ i ] @= 0
  // 
  //   # kill_all
  //   if    s.kill_all:
  //     for i in range( num_entries ):
  //       s.next_entry[ i ].val @= 0
  // 
  //   # complete
  //   elif  s.complete.en:
  //     idx = s.complete.msg
  //     s.complete.ret            @= s.entry[ idx ]
  //     s.entry_alloc.free[ idx ] @= 1
  //     s.next_entry[ idx ].val   @= 0
  // 
  //   # allocate
  //   if s.allocate.en:
  //     s.next_entry[ s.entry_alloc.allocate.ret ] @= s.allocate.msg
  
  always_comb begin : up_comb
    complete__ret = entry[1'd0];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 ) begin
      next_entry[1'(i)] = entry[1'(i)];
      entry_alloc__free[1'(i)] = 1'd0;
    end
    if ( kill_all ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
        next_entry[1'(i)].val = 1'd0;
    end
    else if ( complete__en ) begin
      __tmpvar__up_comb_idx = complete__msg;
      complete__ret = entry[__tmpvar__up_comb_idx];
      entry_alloc__free[__tmpvar__up_comb_idx] = 1'd1;
      next_entry[__tmpvar__up_comb_idx].val = 1'd0;
    end
    if ( allocate__en ) begin
      next_entry[entry_alloc__allocate__ret] = allocate__msg;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/IFetchQueueRTL.py:59
  // @update_ff
  // def up_ff():
  // 
  //   if s.reset:
  //     for i in range( num_entries ):
  //       s.entry[ i ] <<= EntryType()
  //   else:
  //     for i in range( num_entries ):
  //       s.entry[ i ] <<= s.next_entry[ i ]
  
  always_ff @(posedge clk) begin : up_ff
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 )
        entry[1'(i)] <= { 1'd0, 32'd0 };
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 )
        entry[1'(i)] <= next_entry[1'(i)];
  end

  assign entry_alloc__clk = clk;
  assign entry_alloc__reset = reset;
  assign entry_alloc__allocate__en = allocate__en;
  assign allocate__rdy = entry_alloc__allocate__rdy;
  assign allocate__ret = entry_alloc__allocate__ret;

endmodule


// PyMTL Component BypassQueueCtrlRTL Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module BypassQueueCtrlRTL__num_entries_2
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] deq_en ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] enq_en ,
  output logic [0:0] enq_rdy ,
  output logic [0:0] mux_sel ,
  output logic [0:0] raddr ,
  input  logic [0:0] reset ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  logic [0:0] deq_xfer;
  logic [0:0] enq_xfer;
  logic [0:0] head;
  logic [0:0] tail;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:351
  // s.deq_rdy //= lambda: ~s.reset & ( (s.count > CountType(0) ) | s.enq_en )
  
  always_comb begin : _lambda__s_procs_0__fetch_resp_q_ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( ( count > 2'd0 ) | enq_en );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:356
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_procs_0__fetch_resp_q_ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:350
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_procs_0__fetch_resp_q_ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < 2'd2 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:355
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_procs_0__fetch_resp_q_ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:353
  // s.mux_sel //= lambda: s.count == CountType(0)
  
  always_comb begin : _lambda__s_procs_0__fetch_resp_q_ctrl_mux_sel
    mux_sel = count == 2'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:358
  // @update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < 1'd1 ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < 1'd1 ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component Mux Definition
// Full name: Mux__Type_MemRespMsg__type__4__opaque_8__test_2__len_2__data_32__ninputs_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__e8e959655ba0e64d
(
  input  logic [0:0] clk ,
  input  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 in_ [0:1],
  output MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 out ,
  input  logic [0:0] reset ,
  input  logic [0:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_MemRespMsg__type__4__opaque_8__test_2__len_2__data_32__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__94567e9de21bf649
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component BypassQueueDpathRTL Definition
// Full name: BypassQueueDpathRTL__EntryType_MemRespMsg__type__4__opaque_8__test_2__len_2__data_32__num_entries_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module BypassQueueDpathRTL__54f525100615e9d4
(
  input  logic [0:0] clk ,
  output MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 deq_ret ,
  input  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 enq_msg ,
  input  logic [0:0] mux_sel ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component mux
  //-------------------------------------------------------------

  logic [0:0] mux__clk;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 mux__in_ [0:1];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 mux__out;
  logic [0:0] mux__reset;
  logic [0:0] mux__sel;

  Mux__e8e959655ba0e64d mux
  (
    .clk( mux__clk ),
    .in_( mux__in_ ),
    .out( mux__out ),
    .reset( mux__reset ),
    .sel( mux__sel )
  );

  //-------------------------------------------------------------
  // End of component mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__94567e9de21bf649 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;
  assign mux__clk = clk;
  assign mux__reset = reset;
  assign mux__sel = mux_sel;
  assign mux__in_[0] = queue__rdata[0];
  assign mux__in_[1] = enq_msg;
  assign deq_ret = mux__out;

endmodule


// PyMTL Component BypassQueueRTL Definition
// Full name: BypassQueueRTL__EntryType_MemRespMsg__type__4__opaque_8__test_2__len_2__data_32__num_entries_2
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module BypassQueueRTL__54f525100615e9d4
(
  input  logic [0:0] clk ,
  output logic [1:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [1:0] ctrl__count;
  logic [0:0] ctrl__deq_en;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__mux_sel;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  BypassQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .mux_sel( ctrl__mux_sel ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 dpath__deq_ret;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 dpath__enq_msg;
  logic [0:0] dpath__mux_sel;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  BypassQueueDpathRTL__54f525100615e9d4 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .mux_sel( dpath__mux_sel ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign dpath__mux_sel = ctrl__mux_sel;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component FetchUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FetchUnitRTL.py

module FetchUnitRTL__max_pending_reqs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] go_bit ,
  input  logic [0:0] reset ,
  input  logic [31:0] reset_pc ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  output logic [0:0] imem__req__en ,
  output MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 imem__req__msg ,
  input logic [0:0] imem__req__rdy ,
  input logic [0:0] imem__resp__en ,
  input MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 imem__resp__msg ,
  output logic [0:0] imem__resp__rdy ,
  output logic [0:0] send_inst__en  ,
  output F_InstStruct__pc_32__inst_32 send_inst__msg  ,
  input logic [0:0] send_inst__rdy  
);
  localparam logic [0:0] __const__req_q_idx_nbits_at_up_resp_path  = 1'd1;
  logic [31:0] next_pc;
  logic [31:0] pc_reg;
  logic [0:0] pc_reg_en;
  //-------------------------------------------------------------
  // Component pc_incr
  //-------------------------------------------------------------

  logic [0:0] pc_incr__clk;
  logic [31:0] pc_incr__in_;
  logic [31:0] pc_incr__out;
  logic [0:0] pc_incr__reset;

  Incrementer__Type_Bits32__amount_4 pc_incr
  (
    .clk( pc_incr__clk ),
    .in_( pc_incr__in_ ),
    .out( pc_incr__out ),
    .reset( pc_incr__reset )
  );

  //-------------------------------------------------------------
  // End of component pc_incr
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component pc_redirect_q
  //-------------------------------------------------------------

  logic [0:0] pc_redirect_q__clk;
  logic [0:0] pc_redirect_q__count;
  logic [0:0] pc_redirect_q__reset;
  logic [0:0] pc_redirect_q__deq__en;
  logic [0:0] pc_redirect_q__deq__rdy;
  logic [31:0] pc_redirect_q__deq__ret;
  logic [0:0] pc_redirect_q__enq__en;
  logic [31:0] pc_redirect_q__enq__msg;
  logic [0:0] pc_redirect_q__enq__rdy;

  PipeQueueRTL__EntryType_Bits32__num_entries_1 pc_redirect_q
  (
    .clk( pc_redirect_q__clk ),
    .count( pc_redirect_q__count ),
    .reset( pc_redirect_q__reset ),
    .deq__en( pc_redirect_q__deq__en ),
    .deq__rdy( pc_redirect_q__deq__rdy ),
    .deq__ret( pc_redirect_q__deq__ret ),
    .enq__en( pc_redirect_q__enq__en ),
    .enq__msg( pc_redirect_q__enq__msg ),
    .enq__rdy( pc_redirect_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component pc_redirect_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req_q
  //-------------------------------------------------------------

  logic [0:0] req_q__clk;
  logic [0:0] req_q__kill_all;
  logic [0:0] req_q__reset;
  logic [0:0] req_q__allocate__en;
  IFetchReq__val_1__pc_32 req_q__allocate__msg;
  logic [0:0] req_q__allocate__rdy;
  logic [0:0] req_q__allocate__ret;
  logic [0:0] req_q__complete__en;
  logic [0:0] req_q__complete__msg;
  logic [0:0] req_q__complete__rdy;
  IFetchReq__val_1__pc_32 req_q__complete__ret;

  IFetchQueueRTL__21b809c101ecf043 req_q
  (
    .clk( req_q__clk ),
    .kill_all( req_q__kill_all ),
    .reset( req_q__reset ),
    .allocate__en( req_q__allocate__en ),
    .allocate__msg( req_q__allocate__msg ),
    .allocate__rdy( req_q__allocate__rdy ),
    .allocate__ret( req_q__allocate__ret ),
    .complete__en( req_q__complete__en ),
    .complete__msg( req_q__complete__msg ),
    .complete__rdy( req_q__complete__rdy ),
    .complete__ret( req_q__complete__ret )
  );

  //-------------------------------------------------------------
  // End of component req_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component resp_q
  //-------------------------------------------------------------

  logic [0:0] resp_q__clk;
  logic [1:0] resp_q__count;
  logic [0:0] resp_q__reset;
  logic [0:0] resp_q__deq__en;
  logic [0:0] resp_q__deq__rdy;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 resp_q__deq__ret;
  logic [0:0] resp_q__enq__en;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 resp_q__enq__msg;
  logic [0:0] resp_q__enq__rdy;

  BypassQueueRTL__54f525100615e9d4 resp_q
  (
    .clk( resp_q__clk ),
    .count( resp_q__count ),
    .reset( resp_q__reset ),
    .deq__en( resp_q__deq__en ),
    .deq__rdy( resp_q__deq__rdy ),
    .deq__ret( resp_q__deq__ret ),
    .enq__en( resp_q__enq__en ),
    .enq__msg( resp_q__enq__msg ),
    .enq__rdy( resp_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component resp_q
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FetchUnitRTL.py:87
  // s.req_q.kill_all          //= lambda: s.clear_br.en & s.clear_br.msg.kill
  
  always_comb begin : _lambda__s_procs_0__fetch_req_q_kill_all
    req_q__kill_all = clear_br__en & clear_br__msg.kill;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FetchUnitRTL.py:94
  // @update
  // def up_next_pc():
  // 
  //   if    s.clear_br.en & s.clear_br.msg.kill:
  //     s.next_pc @= s.clear_br.msg.pc_redirect
  //   elif  s.pc_redirect_q.deq.rdy:
  //     s.next_pc @= s.pc_redirect_q.deq.ret
  //   else:
  //     s.next_pc @= s.pc_incr.out
  
  always_comb begin : up_next_pc
    if ( clear_br__en & clear_br__msg.kill ) begin
      next_pc = clear_br__msg.pc_redirect;
    end
    else if ( pc_redirect_q__deq__rdy ) begin
      next_pc = pc_redirect_q__deq__ret;
    end
    else
      next_pc = pc_incr__out;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FetchUnitRTL.py:104
  // @update
  // def up_req_path():
  // 
  //   # default
  //   s.pc_reg_en             @= 0
  //   s.pc_redirect_q.deq.en  @= 0
  //   s.pc_redirect_q.enq.en  @= 0
  // 
  //   s.req_q.allocate.en     @= 0
  // 
  //   s.imem.req.en           @= 0
  //   s.imem.req.msg.type_    @= 0
  //   s.imem.req.msg.opaque   @= 0
  //   s.imem.req.msg.addr     @= 0
  //   s.imem.req.msg.len      @= 0
  //   s.imem.req.msg.data     @= 0
  // 
  //   # only send fetch request if go_bit is high
  //   if s.go_bit:
  // 
  //     # Fetch next_pc if both imem req and req_q are ready
  //     if s.imem.req.rdy & s.req_q.allocate.rdy:
  //       # dequeue any PC in pc_redirect_q
  //       s.pc_redirect_q.deq.en @= s.pc_redirect_q.deq.rdy
  // 
  //       # update pc_reg
  //       s.pc_reg_en @= 1
  // 
  //       # make a new imem req
  //       s.req_q.allocate.en   @= 1
  //       s.imem.req.en         @= 1
  //       s.imem.req.msg.type_  @= MemMsgType.READ                  # always READ request
  //       s.imem.req.msg.opaque @= zext( s.req_q.allocate.ret, 8 )  # index in req_q
  //       s.imem.req.msg.addr   @= s.next_pc
  //       s.imem.req.msg.len    @= 0                                # fetch 4-byte words
  //       s.imem.req.msg.data   @= 0                                # no data
  // 
  //     # otherwise, if killed, save the PC into pc_redirect_q
  //     elif  s.clear_br.en & s.clear_br.msg.kill:
  //       # dequeue any PC in pc_redirect_q
  //       s.pc_redirect_q.deq.en @= s.pc_redirect_q.deq.rdy
  // 
  //       # save the new PC
  //       s.pc_redirect_q.enq.en @= 1
  
  always_comb begin : up_req_path
    pc_reg_en = 1'd0;
    pc_redirect_q__deq__en = 1'd0;
    pc_redirect_q__enq__en = 1'd0;
    req_q__allocate__en = 1'd0;
    imem__req__en = 1'd0;
    imem__req__msg.type_ = 4'd0;
    imem__req__msg.opaque = 8'd0;
    imem__req__msg.addr = 32'd0;
    imem__req__msg.len = 2'd0;
    imem__req__msg.data = 32'd0;
    if ( go_bit ) begin
      if ( imem__req__rdy & req_q__allocate__rdy ) begin
        pc_redirect_q__deq__en = pc_redirect_q__deq__rdy;
        pc_reg_en = 1'd1;
        req_q__allocate__en = 1'd1;
        imem__req__en = 1'd1;
        imem__req__msg.type_ = 4'd0;
        imem__req__msg.opaque = { { 7 { 1'b0 } }, req_q__allocate__ret };
        imem__req__msg.addr = next_pc;
        imem__req__msg.len = 2'd0;
        imem__req__msg.data = 32'd0;
      end
      else if ( clear_br__en & clear_br__msg.kill ) begin
        pc_redirect_q__deq__en = pc_redirect_q__deq__rdy;
        pc_redirect_q__enq__en = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FetchUnitRTL.py:149
  // @update
  // def up_resp_path():
  // 
  //   # imem response ready
  //   s.imem.resp.rdy @= ~s.reset & \
  //                      ~( s.clear_br.en & s.clear_br.msg.kill ) & \
  //                      s.resp_q.enq.rdy
  // 
  //   # resp_q.enq
  //   s.resp_q.enq.en  @= s.imem.resp.en
  //   s.resp_q.enq.msg @= s.imem.resp.msg
  // 
  //   # default
  //   s.send_inst.en        @= 0
  //   s.send_inst.msg.pc    @= s.req_q.complete.ret.pc
  //   s.send_inst.msg.inst  @= s.resp_q.deq.ret.data
  // 
  //   s.req_q.complete.en   @= 0
  //   s.resp_q.deq.en       @= 0
  // 
  //   for i in range( req_q_idx_nbits ):
  //     s.req_q.complete.msg[ i ] @= s.resp_q.deq.ret.opaque[ i ]
  // 
  //   #
  //   # there is a response and this unit is not stalled
  //   #
  //   if  s.resp_q.deq.rdy & \
  //       s.req_q.complete.rdy & \
  //       s.send_inst.rdy:
  // 
  //     # dequeue resp_q
  //     s.resp_q.deq.en @= 1
  //     # complete the corresponding request
  //     s.req_q.complete.en @= 1
  //     # if the request has not been killed, send it to the next stage
  //     if s.req_q.complete.ret.val:
  //       s.send_inst.en @= 1
  
  always_comb begin : up_resp_path
    imem__resp__rdy = ( ( ~reset ) & ( ~( clear_br__en & clear_br__msg.kill ) ) ) & resp_q__enq__rdy;
    resp_q__enq__en = imem__resp__en;
    resp_q__enq__msg = imem__resp__msg;
    send_inst__en = 1'd0;
    send_inst__msg.pc = req_q__complete__ret.pc;
    send_inst__msg.inst = resp_q__deq__ret.data;
    req_q__complete__en = 1'd0;
    resp_q__deq__en = 1'd0;
    for ( int unsigned i = 1'd0; i < 1'( __const__req_q_idx_nbits_at_up_resp_path ); i += 1'd1 )
      req_q__complete__msg[1'(i)] = resp_q__deq__ret.opaque[3'(i)];
    if ( ( resp_q__deq__rdy & req_q__complete__rdy ) & send_inst__rdy ) begin
      resp_q__deq__en = 1'd1;
      req_q__complete__en = 1'd1;
      if ( req_q__complete__ret.val ) begin
        send_inst__en = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FetchUnitRTL.py:63
  // @update_ff
  // def up_pc_reg():
  //   if s.reset:        s.pc_reg <<= s.reset_pc - 4
  //   elif s.pc_reg_en:  s.pc_reg <<= s.next_pc
  
  always_ff @(posedge clk) begin : up_pc_reg
    if ( reset ) begin
      pc_reg <= reset_pc - 32'd4;
    end
    else if ( pc_reg_en ) begin
      pc_reg <= next_pc;
    end
  end

  assign pc_redirect_q__clk = clk;
  assign pc_redirect_q__reset = reset;
  assign pc_incr__clk = clk;
  assign pc_incr__reset = reset;
  assign req_q__clk = clk;
  assign req_q__reset = reset;
  assign resp_q__clk = clk;
  assign resp_q__reset = reset;
  assign pc_incr__in_ = pc_reg;
  assign req_q__allocate__msg.val = 1'd1;
  assign req_q__allocate__msg.pc = next_pc;
  assign pc_redirect_q__enq__msg = clear_br__msg.pc_redirect;

endmodule


// PyMTL Component TaggedTableRTL Definition
// Full name: TaggedTableRTL__num_entries_2__BranchTag_Bits2__EntryType_MulDivReqStruct__b78922f82ad9e943__EntryIdx_Bits1__ClearBrStruct_ClearBrStruct__ac353fa5f603c6f1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py

module TaggedTableRTL__23ad185b24fb03a4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate__en  ,
  input MulDivReqStruct__b78922f82ad9e943 allocate__msg  ,
  output logic [0:0] allocate__rdy  ,
  output logic [0:0] allocate__ret  ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] complete__en  ,
  input logic [0:0] complete__msg  ,
  output logic [0:0] complete__rdy  ,
  output MulDivReqStruct__b78922f82ad9e943 complete__ret  
);
  localparam logic [1:0] __const__num_entries_at_up_ff  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_comb  = 2'd2;
  MulDivReqStruct__b78922f82ad9e943 entry [0:1];
  MulDivReqStruct__b78922f82ad9e943 next_entry [0:1];
  //-------------------------------------------------------------
  // Component entry_alloc
  //-------------------------------------------------------------

  logic [0:0] entry_alloc__clk;
  logic [0:0] entry_alloc__empty;
  logic [0:0] entry_alloc__free [0:1];
  logic [0:0] entry_alloc__reset;
  logic [0:0] entry_alloc__allocate__en;
  logic [0:0] entry_alloc__allocate__rdy;
  logic [0:0] entry_alloc__allocate__ret;

  EntryAllocatorRTL__num_entries_2__EntryIdx_Bits1 entry_alloc
  (
    .clk( entry_alloc__clk ),
    .empty( entry_alloc__empty ),
    .free( entry_alloc__free ),
    .reset( entry_alloc__reset ),
    .allocate__en( entry_alloc__allocate__en ),
    .allocate__rdy( entry_alloc__allocate__rdy ),
    .allocate__ret( entry_alloc__allocate__ret )
  );

  //-------------------------------------------------------------
  // End of component entry_alloc
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__up_comb_idx;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py:63
  // s.complete.rdy  //= lambda: ~s.entry_alloc.empty
  
  always_comb begin : _lambda__s_procs_0__fpu_pipe_req_table_complete_rdy
    complete__rdy = ~entry_alloc__empty;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py:74
  // @update
  // def up_comb():
  // 
  //   # default
  //   s.complete.ret @= s.entry[ 0 ]
  //   for i in range( num_entries ):
  //     s.next_entry[ i ]       @= s.entry[ i ]
  //     s.entry_alloc.free[ i ] @= 0
  // 
  //   # clear_br
  //   if s.clear_br.en:
  // 
  //     if s.clear_br.msg.kill:
  //       # if matched with the kill mask, mark this entry as "killed"
  //       for i in range( num_entries ):
  //         if ( s.entry[ i ].br_tag & s.clear_br.msg.br_mask ) != 0:
  //           s.next_entry[ i ].killed @= 1
  // 
  //     else:
  //       # if matched, clear the masked bit
  //       for i in range( num_entries ):
  //         if ( s.entry[ i ].br_tag & s.clear_br.msg.br_mask ) != 0:
  //           s.next_entry[ i ].br_tag @= s.entry[ i ].br_tag & ~s.clear_br.msg.br_mask
  // 
  //   # complete
  //   if  s.complete.en:
  //     idx = s.complete.msg
  //     s.complete.ret            @= s.next_entry[ idx ]
  //     s.entry_alloc.free[ idx ] @= 1
  // 
  //   # allocate
  //   if  s.allocate.en:
  //     idx = s.entry_alloc.allocate.ret
  //     s.next_entry[ idx ] @= s.allocate.msg
  
  always_comb begin : up_comb
    complete__ret = entry[1'd0];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 ) begin
      next_entry[1'(i)] = entry[1'(i)];
      entry_alloc__free[1'(i)] = 1'd0;
    end
    if ( clear_br__en ) begin
      if ( clear_br__msg.kill ) begin
        for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
          if ( ( entry[1'(i)].br_tag & clear_br__msg.br_mask ) != 2'd0 ) begin
            next_entry[1'(i)].killed = 1'd1;
          end
      end
      else
        for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
          if ( ( entry[1'(i)].br_tag & clear_br__msg.br_mask ) != 2'd0 ) begin
            next_entry[1'(i)].br_tag = entry[1'(i)].br_tag & ( ~clear_br__msg.br_mask );
          end
    end
    if ( complete__en ) begin
      __tmpvar__up_comb_idx = complete__msg;
      complete__ret = next_entry[__tmpvar__up_comb_idx];
      entry_alloc__free[__tmpvar__up_comb_idx] = 1'd1;
    end
    if ( allocate__en ) begin
      __tmpvar__up_comb_idx = entry_alloc__allocate__ret;
      next_entry[__tmpvar__up_comb_idx] = allocate__msg;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py:65
  // @update_ff
  // def up_ff():
  //   if s.reset:
  //     for i in range( num_entries ):
  //       s.entry[ i ]  <<= EntryType()
  //   else:
  //     for i in range( num_entries ):
  //       s.entry[ i ]  <<= s.next_entry[ i ]
  
  always_ff @(posedge clk) begin : up_ff
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 )
        entry[1'(i)] <= { 32'd0, 2'd0, 3'd0, 7'd0, 1'd0 };
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 )
        entry[1'(i)] <= next_entry[1'(i)];
  end

  assign entry_alloc__clk = clk;
  assign entry_alloc__reset = reset;
  assign entry_alloc__allocate__en = allocate__en;
  assign allocate__rdy = entry_alloc__allocate__rdy;
  assign allocate__ret = entry_alloc__allocate__ret;

endmodule


// PyMTL Component FloatingPointPipeRTL Definition
// Full name: FloatingPointPipeRTL__max_nreqs_2__FpuReq_FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3__FpuResp_FpuRespMsg_8_32__opaque_8__result_32__fexc_5
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FloatingPointPipeRTL.py

module FloatingPointPipeRTL__d492e0cc77198375
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] bypass__en  ,
  output RegWrStruct__preg_idx_7__data_32 bypass__msg  ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] recv_fpu_resp__en  ,
  input FpuRespMsg_8_32__opaque_8__result_32__fexc_5 recv_fpu_resp__msg  ,
  output logic [0:0] recv_fpu_resp__rdy  ,
  input logic [0:0] recv_inst__en  ,
  input I_InstStruct__c61c86abe6488854 recv_inst__msg  ,
  output logic [0:0] recv_inst__rdy  ,
  output logic [0:0] send_fpu_req__en  ,
  output FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 send_fpu_req__msg  ,
  input logic [0:0] send_fpu_req__rdy  ,
  output logic [0:0] send_inst__en  ,
  output X_InstStruct__b64b8c5076edb89b send_inst__msg  ,
  input logic [0:0] send_inst__rdy  
);
  localparam logic [0:0] __const__req_table_idx_nbits_at_up_resp  = 1'd1;
  I_InstStruct__c61c86abe6488854 in_msg;
  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 recv_q__clear_br__msg;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  I_InstStruct__c61c86abe6488854 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  I_InstStruct__c61c86abe6488854 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  TaggedPipeQueue1EntryRTL__bc00a7d41594514f recv_q
  (
    .clk( recv_q__clk ),
    .reset( recv_q__reset ),
    .clear_br__en( recv_q__clear_br__en ),
    .clear_br__msg( recv_q__clear_br__msg ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req_table
  //-------------------------------------------------------------

  logic [0:0] req_table__clk;
  logic [0:0] req_table__reset;
  logic [0:0] req_table__allocate__en;
  MulDivReqStruct__b78922f82ad9e943 req_table__allocate__msg;
  logic [0:0] req_table__allocate__rdy;
  logic [0:0] req_table__allocate__ret;
  logic [0:0] req_table__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 req_table__clear_br__msg;
  logic [0:0] req_table__complete__en;
  logic [0:0] req_table__complete__msg;
  logic [0:0] req_table__complete__rdy;
  MulDivReqStruct__b78922f82ad9e943 req_table__complete__ret;

  TaggedTableRTL__23ad185b24fb03a4 req_table
  (
    .clk( req_table__clk ),
    .reset( req_table__reset ),
    .allocate__en( req_table__allocate__en ),
    .allocate__msg( req_table__allocate__msg ),
    .allocate__rdy( req_table__allocate__rdy ),
    .allocate__ret( req_table__allocate__ret ),
    .clear_br__en( req_table__clear_br__en ),
    .clear_br__msg( req_table__clear_br__msg ),
    .complete__en( req_table__complete__en ),
    .complete__msg( req_table__complete__msg ),
    .complete__rdy( req_table__complete__rdy ),
    .complete__ret( req_table__complete__ret )
  );

  //-------------------------------------------------------------
  // End of component req_table
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FloatingPointPipeRTL.py:102
  // @update
  // def up_req():
  //   # NOTE: for now, we don't support different rounding mode other than
  //   # FRND_NE (rounding to the nearest)
  // 
  //   # multiplier request
  //   s.send_fpu_req.msg.opaque @= zext( s.req_table.allocate.ret, opq_nbits )
  //   s.send_fpu_req.msg.op_a   @= s.in_msg.op1_val
  //   s.send_fpu_req.msg.op_b   @= s.in_msg.op2_val
  // 
  //   # default
  //   s.recv_q.deq.en           @= 0
  //   s.send_fpu_req.en         @= 0
  //   s.req_table.allocate.en   @= 0
  //   s.send_fpu_req.msg.type_  @= FpuReqType.NUM_TYPES # invalid type
  //   s.send_fpu_req.msg.frnd   @= FpuReqType.FRND_NE   # default round to nearest
  // 
  //   if s.recv_q.deq.rdy:
  // 
  //     # just drop if killed
  //     if    s.in_msg.killed:
  //       s.recv_q.deq.en @= 1
  // 
  //     elif  s.send_fpu_req.rdy & s.req_table.allocate.rdy:
  //       s.recv_q.deq.en           @= 1
  //       s.send_fpu_req.en         @= 1
  //       s.req_table.allocate.en   @= 1
  //       s.send_fpu_req.msg.type_  @= s.in_msg.fpu_type
  
  always_comb begin : up_req
    send_fpu_req__msg.opaque = { { 7 { 1'b0 } }, req_table__allocate__ret };
    send_fpu_req__msg.op_a = in_msg.op1_val;
    send_fpu_req__msg.op_b = in_msg.op2_val;
    recv_q__deq__en = 1'd0;
    send_fpu_req__en = 1'd0;
    req_table__allocate__en = 1'd0;
    send_fpu_req__msg.type_ = 4'd11;
    send_fpu_req__msg.frnd = 3'd0;
    if ( recv_q__deq__rdy ) begin
      if ( in_msg.killed ) begin
        recv_q__deq__en = 1'd1;
      end
      else if ( send_fpu_req__rdy & req_table__allocate__rdy ) begin
        recv_q__deq__en = 1'd1;
        send_fpu_req__en = 1'd1;
        req_table__allocate__en = 1'd1;
        send_fpu_req__msg.type_ = in_msg.fpu_type;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/FloatingPointPipeRTL.py:131
  // @update
  // def up_resp():
  //   # NOTE: for now, we ignore exception bits FEXC from the FPU
  // 
  //   # req_table.complete
  //   for i in range( req_table_idx_nbits ):
  //     s.req_table.complete.msg[ i ] @= s.recv_fpu_resp.msg.opaque[ i ]
  // 
  //   # default
  //   s.req_table.complete.en @= 0
  //   s.send_inst.en          @= 0
  //   s.bypass.en             @= 0
  // 
  //   s.recv_fpu_resp.rdy @= s.req_table.complete.rdy & s.send_inst.rdy
  // 
  //   if s.recv_fpu_resp.en:
  //     s.req_table.complete.en @= 1
  // 
  //     # only send inst to the next stage if it's not killed
  //     if ~s.req_table.complete.ret.killed:
  //       s.send_inst.en  @= 1
  //       s.bypass.en     @= 1
  
  always_comb begin : up_resp
    for ( int unsigned i = 1'd0; i < 1'( __const__req_table_idx_nbits_at_up_resp ); i += 1'd1 )
      req_table__complete__msg[1'(i)] = recv_fpu_resp__msg.opaque[3'(i)];
    req_table__complete__en = 1'd0;
    send_inst__en = 1'd0;
    bypass__en = 1'd0;
    recv_fpu_resp__rdy = req_table__complete__rdy & send_inst__rdy;
    if ( recv_fpu_resp__en ) begin
      req_table__complete__en = 1'd1;
      if ( ~req_table__complete__ret.killed ) begin
        send_inst__en = 1'd1;
        bypass__en = 1'd1;
      end
    end
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = recv_inst__en;
  assign recv_q__enq__msg = recv_inst__msg;
  assign recv_inst__rdy = recv_q__enq__rdy;
  assign recv_q__clear_br__en = clear_br__en;
  assign recv_q__clear_br__msg = clear_br__msg;
  assign in_msg = recv_q__deq__ret;
  assign req_table__clk = clk;
  assign req_table__reset = reset;
  assign req_table__clear_br__en = clear_br__en;
  assign req_table__clear_br__msg = clear_br__msg;
  assign req_table__allocate__msg.pc = in_msg.pc;
  assign req_table__allocate__msg.br_tag = in_msg.br_tag;
  assign req_table__allocate__msg.rob_idx = in_msg.rob_idx;
  assign req_table__allocate__msg.rd_preg = in_msg.rd_preg;
  assign req_table__allocate__msg.killed = in_msg.killed;
  assign send_inst__msg.pc = req_table__complete__ret.pc;
  assign send_inst__msg.inst_val = 1'd1;
  assign send_inst__msg.br_tag = req_table__complete__ret.br_tag;
  assign send_inst__msg.rob_idx = req_table__complete__ret.rob_idx;
  assign send_inst__msg.rd_en = 1'd1;
  assign send_inst__msg.rd_preg = req_table__complete__ret.rd_preg;
  assign send_inst__msg.csr_wen = 1'd0;
  assign send_inst__msg.result = recv_fpu_resp__msg.result;
  assign send_inst__msg.killed = 1'd0;
  assign bypass__msg.preg_idx = req_table__complete__ret.rd_preg;
  assign bypass__msg.data = recv_fpu_resp__msg.result;

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_Bits32__ninputs_3
(
  input  logic [0:0] clk ,
  input  logic [31:0] in_ [0:2],
  output logic [31:0] out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component TaggedNormalQueue2EntryRTL Definition
// Full name: TaggedNormalQueue2EntryRTL__EntryStruct_D_InstStruct__e597a7f7aebd8fbc__ClearBrStruct_ClearBrStruct__ac353fa5f603c6f1__BranchTag_Bits2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedNormalQueue2EntryRTL.py

module TaggedNormalQueue2EntryRTL__ca4fef781f541716
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output D_InstStruct__e597a7f7aebd8fbc deq__ret  ,
  input logic [0:0] enq__en  ,
  input D_InstStruct__e597a7f7aebd8fbc enq__msg  ,
  output logic [0:0] enq__rdy  
);
  D_InstStruct__e597a7f7aebd8fbc pri_entry;
  D_InstStruct__e597a7f7aebd8fbc sec_entry;
  logic [1:0] size;
  D_InstStruct__e597a7f7aebd8fbc updated_pri_entry;
  D_InstStruct__e597a7f7aebd8fbc updated_sec_entry;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedNormalQueue2EntryRTL.py:104
  // @update
  // def up_comb():
  // 
  //   s.enq.rdy @= ( s.size < 2 )
  //   s.deq.rdy @= ( s.size > 0 )
  // 
  //   s.updated_pri_entry @= s.pri_entry
  //   s.updated_sec_entry @= s.sec_entry
  // 
  //   if s.clear_br.en:
  // 
  //     if s.pri_entry.br_tag & s.clear_br.msg.br_mask:
  //       if s.clear_br.msg.kill:
  //         s.updated_pri_entry.killed @= 1
  //       else:
  //         s.updated_pri_entry.br_tag @= s.pri_entry.br_tag & ~s.clear_br.msg.br_mask
  // 
  //     if s.sec_entry.br_tag & s.clear_br.msg.br_mask:
  //       if s.clear_br.msg.kill:
  //         s.updated_sec_entry.killed @= 1
  //       else:
  //         s.updated_sec_entry.br_tag @= s.sec_entry.br_tag & ~s.clear_br.msg.br_mask
  // 
  //   s.deq.ret @= s.updated_pri_entry
  
  always_comb begin : up_comb
    enq__rdy = size < 2'd2;
    deq__rdy = size > 2'd0;
    updated_pri_entry = pri_entry;
    updated_sec_entry = sec_entry;
    if ( clear_br__en ) begin
      if ( pri_entry.br_tag & clear_br__msg.br_mask ) begin
        if ( clear_br__msg.kill ) begin
          updated_pri_entry.killed = 1'd1;
        end
        else
          updated_pri_entry.br_tag = pri_entry.br_tag & ( ~clear_br__msg.br_mask );
      end
      if ( sec_entry.br_tag & clear_br__msg.br_mask ) begin
        if ( clear_br__msg.kill ) begin
          updated_sec_entry.killed = 1'd1;
        end
        else
          updated_sec_entry.br_tag = sec_entry.br_tag & ( ~clear_br__msg.br_mask );
      end
    end
    deq__ret = updated_pri_entry;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedNormalQueue2EntryRTL.py:54
  // @update_ff
  // def up_states():
  // 
  //   # reset
  //   if    s.reset:
  //     s.size <<= 0
  // 
  //   # enq and deq
  //   elif  s.enq.en & s.deq.en:
  // 
  //     # enq -> pri_entry
  //     if    s.size == 1:
  //       s.pri_entry <<= s.enq.msg
  // 
  //     # enq -> sec_entry -> pri_entry
  //     elif  s.size == 2:
  //       s.pri_entry <<= s.updated_sec_entry
  //       s.sec_entry <<= s.enq.msg
  // 
  //   # not enq and deq
  //   elif  ~s.enq.en & s.deq.en:
  // 
  //     # pri_entry -> deq
  //     if    s.size == 1:
  //       s.size <<= 0
  // 
  //     # sec_entry -> pri_entry -> deq
  //     elif  s.size == 2:
  //       s.size      <<= 1
  //       s.pri_entry <<= s.updated_sec_entry
  // 
  //   # enq and not deq
  //   elif  s.enq.en & ~s.deq.en:
  // 
  //     # enq -> pri_entry
  //     if    s.size == 0:
  //       s.size      <<= 1
  //       s.pri_entry <<= s.enq.msg
  // 
  //     # enq -> sec_entry
  //     elif  s.size == 1:
  //       s.size      <<= 2
  //       s.pri_entry <<= s.updated_pri_entry
  //       s.sec_entry <<= s.enq.msg
  // 
  //   # not enq and not deq
  //   else:
  //     s.pri_entry <<= s.updated_pri_entry
  //     s.sec_entry <<= s.updated_sec_entry
  
  always_ff @(posedge clk) begin : up_states
    if ( reset ) begin
      size <= 2'd0;
    end
    else if ( enq__en & deq__en ) begin
      if ( size == 2'd1 ) begin
        pri_entry <= enq__msg;
      end
      else if ( size == 2'd2 ) begin
        pri_entry <= updated_sec_entry;
        sec_entry <= enq__msg;
      end
    end
    else if ( ( ~enq__en ) & deq__en ) begin
      if ( size == 2'd1 ) begin
        size <= 2'd0;
      end
      else if ( size == 2'd2 ) begin
        size <= 2'd1;
        pri_entry <= updated_sec_entry;
      end
    end
    else if ( enq__en & ( ~deq__en ) ) begin
      if ( size == 2'd0 ) begin
        size <= 2'd1;
        pri_entry <= enq__msg;
      end
      else if ( size == 2'd1 ) begin
        size <= 2'd2;
        pri_entry <= updated_pri_entry;
        sec_entry <= enq__msg;
      end
    end
    else begin
      pri_entry <= updated_pri_entry;
      sec_entry <= updated_sec_entry;
    end
  end

endmodule


// PyMTL Component IssueUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/IssueUnitRTL.py

module IssueUnitRTL__num_rd_ports_2__num_FUs_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  output logic [0:0] rd_csr__en  ,
  output logic [11:0] rd_csr__msg  ,
  input logic [31:0] rd_csr__ret  ,
  input logic [0:0] rd_csr__suc  ,
  output logic [0:0] rd_reg__en [0:1] ,
  output logic [6:0] rd_reg__msg [0:1] ,
  input logic [31:0] rd_reg__ret [0:1] ,
  input logic [0:0] rd_reg__suc [0:1] ,
  input logic [0:0] recv_inst__en  ,
  input D_InstStruct__e597a7f7aebd8fbc recv_inst__msg  ,
  output logic [0:0] recv_inst__rdy  ,
  output logic [0:0] send_inst__en [0:3] ,
  output I_InstStruct__c61c86abe6488854 send_inst__msg [0:3] ,
  input logic [0:0] send_inst__rdy [0:3] ,
  output logic [0:0] set_reg__en  ,
  output logic [6:0] set_reg__msg  
);
  localparam logic [1:0] __const__num_rd_ports_at_issue_comb  = 2'd2;
  localparam logic [2:0] __const__num_FUs_at_issue_comb  = 3'd4;
  localparam logic [3:0] __const__fp_x  = 4'd11;
  localparam logic [1:0] __const__FPU_PIPE  = 2'd3;
  localparam logic [3:0] __const__md_x  = 4'd0;
  localparam logic [1:0] __const__MDU_PIPE  = 2'd2;
  localparam logic [3:0] __const__mem_x  = 4'd0;
  localparam logic [1:0] __const__MEM_PIPE  = 2'd1;
  localparam logic [1:0] __const__ALU_PIPE  = 2'd0;
  localparam logic [1:0] __const__csr_rd  = 2'd1;
  D_InstStruct__e597a7f7aebd8fbc in_msg;
  logic [31:0] rs1_data;
  logic [31:0] rs2_data;
  //-------------------------------------------------------------
  // Component op1_sel_mux
  //-------------------------------------------------------------

  logic [0:0] op1_sel_mux__clk;
  logic [31:0] op1_sel_mux__in_ [0:1];
  logic [31:0] op1_sel_mux__out;
  logic [0:0] op1_sel_mux__reset;
  logic [0:0] op1_sel_mux__sel;

  Mux__Type_Bits32__ninputs_2 op1_sel_mux
  (
    .clk( op1_sel_mux__clk ),
    .in_( op1_sel_mux__in_ ),
    .out( op1_sel_mux__out ),
    .reset( op1_sel_mux__reset ),
    .sel( op1_sel_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component op1_sel_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component op2_sel_mux
  //-------------------------------------------------------------

  logic [0:0] op2_sel_mux__clk;
  logic [31:0] op2_sel_mux__in_ [0:2];
  logic [31:0] op2_sel_mux__out;
  logic [0:0] op2_sel_mux__reset;
  logic [1:0] op2_sel_mux__sel;

  Mux__Type_Bits32__ninputs_3 op2_sel_mux
  (
    .clk( op2_sel_mux__clk ),
    .in_( op2_sel_mux__in_ ),
    .out( op2_sel_mux__out ),
    .reset( op2_sel_mux__reset ),
    .sel( op2_sel_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component op2_sel_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 recv_q__clear_br__msg;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  D_InstStruct__e597a7f7aebd8fbc recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  D_InstStruct__e597a7f7aebd8fbc recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  TaggedNormalQueue2EntryRTL__ca4fef781f541716 recv_q
  (
    .clk( recv_q__clk ),
    .reset( recv_q__reset ),
    .clear_br__en( recv_q__clear_br__en ),
    .clear_br__msg( recv_q__clear_br__msg ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------
  logic [1:0] __tmpvar__issue_comb_fu_id;
  logic [0:0] __tmpvar__issue_comb_stall;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/IssueUnitRTL.py:116
  // @update
  // def issue_comb():
  //   # default
  //   s.recv_q.deq.en @= 0
  //   s.set_reg.en    @= 0
  //   s.rd_csr.en     @= 0
  //   for i in range( num_rd_ports ):
  //     s.rd_reg[ i ].en @= 0
  //   for i in range( num_FUs ):
  //     s.send_inst[ i ].en @= 0
  // 
  //   # check if we have inst to process
  //   if s.recv_q.deq.rdy:
  //     if    s.in_msg.fpu_type != fp_x:
  //       fu_id = FPU_PIPE
  //     elif  s.in_msg.mdu_type != md_x:
  //       fu_id = MDU_PIPE
  //     elif  s.in_msg.mem_type != mem_x:
  //       fu_id = MEM_PIPE
  //     else:
  //       fu_id = ALU_PIPE
  // 
  //     # check if target FU is ready
  //     if s.send_inst[ fu_id ].rdy:
  // 
  //       if  s.recv_q.deq.ret.killed:
  //         # drop killed inst
  //         s.recv_q.deq.en @= 1
  //       else:
  //         # try to read regs
  //         s.rd_reg[ 0 ].en  @= s.in_msg.rs1_en
  //         s.rd_reg[ 1 ].en  @= s.in_msg.rs2_en
  //         s.rd_csr.en       @= ( s.in_msg.csr_type == csr_rd )
  // 
  //         # stall if we fail to read any register
  //         stall = ( s.in_msg.rs1_en & ~s.rd_reg[ 0 ].suc ) | \
  //                 ( s.in_msg.rs2_en & ~s.rd_reg[ 1 ].suc ) | \
  //                 ( s.rd_csr.en     & ~s.rd_csr.suc      )
  // 
  //         # process if not stalled
  //         s.recv_q.deq.en         @= ~stall
  //         s.send_inst[ fu_id ].en @= ~stall
  //         s.set_reg.en            @= ~stall
  
  always_comb begin : issue_comb
    recv_q__deq__en = 1'd0;
    set_reg__en = 1'd0;
    rd_csr__en = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'( __const__num_rd_ports_at_issue_comb ); i += 1'd1 )
      rd_reg__en[1'(i)] = 1'd0;
    for ( int unsigned i = 1'd0; i < 3'( __const__num_FUs_at_issue_comb ); i += 1'd1 )
      send_inst__en[2'(i)] = 1'd0;
    if ( recv_q__deq__rdy ) begin
      if ( in_msg.fpu_type != 4'( __const__fp_x ) ) begin
        __tmpvar__issue_comb_fu_id = 2'( __const__FPU_PIPE );
      end
      else if ( in_msg.mdu_type != 4'( __const__md_x ) ) begin
        __tmpvar__issue_comb_fu_id = 2'( __const__MDU_PIPE );
      end
      else if ( in_msg.mem_type != 4'( __const__mem_x ) ) begin
        __tmpvar__issue_comb_fu_id = 2'( __const__MEM_PIPE );
      end
      else
        __tmpvar__issue_comb_fu_id = 2'( __const__ALU_PIPE );
      if ( send_inst__rdy[__tmpvar__issue_comb_fu_id] ) begin
        if ( recv_q__deq__ret.killed ) begin
          recv_q__deq__en = 1'd1;
        end
        else begin
          rd_reg__en[1'd0] = in_msg.rs1_en;
          rd_reg__en[1'd1] = in_msg.rs2_en;
          rd_csr__en = in_msg.csr_type == 2'( __const__csr_rd );
          __tmpvar__issue_comb_stall = ( ( in_msg.rs1_en & ( ~rd_reg__suc[1'd0] ) ) | ( in_msg.rs2_en & ( ~rd_reg__suc[1'd1] ) ) ) | ( rd_csr__en & ( ~rd_csr__suc ) );
          recv_q__deq__en = ~__tmpvar__issue_comb_stall;
          send_inst__en[__tmpvar__issue_comb_fu_id] = ~__tmpvar__issue_comb_stall;
          set_reg__en = ~__tmpvar__issue_comb_stall;
        end
      end
    end
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = recv_inst__en;
  assign recv_q__enq__msg = recv_inst__msg;
  assign recv_inst__rdy = recv_q__enq__rdy;
  assign recv_q__clear_br__en = clear_br__en;
  assign recv_q__clear_br__msg = clear_br__msg;
  assign in_msg = recv_q__deq__ret;
  assign op1_sel_mux__clk = clk;
  assign op1_sel_mux__reset = reset;
  assign op1_sel_mux__in_[0] = rd_reg__ret[0];
  assign op1_sel_mux__in_[1] = in_msg.pc;
  assign op1_sel_mux__sel = in_msg.op1_sel;
  assign op2_sel_mux__clk = clk;
  assign op2_sel_mux__reset = reset;
  assign op2_sel_mux__in_[0] = rd_reg__ret[1];
  assign op2_sel_mux__in_[1] = in_msg.imm_val;
  assign op2_sel_mux__in_[2] = rd_csr__ret;
  assign op2_sel_mux__sel = in_msg.op2_sel;
  assign rs1_data = rd_reg__ret[0];
  assign rs2_data = rd_reg__ret[1];
  assign rd_reg__msg[0] = in_msg.rs1_preg;
  assign rd_reg__msg[1] = in_msg.rs2_preg;
  assign set_reg__msg = in_msg.rd_preg;
  assign rd_csr__msg = in_msg.csr_num;
  assign send_inst__msg[0].pc = in_msg.pc;
  assign send_inst__msg[0].inst_val = in_msg.inst_val;
  assign send_inst__msg[0].br_tag = in_msg.br_tag;
  assign send_inst__msg[0].rob_idx = in_msg.rob_idx;
  assign send_inst__msg[0].op1_val = op1_sel_mux__out;
  assign send_inst__msg[0].op2_val = op2_sel_mux__out;
  assign send_inst__msg[0].rd_en = in_msg.rd_en;
  assign send_inst__msg[0].rd_preg = in_msg.rd_preg;
  assign send_inst__msg[0].br_type = in_msg.br_type;
  assign send_inst__msg[0].alu_type = in_msg.alu_type;
  assign send_inst__msg[0].csr_type = in_msg.csr_type;
  assign send_inst__msg[0].fpu_type = in_msg.fpu_type;
  assign send_inst__msg[0].br_idx = in_msg.br_idx;
  assign send_inst__msg[0].br_target = in_msg.br_target;
  assign send_inst__msg[0].mdu_type = in_msg.mdu_type;
  assign send_inst__msg[0].mem_type = in_msg.mem_type;
  assign send_inst__msg[0].mem_len = in_msg.mem_len;
  assign send_inst__msg[0].mem_ext = in_msg.mem_ext;
  assign send_inst__msg[0].st_data = rs2_data;
  assign send_inst__msg[0].fls = in_msg.fls;
  assign send_inst__msg[0].inv = in_msg.inv;
  assign send_inst__msg[0].killed = 1'd0;
  assign send_inst__msg[1].pc = in_msg.pc;
  assign send_inst__msg[1].inst_val = in_msg.inst_val;
  assign send_inst__msg[1].br_tag = in_msg.br_tag;
  assign send_inst__msg[1].rob_idx = in_msg.rob_idx;
  assign send_inst__msg[1].op1_val = op1_sel_mux__out;
  assign send_inst__msg[1].op2_val = op2_sel_mux__out;
  assign send_inst__msg[1].rd_en = in_msg.rd_en;
  assign send_inst__msg[1].rd_preg = in_msg.rd_preg;
  assign send_inst__msg[1].br_type = in_msg.br_type;
  assign send_inst__msg[1].alu_type = in_msg.alu_type;
  assign send_inst__msg[1].csr_type = in_msg.csr_type;
  assign send_inst__msg[1].fpu_type = in_msg.fpu_type;
  assign send_inst__msg[1].br_idx = in_msg.br_idx;
  assign send_inst__msg[1].br_target = in_msg.br_target;
  assign send_inst__msg[1].mdu_type = in_msg.mdu_type;
  assign send_inst__msg[1].mem_type = in_msg.mem_type;
  assign send_inst__msg[1].mem_len = in_msg.mem_len;
  assign send_inst__msg[1].mem_ext = in_msg.mem_ext;
  assign send_inst__msg[1].st_data = rs2_data;
  assign send_inst__msg[1].fls = in_msg.fls;
  assign send_inst__msg[1].inv = in_msg.inv;
  assign send_inst__msg[1].killed = 1'd0;
  assign send_inst__msg[2].pc = in_msg.pc;
  assign send_inst__msg[2].inst_val = in_msg.inst_val;
  assign send_inst__msg[2].br_tag = in_msg.br_tag;
  assign send_inst__msg[2].rob_idx = in_msg.rob_idx;
  assign send_inst__msg[2].op1_val = op1_sel_mux__out;
  assign send_inst__msg[2].op2_val = op2_sel_mux__out;
  assign send_inst__msg[2].rd_en = in_msg.rd_en;
  assign send_inst__msg[2].rd_preg = in_msg.rd_preg;
  assign send_inst__msg[2].br_type = in_msg.br_type;
  assign send_inst__msg[2].alu_type = in_msg.alu_type;
  assign send_inst__msg[2].csr_type = in_msg.csr_type;
  assign send_inst__msg[2].fpu_type = in_msg.fpu_type;
  assign send_inst__msg[2].br_idx = in_msg.br_idx;
  assign send_inst__msg[2].br_target = in_msg.br_target;
  assign send_inst__msg[2].mdu_type = in_msg.mdu_type;
  assign send_inst__msg[2].mem_type = in_msg.mem_type;
  assign send_inst__msg[2].mem_len = in_msg.mem_len;
  assign send_inst__msg[2].mem_ext = in_msg.mem_ext;
  assign send_inst__msg[2].st_data = rs2_data;
  assign send_inst__msg[2].fls = in_msg.fls;
  assign send_inst__msg[2].inv = in_msg.inv;
  assign send_inst__msg[2].killed = 1'd0;
  assign send_inst__msg[3].pc = in_msg.pc;
  assign send_inst__msg[3].inst_val = in_msg.inst_val;
  assign send_inst__msg[3].br_tag = in_msg.br_tag;
  assign send_inst__msg[3].rob_idx = in_msg.rob_idx;
  assign send_inst__msg[3].op1_val = op1_sel_mux__out;
  assign send_inst__msg[3].op2_val = op2_sel_mux__out;
  assign send_inst__msg[3].rd_en = in_msg.rd_en;
  assign send_inst__msg[3].rd_preg = in_msg.rd_preg;
  assign send_inst__msg[3].br_type = in_msg.br_type;
  assign send_inst__msg[3].alu_type = in_msg.alu_type;
  assign send_inst__msg[3].csr_type = in_msg.csr_type;
  assign send_inst__msg[3].fpu_type = in_msg.fpu_type;
  assign send_inst__msg[3].br_idx = in_msg.br_idx;
  assign send_inst__msg[3].br_target = in_msg.br_target;
  assign send_inst__msg[3].mdu_type = in_msg.mdu_type;
  assign send_inst__msg[3].mem_type = in_msg.mem_type;
  assign send_inst__msg[3].mem_len = in_msg.mem_len;
  assign send_inst__msg[3].mem_ext = in_msg.mem_ext;
  assign send_inst__msg[3].st_data = rs2_data;
  assign send_inst__msg[3].fls = in_msg.fls;
  assign send_inst__msg[3].inv = in_msg.inv;
  assign send_inst__msg[3].killed = 1'd0;

endmodule


// PyMTL Component MulDivPipeRTL Definition
// Full name: MulDivPipeRTL__max_nreqs_2__MduReq_MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32__MduResp_MduRespMsg_8_32__opaque_8__res_32
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/MulDivPipeRTL.py

module MulDivPipeRTL__109d9cf22badb0b4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] bypass__en  ,
  output RegWrStruct__preg_idx_7__data_32 bypass__msg  ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] recv_inst__en  ,
  input I_InstStruct__c61c86abe6488854 recv_inst__msg  ,
  output logic [0:0] recv_inst__rdy  ,
  input logic [0:0] recv_mdu_resp__en  ,
  input MduRespMsg_8_32__opaque_8__res_32 recv_mdu_resp__msg  ,
  output logic [0:0] recv_mdu_resp__rdy  ,
  output logic [0:0] send_inst__en  ,
  output X_InstStruct__b64b8c5076edb89b send_inst__msg  ,
  input logic [0:0] send_inst__rdy  ,
  output logic [0:0] send_mdu_req__en  ,
  output MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 send_mdu_req__msg  ,
  input logic [0:0] send_mdu_req__rdy  
);
  localparam logic [3:0] __const__md_mul  = 4'd1;
  localparam logic [3:0] __const__md_mh  = 4'd2;
  localparam logic [3:0] __const__md_mhsu  = 4'd3;
  localparam logic [3:0] __const__md_mhu  = 4'd4;
  localparam logic [3:0] __const__md_div  = 4'd5;
  localparam logic [3:0] __const__md_divu  = 4'd6;
  localparam logic [3:0] __const__md_rem  = 4'd7;
  localparam logic [3:0] __const__md_remu  = 4'd8;
  localparam logic [0:0] __const__req_table_idx_nbits_at_up_resp  = 1'd1;
  I_InstStruct__c61c86abe6488854 in_msg;
  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 recv_q__clear_br__msg;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  I_InstStruct__c61c86abe6488854 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  I_InstStruct__c61c86abe6488854 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  TaggedPipeQueue1EntryRTL__bc00a7d41594514f recv_q
  (
    .clk( recv_q__clk ),
    .reset( recv_q__reset ),
    .clear_br__en( recv_q__clear_br__en ),
    .clear_br__msg( recv_q__clear_br__msg ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req_table
  //-------------------------------------------------------------

  logic [0:0] req_table__clk;
  logic [0:0] req_table__reset;
  logic [0:0] req_table__allocate__en;
  MulDivReqStruct__b78922f82ad9e943 req_table__allocate__msg;
  logic [0:0] req_table__allocate__rdy;
  logic [0:0] req_table__allocate__ret;
  logic [0:0] req_table__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 req_table__clear_br__msg;
  logic [0:0] req_table__complete__en;
  logic [0:0] req_table__complete__msg;
  logic [0:0] req_table__complete__rdy;
  MulDivReqStruct__b78922f82ad9e943 req_table__complete__ret;

  TaggedTableRTL__23ad185b24fb03a4 req_table
  (
    .clk( req_table__clk ),
    .reset( req_table__reset ),
    .allocate__en( req_table__allocate__en ),
    .allocate__msg( req_table__allocate__msg ),
    .allocate__rdy( req_table__allocate__rdy ),
    .allocate__ret( req_table__allocate__ret ),
    .clear_br__en( req_table__clear_br__en ),
    .clear_br__msg( req_table__clear_br__msg ),
    .complete__en( req_table__complete__en ),
    .complete__msg( req_table__complete__msg ),
    .complete__rdy( req_table__complete__rdy ),
    .complete__ret( req_table__complete__ret )
  );

  //-------------------------------------------------------------
  // End of component req_table
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/MulDivPipeRTL.py:102
  // @update
  // def up_req():
  // 
  //   # multiplier request
  //   s.send_mdu_req.msg.opaque @= zext( s.req_table.allocate.ret, opq_nbits )
  //   s.send_mdu_req.msg.op_a   @= s.in_msg.op1_val
  //   s.send_mdu_req.msg.op_b   @= s.in_msg.op2_val
  // 
  //   # default
  //   s.recv_q.deq.en           @= 0
  //   s.send_mdu_req.en         @= 0
  //   s.req_table.allocate.en   @= 0
  //   s.send_mdu_req.msg.type_  @= MduMsgType.TYPE_MUL
  // 
  //   if s.recv_q.deq.rdy:
  // 
  //     # just drop if killed
  //     if    s.in_msg.killed:
  //       s.recv_q.deq.en @= 1
  // 
  //     elif  s.send_mdu_req.rdy & s.req_table.allocate.rdy:
  //       s.recv_q.deq.en         @= 1
  //       s.send_mdu_req.en       @= 1
  //       s.req_table.allocate.en @= 1
  // 
  //       if    s.in_msg.mdu_type == md_mul:  s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_MUL
  //       elif  s.in_msg.mdu_type == md_mh:   s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_MULH
  //       elif  s.in_msg.mdu_type == md_mhsu: s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_MULHSU
  //       elif  s.in_msg.mdu_type == md_mhu:  s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_MULHU
  //       elif  s.in_msg.mdu_type == md_div:  s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_DIV
  //       elif  s.in_msg.mdu_type == md_divu: s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_DIVU
  //       elif  s.in_msg.mdu_type == md_rem:  s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_REM
  //       elif  s.in_msg.mdu_type == md_remu: s.send_mdu_req.msg.type_ @= MduMsgType.TYPE_REMU
  
  always_comb begin : up_req
    send_mdu_req__msg.opaque = { { 7 { 1'b0 } }, req_table__allocate__ret };
    send_mdu_req__msg.op_a = in_msg.op1_val;
    send_mdu_req__msg.op_b = in_msg.op2_val;
    recv_q__deq__en = 1'd0;
    send_mdu_req__en = 1'd0;
    req_table__allocate__en = 1'd0;
    send_mdu_req__msg.type_ = 3'd0;
    if ( recv_q__deq__rdy ) begin
      if ( in_msg.killed ) begin
        recv_q__deq__en = 1'd1;
      end
      else if ( send_mdu_req__rdy & req_table__allocate__rdy ) begin
        recv_q__deq__en = 1'd1;
        send_mdu_req__en = 1'd1;
        req_table__allocate__en = 1'd1;
        if ( in_msg.mdu_type == 4'( __const__md_mul ) ) begin
          send_mdu_req__msg.type_ = 3'd0;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_mh ) ) begin
          send_mdu_req__msg.type_ = 3'd1;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_mhsu ) ) begin
          send_mdu_req__msg.type_ = 3'd2;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_mhu ) ) begin
          send_mdu_req__msg.type_ = 3'd3;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_div ) ) begin
          send_mdu_req__msg.type_ = 3'd4;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_divu ) ) begin
          send_mdu_req__msg.type_ = 3'd5;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_rem ) ) begin
          send_mdu_req__msg.type_ = 3'd6;
        end
        else if ( in_msg.mdu_type == 4'( __const__md_remu ) ) begin
          send_mdu_req__msg.type_ = 3'd7;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/MulDivPipeRTL.py:136
  // @update
  // def up_resp():
  // 
  //   # req_table.complete
  //   for i in range( req_table_idx_nbits ):
  //     s.req_table.complete.msg[ i ] @= s.recv_mdu_resp.msg.opaque[ i ]
  // 
  //   # default
  //   s.req_table.complete.en   @= 0
  //   s.send_inst.en            @= 0
  //   s.bypass.en               @= 0
  // 
  //   s.recv_mdu_resp.rdy @= s.req_table.complete.rdy & s.send_inst.rdy
  // 
  //   if s.recv_mdu_resp.en:
  //     s.req_table.complete.en @= 1
  // 
  //     # only send inst to the next stage if it's not killed
  //     if ~s.req_table.complete.ret.killed:
  //       s.send_inst.en  @= 1
  //       s.bypass.en     @= 1
  
  always_comb begin : up_resp
    for ( int unsigned i = 1'd0; i < 1'( __const__req_table_idx_nbits_at_up_resp ); i += 1'd1 )
      req_table__complete__msg[1'(i)] = recv_mdu_resp__msg.opaque[3'(i)];
    req_table__complete__en = 1'd0;
    send_inst__en = 1'd0;
    bypass__en = 1'd0;
    recv_mdu_resp__rdy = req_table__complete__rdy & send_inst__rdy;
    if ( recv_mdu_resp__en ) begin
      req_table__complete__en = 1'd1;
      if ( ~req_table__complete__ret.killed ) begin
        send_inst__en = 1'd1;
        bypass__en = 1'd1;
      end
    end
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = recv_inst__en;
  assign recv_q__enq__msg = recv_inst__msg;
  assign recv_inst__rdy = recv_q__enq__rdy;
  assign recv_q__clear_br__en = clear_br__en;
  assign recv_q__clear_br__msg = clear_br__msg;
  assign in_msg = recv_q__deq__ret;
  assign req_table__clk = clk;
  assign req_table__reset = reset;
  assign req_table__clear_br__en = clear_br__en;
  assign req_table__clear_br__msg = clear_br__msg;
  assign req_table__allocate__msg.pc = in_msg.pc;
  assign req_table__allocate__msg.br_tag = in_msg.br_tag;
  assign req_table__allocate__msg.rob_idx = in_msg.rob_idx;
  assign req_table__allocate__msg.rd_preg = in_msg.rd_preg;
  assign req_table__allocate__msg.killed = in_msg.killed;
  assign send_inst__msg.pc = req_table__complete__ret.pc;
  assign send_inst__msg.inst_val = 1'd1;
  assign send_inst__msg.br_tag = req_table__complete__ret.br_tag;
  assign send_inst__msg.rob_idx = req_table__complete__ret.rob_idx;
  assign send_inst__msg.rd_en = 1'd1;
  assign send_inst__msg.rd_preg = req_table__complete__ret.rd_preg;
  assign send_inst__msg.csr_wen = 1'd0;
  assign send_inst__msg.result = recv_mdu_resp__msg.res;
  assign send_inst__msg.killed = 1'd0;
  assign bypass__msg.preg_idx = req_table__complete__ret.rd_preg;
  assign bypass__msg.data = recv_mdu_resp__msg.res;

endmodule


// PyMTL Component TaggedTableRTL Definition
// Full name: TaggedTableRTL__num_entries_2__BranchTag_Bits2__EntryType_MemCompleteStruct__c5bd3cabb5deb86b__EntryIdx_Bits1__ClearBrStruct_ClearBrStruct__ac353fa5f603c6f1
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py

module TaggedTableRTL__a82100b5ae07ef48
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] allocate__en  ,
  input MemCompleteStruct__c5bd3cabb5deb86b allocate__msg  ,
  output logic [0:0] allocate__rdy  ,
  output logic [0:0] allocate__ret  ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] complete__en  ,
  input logic [0:0] complete__msg  ,
  output logic [0:0] complete__rdy  ,
  output MemCompleteStruct__c5bd3cabb5deb86b complete__ret  
);
  localparam logic [1:0] __const__num_entries_at_up_ff  = 2'd2;
  localparam logic [1:0] __const__num_entries_at_up_comb  = 2'd2;
  MemCompleteStruct__c5bd3cabb5deb86b entry [0:1];
  MemCompleteStruct__c5bd3cabb5deb86b next_entry [0:1];
  //-------------------------------------------------------------
  // Component entry_alloc
  //-------------------------------------------------------------

  logic [0:0] entry_alloc__clk;
  logic [0:0] entry_alloc__empty;
  logic [0:0] entry_alloc__free [0:1];
  logic [0:0] entry_alloc__reset;
  logic [0:0] entry_alloc__allocate__en;
  logic [0:0] entry_alloc__allocate__rdy;
  logic [0:0] entry_alloc__allocate__ret;

  EntryAllocatorRTL__num_entries_2__EntryIdx_Bits1 entry_alloc
  (
    .clk( entry_alloc__clk ),
    .empty( entry_alloc__empty ),
    .free( entry_alloc__free ),
    .reset( entry_alloc__reset ),
    .allocate__en( entry_alloc__allocate__en ),
    .allocate__rdy( entry_alloc__allocate__rdy ),
    .allocate__ret( entry_alloc__allocate__ret )
  );

  //-------------------------------------------------------------
  // End of component entry_alloc
  //-------------------------------------------------------------
  logic [0:0] __tmpvar__up_comb_idx;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py:63
  // s.complete.rdy  //= lambda: ~s.entry_alloc.empty
  
  always_comb begin : _lambda__s_procs_0__mem_flow_amo_q_complete_rdy
    complete__rdy = ~entry_alloc__empty;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py:74
  // @update
  // def up_comb():
  // 
  //   # default
  //   s.complete.ret @= s.entry[ 0 ]
  //   for i in range( num_entries ):
  //     s.next_entry[ i ]       @= s.entry[ i ]
  //     s.entry_alloc.free[ i ] @= 0
  // 
  //   # clear_br
  //   if s.clear_br.en:
  // 
  //     if s.clear_br.msg.kill:
  //       # if matched with the kill mask, mark this entry as "killed"
  //       for i in range( num_entries ):
  //         if ( s.entry[ i ].br_tag & s.clear_br.msg.br_mask ) != 0:
  //           s.next_entry[ i ].killed @= 1
  // 
  //     else:
  //       # if matched, clear the masked bit
  //       for i in range( num_entries ):
  //         if ( s.entry[ i ].br_tag & s.clear_br.msg.br_mask ) != 0:
  //           s.next_entry[ i ].br_tag @= s.entry[ i ].br_tag & ~s.clear_br.msg.br_mask
  // 
  //   # complete
  //   if  s.complete.en:
  //     idx = s.complete.msg
  //     s.complete.ret            @= s.next_entry[ idx ]
  //     s.entry_alloc.free[ idx ] @= 1
  // 
  //   # allocate
  //   if  s.allocate.en:
  //     idx = s.entry_alloc.allocate.ret
  //     s.next_entry[ idx ] @= s.allocate.msg
  
  always_comb begin : up_comb
    complete__ret = entry[1'd0];
    for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 ) begin
      next_entry[1'(i)] = entry[1'(i)];
      entry_alloc__free[1'(i)] = 1'd0;
    end
    if ( clear_br__en ) begin
      if ( clear_br__msg.kill ) begin
        for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
          if ( ( entry[1'(i)].br_tag & clear_br__msg.br_mask ) != 2'd0 ) begin
            next_entry[1'(i)].killed = 1'd1;
          end
      end
      else
        for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_comb ); i += 1'd1 )
          if ( ( entry[1'(i)].br_tag & clear_br__msg.br_mask ) != 2'd0 ) begin
            next_entry[1'(i)].br_tag = entry[1'(i)].br_tag & ( ~clear_br__msg.br_mask );
          end
    end
    if ( complete__en ) begin
      __tmpvar__up_comb_idx = complete__msg;
      complete__ret = next_entry[__tmpvar__up_comb_idx];
      entry_alloc__free[__tmpvar__up_comb_idx] = 1'd1;
    end
    if ( allocate__en ) begin
      __tmpvar__up_comb_idx = entry_alloc__allocate__ret;
      next_entry[__tmpvar__up_comb_idx] = allocate__msg;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedTableRTL.py:65
  // @update_ff
  // def up_ff():
  //   if s.reset:
  //     for i in range( num_entries ):
  //       s.entry[ i ]  <<= EntryType()
  //   else:
  //     for i in range( num_entries ):
  //       s.entry[ i ]  <<= s.next_entry[ i ]
  
  always_ff @(posedge clk) begin : up_ff
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 )
        entry[1'(i)] <= { 32'd0, 1'd0, 2'd0, 3'd0, 1'd0, 7'd0, 1'd0, 32'd0, 1'd0 };
    end
    else
      for ( int unsigned i = 1'd0; i < 2'( __const__num_entries_at_up_ff ); i += 1'd1 )
        entry[1'(i)] <= next_entry[1'(i)];
  end

  assign entry_alloc__clk = clk;
  assign entry_alloc__reset = reset;
  assign entry_alloc__allocate__en = allocate__en;
  assign allocate__rdy = entry_alloc__allocate__rdy;
  assign allocate__ret = entry_alloc__allocate__ret;

endmodule


// PyMTL Component NormalQueue1EntryRTL Definition
// Full name: NormalQueue1EntryRTL__EntryType_MemExecuteStruct__af5802ecac25c83f
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueue1EntryRTL__a7c5051a6a3819e6
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MemExecuteStruct__af5802ecac25c83f deq__ret  ,
  input logic [0:0] enq__en  ,
  input MemExecuteStruct__af5802ecac25c83f enq__msg  ,
  output logic [0:0] enq__rdy  
);
  MemExecuteStruct__af5802ecac25c83f entry;
  logic [0:0] full;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:453
  // s.deq.rdy //= lambda: ~s.reset & s.full
  
  always_comb begin : _lambda__s_procs_0__mem_flow_fence_q_q_deq_rdy
    deq__rdy = ( ~reset ) & full;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:452
  // s.enq.rdy //= lambda: ~s.reset & ~s.full
  
  always_comb begin : _lambda__s_procs_0__mem_flow_fence_q_q_enq_rdy
    enq__rdy = ( ~reset ) & ( ~full );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py:455
  // @update_ff
  // def ff_normal1():
  //   s.full <<= ~s.reset & ( ~s.deq.en & (s.enq.en | s.full) )
  //   if s.enq.en:
  //     s.entry <<= s.enq.msg
  
  always_ff @(posedge clk) begin : ff_normal1
    full <= ( ~reset ) & ( ( ~deq__en ) & ( enq__en | full ) );
    if ( enq__en ) begin
      entry <= enq__msg;
    end
  end

  assign count = full;
  assign deq__ret = entry;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__EntryType_MemExecuteStruct__af5802ecac25c83f__num_entries_1
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/queues/queues.py

module NormalQueueRTL__070347defe7eba11
(
  input  logic [0:0] clk ,
  output logic [0:0] count ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output MemExecuteStruct__af5802ecac25c83f deq__ret  ,
  input logic [0:0] enq__en  ,
  input MemExecuteStruct__af5802ecac25c83f enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component q
  //-------------------------------------------------------------

  logic [0:0] q__clk;
  logic [0:0] q__count;
  logic [0:0] q__reset;
  logic [0:0] q__deq__en;
  logic [0:0] q__deq__rdy;
  MemExecuteStruct__af5802ecac25c83f q__deq__ret;
  logic [0:0] q__enq__en;
  MemExecuteStruct__af5802ecac25c83f q__enq__msg;
  logic [0:0] q__enq__rdy;

  NormalQueue1EntryRTL__a7c5051a6a3819e6 q
  (
    .clk( q__clk ),
    .count( q__count ),
    .reset( q__reset ),
    .deq__en( q__deq__en ),
    .deq__rdy( q__deq__rdy ),
    .deq__ret( q__deq__ret ),
    .enq__en( q__enq__en ),
    .enq__msg( q__enq__msg ),
    .enq__rdy( q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component q
  //-------------------------------------------------------------

  assign q__clk = clk;
  assign q__reset = reset;
  assign q__enq__en = enq__en;
  assign q__enq__msg = enq__msg;
  assign enq__rdy = q__enq__rdy;
  assign q__deq__en = deq__en;
  assign deq__rdy = q__deq__rdy;
  assign deq__ret = q__deq__ret;
  assign count = q__count;

endmodule


// PyMTL Component MemFlowManagerRTL Definition
// Full name: MemFlowManagerRTL__num_ld_entries_2__num_st_entries_2__num_amo_entries_2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/MemFlowManagerRTL.py

module MemFlowManagerRTL__a29f503bbf1fc2da
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  output logic [0:0] complete_mem__en  ,
  output MemCompleteStruct__c5bd3cabb5deb86b complete_mem__msg  ,
  input logic [0:0] complete_mem__rdy  ,
  output logic [0:0] dmem__req__en ,
  output MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 dmem__req__msg ,
  input logic [0:0] dmem__req__rdy ,
  input logic [0:0] dmem__resp__en ,
  input MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 dmem__resp__msg ,
  output logic [0:0] dmem__resp__rdy ,
  input logic [0:0] execute_mem__en  ,
  input MemExecuteStruct__af5802ecac25c83f execute_mem__msg  ,
  output logic [0:0] execute_mem__suc  
);
  localparam logic [3:0] __const__mem_f  = 4'd12;
  localparam logic [3:0] __const__mem_ld  = 4'd1;
  localparam logic [3:0] __const__mem_st  = 4'd2;
  localparam logic [3:0] __const__mem_add  = 4'd3;
  localparam logic [3:0] __const__mem_and  = 4'd4;
  localparam logic [3:0] __const__mem_max  = 4'd9;
  localparam logic [3:0] __const__mem_maxu  = 4'd10;
  localparam logic [3:0] __const__mem_min  = 4'd7;
  localparam logic [3:0] __const__mem_minu  = 4'd8;
  localparam logic [3:0] __const__mem_or  = 4'd5;
  localparam logic [3:0] __const__mem_swp  = 4'd6;
  localparam logic [3:0] __const__mem_xor  = 4'd11;
  localparam logic [0:0] __const__ld_idx_nbits_at_up_complete  = 1'd1;
  localparam logic [0:0] __const__st_idx_nbits_at_up_complete  = 1'd1;
  localparam logic [0:0] __const__amo_idx_nbits_at_up_complete  = 1'd1;
  localparam logic [1:0] __const__mlen_b  = 2'd1;
  localparam logic [0:0] __const__se  = 1'd0;
  localparam logic [1:0] __const__mlen_h  = 2'd2;
  logic [0:0] send_inv_reg;
  //-------------------------------------------------------------
  // Component amo_q
  //-------------------------------------------------------------

  logic [0:0] amo_q__clk;
  logic [0:0] amo_q__reset;
  logic [0:0] amo_q__allocate__en;
  MemCompleteStruct__c5bd3cabb5deb86b amo_q__allocate__msg;
  logic [0:0] amo_q__allocate__rdy;
  logic [0:0] amo_q__allocate__ret;
  logic [0:0] amo_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 amo_q__clear_br__msg;
  logic [0:0] amo_q__complete__en;
  logic [0:0] amo_q__complete__msg;
  logic [0:0] amo_q__complete__rdy;
  MemCompleteStruct__c5bd3cabb5deb86b amo_q__complete__ret;

  TaggedTableRTL__a82100b5ae07ef48 amo_q
  (
    .clk( amo_q__clk ),
    .reset( amo_q__reset ),
    .allocate__en( amo_q__allocate__en ),
    .allocate__msg( amo_q__allocate__msg ),
    .allocate__rdy( amo_q__allocate__rdy ),
    .allocate__ret( amo_q__allocate__ret ),
    .clear_br__en( amo_q__clear_br__en ),
    .clear_br__msg( amo_q__clear_br__msg ),
    .complete__en( amo_q__complete__en ),
    .complete__msg( amo_q__complete__msg ),
    .complete__rdy( amo_q__complete__rdy ),
    .complete__ret( amo_q__complete__ret )
  );

  //-------------------------------------------------------------
  // End of component amo_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fence_q
  //-------------------------------------------------------------

  logic [0:0] fence_q__clk;
  logic [0:0] fence_q__count;
  logic [0:0] fence_q__reset;
  logic [0:0] fence_q__deq__en;
  logic [0:0] fence_q__deq__rdy;
  MemExecuteStruct__af5802ecac25c83f fence_q__deq__ret;
  logic [0:0] fence_q__enq__en;
  MemExecuteStruct__af5802ecac25c83f fence_q__enq__msg;
  logic [0:0] fence_q__enq__rdy;

  NormalQueueRTL__070347defe7eba11 fence_q
  (
    .clk( fence_q__clk ),
    .count( fence_q__count ),
    .reset( fence_q__reset ),
    .deq__en( fence_q__deq__en ),
    .deq__rdy( fence_q__deq__rdy ),
    .deq__ret( fence_q__deq__ret ),
    .enq__en( fence_q__enq__en ),
    .enq__msg( fence_q__enq__msg ),
    .enq__rdy( fence_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component fence_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ld_q
  //-------------------------------------------------------------

  logic [0:0] ld_q__clk;
  logic [0:0] ld_q__reset;
  logic [0:0] ld_q__allocate__en;
  MemCompleteStruct__c5bd3cabb5deb86b ld_q__allocate__msg;
  logic [0:0] ld_q__allocate__rdy;
  logic [0:0] ld_q__allocate__ret;
  logic [0:0] ld_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 ld_q__clear_br__msg;
  logic [0:0] ld_q__complete__en;
  logic [0:0] ld_q__complete__msg;
  logic [0:0] ld_q__complete__rdy;
  MemCompleteStruct__c5bd3cabb5deb86b ld_q__complete__ret;

  TaggedTableRTL__a82100b5ae07ef48 ld_q
  (
    .clk( ld_q__clk ),
    .reset( ld_q__reset ),
    .allocate__en( ld_q__allocate__en ),
    .allocate__msg( ld_q__allocate__msg ),
    .allocate__rdy( ld_q__allocate__rdy ),
    .allocate__ret( ld_q__allocate__ret ),
    .clear_br__en( ld_q__clear_br__en ),
    .clear_br__msg( ld_q__clear_br__msg ),
    .complete__en( ld_q__complete__en ),
    .complete__msg( ld_q__complete__msg ),
    .complete__rdy( ld_q__complete__rdy ),
    .complete__ret( ld_q__complete__ret )
  );

  //-------------------------------------------------------------
  // End of component ld_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component st_q
  //-------------------------------------------------------------

  logic [0:0] st_q__clk;
  logic [0:0] st_q__reset;
  logic [0:0] st_q__allocate__en;
  MemCompleteStruct__c5bd3cabb5deb86b st_q__allocate__msg;
  logic [0:0] st_q__allocate__rdy;
  logic [0:0] st_q__allocate__ret;
  logic [0:0] st_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 st_q__clear_br__msg;
  logic [0:0] st_q__complete__en;
  logic [0:0] st_q__complete__msg;
  logic [0:0] st_q__complete__rdy;
  MemCompleteStruct__c5bd3cabb5deb86b st_q__complete__ret;

  TaggedTableRTL__a82100b5ae07ef48 st_q
  (
    .clk( st_q__clk ),
    .reset( st_q__reset ),
    .allocate__en( st_q__allocate__en ),
    .allocate__msg( st_q__allocate__msg ),
    .allocate__rdy( st_q__allocate__rdy ),
    .allocate__ret( st_q__allocate__ret ),
    .clear_br__en( st_q__clear_br__en ),
    .clear_br__msg( st_q__clear_br__msg ),
    .complete__en( st_q__complete__en ),
    .complete__msg( st_q__complete__msg ),
    .complete__rdy( st_q__complete__rdy ),
    .complete__ret( st_q__complete__ret )
  );

  //-------------------------------------------------------------
  // End of component st_q
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/MemFlowManagerRTL.py:81
  // @update
  // def up_clear_br():
  //   # Only ld_q can hold speculative instructions and therefore needs
  //   # to be connected to clear_br interface. Other queues cannot hold
  //   # speculative entries, so we just disable their clear_br interface
  //   s.ld_q.clear_br.en    @= s.clear_br.en
  //   s.ld_q.clear_br.msg   @= s.clear_br.msg
  //   s.st_q.clear_br.en    @= 0
  //   s.st_q.clear_br.msg   @= ClearBrStruct()
  //   s.amo_q.clear_br.en   @= 0
  //   s.amo_q.clear_br.msg  @= ClearBrStruct()
  
  always_comb begin : up_clear_br
    ld_q__clear_br__en = clear_br__en;
    ld_q__clear_br__msg = clear_br__msg;
    st_q__clear_br__en = 1'd0;
    st_q__clear_br__msg = { 1'd0, 2'd0, 32'd0, 1'd0, 3'd0, 3'd0, 2'd0 };
    amo_q__clear_br__en = 1'd0;
    amo_q__clear_br__msg = { 1'd0, 2'd0, 32'd0, 1'd0, 3'd0, 3'd0, 2'd0 };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/MemFlowManagerRTL.py:259
  // @update
  // def up_complete():
  // 
  //   # dmem resp ready
  //   s.dmem.resp.rdy @=  ~s.reset & s.complete_mem.rdy & \
  //                       ( s.ld_q.complete.rdy | s.st_q.complete.rdy | \
  //                         s.amo_q.complete.rdy | s.fence_q.deq.rdy )
  // 
  //   # default
  //   s.fence_q.deq.en @= 0
  // 
  //   s.ld_q.complete.en @= 0
  //   for i in range( ld_idx_nbits ):
  //     s.ld_q.complete.msg[ i ] @= s.dmem.resp.msg.opaque[ i ]
  // 
  //   s.st_q.complete.en @= 0
  //   for i in range( st_idx_nbits ):
  //     s.st_q.complete.msg[ i ] @= s.dmem.resp.msg.opaque[ i ]
  // 
  //   s.amo_q.complete.en @= 0
  //   for i in range( amo_idx_nbits ):
  //     s.amo_q.complete.msg[ i ] @= s.dmem.resp.msg.opaque[ i ]
  // 
  //   s.complete_mem.en  @= 0
  //   s.complete_mem.msg @= MemCompleteStruct()
  // 
  //   # complete a mem from dmem resp
  //   if  s.dmem.resp.en:
  // 
  //     # load resp
  //     if s.dmem.resp.msg.type_ == MemMsgType.READ:
  // 
  //       s.ld_q.complete.en @= 1
  // 
  //       # if not killed, complete this inst
  //       if ~s.ld_q.complete.ret.killed:
  //         s.complete_mem.en           @= 1
  //         s.complete_mem.msg.pc       @= s.ld_q.complete.ret.pc
  //         s.complete_mem.msg.inst_val @= s.ld_q.complete.ret.inst_val
  //         s.complete_mem.msg.br_tag   @= s.ld_q.complete.ret.br_tag
  //         s.complete_mem.msg.rob_idx  @= s.ld_q.complete.ret.rob_idx
  //         s.complete_mem.msg.rd_en    @= s.ld_q.complete.ret.rd_en
  //         s.complete_mem.msg.rd_preg  @= s.ld_q.complete.ret.rd_preg
  //         s.complete_mem.msg.killed   @= 0
  // 
  //         if  s.dmem.resp.msg.len == mlen_b:
  //           if s.ld_q.complete.ret.mem_ext == se:
  //             s.complete_mem.msg.data @= sext( s.dmem.resp.msg.data[ 0:8 ], 32 )
  //           else:
  //             s.complete_mem.msg.data @= zext( s.dmem.resp.msg.data[ 0:8 ], 32 )
  // 
  //         elif  s.dmem.resp.msg.len == mlen_h:
  //           if s.ld_q.complete.ret.mem_ext == se:
  //             s.complete_mem.msg.data @= sext( s.dmem.resp.msg.data[ 0:16 ], 32 )
  //           else:
  //             s.complete_mem.msg.data @= zext( s.dmem.resp.msg.data[ 0:16 ], 32 )
  // 
  //         else:
  //           s.complete_mem.msg.data @= s.dmem.resp.msg.data
  // 
  //     # store resp
  //     elif s.dmem.resp.msg.type_ == MemMsgType.WRITE:
  // 
  //       s.st_q.complete.en          @= 1
  //       s.complete_mem.en           @= 1
  //       s.complete_mem.msg.pc       @= s.st_q.complete.ret.pc
  //       s.complete_mem.msg.inst_val @= s.st_q.complete.ret.inst_val
  //       s.complete_mem.msg.br_tag   @= s.st_q.complete.ret.br_tag
  //       s.complete_mem.msg.rob_idx  @= s.st_q.complete.ret.rob_idx
  //       s.complete_mem.msg.rd_en    @= s.st_q.complete.ret.rd_en
  //       s.complete_mem.msg.rd_preg  @= s.st_q.complete.ret.rd_preg
  //       s.complete_mem.msg.data     @= 0
  //       s.complete_mem.msg.killed   @= 0
  // 
  //     # amo resp
  //     elif  ( s.dmem.resp.msg.type_ == MemMsgType.AMO_ADD   ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_AND   ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_MAX   ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_MAXU  ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_MIN   ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_MINU  ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_OR    ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_SWAP  ) | \
  //           ( s.dmem.resp.msg.type_ == MemMsgType.AMO_XOR   ):
  // 
  //       s.amo_q.complete.en         @= 1
  //       s.complete_mem.en           @= 1
  //       s.complete_mem.msg.pc       @= s.amo_q.complete.ret.pc
  //       s.complete_mem.msg.inst_val @= s.amo_q.complete.ret.inst_val
  //       s.complete_mem.msg.br_tag   @= s.amo_q.complete.ret.br_tag
  //       s.complete_mem.msg.rob_idx  @= s.amo_q.complete.ret.rob_idx
  //       s.complete_mem.msg.rd_en    @= s.amo_q.complete.ret.rd_en
  //       s.complete_mem.msg.rd_preg  @= s.amo_q.complete.ret.rd_preg
  //       s.complete_mem.msg.data     @= s.dmem.resp.msg.data
  //       s.complete_mem.msg.killed   @= 0
  // 
  //     # flush resp
  //     elif  s.dmem.resp.msg.type_ == MemMsgType.FLUSH:
  // 
  //       # if there is no following INV, complete this fence
  //       if ~s.fence_q.deq.ret.inv:
  //         s.fence_q.deq.en            @= 1
  //         s.complete_mem.en           @= 1
  //         s.complete_mem.msg.pc       @= s.fence_q.deq.ret.pc
  //         s.complete_mem.msg.inst_val @= s.fence_q.deq.ret.inst_val
  //         s.complete_mem.msg.br_tag   @= s.fence_q.deq.ret.br_tag
  //         s.complete_mem.msg.rob_idx  @= s.fence_q.deq.ret.rob_idx
  //         s.complete_mem.msg.rd_en    @= s.fence_q.deq.ret.rd_en
  //         s.complete_mem.msg.rd_preg  @= s.fence_q.deq.ret.rd_preg
  //         s.complete_mem.msg.data     @= 0
  //         s.complete_mem.msg.killed   @= 0
  // 
  //     # inv resp
  //     elif  s.dmem.resp.msg.type_ == MemMsgType.INV:
  // 
  //       s.fence_q.deq.en            @= 1
  //       s.complete_mem.en           @= 1
  //       s.complete_mem.msg.pc       @= s.fence_q.deq.ret.pc
  //       s.complete_mem.msg.inst_val @= s.fence_q.deq.ret.inst_val
  //       s.complete_mem.msg.br_tag   @= s.fence_q.deq.ret.br_tag
  //       s.complete_mem.msg.rob_idx  @= s.fence_q.deq.ret.rob_idx
  //       s.complete_mem.msg.rd_en    @= s.fence_q.deq.ret.rd_en
  //       s.complete_mem.msg.rd_preg  @= s.fence_q.deq.ret.rd_preg
  //       s.complete_mem.msg.data     @= 0
  //       s.complete_mem.msg.killed   @= 0
  
  always_comb begin : up_complete
    dmem__resp__rdy = ( ( ~reset ) & complete_mem__rdy ) & ( ( ( ld_q__complete__rdy | st_q__complete__rdy ) | amo_q__complete__rdy ) | fence_q__deq__rdy );
    fence_q__deq__en = 1'd0;
    ld_q__complete__en = 1'd0;
    for ( int unsigned i = 1'd0; i < 1'( __const__ld_idx_nbits_at_up_complete ); i += 1'd1 )
      ld_q__complete__msg[1'(i)] = dmem__resp__msg.opaque[3'(i)];
    st_q__complete__en = 1'd0;
    for ( int unsigned i = 1'd0; i < 1'( __const__st_idx_nbits_at_up_complete ); i += 1'd1 )
      st_q__complete__msg[1'(i)] = dmem__resp__msg.opaque[3'(i)];
    amo_q__complete__en = 1'd0;
    for ( int unsigned i = 1'd0; i < 1'( __const__amo_idx_nbits_at_up_complete ); i += 1'd1 )
      amo_q__complete__msg[1'(i)] = dmem__resp__msg.opaque[3'(i)];
    complete_mem__en = 1'd0;
    complete_mem__msg = { 32'd0, 1'd0, 2'd0, 3'd0, 1'd0, 7'd0, 1'd0, 32'd0, 1'd0 };
    if ( dmem__resp__en ) begin
      if ( dmem__resp__msg.type_ == 4'd0 ) begin
        ld_q__complete__en = 1'd1;
        if ( ~ld_q__complete__ret.killed ) begin
          complete_mem__en = 1'd1;
          complete_mem__msg.pc = ld_q__complete__ret.pc;
          complete_mem__msg.inst_val = ld_q__complete__ret.inst_val;
          complete_mem__msg.br_tag = ld_q__complete__ret.br_tag;
          complete_mem__msg.rob_idx = ld_q__complete__ret.rob_idx;
          complete_mem__msg.rd_en = ld_q__complete__ret.rd_en;
          complete_mem__msg.rd_preg = ld_q__complete__ret.rd_preg;
          complete_mem__msg.killed = 1'd0;
          if ( dmem__resp__msg.len == 2'( __const__mlen_b ) ) begin
            if ( ld_q__complete__ret.mem_ext == 1'( __const__se ) ) begin
              complete_mem__msg.data = { { 24 { dmem__resp__msg.data[5'd7] } }, dmem__resp__msg.data[5'd7:5'd0] };
            end
            else
              complete_mem__msg.data = { { 24 { 1'b0 } }, dmem__resp__msg.data[5'd7:5'd0] };
          end
          else if ( dmem__resp__msg.len == 2'( __const__mlen_h ) ) begin
            if ( ld_q__complete__ret.mem_ext == 1'( __const__se ) ) begin
              complete_mem__msg.data = { { 16 { dmem__resp__msg.data[5'd15] } }, dmem__resp__msg.data[5'd15:5'd0] };
            end
            else
              complete_mem__msg.data = { { 16 { 1'b0 } }, dmem__resp__msg.data[5'd15:5'd0] };
          end
          else
            complete_mem__msg.data = dmem__resp__msg.data;
        end
      end
      else if ( dmem__resp__msg.type_ == 4'd1 ) begin
        st_q__complete__en = 1'd1;
        complete_mem__en = 1'd1;
        complete_mem__msg.pc = st_q__complete__ret.pc;
        complete_mem__msg.inst_val = st_q__complete__ret.inst_val;
        complete_mem__msg.br_tag = st_q__complete__ret.br_tag;
        complete_mem__msg.rob_idx = st_q__complete__ret.rob_idx;
        complete_mem__msg.rd_en = st_q__complete__ret.rd_en;
        complete_mem__msg.rd_preg = st_q__complete__ret.rd_preg;
        complete_mem__msg.data = 32'd0;
        complete_mem__msg.killed = 1'd0;
      end
      else if ( ( ( ( ( ( ( ( ( dmem__resp__msg.type_ == 4'd3 ) | ( dmem__resp__msg.type_ == 4'd4 ) ) | ( dmem__resp__msg.type_ == 4'd9 ) ) | ( dmem__resp__msg.type_ == 4'd10 ) ) | ( dmem__resp__msg.type_ == 4'd7 ) ) | ( dmem__resp__msg.type_ == 4'd8 ) ) | ( dmem__resp__msg.type_ == 4'd5 ) ) | ( dmem__resp__msg.type_ == 4'd6 ) ) | ( dmem__resp__msg.type_ == 4'd11 ) ) begin
        amo_q__complete__en = 1'd1;
        complete_mem__en = 1'd1;
        complete_mem__msg.pc = amo_q__complete__ret.pc;
        complete_mem__msg.inst_val = amo_q__complete__ret.inst_val;
        complete_mem__msg.br_tag = amo_q__complete__ret.br_tag;
        complete_mem__msg.rob_idx = amo_q__complete__ret.rob_idx;
        complete_mem__msg.rd_en = amo_q__complete__ret.rd_en;
        complete_mem__msg.rd_preg = amo_q__complete__ret.rd_preg;
        complete_mem__msg.data = dmem__resp__msg.data;
        complete_mem__msg.killed = 1'd0;
      end
      else if ( dmem__resp__msg.type_ == 4'd15 ) begin
        if ( ~fence_q__deq__ret.inv ) begin
          fence_q__deq__en = 1'd1;
          complete_mem__en = 1'd1;
          complete_mem__msg.pc = fence_q__deq__ret.pc;
          complete_mem__msg.inst_val = fence_q__deq__ret.inst_val;
          complete_mem__msg.br_tag = fence_q__deq__ret.br_tag;
          complete_mem__msg.rob_idx = fence_q__deq__ret.rob_idx;
          complete_mem__msg.rd_en = fence_q__deq__ret.rd_en;
          complete_mem__msg.rd_preg = fence_q__deq__ret.rd_preg;
          complete_mem__msg.data = 32'd0;
          complete_mem__msg.killed = 1'd0;
        end
      end
      else if ( dmem__resp__msg.type_ == 4'd14 ) begin
        fence_q__deq__en = 1'd1;
        complete_mem__en = 1'd1;
        complete_mem__msg.pc = fence_q__deq__ret.pc;
        complete_mem__msg.inst_val = fence_q__deq__ret.inst_val;
        complete_mem__msg.br_tag = fence_q__deq__ret.br_tag;
        complete_mem__msg.rob_idx = fence_q__deq__ret.rob_idx;
        complete_mem__msg.rd_en = fence_q__deq__ret.rd_en;
        complete_mem__msg.rd_preg = fence_q__deq__ret.rd_preg;
        complete_mem__msg.data = 32'd0;
        complete_mem__msg.killed = 1'd0;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/MemFlowManagerRTL.py:97
  // @update
  // def up_execute():
  // 
  //   # default
  //   s.execute_mem.suc     @= 0
  // 
  //   s.dmem.req.en         @= 0
  //   s.dmem.req.msg.type_  @= 0
  //   s.dmem.req.msg.opaque @= 0
  //   s.dmem.req.msg.addr   @= 0
  //   s.dmem.req.msg.len    @= 0
  //   s.dmem.req.msg.data   @= 0
  // 
  //   s.fence_q.enq.en      @= 0
  //   s.fence_q.enq.msg     @= s.execute_mem.msg
  // 
  //   s.ld_q.allocate.en            @= 0
  //   s.ld_q.allocate.msg.pc        @= s.execute_mem.msg.pc
  //   s.ld_q.allocate.msg.inst_val  @= s.execute_mem.msg.inst_val
  //   s.ld_q.allocate.msg.br_tag    @= s.execute_mem.msg.br_tag
  //   s.ld_q.allocate.msg.rob_idx   @= s.execute_mem.msg.rob_idx
  //   s.ld_q.allocate.msg.rd_en     @= s.execute_mem.msg.rd_en
  //   s.ld_q.allocate.msg.rd_preg   @= s.execute_mem.msg.rd_preg
  //   s.ld_q.allocate.msg.mem_ext   @= s.execute_mem.msg.mem_ext
  //   s.ld_q.allocate.msg.data      @= 0
  //   s.ld_q.allocate.msg.killed    @= 0
  // 
  //   s.st_q.allocate.en            @= 0
  //   s.st_q.allocate.msg.pc        @= s.execute_mem.msg.pc
  //   s.st_q.allocate.msg.inst_val  @= s.execute_mem.msg.inst_val
  //   s.st_q.allocate.msg.br_tag    @= s.execute_mem.msg.br_tag
  //   s.st_q.allocate.msg.rob_idx   @= s.execute_mem.msg.rob_idx
  //   s.st_q.allocate.msg.rd_en     @= s.execute_mem.msg.rd_en
  //   s.st_q.allocate.msg.rd_preg   @= s.execute_mem.msg.rd_preg
  //   s.st_q.allocate.msg.mem_ext   @= 0     # don't care
  //   s.st_q.allocate.msg.data      @= 0
  //   s.st_q.allocate.msg.killed    @= 0
  // 
  //   s.amo_q.allocate.en           @= 0
  //   s.amo_q.allocate.msg.pc       @= s.execute_mem.msg.pc
  //   s.amo_q.allocate.msg.inst_val @= s.execute_mem.msg.inst_val
  //   s.amo_q.allocate.msg.br_tag   @= s.execute_mem.msg.br_tag
  //   s.amo_q.allocate.msg.rob_idx  @= s.execute_mem.msg.rob_idx
  //   s.amo_q.allocate.msg.rd_en    @= s.execute_mem.msg.rd_en
  //   s.amo_q.allocate.msg.rd_preg  @= s.execute_mem.msg.rd_preg
  //   s.amo_q.allocate.msg.mem_ext  @= 0
  //   s.amo_q.allocate.msg.data     @= 0
  //   s.amo_q.allocate.msg.killed   @= 0
  // 
  //   #
  //   # pending fence, wait and send INV if necessary
  //   #
  //   if s.fence_q.deq.rdy:
  // 
  //     if s.send_inv_reg & s.dmem.req.rdy:
  //       s.dmem.req.en         @= 1
  //       s.dmem.req.msg.type_  @= MemMsgType.INV
  //       s.dmem.req.msg.opaque @= 0
  //       s.dmem.req.msg.addr   @= 0
  //       s.dmem.req.msg.len    @= 0
  // 
  //   #
  //   # No pending fence, try to issue a request to dmem
  //   #
  //   elif s.execute_mem.en:
  // 
  //     # A fence must wait for all pending LD, ST, AMO and fence to
  //     # complete before it can be executed.
  //     # Also fences are non-speculatively executed (i.e., its branch tag
  //     # is zero)
  //     if    ( s.execute_mem.msg.mem_type == mem_f ) & \
  //           ~s.ld_q.complete.rdy                    & \
  //           ~s.st_q.complete.rdy                    & \
  //           ~s.amo_q.complete.rdy                   & \
  //           s.fence_q.enq.rdy                       & \
  //           ( s.execute_mem.msg.br_tag == 0 ):
  // 
  //       if    s.execute_mem.msg.fls & s.dmem.req.rdy:
  //         s.execute_mem.suc     @= 1
  //         s.fence_q.enq.en      @= 1
  // 
  //         s.dmem.req.en         @= 1
  //         s.dmem.req.msg.type_  @= MemMsgType.FLUSH
  //         s.dmem.req.msg.opaque @= 0
  //         s.dmem.req.msg.addr   @= 0
  //         s.dmem.req.msg.len    @= 0
  // 
  //       elif  s.execute_mem.msg.inv & s.dmem.req.rdy:
  //         s.execute_mem.suc     @= 1
  //         s.fence_q.enq.en      @= 1
  // 
  //         s.dmem.req.en         @= 1
  //         s.dmem.req.msg.type_  @= MemMsgType.INV
  //         s.dmem.req.msg.opaque @= 0
  //         s.dmem.req.msg.addr   @= 0
  //         s.dmem.req.msg.len    @= 0
  // 
  //     # Load req: no need to check for memory conflict since we execute
  //     # memory instructions in order
  //     elif  ( s.execute_mem.msg.mem_type == mem_ld )  & \
  //           s.ld_q.allocate.rdy                       & \
  //           s.dmem.req.rdy:
  //       s.execute_mem.suc     @= 1
  //       s.ld_q.allocate.en    @= 1
  // 
  //       s.dmem.req.en         @= 1
  //       s.dmem.req.msg.type_  @= MemMsgType.READ
  //       s.dmem.req.msg.opaque @= zext( s.ld_q.allocate.ret, 8 )
  //       s.dmem.req.msg.addr   @= s.execute_mem.msg.mem_addr
  //       s.dmem.req.msg.len    @= s.execute_mem.msg.mem_len
  // 
  //     # Store req: stores are non-speculatively executed
  //     elif  ( s.execute_mem.msg.mem_type == mem_st )  & \
  //           s.st_q.allocate.rdy                       & \
  //           s.dmem.req.rdy                            & \
  //           ( s.execute_mem.msg.br_tag == 0 ):
  //       s.execute_mem.suc     @= 1
  //       s.st_q.allocate.en    @= 1
  // 
  //       s.dmem.req.en         @= 1
  //       s.dmem.req.msg.type_  @= MemMsgType.WRITE
  //       s.dmem.req.msg.opaque @= zext( s.st_q.allocate.ret, 8 )
  //       s.dmem.req.msg.addr   @= s.execute_mem.msg.mem_addr
  //       s.dmem.req.msg.len    @= s.execute_mem.msg.mem_len
  //       s.dmem.req.msg.data   @= s.execute_mem.msg.st_data
  // 
  //     # AMO req: AMOs are non-speculatively executed
  //     elif  ( s.execute_mem.msg.mem_type == mem_add  ) | \
  //           ( s.execute_mem.msg.mem_type == mem_and  ) | \
  //           ( s.execute_mem.msg.mem_type == mem_max  ) | \
  //           ( s.execute_mem.msg.mem_type == mem_maxu ) | \
  //           ( s.execute_mem.msg.mem_type == mem_min  ) | \
  //           ( s.execute_mem.msg.mem_type == mem_minu ) | \
  //           ( s.execute_mem.msg.mem_type == mem_or   ) | \
  //           ( s.execute_mem.msg.mem_type == mem_swp  ) | \
  //           ( s.execute_mem.msg.mem_type == mem_xor  ):
  // 
  //       if  s.amo_q.allocate.rdy  & \
  //           s.dmem.req.rdy        & \
  //           ( s.execute_mem.msg.br_tag == 0 ):
  //         s.execute_mem.suc   @= 1
  //         s.amo_q.allocate.en @= 1
  // 
  //         s.dmem.req.en       @= 1
  //         if   ( s.execute_mem.msg.mem_type == mem_add  ): s.dmem.req.msg.type_ @= MemMsgType.AMO_ADD
  //         elif ( s.execute_mem.msg.mem_type == mem_and  ): s.dmem.req.msg.type_ @= MemMsgType.AMO_AND
  //         elif ( s.execute_mem.msg.mem_type == mem_max  ): s.dmem.req.msg.type_ @= MemMsgType.AMO_MAX
  //         elif ( s.execute_mem.msg.mem_type == mem_maxu ): s.dmem.req.msg.type_ @= MemMsgType.AMO_MAXU
  //         elif ( s.execute_mem.msg.mem_type == mem_min  ): s.dmem.req.msg.type_ @= MemMsgType.AMO_MIN
  //         elif ( s.execute_mem.msg.mem_type == mem_minu ): s.dmem.req.msg.type_ @= MemMsgType.AMO_MINU
  //         elif ( s.execute_mem.msg.mem_type == mem_or   ): s.dmem.req.msg.type_ @= MemMsgType.AMO_OR
  //         elif ( s.execute_mem.msg.mem_type == mem_swp  ): s.dmem.req.msg.type_ @= MemMsgType.AMO_SWAP
  //         elif ( s.execute_mem.msg.mem_type == mem_xor  ): s.dmem.req.msg.type_ @= MemMsgType.AMO_XOR
  //         s.dmem.req.msg.opaque @= zext( s.amo_q.allocate.ret, 8 )
  //         s.dmem.req.msg.addr   @= s.execute_mem.msg.mem_addr
  //         s.dmem.req.msg.len    @= s.execute_mem.msg.mem_len
  //         s.dmem.req.msg.data   @= s.execute_mem.msg.st_data
  
  always_comb begin : up_execute
    execute_mem__suc = 1'd0;
    dmem__req__en = 1'd0;
    dmem__req__msg.type_ = 4'd0;
    dmem__req__msg.opaque = 8'd0;
    dmem__req__msg.addr = 32'd0;
    dmem__req__msg.len = 2'd0;
    dmem__req__msg.data = 32'd0;
    fence_q__enq__en = 1'd0;
    fence_q__enq__msg = execute_mem__msg;
    ld_q__allocate__en = 1'd0;
    ld_q__allocate__msg.pc = execute_mem__msg.pc;
    ld_q__allocate__msg.inst_val = execute_mem__msg.inst_val;
    ld_q__allocate__msg.br_tag = execute_mem__msg.br_tag;
    ld_q__allocate__msg.rob_idx = execute_mem__msg.rob_idx;
    ld_q__allocate__msg.rd_en = execute_mem__msg.rd_en;
    ld_q__allocate__msg.rd_preg = execute_mem__msg.rd_preg;
    ld_q__allocate__msg.mem_ext = execute_mem__msg.mem_ext;
    ld_q__allocate__msg.data = 32'd0;
    ld_q__allocate__msg.killed = 1'd0;
    st_q__allocate__en = 1'd0;
    st_q__allocate__msg.pc = execute_mem__msg.pc;
    st_q__allocate__msg.inst_val = execute_mem__msg.inst_val;
    st_q__allocate__msg.br_tag = execute_mem__msg.br_tag;
    st_q__allocate__msg.rob_idx = execute_mem__msg.rob_idx;
    st_q__allocate__msg.rd_en = execute_mem__msg.rd_en;
    st_q__allocate__msg.rd_preg = execute_mem__msg.rd_preg;
    st_q__allocate__msg.mem_ext = 1'd0;
    st_q__allocate__msg.data = 32'd0;
    st_q__allocate__msg.killed = 1'd0;
    amo_q__allocate__en = 1'd0;
    amo_q__allocate__msg.pc = execute_mem__msg.pc;
    amo_q__allocate__msg.inst_val = execute_mem__msg.inst_val;
    amo_q__allocate__msg.br_tag = execute_mem__msg.br_tag;
    amo_q__allocate__msg.rob_idx = execute_mem__msg.rob_idx;
    amo_q__allocate__msg.rd_en = execute_mem__msg.rd_en;
    amo_q__allocate__msg.rd_preg = execute_mem__msg.rd_preg;
    amo_q__allocate__msg.mem_ext = 1'd0;
    amo_q__allocate__msg.data = 32'd0;
    amo_q__allocate__msg.killed = 1'd0;
    if ( fence_q__deq__rdy ) begin
      if ( send_inv_reg & dmem__req__rdy ) begin
        dmem__req__en = 1'd1;
        dmem__req__msg.type_ = 4'd14;
        dmem__req__msg.opaque = 8'd0;
        dmem__req__msg.addr = 32'd0;
        dmem__req__msg.len = 2'd0;
      end
    end
    else if ( execute_mem__en ) begin
      if ( ( ( ( ( ( execute_mem__msg.mem_type == 4'( __const__mem_f ) ) & ( ~ld_q__complete__rdy ) ) & ( ~st_q__complete__rdy ) ) & ( ~amo_q__complete__rdy ) ) & fence_q__enq__rdy ) & ( execute_mem__msg.br_tag == 2'd0 ) ) begin
        if ( execute_mem__msg.fls & dmem__req__rdy ) begin
          execute_mem__suc = 1'd1;
          fence_q__enq__en = 1'd1;
          dmem__req__en = 1'd1;
          dmem__req__msg.type_ = 4'd15;
          dmem__req__msg.opaque = 8'd0;
          dmem__req__msg.addr = 32'd0;
          dmem__req__msg.len = 2'd0;
        end
        else if ( execute_mem__msg.inv & dmem__req__rdy ) begin
          execute_mem__suc = 1'd1;
          fence_q__enq__en = 1'd1;
          dmem__req__en = 1'd1;
          dmem__req__msg.type_ = 4'd14;
          dmem__req__msg.opaque = 8'd0;
          dmem__req__msg.addr = 32'd0;
          dmem__req__msg.len = 2'd0;
        end
      end
      else if ( ( ( execute_mem__msg.mem_type == 4'( __const__mem_ld ) ) & ld_q__allocate__rdy ) & dmem__req__rdy ) begin
        execute_mem__suc = 1'd1;
        ld_q__allocate__en = 1'd1;
        dmem__req__en = 1'd1;
        dmem__req__msg.type_ = 4'd0;
        dmem__req__msg.opaque = { { 7 { 1'b0 } }, ld_q__allocate__ret };
        dmem__req__msg.addr = execute_mem__msg.mem_addr;
        dmem__req__msg.len = execute_mem__msg.mem_len;
      end
      else if ( ( ( ( execute_mem__msg.mem_type == 4'( __const__mem_st ) ) & st_q__allocate__rdy ) & dmem__req__rdy ) & ( execute_mem__msg.br_tag == 2'd0 ) ) begin
        execute_mem__suc = 1'd1;
        st_q__allocate__en = 1'd1;
        dmem__req__en = 1'd1;
        dmem__req__msg.type_ = 4'd1;
        dmem__req__msg.opaque = { { 7 { 1'b0 } }, st_q__allocate__ret };
        dmem__req__msg.addr = execute_mem__msg.mem_addr;
        dmem__req__msg.len = execute_mem__msg.mem_len;
        dmem__req__msg.data = execute_mem__msg.st_data;
      end
      else if ( ( ( ( ( ( ( ( ( execute_mem__msg.mem_type == 4'( __const__mem_add ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_and ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_max ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_maxu ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_min ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_minu ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_or ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_swp ) ) ) | ( execute_mem__msg.mem_type == 4'( __const__mem_xor ) ) ) begin
        if ( ( amo_q__allocate__rdy & dmem__req__rdy ) & ( execute_mem__msg.br_tag == 2'd0 ) ) begin
          execute_mem__suc = 1'd1;
          amo_q__allocate__en = 1'd1;
          dmem__req__en = 1'd1;
          if ( execute_mem__msg.mem_type == 4'( __const__mem_add ) ) begin
            dmem__req__msg.type_ = 4'd3;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_and ) ) begin
            dmem__req__msg.type_ = 4'd4;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_max ) ) begin
            dmem__req__msg.type_ = 4'd9;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_maxu ) ) begin
            dmem__req__msg.type_ = 4'd10;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_min ) ) begin
            dmem__req__msg.type_ = 4'd7;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_minu ) ) begin
            dmem__req__msg.type_ = 4'd8;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_or ) ) begin
            dmem__req__msg.type_ = 4'd5;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_swp ) ) begin
            dmem__req__msg.type_ = 4'd6;
          end
          else if ( execute_mem__msg.mem_type == 4'( __const__mem_xor ) ) begin
            dmem__req__msg.type_ = 4'd11;
          end
          dmem__req__msg.opaque = { { 7 { 1'b0 } }, amo_q__allocate__ret };
          dmem__req__msg.addr = execute_mem__msg.mem_addr;
          dmem__req__msg.len = execute_mem__msg.mem_len;
          dmem__req__msg.data = execute_mem__msg.st_data;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/MemFlowManagerRTL.py:59
  // @update_ff
  // def up_send_inv():
  //   if    s.reset:
  //     s.send_inv_reg <<= 0
  // 
  //   # clear send_inv_reg when we send an INV request to dmem
  //   elif  s.dmem.req.en & \
  //         ( s.dmem.req.msg.type_ == MemMsgType.INV ):
  //     s.send_inv_reg <<= 0
  // 
  //   # set send_inv_reg when we receive a FLUSH response and the
  //   # pending fence needs to send an INV request to dmem
  //   elif  s.dmem.resp.en & \
  //         ( s.dmem.resp.msg.type_ == MemMsgType.FLUSH ) & \
  //         s.fence_q.deq.rdy & \
  //         s.fence_q.deq.ret.inv:
  //     s.send_inv_reg <<= 1
  
  always_ff @(posedge clk) begin : up_send_inv
    if ( reset ) begin
      send_inv_reg <= 1'd0;
    end
    else if ( dmem__req__en & ( dmem__req__msg.type_ == 4'd14 ) ) begin
      send_inv_reg <= 1'd0;
    end
    else if ( ( ( dmem__resp__en & ( dmem__resp__msg.type_ == 4'd15 ) ) & fence_q__deq__rdy ) & fence_q__deq__ret.inv ) begin
      send_inv_reg <= 1'd1;
    end
  end

  assign ld_q__clk = clk;
  assign ld_q__reset = reset;
  assign st_q__clk = clk;
  assign st_q__reset = reset;
  assign amo_q__clk = clk;
  assign amo_q__reset = reset;
  assign fence_q__clk = clk;
  assign fence_q__reset = reset;

endmodule


// PyMTL Component MemUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/MemUnitRTL.py

module MemUnitRTL_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] bypass__en  ,
  output RegWrStruct__preg_idx_7__data_32 bypass__msg  ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] complete_mem__en  ,
  input MemCompleteStruct__c5bd3cabb5deb86b complete_mem__msg  ,
  output logic [0:0] complete_mem__rdy  ,
  output logic [0:0] execute_mem__en  ,
  output MemExecuteStruct__af5802ecac25c83f execute_mem__msg  ,
  input logic [0:0] execute_mem__suc  ,
  input logic [0:0] recv_inst__en  ,
  input I_InstStruct__c61c86abe6488854 recv_inst__msg  ,
  output logic [0:0] recv_inst__rdy  ,
  output logic [0:0] send_inst__en  ,
  output X_InstStruct__b64b8c5076edb89b send_inst__msg  ,
  input logic [0:0] send_inst__rdy  
);
  localparam logic [3:0] __const__mem_ld  = 4'd1;
  localparam logic [3:0] __const__mem_st  = 4'd2;
  localparam logic [3:0] __const__mem_add  = 4'd3;
  localparam logic [3:0] __const__mem_and  = 4'd4;
  localparam logic [3:0] __const__mem_max  = 4'd9;
  localparam logic [3:0] __const__mem_maxu  = 4'd10;
  localparam logic [3:0] __const__mem_min  = 4'd7;
  localparam logic [3:0] __const__mem_minu  = 4'd8;
  localparam logic [3:0] __const__mem_or  = 4'd5;
  localparam logic [3:0] __const__mem_swp  = 4'd6;
  localparam logic [3:0] __const__mem_xor  = 4'd11;
  I_InstStruct__c61c86abe6488854 in_msg;
  //-------------------------------------------------------------
  // Component recv_q
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk;
  logic [0:0] recv_q__reset;
  logic [0:0] recv_q__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 recv_q__clear_br__msg;
  logic [0:0] recv_q__deq__en;
  logic [0:0] recv_q__deq__rdy;
  I_InstStruct__c61c86abe6488854 recv_q__deq__ret;
  logic [0:0] recv_q__enq__en;
  I_InstStruct__c61c86abe6488854 recv_q__enq__msg;
  logic [0:0] recv_q__enq__rdy;

  TaggedPipeQueue1EntryRTL__bc00a7d41594514f recv_q
  (
    .clk( recv_q__clk ),
    .reset( recv_q__reset ),
    .clear_br__en( recv_q__clear_br__en ),
    .clear_br__msg( recv_q__clear_br__msg ),
    .deq__en( recv_q__deq__en ),
    .deq__rdy( recv_q__deq__rdy ),
    .deq__ret( recv_q__deq__ret ),
    .enq__en( recv_q__enq__en ),
    .enq__msg( recv_q__enq__msg ),
    .enq__rdy( recv_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component recv_q
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/MemUnitRTL.py:84
  // @update
  // def req_comb():
  // 
  //   # default
  //   s.recv_q.deq.en             @= 0
  //   s.execute_mem.en            @= 0
  //   s.execute_mem.msg.mem_addr  @= 0
  // 
  //   # ld & st
  //   if    ( s.recv_q.deq.ret.mem_type == mem_ld ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_st ):
  //     s.execute_mem.msg.mem_addr @= s.in_msg.op1_val + s.in_msg.op2_val
  // 
  //   # amo
  //   elif  ( s.recv_q.deq.ret.mem_type == mem_add  ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_and  ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_max  ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_maxu ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_min  ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_minu ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_or   ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_swp  ) | \
  //         ( s.recv_q.deq.ret.mem_type == mem_xor  ):
  //     s.execute_mem.msg.mem_addr @= s.in_msg.op1_val
  // 
  //   if s.recv_q.deq.rdy:
  // 
  //     # simply drop already killed inst
  //     if    s.in_msg.killed:
  //       s.recv_q.deq.en   @= 1
  //     else:
  //       s.execute_mem.en  @= 1
  //       s.recv_q.deq.en   @= s.execute_mem.suc
  
  always_comb begin : req_comb
    recv_q__deq__en = 1'd0;
    execute_mem__en = 1'd0;
    execute_mem__msg.mem_addr = 32'd0;
    if ( ( recv_q__deq__ret.mem_type == 4'( __const__mem_ld ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_st ) ) ) begin
      execute_mem__msg.mem_addr = in_msg.op1_val + in_msg.op2_val;
    end
    else if ( ( ( ( ( ( ( ( ( recv_q__deq__ret.mem_type == 4'( __const__mem_add ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_and ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_max ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_maxu ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_min ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_minu ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_or ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_swp ) ) ) | ( recv_q__deq__ret.mem_type == 4'( __const__mem_xor ) ) ) begin
      execute_mem__msg.mem_addr = in_msg.op1_val;
    end
    if ( recv_q__deq__rdy ) begin
      if ( in_msg.killed ) begin
        recv_q__deq__en = 1'd1;
      end
      else begin
        execute_mem__en = 1'd1;
        recv_q__deq__en = execute_mem__suc;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/MemUnitRTL.py:118
  // @update
  // def resp_comb():
  // 
  //   # default
  //   s.send_inst.en  @= 0
  //   s.send_inst.msg @= X_InstStruct()
  //   s.bypass.en     @= 0
  // 
  //   if  s.complete_mem.en:
  // 
  //     # if the inst has been killed, drop it
  //     # otherwise, try to send it to the next stage
  //     if ~s.complete_mem.msg.killed:
  // 
  //       # bypass if this inst is writiting to RF
  //       s.bypass.en @= s.complete_mem.msg.rd_en
  // 
  //       # send inst to the next unit
  //       s.send_inst.en            @= 1
  //       s.send_inst.msg.pc        @= s.complete_mem.msg.pc
  //       s.send_inst.msg.inst_val  @= s.complete_mem.msg.inst_val
  //       s.send_inst.msg.br_tag    @= s.complete_mem.msg.br_tag
  //       s.send_inst.msg.rob_idx   @= s.complete_mem.msg.rob_idx
  //       s.send_inst.msg.rd_en     @= s.complete_mem.msg.rd_en
  //       s.send_inst.msg.rd_preg   @= s.complete_mem.msg.rd_preg
  //       s.send_inst.msg.csr_wen   @= 0
  //       s.send_inst.msg.result    @= s.complete_mem.msg.data
  //       s.send_inst.msg.killed    @= s.complete_mem.msg.killed
  
  always_comb begin : resp_comb
    send_inst__en = 1'd0;
    send_inst__msg = { 32'd0, 1'd0, 2'd0, 3'd0, 1'd0, 7'd0, 1'd0, 32'd0, 1'd0 };
    bypass__en = 1'd0;
    if ( complete_mem__en ) begin
      if ( ~complete_mem__msg.killed ) begin
        bypass__en = complete_mem__msg.rd_en;
        send_inst__en = 1'd1;
        send_inst__msg.pc = complete_mem__msg.pc;
        send_inst__msg.inst_val = complete_mem__msg.inst_val;
        send_inst__msg.br_tag = complete_mem__msg.br_tag;
        send_inst__msg.rob_idx = complete_mem__msg.rob_idx;
        send_inst__msg.rd_en = complete_mem__msg.rd_en;
        send_inst__msg.rd_preg = complete_mem__msg.rd_preg;
        send_inst__msg.csr_wen = 1'd0;
        send_inst__msg.result = complete_mem__msg.data;
        send_inst__msg.killed = complete_mem__msg.killed;
      end
    end
  end

  assign recv_q__clk = clk;
  assign recv_q__reset = reset;
  assign recv_q__enq__en = recv_inst__en;
  assign recv_q__enq__msg = recv_inst__msg;
  assign recv_inst__rdy = recv_q__enq__rdy;
  assign recv_q__clear_br__en = clear_br__en;
  assign recv_q__clear_br__msg = clear_br__msg;
  assign in_msg = recv_q__deq__ret;
  assign execute_mem__msg.pc = in_msg.pc;
  assign execute_mem__msg.br_tag = in_msg.br_tag;
  assign execute_mem__msg.rob_idx = in_msg.rob_idx;
  assign execute_mem__msg.rd_en = in_msg.rd_en;
  assign execute_mem__msg.rd_preg = in_msg.rd_preg;
  assign execute_mem__msg.mem_type = in_msg.mem_type;
  assign execute_mem__msg.mem_len = in_msg.mem_len;
  assign execute_mem__msg.mem_ext = in_msg.mem_ext;
  assign execute_mem__msg.st_data = in_msg.st_data;
  assign execute_mem__msg.fls = in_msg.fls;
  assign execute_mem__msg.inv = in_msg.inv;
  assign execute_mem__msg.killed = in_msg.killed;
  assign bypass__msg.preg_idx = complete_mem__msg.rd_preg;
  assign bypass__msg.data = complete_mem__msg.data;
  assign complete_mem__rdy = send_inst__rdy;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits4__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py

module RoundRobinArbiterEn__nreqs_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [3:0] grants ,
  input  logic [3:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__nreqs_at_comb_reqs_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_reqs_int  = 4'd8;
  localparam logic [2:0] __const__nreqs_at_comb_grants  = 3'd4;
  localparam logic [2:0] __const__nreqs_at_comb_priority_int  = 3'd4;
  localparam logic [3:0] __const__nreqsX2_at_comb_priority_int  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_kills  = 4'd8;
  localparam logic [3:0] __const__nreqsX2_at_comb_grants_int  = 4'd8;
  logic [7:0] grants_int;
  logic [8:0] kills;
  logic [0:0] priority_en;
  logic [7:0] priority_int;
  logic [7:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [3:0] priority_reg__in_;
  logic [3:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits4__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[2'(i)] = grants_int[3'(i)] | grants_int[3'( __const__nreqs_at_comb_grants ) + 3'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        grants_int[3'(i)] = reqs_int[3'(i)];
      end
      else
        grants_int[3'(i)] = ( ~kills[4'(i)] ) & reqs_int[3'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[4'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 4'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[3'(i)] ) begin
        kills[4'(i) + 4'd1] = reqs_int[3'(i)];
      end
      else
        kills[4'(i) + 4'd1] = kills[4'(i)] | ( ( ~kills[4'(i)] ) & reqs_int[3'(i)] );
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 4'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[3'd3:3'd0] = priority_reg__out;
    priority_int[3'd7:3'( __const__nreqs_at_comb_priority_int )] = 4'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[3'd3:3'd0] = reqs;
    reqs_int[3'd7:3'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[3:1] = grants[2:0];
  assign priority_reg__in_[0:0] = grants[3:3];

endmodule


// PyMTL Component Encoder Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/encoders.py

module Encoder__in_nbits_4__out_nbits_2
(
  input  logic [0:0] clk ,
  input  logic [3:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 2'd0;
    for ( int unsigned i = 1'd0; i < 3'd4; i += 1'd1 )
      if ( in_[2'(i)] ) begin
        out = 2'(i);
      end
  end

endmodule


// PyMTL Component Mux Definition
// At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py

module Mux__Type_X_InstStruct__b64b8c5076edb89b__ninputs_4
(
  input  logic [0:0] clk ,
  input  X_InstStruct__b64b8c5076edb89b in_ [0:3],
  output X_InstStruct__b64b8c5076edb89b out ,
  input  logic [0:0] reset ,
  input  logic [1:0] sel 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/pymtl3/pymtl3/stdlib/basic_rtl/arithmetics.py:13
  // @update
  // def up_mux():
  //   s.out @= s.in_[ s.sel ]
  
  always_comb begin : up_mux
    out = in_[sel];
  end

endmodule


// PyMTL Component TaggedPipeQueue1EntryRTL Definition
// Full name: TaggedPipeQueue1EntryRTL__EntryStruct_X_InstStruct__b64b8c5076edb89b__ClearBrStruct_ClearBrStruct__ac353fa5f603c6f1__BranchTag_Bits2
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedPipeQueue1EntryRTL.py

module TaggedPipeQueue1EntryRTL__e07b2d49c3bc181e
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output X_InstStruct__b64b8c5076edb89b deq__ret  ,
  input logic [0:0] enq__en  ,
  input X_InstStruct__b64b8c5076edb89b enq__msg  ,
  output logic [0:0] enq__rdy  
);
  X_InstStruct__b64b8c5076edb89b entry;
  logic [0:0] full;
  X_InstStruct__b64b8c5076edb89b updated_entry;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedPipeQueue1EntryRTL.py:81
  // @update
  // def up_comb():
  // 
  //   s.enq.rdy @= ~s.full | s.deq.en
  //   s.deq.rdy @= s.full
  // 
  //   #s.updated_entry @= deepcopy( s.entry )
  //   s.updated_entry @= s.entry
  // 
  //   if  s.clear_br.en & \
  //       ( ( s.entry.br_tag & s.clear_br.msg.br_mask ) != 0 ):
  // 
  //     if  s.clear_br.msg.kill:
  //       s.updated_entry.killed @= 1
  //     else:
  //       s.updated_entry.br_tag @= s.entry.br_tag & ~s.clear_br.msg.br_mask
  // 
  //   s.deq.ret @= s.updated_entry
  
  always_comb begin : up_comb
    enq__rdy = ( ~full ) | deq__en;
    deq__rdy = full;
    updated_entry = entry;
    if ( clear_br__en & ( ( entry.br_tag & clear_br__msg.br_mask ) != 2'd0 ) ) begin
      if ( clear_br__msg.kill ) begin
        updated_entry.killed = 1'd1;
      end
      else
        updated_entry.br_tag = entry.br_tag & ( ~clear_br__msg.br_mask );
    end
    deq__ret = updated_entry;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/structures/TaggedPipeQueue1EntryRTL.py:56
  // @update_ff
  // def up_states():
  // 
  //   # reset
  //   if    s.reset:
  //     s.full <<= 0
  // 
  //   # enq and deq
  //   elif  s.enq.en & s.deq.en:
  //     s.full  <<= 1
  //     s.entry <<= s.enq.msg
  // 
  //   # not enq and deq
  //   elif  ~s.enq.en & s.deq.en:
  //     s.full <<= 0
  // 
  //   # enq and not deq
  //   elif  s.enq.en & ~s.deq.en:
  //     s.full  <<= 1
  //     s.entry <<= s.enq.msg
  // 
  //   # not enq and not deq
  //   else:
  //     s.entry <<= s.updated_entry
  
  always_ff @(posedge clk) begin : up_states
    if ( reset ) begin
      full <= 1'd0;
    end
    else if ( enq__en & deq__en ) begin
      full <= 1'd1;
      entry <= enq__msg;
    end
    else if ( ( ~enq__en ) & deq__en ) begin
      full <= 1'd0;
    end
    else if ( enq__en & ( ~deq__en ) ) begin
      full <= 1'd1;
      entry <= enq__msg;
    end
    else
      entry <= updated_entry;
  end

endmodule


// PyMTL Component WritebackUnitRTL Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/WritebackUnitRTL.py

module WritebackUnitRTL__num_FUs_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] bypass__en [0:3] ,
  output RegWrStruct__preg_idx_7__data_32 bypass__msg [0:3] ,
  input logic [0:0] clear_br__en  ,
  input ClearBrStruct__ac353fa5f603c6f1 clear_br__msg  ,
  output logic [0:0] complete_inst__en  ,
  output logic [2:0] complete_inst__msg  ,
  input logic [0:0] recv_inst__en [0:3] ,
  input X_InstStruct__b64b8c5076edb89b recv_inst__msg [0:3] ,
  output logic [0:0] recv_inst__rdy [0:3] ,
  output logic [0:0] wr_csr__en  ,
  output logic [31:0] wr_csr__msg  ,
  output logic [0:0] wr_reg__en  ,
  output RegWrStruct__preg_idx_7__data_32 wr_reg__msg  
);
  localparam logic [2:0] __const__num_FUs_at_writeback_comb  = 3'd4;
  localparam logic [2:0] __const__num_FUs_at_bypass_comb  = 3'd4;
  X_InstStruct__b64b8c5076edb89b in_msg;
  logic [0:0] in_rdy;
  logic [1:0] sel_fu_id;
  //-------------------------------------------------------------
  // Component arbiter
  //-------------------------------------------------------------

  logic [0:0] arbiter__clk;
  logic [0:0] arbiter__en;
  logic [3:0] arbiter__grants;
  logic [3:0] arbiter__reqs;
  logic [0:0] arbiter__reset;

  RoundRobinArbiterEn__nreqs_4 arbiter
  (
    .clk( arbiter__clk ),
    .en( arbiter__en ),
    .grants( arbiter__grants ),
    .reqs( arbiter__reqs ),
    .reset( arbiter__reset )
  );

  //-------------------------------------------------------------
  // End of component arbiter
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [3:0] encoder__in_;
  logic [1:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_4__out_nbits_2 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component in_sel_mux
  //-------------------------------------------------------------

  logic [0:0] in_sel_mux__clk;
  X_InstStruct__b64b8c5076edb89b in_sel_mux__in_ [0:3];
  X_InstStruct__b64b8c5076edb89b in_sel_mux__out;
  logic [0:0] in_sel_mux__reset;
  logic [1:0] in_sel_mux__sel;

  Mux__Type_X_InstStruct__b64b8c5076edb89b__ninputs_4 in_sel_mux
  (
    .clk( in_sel_mux__clk ),
    .in_( in_sel_mux__in_ ),
    .out( in_sel_mux__out ),
    .reset( in_sel_mux__reset ),
    .sel( in_sel_mux__sel )
  );

  //-------------------------------------------------------------
  // End of component in_sel_mux
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component recv_q[0:3]
  //-------------------------------------------------------------

  logic [0:0] recv_q__clk [0:3];
  logic [0:0] recv_q__reset [0:3];
  logic [0:0] recv_q__clear_br__en [0:3];
  ClearBrStruct__ac353fa5f603c6f1 recv_q__clear_br__msg [0:3];
  logic [0:0] recv_q__deq__en [0:3];
  logic [0:0] recv_q__deq__rdy [0:3];
  X_InstStruct__b64b8c5076edb89b recv_q__deq__ret [0:3];
  logic [0:0] recv_q__enq__en [0:3];
  X_InstStruct__b64b8c5076edb89b recv_q__enq__msg [0:3];
  logic [0:0] recv_q__enq__rdy [0:3];

  TaggedPipeQueue1EntryRTL__e07b2d49c3bc181e recv_q__0
  (
    .clk( recv_q__clk[0] ),
    .reset( recv_q__reset[0] ),
    .clear_br__en( recv_q__clear_br__en[0] ),
    .clear_br__msg( recv_q__clear_br__msg[0] ),
    .deq__en( recv_q__deq__en[0] ),
    .deq__rdy( recv_q__deq__rdy[0] ),
    .deq__ret( recv_q__deq__ret[0] ),
    .enq__en( recv_q__enq__en[0] ),
    .enq__msg( recv_q__enq__msg[0] ),
    .enq__rdy( recv_q__enq__rdy[0] )
  );

  TaggedPipeQueue1EntryRTL__e07b2d49c3bc181e recv_q__1
  (
    .clk( recv_q__clk[1] ),
    .reset( recv_q__reset[1] ),
    .clear_br__en( recv_q__clear_br__en[1] ),
    .clear_br__msg( recv_q__clear_br__msg[1] ),
    .deq__en( recv_q__deq__en[1] ),
    .deq__rdy( recv_q__deq__rdy[1] ),
    .deq__ret( recv_q__deq__ret[1] ),
    .enq__en( recv_q__enq__en[1] ),
    .enq__msg( recv_q__enq__msg[1] ),
    .enq__rdy( recv_q__enq__rdy[1] )
  );

  TaggedPipeQueue1EntryRTL__e07b2d49c3bc181e recv_q__2
  (
    .clk( recv_q__clk[2] ),
    .reset( recv_q__reset[2] ),
    .clear_br__en( recv_q__clear_br__en[2] ),
    .clear_br__msg( recv_q__clear_br__msg[2] ),
    .deq__en( recv_q__deq__en[2] ),
    .deq__rdy( recv_q__deq__rdy[2] ),
    .deq__ret( recv_q__deq__ret[2] ),
    .enq__en( recv_q__enq__en[2] ),
    .enq__msg( recv_q__enq__msg[2] ),
    .enq__rdy( recv_q__enq__rdy[2] )
  );

  TaggedPipeQueue1EntryRTL__e07b2d49c3bc181e recv_q__3
  (
    .clk( recv_q__clk[3] ),
    .reset( recv_q__reset[3] ),
    .clear_br__en( recv_q__clear_br__en[3] ),
    .clear_br__msg( recv_q__clear_br__msg[3] ),
    .deq__en( recv_q__deq__en[3] ),
    .deq__rdy( recv_q__deq__rdy[3] ),
    .deq__ret( recv_q__deq__ret[3] ),
    .enq__en( recv_q__enq__en[3] ),
    .enq__msg( recv_q__enq__msg[3] ),
    .enq__rdy( recv_q__enq__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component recv_q[0:3]
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/WritebackUnitRTL.py:100
  // s.in_rdy //= lambda: s.arbiter.grants > GrantType( 0 )
  
  always_comb begin : _lambda__s_procs_0__writeback_in_rdy
    in_rdy = arbiter__grants > 4'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/WritebackUnitRTL.py:134
  // @update
  // def bypass_comb():
  // 
  //   for fu_id in range( num_FUs ):
  //     # default
  //     s.bypass[ fu_id ].en  @= 0
  //     s.bypass[ fu_id ].msg @= RegWrStruct()
  // 
  //     if  s.recv_q[ fu_id ].deq.rdy & \
  //         ~s.recv_q[ fu_id ].deq.ret.killed & \
  //         s.recv_q[ fu_id ].deq.ret.rd_en:
  //       s.bypass[ fu_id ].en            @= 1
  //       s.bypass[ fu_id ].msg.preg_idx  @= s.recv_q[ fu_id ].deq.ret.rd_preg
  //       s.bypass[ fu_id ].msg.data      @= s.recv_q[ fu_id ].deq.ret.result
  
  always_comb begin : bypass_comb
    for ( int unsigned fu_id = 1'd0; fu_id < 3'( __const__num_FUs_at_bypass_comb ); fu_id += 1'd1 ) begin
      bypass__en[2'(fu_id)] = 1'd0;
      bypass__msg[2'(fu_id)] = { 7'd0, 32'd0 };
      if ( ( recv_q__deq__rdy[2'(fu_id)] & ( ~recv_q__deq__ret[2'(fu_id)].killed ) ) & recv_q__deq__ret[2'(fu_id)].rd_en ) begin
        bypass__en[2'(fu_id)] = 1'd1;
        bypass__msg[2'(fu_id)].preg_idx = recv_q__deq__ret[2'(fu_id)].rd_preg;
        bypass__msg[2'(fu_id)].data = recv_q__deq__ret[2'(fu_id)].result;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/units/WritebackUnitRTL.py:113
  // @update
  // def writeback_comb():
  // 
  //   # default
  //   s.wr_reg.en         @= 0
  //   s.wr_csr.en         @= 0
  //   s.complete_inst.en  @= 0
  //   for fu_id in range( num_FUs ):
  //     s.recv_q[ fu_id ].deq.en @= 0
  // 
  //   # there is a granted request
  //   if s.in_rdy:
  // 
  //     # dequeue the inst from recv_q
  //     s.recv_q[ s.sel_fu_id ].deq.en @= 1
  // 
  //     # complete the selected inst and write to RF/CSR only if it's still alive
  //     s.complete_inst.en @= ~s.recv_q[ s.sel_fu_id ].deq.ret.killed
  //     s.wr_reg.en        @= ~s.recv_q[ s.sel_fu_id ].deq.ret.killed & s.in_msg.rd_en
  //     s.wr_csr.en        @= ~s.recv_q[ s.sel_fu_id ].deq.ret.killed & s.in_msg.csr_wen
  
  always_comb begin : writeback_comb
    wr_reg__en = 1'd0;
    wr_csr__en = 1'd0;
    complete_inst__en = 1'd0;
    for ( int unsigned fu_id = 1'd0; fu_id < 3'( __const__num_FUs_at_writeback_comb ); fu_id += 1'd1 )
      recv_q__deq__en[2'(fu_id)] = 1'd0;
    if ( in_rdy ) begin
      recv_q__deq__en[sel_fu_id] = 1'd1;
      complete_inst__en = ~recv_q__deq__ret[sel_fu_id].killed;
      wr_reg__en = ( ~recv_q__deq__ret[sel_fu_id].killed ) & in_msg.rd_en;
      wr_csr__en = ( ~recv_q__deq__ret[sel_fu_id].killed ) & in_msg.csr_wen;
    end
  end

  assign recv_q__clk[0] = clk;
  assign recv_q__reset[0] = reset;
  assign recv_q__clk[1] = clk;
  assign recv_q__reset[1] = reset;
  assign recv_q__clk[2] = clk;
  assign recv_q__reset[2] = reset;
  assign recv_q__clk[3] = clk;
  assign recv_q__reset[3] = reset;
  assign recv_q__enq__en[0] = recv_inst__en[0];
  assign recv_q__enq__msg[0] = recv_inst__msg[0];
  assign recv_inst__rdy[0] = recv_q__enq__rdy[0];
  assign recv_q__clear_br__en[0] = clear_br__en;
  assign recv_q__clear_br__msg[0] = clear_br__msg;
  assign recv_q__enq__en[1] = recv_inst__en[1];
  assign recv_q__enq__msg[1] = recv_inst__msg[1];
  assign recv_inst__rdy[1] = recv_q__enq__rdy[1];
  assign recv_q__clear_br__en[1] = clear_br__en;
  assign recv_q__clear_br__msg[1] = clear_br__msg;
  assign recv_q__enq__en[2] = recv_inst__en[2];
  assign recv_q__enq__msg[2] = recv_inst__msg[2];
  assign recv_inst__rdy[2] = recv_q__enq__rdy[2];
  assign recv_q__clear_br__en[2] = clear_br__en;
  assign recv_q__clear_br__msg[2] = clear_br__msg;
  assign recv_q__enq__en[3] = recv_inst__en[3];
  assign recv_q__enq__msg[3] = recv_inst__msg[3];
  assign recv_inst__rdy[3] = recv_q__enq__rdy[3];
  assign recv_q__clear_br__en[3] = clear_br__en;
  assign recv_q__clear_br__msg[3] = clear_br__msg;
  assign arbiter__clk = clk;
  assign arbiter__reset = reset;
  assign arbiter__en = 1'd1;
  assign arbiter__reqs[0:0] = recv_q__deq__rdy[0];
  assign arbiter__reqs[1:1] = recv_q__deq__rdy[1];
  assign arbiter__reqs[2:2] = recv_q__deq__rdy[2];
  assign arbiter__reqs[3:3] = recv_q__deq__rdy[3];
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arbiter__grants;
  assign sel_fu_id = encoder__out;
  assign in_sel_mux__clk = clk;
  assign in_sel_mux__reset = reset;
  assign in_sel_mux__sel = encoder__out;
  assign in_sel_mux__in_[0] = recv_q__deq__ret[0];
  assign in_sel_mux__in_[1] = recv_q__deq__ret[1];
  assign in_sel_mux__in_[2] = recv_q__deq__ret[2];
  assign in_sel_mux__in_[3] = recv_q__deq__ret[3];
  assign in_msg = in_sel_mux__out;
  assign wr_reg__msg.preg_idx = in_msg.rd_preg;
  assign wr_reg__msg.data = in_msg.result;
  assign wr_csr__msg = in_msg.result;
  assign complete_inst__msg = in_msg.rob_idx;

endmodule


// PyMTL Component ProcI2OL_Pipeline Definition
// At /work/global/mw828/cifer/cifer-chip/pymtl3_proc/proc_i2ol/ProcI2OL_Pipeline.py

module ProcI2OL_Pipeline__numcores_1__coreid_0
(
  input  logic [0:0] clk ,
  output logic [0:0] commit_inst ,
  output logic [31:0] commit_pc ,
  input  logic [0:0] go_bit ,
  input  logic [31:0] ntiles ,
  input  logic [0:0] reset ,
  input  logic [31:0] reset_pc ,
  output logic [0:0] stats_en ,
  input  logic [31:0] tile_x ,
  input  logic [31:0] tile_y ,
  input  logic [31:0] tileid ,
  output logic [0:0] dmem__req__en ,
  output MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 dmem__req__msg ,
  input logic [0:0] dmem__req__rdy ,
  input logic [0:0] dmem__resp__en ,
  input MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 dmem__resp__msg ,
  output logic [0:0] dmem__resp__rdy ,
  output logic [0:0] fpu__req__en ,
  output FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fpu__req__msg ,
  input logic [0:0] fpu__req__rdy ,
  input logic [0:0] fpu__resp__en ,
  input FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fpu__resp__msg ,
  output logic [0:0] fpu__resp__rdy ,
  output logic [0:0] imem__req__en ,
  output MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 imem__req__msg ,
  input logic [0:0] imem__req__rdy ,
  input logic [0:0] imem__resp__en ,
  input MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 imem__resp__msg ,
  output logic [0:0] imem__resp__rdy ,
  output logic [0:0] mdu__req__en ,
  output MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 mdu__req__msg ,
  input logic [0:0] mdu__req__rdy ,
  input logic [0:0] mdu__resp__en ,
  input MduRespMsg_8_32__opaque_8__res_32 mdu__resp__msg ,
  output logic [0:0] mdu__resp__rdy ,
  input logic [0:0] mngr2proc__en  ,
  input logic [31:0] mngr2proc__msg  ,
  output logic [0:0] mngr2proc__rdy  ,
  output logic [0:0] proc2mngr__en  ,
  output logic [31:0] proc2mngr__msg  ,
  input logic [0:0] proc2mngr__rdy  
);
  //-------------------------------------------------------------
  // Component alu_pipe
  //-------------------------------------------------------------

  logic [0:0] alu_pipe__clk;
  logic [0:0] alu_pipe__reset;
  logic [0:0] alu_pipe__bypass__en;
  RegWrStruct__preg_idx_7__data_32 alu_pipe__bypass__msg;
  logic [0:0] alu_pipe__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 alu_pipe__clear_br__msg;
  logic [0:0] alu_pipe__recv_inst__en;
  I_InstStruct__c61c86abe6488854 alu_pipe__recv_inst__msg;
  logic [0:0] alu_pipe__recv_inst__rdy;
  logic [0:0] alu_pipe__resolve_br__en;
  ResolveBranchStruct__7003e9cf5478f896 alu_pipe__resolve_br__msg;
  logic [0:0] alu_pipe__send_inst__en;
  X_InstStruct__b64b8c5076edb89b alu_pipe__send_inst__msg;
  logic [0:0] alu_pipe__send_inst__rdy;

  ALUExecuteUnitRTL_noparam alu_pipe
  (
    .clk( alu_pipe__clk ),
    .reset( alu_pipe__reset ),
    .bypass__en( alu_pipe__bypass__en ),
    .bypass__msg( alu_pipe__bypass__msg ),
    .clear_br__en( alu_pipe__clear_br__en ),
    .clear_br__msg( alu_pipe__clear_br__msg ),
    .recv_inst__en( alu_pipe__recv_inst__en ),
    .recv_inst__msg( alu_pipe__recv_inst__msg ),
    .recv_inst__rdy( alu_pipe__recv_inst__rdy ),
    .resolve_br__en( alu_pipe__resolve_br__en ),
    .resolve_br__msg( alu_pipe__resolve_br__msg ),
    .send_inst__en( alu_pipe__send_inst__en ),
    .send_inst__msg( alu_pipe__send_inst__msg ),
    .send_inst__rdy( alu_pipe__send_inst__rdy )
  );

  //-------------------------------------------------------------
  // End of component alu_pipe
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component commit
  //-------------------------------------------------------------

  logic [0:0] commit__clk;
  logic [0:0] commit__committed;
  logic [31:0] commit__committed_pc;
  logic [0:0] commit__reset;
  logic [0:0] commit__commit_csr__en;
  logic [11:0] commit__commit_csr__msg;
  logic [0:0] commit__commit_csr__suc;
  logic [0:0] commit__commit_head__en;
  logic [0:0] commit__commit_head__rdy;
  logic [0:0] commit__free_reg__en;
  logic [6:0] commit__free_reg__msg;
  logic [0:0] commit__free_reg__rdy;
  logic [0:0] commit__get_head__en;
  logic [0:0] commit__get_head__rdy;
  ROBEntry__81cd62f62fe20808 commit__get_head__ret;

  CommitUnitRTL_noparam commit
  (
    .clk( commit__clk ),
    .committed( commit__committed ),
    .committed_pc( commit__committed_pc ),
    .reset( commit__reset ),
    .commit_csr__en( commit__commit_csr__en ),
    .commit_csr__msg( commit__commit_csr__msg ),
    .commit_csr__suc( commit__commit_csr__suc ),
    .commit_head__en( commit__commit_head__en ),
    .commit_head__rdy( commit__commit_head__rdy ),
    .free_reg__en( commit__free_reg__en ),
    .free_reg__msg( commit__free_reg__msg ),
    .free_reg__rdy( commit__free_reg__rdy ),
    .get_head__en( commit__get_head__en ),
    .get_head__rdy( commit__get_head__rdy ),
    .get_head__ret( commit__get_head__ret )
  );

  //-------------------------------------------------------------
  // End of component commit
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component csr_flow
  //-------------------------------------------------------------

  logic [0:0] csr_flow__clk;
  logic [0:0] csr_flow__committed;
  logic [0:0] csr_flow__go_bit;
  logic [31:0] csr_flow__ntiles;
  logic [0:0] csr_flow__reset;
  logic [0:0] csr_flow__stats_en;
  logic [31:0] csr_flow__tile_x;
  logic [31:0] csr_flow__tile_y;
  logic [31:0] csr_flow__tileid;
  logic [0:0] csr_flow__commit_csr__en;
  logic [11:0] csr_flow__commit_csr__msg;
  logic [0:0] csr_flow__commit_csr__suc;
  logic [0:0] csr_flow__mngr2proc__en;
  logic [31:0] csr_flow__mngr2proc__msg;
  logic [0:0] csr_flow__mngr2proc__rdy;
  logic [0:0] csr_flow__proc2mngr__en;
  logic [31:0] csr_flow__proc2mngr__msg;
  logic [0:0] csr_flow__proc2mngr__rdy;
  logic [0:0] csr_flow__rd_csr__en;
  logic [11:0] csr_flow__rd_csr__msg;
  logic [31:0] csr_flow__rd_csr__ret;
  logic [0:0] csr_flow__rd_csr__suc;
  logic [0:0] csr_flow__wr_csr__en;
  logic [31:0] csr_flow__wr_csr__msg;

  CSRFlowManagerRTL__numcores_1__coreid_0 csr_flow
  (
    .clk( csr_flow__clk ),
    .committed( csr_flow__committed ),
    .go_bit( csr_flow__go_bit ),
    .ntiles( csr_flow__ntiles ),
    .reset( csr_flow__reset ),
    .stats_en( csr_flow__stats_en ),
    .tile_x( csr_flow__tile_x ),
    .tile_y( csr_flow__tile_y ),
    .tileid( csr_flow__tileid ),
    .commit_csr__en( csr_flow__commit_csr__en ),
    .commit_csr__msg( csr_flow__commit_csr__msg ),
    .commit_csr__suc( csr_flow__commit_csr__suc ),
    .mngr2proc__en( csr_flow__mngr2proc__en ),
    .mngr2proc__msg( csr_flow__mngr2proc__msg ),
    .mngr2proc__rdy( csr_flow__mngr2proc__rdy ),
    .proc2mngr__en( csr_flow__proc2mngr__en ),
    .proc2mngr__msg( csr_flow__proc2mngr__msg ),
    .proc2mngr__rdy( csr_flow__proc2mngr__rdy ),
    .rd_csr__en( csr_flow__rd_csr__en ),
    .rd_csr__msg( csr_flow__rd_csr__msg ),
    .rd_csr__ret( csr_flow__rd_csr__ret ),
    .rd_csr__suc( csr_flow__rd_csr__suc ),
    .wr_csr__en( csr_flow__wr_csr__en ),
    .wr_csr__msg( csr_flow__wr_csr__msg )
  );

  //-------------------------------------------------------------
  // End of component csr_flow
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_flow
  //-------------------------------------------------------------

  logic [0:0] ctrl_flow__clk;
  logic [0:0] ctrl_flow__reset;
  logic [0:0] ctrl_flow__checkpoint__en;
  logic [0:0] ctrl_flow__checkpoint__msg;
  logic [2:0] ctrl_flow__checkpoint__ret;
  logic [0:0] ctrl_flow__clear_back_end__en;
  ClearBrStruct__ac353fa5f603c6f1 ctrl_flow__clear_back_end__msg;
  logic [0:0] ctrl_flow__clear_front_end__en;
  ClearBrStruct__ac353fa5f603c6f1 ctrl_flow__clear_front_end__msg;
  logic [0:0] ctrl_flow__commit_head__en;
  logic [0:0] ctrl_flow__commit_head__rdy;
  logic [0:0] ctrl_flow__complete_inst__en;
  logic [2:0] ctrl_flow__complete_inst__msg;
  logic [0:0] ctrl_flow__get_head__en;
  logic [0:0] ctrl_flow__get_head__rdy;
  ROBEntry__81cd62f62fe20808 ctrl_flow__get_head__ret;
  logic [0:0] ctrl_flow__register_inst__en;
  RegInstStruct__496c286c2dc8d523 ctrl_flow__register_inst__msg;
  RegInstRetStruct__rob_idx_3__br_idx_1__br_tag_2 ctrl_flow__register_inst__ret;
  logic [0:0] ctrl_flow__register_inst__suc;
  logic [0:0] ctrl_flow__resolve_br_D__en;
  ResolveBranchStruct__7003e9cf5478f896 ctrl_flow__resolve_br_D__msg;
  logic [0:0] ctrl_flow__resolve_br_X__en;
  ResolveBranchStruct__7003e9cf5478f896 ctrl_flow__resolve_br_X__msg;
  logic [0:0] ctrl_flow__rollback__en;
  RollbackStruct__br_idx_1__ckpt_head_3 ctrl_flow__rollback__msg;

  CtrlFlowManagerRTL__c13a272fbad281f0 ctrl_flow
  (
    .clk( ctrl_flow__clk ),
    .reset( ctrl_flow__reset ),
    .checkpoint__en( ctrl_flow__checkpoint__en ),
    .checkpoint__msg( ctrl_flow__checkpoint__msg ),
    .checkpoint__ret( ctrl_flow__checkpoint__ret ),
    .clear_back_end__en( ctrl_flow__clear_back_end__en ),
    .clear_back_end__msg( ctrl_flow__clear_back_end__msg ),
    .clear_front_end__en( ctrl_flow__clear_front_end__en ),
    .clear_front_end__msg( ctrl_flow__clear_front_end__msg ),
    .commit_head__en( ctrl_flow__commit_head__en ),
    .commit_head__rdy( ctrl_flow__commit_head__rdy ),
    .complete_inst__en( ctrl_flow__complete_inst__en ),
    .complete_inst__msg( ctrl_flow__complete_inst__msg ),
    .get_head__en( ctrl_flow__get_head__en ),
    .get_head__rdy( ctrl_flow__get_head__rdy ),
    .get_head__ret( ctrl_flow__get_head__ret ),
    .register_inst__en( ctrl_flow__register_inst__en ),
    .register_inst__msg( ctrl_flow__register_inst__msg ),
    .register_inst__ret( ctrl_flow__register_inst__ret ),
    .register_inst__suc( ctrl_flow__register_inst__suc ),
    .resolve_br_D__en( ctrl_flow__resolve_br_D__en ),
    .resolve_br_D__msg( ctrl_flow__resolve_br_D__msg ),
    .resolve_br_X__en( ctrl_flow__resolve_br_X__en ),
    .resolve_br_X__msg( ctrl_flow__resolve_br_X__msg ),
    .rollback__en( ctrl_flow__rollback__en ),
    .rollback__msg( ctrl_flow__rollback__msg )
  );

  //-------------------------------------------------------------
  // End of component ctrl_flow
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component data_flow
  //-------------------------------------------------------------

  logic [0:0] data_flow__clk;
  logic [0:0] data_flow__reset;
  logic [0:0] data_flow__bypass_W__en [0:3];
  RegWrStruct__preg_idx_7__data_32 data_flow__bypass_W__msg [0:3];
  logic [0:0] data_flow__bypass_X__en [0:3];
  RegWrStruct__preg_idx_7__data_32 data_flow__bypass_X__msg [0:3];
  logic [0:0] data_flow__checkpoint__en;
  logic [0:0] data_flow__checkpoint__msg;
  logic [2:0] data_flow__checkpoint__ret;
  logic [0:0] data_flow__free_reg__en;
  logic [6:0] data_flow__free_reg__msg;
  logic [0:0] data_flow__free_reg__rdy;
  logic [0:0] data_flow__lookup__en [0:2];
  logic [5:0] data_flow__lookup__msg [0:2];
  logic [6:0] data_flow__lookup__ret [0:2];
  logic [0:0] data_flow__rd_reg__en [0:1];
  logic [6:0] data_flow__rd_reg__msg [0:1];
  logic [31:0] data_flow__rd_reg__ret [0:1];
  logic [0:0] data_flow__rd_reg__suc [0:1];
  logic [0:0] data_flow__rename__en;
  logic [5:0] data_flow__rename__msg;
  logic [0:0] data_flow__rename__rdy;
  logic [6:0] data_flow__rename__ret;
  logic [0:0] data_flow__rollback__en;
  RollbackStruct__br_idx_1__ckpt_head_3 data_flow__rollback__msg;
  logic [0:0] data_flow__set_reg__en;
  logic [6:0] data_flow__set_reg__msg;
  logic [0:0] data_flow__wr_reg__en [0:0];
  RegWrStruct__preg_idx_7__data_32 data_flow__wr_reg__msg [0:0];

  DataFlowManagerRTL__849fb2bb88e036ca data_flow
  (
    .clk( data_flow__clk ),
    .reset( data_flow__reset ),
    .bypass_W__en( data_flow__bypass_W__en ),
    .bypass_W__msg( data_flow__bypass_W__msg ),
    .bypass_X__en( data_flow__bypass_X__en ),
    .bypass_X__msg( data_flow__bypass_X__msg ),
    .checkpoint__en( data_flow__checkpoint__en ),
    .checkpoint__msg( data_flow__checkpoint__msg ),
    .checkpoint__ret( data_flow__checkpoint__ret ),
    .free_reg__en( data_flow__free_reg__en ),
    .free_reg__msg( data_flow__free_reg__msg ),
    .free_reg__rdy( data_flow__free_reg__rdy ),
    .lookup__en( data_flow__lookup__en ),
    .lookup__msg( data_flow__lookup__msg ),
    .lookup__ret( data_flow__lookup__ret ),
    .rd_reg__en( data_flow__rd_reg__en ),
    .rd_reg__msg( data_flow__rd_reg__msg ),
    .rd_reg__ret( data_flow__rd_reg__ret ),
    .rd_reg__suc( data_flow__rd_reg__suc ),
    .rename__en( data_flow__rename__en ),
    .rename__msg( data_flow__rename__msg ),
    .rename__rdy( data_flow__rename__rdy ),
    .rename__ret( data_flow__rename__ret ),
    .rollback__en( data_flow__rollback__en ),
    .rollback__msg( data_flow__rollback__msg ),
    .set_reg__en( data_flow__set_reg__en ),
    .set_reg__msg( data_flow__set_reg__msg ),
    .wr_reg__en( data_flow__wr_reg__en ),
    .wr_reg__msg( data_flow__wr_reg__msg )
  );

  //-------------------------------------------------------------
  // End of component data_flow
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component decode
  //-------------------------------------------------------------

  logic [0:0] decode__clk;
  logic [0:0] decode__reset;
  logic [0:0] decode__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 decode__clear_br__msg;
  logic [0:0] decode__lookup_rd__en;
  logic [5:0] decode__lookup_rd__msg;
  logic [6:0] decode__lookup_rd__ret;
  logic [0:0] decode__lookup_rs1__en;
  logic [5:0] decode__lookup_rs1__msg;
  logic [6:0] decode__lookup_rs1__ret;
  logic [0:0] decode__lookup_rs2__en;
  logic [5:0] decode__lookup_rs2__msg;
  logic [6:0] decode__lookup_rs2__ret;
  logic [0:0] decode__recv_inst__en;
  F_InstStruct__pc_32__inst_32 decode__recv_inst__msg;
  logic [0:0] decode__recv_inst__rdy;
  logic [0:0] decode__register_inst__en;
  RegInstStruct__496c286c2dc8d523 decode__register_inst__msg;
  RegInstRetStruct__rob_idx_3__br_idx_1__br_tag_2 decode__register_inst__ret;
  logic [0:0] decode__register_inst__suc;
  logic [0:0] decode__rename_rd__en;
  logic [5:0] decode__rename_rd__msg;
  logic [0:0] decode__rename_rd__rdy;
  logic [6:0] decode__rename_rd__ret;
  logic [0:0] decode__resolve_br__en;
  ResolveBranchStruct__7003e9cf5478f896 decode__resolve_br__msg;
  logic [0:0] decode__send_inst__en;
  D_InstStruct__e597a7f7aebd8fbc decode__send_inst__msg;
  logic [0:0] decode__send_inst__rdy;

  DecodeUnitRTL__bee45fa5195f09f5 decode
  (
    .clk( decode__clk ),
    .reset( decode__reset ),
    .clear_br__en( decode__clear_br__en ),
    .clear_br__msg( decode__clear_br__msg ),
    .lookup_rd__en( decode__lookup_rd__en ),
    .lookup_rd__msg( decode__lookup_rd__msg ),
    .lookup_rd__ret( decode__lookup_rd__ret ),
    .lookup_rs1__en( decode__lookup_rs1__en ),
    .lookup_rs1__msg( decode__lookup_rs1__msg ),
    .lookup_rs1__ret( decode__lookup_rs1__ret ),
    .lookup_rs2__en( decode__lookup_rs2__en ),
    .lookup_rs2__msg( decode__lookup_rs2__msg ),
    .lookup_rs2__ret( decode__lookup_rs2__ret ),
    .recv_inst__en( decode__recv_inst__en ),
    .recv_inst__msg( decode__recv_inst__msg ),
    .recv_inst__rdy( decode__recv_inst__rdy ),
    .register_inst__en( decode__register_inst__en ),
    .register_inst__msg( decode__register_inst__msg ),
    .register_inst__ret( decode__register_inst__ret ),
    .register_inst__suc( decode__register_inst__suc ),
    .rename_rd__en( decode__rename_rd__en ),
    .rename_rd__msg( decode__rename_rd__msg ),
    .rename_rd__rdy( decode__rename_rd__rdy ),
    .rename_rd__ret( decode__rename_rd__ret ),
    .resolve_br__en( decode__resolve_br__en ),
    .resolve_br__msg( decode__resolve_br__msg ),
    .send_inst__en( decode__send_inst__en ),
    .send_inst__msg( decode__send_inst__msg ),
    .send_inst__rdy( decode__send_inst__rdy )
  );

  //-------------------------------------------------------------
  // End of component decode
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fetch
  //-------------------------------------------------------------

  logic [0:0] fetch__clk;
  logic [0:0] fetch__go_bit;
  logic [0:0] fetch__reset;
  logic [31:0] fetch__reset_pc;
  logic [0:0] fetch__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 fetch__clear_br__msg;
  logic [0:0] fetch__imem__req__en;
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 fetch__imem__req__msg;
  logic [0:0] fetch__imem__req__rdy;
  logic [0:0] fetch__imem__resp__en;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 fetch__imem__resp__msg;
  logic [0:0] fetch__imem__resp__rdy;
  logic [0:0] fetch__send_inst__en;
  F_InstStruct__pc_32__inst_32 fetch__send_inst__msg;
  logic [0:0] fetch__send_inst__rdy;

  FetchUnitRTL__max_pending_reqs_2 fetch
  (
    .clk( fetch__clk ),
    .go_bit( fetch__go_bit ),
    .reset( fetch__reset ),
    .reset_pc( fetch__reset_pc ),
    .clear_br__en( fetch__clear_br__en ),
    .clear_br__msg( fetch__clear_br__msg ),
    .imem__req__en( fetch__imem__req__en ),
    .imem__req__msg( fetch__imem__req__msg ),
    .imem__req__rdy( fetch__imem__req__rdy ),
    .imem__resp__en( fetch__imem__resp__en ),
    .imem__resp__msg( fetch__imem__resp__msg ),
    .imem__resp__rdy( fetch__imem__resp__rdy ),
    .send_inst__en( fetch__send_inst__en ),
    .send_inst__msg( fetch__send_inst__msg ),
    .send_inst__rdy( fetch__send_inst__rdy )
  );

  //-------------------------------------------------------------
  // End of component fetch
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fpu_pipe
  //-------------------------------------------------------------

  logic [0:0] fpu_pipe__clk;
  logic [0:0] fpu_pipe__reset;
  logic [0:0] fpu_pipe__bypass__en;
  RegWrStruct__preg_idx_7__data_32 fpu_pipe__bypass__msg;
  logic [0:0] fpu_pipe__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 fpu_pipe__clear_br__msg;
  logic [0:0] fpu_pipe__recv_fpu_resp__en;
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fpu_pipe__recv_fpu_resp__msg;
  logic [0:0] fpu_pipe__recv_fpu_resp__rdy;
  logic [0:0] fpu_pipe__recv_inst__en;
  I_InstStruct__c61c86abe6488854 fpu_pipe__recv_inst__msg;
  logic [0:0] fpu_pipe__recv_inst__rdy;
  logic [0:0] fpu_pipe__send_fpu_req__en;
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fpu_pipe__send_fpu_req__msg;
  logic [0:0] fpu_pipe__send_fpu_req__rdy;
  logic [0:0] fpu_pipe__send_inst__en;
  X_InstStruct__b64b8c5076edb89b fpu_pipe__send_inst__msg;
  logic [0:0] fpu_pipe__send_inst__rdy;

  FloatingPointPipeRTL__d492e0cc77198375 fpu_pipe
  (
    .clk( fpu_pipe__clk ),
    .reset( fpu_pipe__reset ),
    .bypass__en( fpu_pipe__bypass__en ),
    .bypass__msg( fpu_pipe__bypass__msg ),
    .clear_br__en( fpu_pipe__clear_br__en ),
    .clear_br__msg( fpu_pipe__clear_br__msg ),
    .recv_fpu_resp__en( fpu_pipe__recv_fpu_resp__en ),
    .recv_fpu_resp__msg( fpu_pipe__recv_fpu_resp__msg ),
    .recv_fpu_resp__rdy( fpu_pipe__recv_fpu_resp__rdy ),
    .recv_inst__en( fpu_pipe__recv_inst__en ),
    .recv_inst__msg( fpu_pipe__recv_inst__msg ),
    .recv_inst__rdy( fpu_pipe__recv_inst__rdy ),
    .send_fpu_req__en( fpu_pipe__send_fpu_req__en ),
    .send_fpu_req__msg( fpu_pipe__send_fpu_req__msg ),
    .send_fpu_req__rdy( fpu_pipe__send_fpu_req__rdy ),
    .send_inst__en( fpu_pipe__send_inst__en ),
    .send_inst__msg( fpu_pipe__send_inst__msg ),
    .send_inst__rdy( fpu_pipe__send_inst__rdy )
  );

  //-------------------------------------------------------------
  // End of component fpu_pipe
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component issue
  //-------------------------------------------------------------

  logic [0:0] issue__clk;
  logic [0:0] issue__reset;
  logic [0:0] issue__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 issue__clear_br__msg;
  logic [0:0] issue__rd_csr__en;
  logic [11:0] issue__rd_csr__msg;
  logic [31:0] issue__rd_csr__ret;
  logic [0:0] issue__rd_csr__suc;
  logic [0:0] issue__rd_reg__en [0:1];
  logic [6:0] issue__rd_reg__msg [0:1];
  logic [31:0] issue__rd_reg__ret [0:1];
  logic [0:0] issue__rd_reg__suc [0:1];
  logic [0:0] issue__recv_inst__en;
  D_InstStruct__e597a7f7aebd8fbc issue__recv_inst__msg;
  logic [0:0] issue__recv_inst__rdy;
  logic [0:0] issue__send_inst__en [0:3];
  I_InstStruct__c61c86abe6488854 issue__send_inst__msg [0:3];
  logic [0:0] issue__send_inst__rdy [0:3];
  logic [0:0] issue__set_reg__en;
  logic [6:0] issue__set_reg__msg;

  IssueUnitRTL__num_rd_ports_2__num_FUs_4 issue
  (
    .clk( issue__clk ),
    .reset( issue__reset ),
    .clear_br__en( issue__clear_br__en ),
    .clear_br__msg( issue__clear_br__msg ),
    .rd_csr__en( issue__rd_csr__en ),
    .rd_csr__msg( issue__rd_csr__msg ),
    .rd_csr__ret( issue__rd_csr__ret ),
    .rd_csr__suc( issue__rd_csr__suc ),
    .rd_reg__en( issue__rd_reg__en ),
    .rd_reg__msg( issue__rd_reg__msg ),
    .rd_reg__ret( issue__rd_reg__ret ),
    .rd_reg__suc( issue__rd_reg__suc ),
    .recv_inst__en( issue__recv_inst__en ),
    .recv_inst__msg( issue__recv_inst__msg ),
    .recv_inst__rdy( issue__recv_inst__rdy ),
    .send_inst__en( issue__send_inst__en ),
    .send_inst__msg( issue__send_inst__msg ),
    .send_inst__rdy( issue__send_inst__rdy ),
    .set_reg__en( issue__set_reg__en ),
    .set_reg__msg( issue__set_reg__msg )
  );

  //-------------------------------------------------------------
  // End of component issue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mdu_pipe
  //-------------------------------------------------------------

  logic [0:0] mdu_pipe__clk;
  logic [0:0] mdu_pipe__reset;
  logic [0:0] mdu_pipe__bypass__en;
  RegWrStruct__preg_idx_7__data_32 mdu_pipe__bypass__msg;
  logic [0:0] mdu_pipe__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 mdu_pipe__clear_br__msg;
  logic [0:0] mdu_pipe__recv_inst__en;
  I_InstStruct__c61c86abe6488854 mdu_pipe__recv_inst__msg;
  logic [0:0] mdu_pipe__recv_inst__rdy;
  logic [0:0] mdu_pipe__recv_mdu_resp__en;
  MduRespMsg_8_32__opaque_8__res_32 mdu_pipe__recv_mdu_resp__msg;
  logic [0:0] mdu_pipe__recv_mdu_resp__rdy;
  logic [0:0] mdu_pipe__send_inst__en;
  X_InstStruct__b64b8c5076edb89b mdu_pipe__send_inst__msg;
  logic [0:0] mdu_pipe__send_inst__rdy;
  logic [0:0] mdu_pipe__send_mdu_req__en;
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 mdu_pipe__send_mdu_req__msg;
  logic [0:0] mdu_pipe__send_mdu_req__rdy;

  MulDivPipeRTL__109d9cf22badb0b4 mdu_pipe
  (
    .clk( mdu_pipe__clk ),
    .reset( mdu_pipe__reset ),
    .bypass__en( mdu_pipe__bypass__en ),
    .bypass__msg( mdu_pipe__bypass__msg ),
    .clear_br__en( mdu_pipe__clear_br__en ),
    .clear_br__msg( mdu_pipe__clear_br__msg ),
    .recv_inst__en( mdu_pipe__recv_inst__en ),
    .recv_inst__msg( mdu_pipe__recv_inst__msg ),
    .recv_inst__rdy( mdu_pipe__recv_inst__rdy ),
    .recv_mdu_resp__en( mdu_pipe__recv_mdu_resp__en ),
    .recv_mdu_resp__msg( mdu_pipe__recv_mdu_resp__msg ),
    .recv_mdu_resp__rdy( mdu_pipe__recv_mdu_resp__rdy ),
    .send_inst__en( mdu_pipe__send_inst__en ),
    .send_inst__msg( mdu_pipe__send_inst__msg ),
    .send_inst__rdy( mdu_pipe__send_inst__rdy ),
    .send_mdu_req__en( mdu_pipe__send_mdu_req__en ),
    .send_mdu_req__msg( mdu_pipe__send_mdu_req__msg ),
    .send_mdu_req__rdy( mdu_pipe__send_mdu_req__rdy )
  );

  //-------------------------------------------------------------
  // End of component mdu_pipe
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_flow
  //-------------------------------------------------------------

  logic [0:0] mem_flow__clk;
  logic [0:0] mem_flow__reset;
  logic [0:0] mem_flow__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 mem_flow__clear_br__msg;
  logic [0:0] mem_flow__complete_mem__en;
  MemCompleteStruct__c5bd3cabb5deb86b mem_flow__complete_mem__msg;
  logic [0:0] mem_flow__complete_mem__rdy;
  logic [0:0] mem_flow__dmem__req__en;
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 mem_flow__dmem__req__msg;
  logic [0:0] mem_flow__dmem__req__rdy;
  logic [0:0] mem_flow__dmem__resp__en;
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 mem_flow__dmem__resp__msg;
  logic [0:0] mem_flow__dmem__resp__rdy;
  logic [0:0] mem_flow__execute_mem__en;
  MemExecuteStruct__af5802ecac25c83f mem_flow__execute_mem__msg;
  logic [0:0] mem_flow__execute_mem__suc;

  MemFlowManagerRTL__a29f503bbf1fc2da mem_flow
  (
    .clk( mem_flow__clk ),
    .reset( mem_flow__reset ),
    .clear_br__en( mem_flow__clear_br__en ),
    .clear_br__msg( mem_flow__clear_br__msg ),
    .complete_mem__en( mem_flow__complete_mem__en ),
    .complete_mem__msg( mem_flow__complete_mem__msg ),
    .complete_mem__rdy( mem_flow__complete_mem__rdy ),
    .dmem__req__en( mem_flow__dmem__req__en ),
    .dmem__req__msg( mem_flow__dmem__req__msg ),
    .dmem__req__rdy( mem_flow__dmem__req__rdy ),
    .dmem__resp__en( mem_flow__dmem__resp__en ),
    .dmem__resp__msg( mem_flow__dmem__resp__msg ),
    .dmem__resp__rdy( mem_flow__dmem__resp__rdy ),
    .execute_mem__en( mem_flow__execute_mem__en ),
    .execute_mem__msg( mem_flow__execute_mem__msg ),
    .execute_mem__suc( mem_flow__execute_mem__suc )
  );

  //-------------------------------------------------------------
  // End of component mem_flow
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_pipe
  //-------------------------------------------------------------

  logic [0:0] mem_pipe__clk;
  logic [0:0] mem_pipe__reset;
  logic [0:0] mem_pipe__bypass__en;
  RegWrStruct__preg_idx_7__data_32 mem_pipe__bypass__msg;
  logic [0:0] mem_pipe__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 mem_pipe__clear_br__msg;
  logic [0:0] mem_pipe__complete_mem__en;
  MemCompleteStruct__c5bd3cabb5deb86b mem_pipe__complete_mem__msg;
  logic [0:0] mem_pipe__complete_mem__rdy;
  logic [0:0] mem_pipe__execute_mem__en;
  MemExecuteStruct__af5802ecac25c83f mem_pipe__execute_mem__msg;
  logic [0:0] mem_pipe__execute_mem__suc;
  logic [0:0] mem_pipe__recv_inst__en;
  I_InstStruct__c61c86abe6488854 mem_pipe__recv_inst__msg;
  logic [0:0] mem_pipe__recv_inst__rdy;
  logic [0:0] mem_pipe__send_inst__en;
  X_InstStruct__b64b8c5076edb89b mem_pipe__send_inst__msg;
  logic [0:0] mem_pipe__send_inst__rdy;

  MemUnitRTL_noparam mem_pipe
  (
    .clk( mem_pipe__clk ),
    .reset( mem_pipe__reset ),
    .bypass__en( mem_pipe__bypass__en ),
    .bypass__msg( mem_pipe__bypass__msg ),
    .clear_br__en( mem_pipe__clear_br__en ),
    .clear_br__msg( mem_pipe__clear_br__msg ),
    .complete_mem__en( mem_pipe__complete_mem__en ),
    .complete_mem__msg( mem_pipe__complete_mem__msg ),
    .complete_mem__rdy( mem_pipe__complete_mem__rdy ),
    .execute_mem__en( mem_pipe__execute_mem__en ),
    .execute_mem__msg( mem_pipe__execute_mem__msg ),
    .execute_mem__suc( mem_pipe__execute_mem__suc ),
    .recv_inst__en( mem_pipe__recv_inst__en ),
    .recv_inst__msg( mem_pipe__recv_inst__msg ),
    .recv_inst__rdy( mem_pipe__recv_inst__rdy ),
    .send_inst__en( mem_pipe__send_inst__en ),
    .send_inst__msg( mem_pipe__send_inst__msg ),
    .send_inst__rdy( mem_pipe__send_inst__rdy )
  );

  //-------------------------------------------------------------
  // End of component mem_pipe
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component writeback
  //-------------------------------------------------------------

  logic [0:0] writeback__clk;
  logic [0:0] writeback__reset;
  logic [0:0] writeback__bypass__en [0:3];
  RegWrStruct__preg_idx_7__data_32 writeback__bypass__msg [0:3];
  logic [0:0] writeback__clear_br__en;
  ClearBrStruct__ac353fa5f603c6f1 writeback__clear_br__msg;
  logic [0:0] writeback__complete_inst__en;
  logic [2:0] writeback__complete_inst__msg;
  logic [0:0] writeback__recv_inst__en [0:3];
  X_InstStruct__b64b8c5076edb89b writeback__recv_inst__msg [0:3];
  logic [0:0] writeback__recv_inst__rdy [0:3];
  logic [0:0] writeback__wr_csr__en;
  logic [31:0] writeback__wr_csr__msg;
  logic [0:0] writeback__wr_reg__en;
  RegWrStruct__preg_idx_7__data_32 writeback__wr_reg__msg;

  WritebackUnitRTL__num_FUs_4 writeback
  (
    .clk( writeback__clk ),
    .reset( writeback__reset ),
    .bypass__en( writeback__bypass__en ),
    .bypass__msg( writeback__bypass__msg ),
    .clear_br__en( writeback__clear_br__en ),
    .clear_br__msg( writeback__clear_br__msg ),
    .complete_inst__en( writeback__complete_inst__en ),
    .complete_inst__msg( writeback__complete_inst__msg ),
    .recv_inst__en( writeback__recv_inst__en ),
    .recv_inst__msg( writeback__recv_inst__msg ),
    .recv_inst__rdy( writeback__recv_inst__rdy ),
    .wr_csr__en( writeback__wr_csr__en ),
    .wr_csr__msg( writeback__wr_csr__msg ),
    .wr_reg__en( writeback__wr_reg__en ),
    .wr_reg__msg( writeback__wr_reg__msg )
  );

  //-------------------------------------------------------------
  // End of component writeback
  //-------------------------------------------------------------

  assign ctrl_flow__clk = clk;
  assign ctrl_flow__reset = reset;
  assign data_flow__clk = clk;
  assign data_flow__reset = reset;
  assign csr_flow__clk = clk;
  assign csr_flow__reset = reset;
  assign mem_flow__clk = clk;
  assign mem_flow__reset = reset;
  assign fetch__clk = clk;
  assign fetch__reset = reset;
  assign decode__clk = clk;
  assign decode__reset = reset;
  assign issue__clk = clk;
  assign issue__reset = reset;
  assign alu_pipe__clk = clk;
  assign alu_pipe__reset = reset;
  assign mem_pipe__clk = clk;
  assign mem_pipe__reset = reset;
  assign mdu_pipe__clk = clk;
  assign mdu_pipe__reset = reset;
  assign fpu_pipe__clk = clk;
  assign fpu_pipe__reset = reset;
  assign writeback__clk = clk;
  assign writeback__reset = reset;
  assign commit__clk = clk;
  assign commit__reset = reset;
  assign csr_flow__ntiles = ntiles;
  assign csr_flow__tileid = tileid;
  assign csr_flow__tile_x = tile_x;
  assign csr_flow__tile_y = tile_y;
  assign fetch__go_bit = go_bit;
  assign decode__recv_inst__en = fetch__send_inst__en;
  assign decode__recv_inst__msg = fetch__send_inst__msg;
  assign fetch__send_inst__rdy = decode__recv_inst__rdy;
  assign fetch__clear_br__en = ctrl_flow__clear_front_end__en;
  assign fetch__clear_br__msg = ctrl_flow__clear_front_end__msg;
  assign imem__req__en = fetch__imem__req__en;
  assign imem__req__msg = fetch__imem__req__msg;
  assign fetch__imem__req__rdy = imem__req__rdy;
  assign fetch__imem__resp__en = imem__resp__en;
  assign fetch__imem__resp__msg = imem__resp__msg;
  assign imem__resp__rdy = fetch__imem__resp__rdy;
  assign fetch__reset_pc = reset_pc;
  assign issue__recv_inst__en = decode__send_inst__en;
  assign issue__recv_inst__msg = decode__send_inst__msg;
  assign decode__send_inst__rdy = issue__recv_inst__rdy;
  assign decode__clear_br__en = ctrl_flow__clear_front_end__en;
  assign decode__clear_br__msg = ctrl_flow__clear_front_end__msg;
  assign ctrl_flow__register_inst__en = decode__register_inst__en;
  assign ctrl_flow__register_inst__msg = decode__register_inst__msg;
  assign decode__register_inst__ret = ctrl_flow__register_inst__ret;
  assign decode__register_inst__suc = ctrl_flow__register_inst__suc;
  assign ctrl_flow__resolve_br_D__en = decode__resolve_br__en;
  assign ctrl_flow__resolve_br_D__msg = decode__resolve_br__msg;
  assign data_flow__lookup__en[0] = decode__lookup_rs1__en;
  assign data_flow__lookup__msg[0] = decode__lookup_rs1__msg;
  assign decode__lookup_rs1__ret = data_flow__lookup__ret[0];
  assign data_flow__lookup__en[1] = decode__lookup_rs2__en;
  assign data_flow__lookup__msg[1] = decode__lookup_rs2__msg;
  assign decode__lookup_rs2__ret = data_flow__lookup__ret[1];
  assign data_flow__lookup__en[2] = decode__lookup_rd__en;
  assign data_flow__lookup__msg[2] = decode__lookup_rd__msg;
  assign decode__lookup_rd__ret = data_flow__lookup__ret[2];
  assign data_flow__rename__en = decode__rename_rd__en;
  assign data_flow__rename__msg = decode__rename_rd__msg;
  assign decode__rename_rd__rdy = data_flow__rename__rdy;
  assign decode__rename_rd__ret = data_flow__rename__ret;
  assign alu_pipe__recv_inst__en = issue__send_inst__en[0];
  assign alu_pipe__recv_inst__msg = issue__send_inst__msg[0];
  assign issue__send_inst__rdy[0] = alu_pipe__recv_inst__rdy;
  assign mem_pipe__recv_inst__en = issue__send_inst__en[1];
  assign mem_pipe__recv_inst__msg = issue__send_inst__msg[1];
  assign issue__send_inst__rdy[1] = mem_pipe__recv_inst__rdy;
  assign mdu_pipe__recv_inst__en = issue__send_inst__en[2];
  assign mdu_pipe__recv_inst__msg = issue__send_inst__msg[2];
  assign issue__send_inst__rdy[2] = mdu_pipe__recv_inst__rdy;
  assign fpu_pipe__recv_inst__en = issue__send_inst__en[3];
  assign fpu_pipe__recv_inst__msg = issue__send_inst__msg[3];
  assign issue__send_inst__rdy[3] = fpu_pipe__recv_inst__rdy;
  assign issue__clear_br__en = ctrl_flow__clear_back_end__en;
  assign issue__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign data_flow__rd_reg__en[0] = issue__rd_reg__en[0];
  assign data_flow__rd_reg__msg[0] = issue__rd_reg__msg[0];
  assign issue__rd_reg__ret[0] = data_flow__rd_reg__ret[0];
  assign issue__rd_reg__suc[0] = data_flow__rd_reg__suc[0];
  assign data_flow__rd_reg__en[1] = issue__rd_reg__en[1];
  assign data_flow__rd_reg__msg[1] = issue__rd_reg__msg[1];
  assign issue__rd_reg__ret[1] = data_flow__rd_reg__ret[1];
  assign issue__rd_reg__suc[1] = data_flow__rd_reg__suc[1];
  assign data_flow__set_reg__en = issue__set_reg__en;
  assign data_flow__set_reg__msg = issue__set_reg__msg;
  assign csr_flow__rd_csr__en = issue__rd_csr__en;
  assign csr_flow__rd_csr__msg = issue__rd_csr__msg;
  assign issue__rd_csr__ret = csr_flow__rd_csr__ret;
  assign issue__rd_csr__suc = csr_flow__rd_csr__suc;
  assign writeback__recv_inst__en[0] = alu_pipe__send_inst__en;
  assign writeback__recv_inst__msg[0] = alu_pipe__send_inst__msg;
  assign alu_pipe__send_inst__rdy = writeback__recv_inst__rdy[0];
  assign alu_pipe__clear_br__en = ctrl_flow__clear_back_end__en;
  assign alu_pipe__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign data_flow__bypass_X__en[0] = alu_pipe__bypass__en;
  assign data_flow__bypass_X__msg[0] = alu_pipe__bypass__msg;
  assign ctrl_flow__resolve_br_X__en = alu_pipe__resolve_br__en;
  assign ctrl_flow__resolve_br_X__msg = alu_pipe__resolve_br__msg;
  assign writeback__recv_inst__en[1] = mem_pipe__send_inst__en;
  assign writeback__recv_inst__msg[1] = mem_pipe__send_inst__msg;
  assign mem_pipe__send_inst__rdy = writeback__recv_inst__rdy[1];
  assign mem_pipe__clear_br__en = ctrl_flow__clear_back_end__en;
  assign mem_pipe__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign data_flow__bypass_X__en[1] = mem_pipe__bypass__en;
  assign data_flow__bypass_X__msg[1] = mem_pipe__bypass__msg;
  assign writeback__recv_inst__en[2] = mdu_pipe__send_inst__en;
  assign writeback__recv_inst__msg[2] = mdu_pipe__send_inst__msg;
  assign mdu_pipe__send_inst__rdy = writeback__recv_inst__rdy[2];
  assign mdu_pipe__clear_br__en = ctrl_flow__clear_back_end__en;
  assign mdu_pipe__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign data_flow__bypass_X__en[2] = mdu_pipe__bypass__en;
  assign data_flow__bypass_X__msg[2] = mdu_pipe__bypass__msg;
  assign mdu__req__en = mdu_pipe__send_mdu_req__en;
  assign mdu__req__msg = mdu_pipe__send_mdu_req__msg;
  assign mdu_pipe__send_mdu_req__rdy = mdu__req__rdy;
  assign mdu_pipe__recv_mdu_resp__en = mdu__resp__en;
  assign mdu_pipe__recv_mdu_resp__msg = mdu__resp__msg;
  assign mdu__resp__rdy = mdu_pipe__recv_mdu_resp__rdy;
  assign writeback__recv_inst__en[3] = fpu_pipe__send_inst__en;
  assign writeback__recv_inst__msg[3] = fpu_pipe__send_inst__msg;
  assign fpu_pipe__send_inst__rdy = writeback__recv_inst__rdy[3];
  assign fpu_pipe__clear_br__en = ctrl_flow__clear_back_end__en;
  assign fpu_pipe__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign data_flow__bypass_X__en[3] = fpu_pipe__bypass__en;
  assign data_flow__bypass_X__msg[3] = fpu_pipe__bypass__msg;
  assign fpu__req__en = fpu_pipe__send_fpu_req__en;
  assign fpu__req__msg = fpu_pipe__send_fpu_req__msg;
  assign fpu_pipe__send_fpu_req__rdy = fpu__req__rdy;
  assign fpu_pipe__recv_fpu_resp__en = fpu__resp__en;
  assign fpu_pipe__recv_fpu_resp__msg = fpu__resp__msg;
  assign fpu__resp__rdy = fpu_pipe__recv_fpu_resp__rdy;
  assign writeback__clear_br__en = ctrl_flow__clear_back_end__en;
  assign writeback__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign data_flow__wr_reg__en[0] = writeback__wr_reg__en;
  assign data_flow__wr_reg__msg[0] = writeback__wr_reg__msg;
  assign csr_flow__wr_csr__en = writeback__wr_csr__en;
  assign csr_flow__wr_csr__msg = writeback__wr_csr__msg;
  assign ctrl_flow__complete_inst__en = writeback__complete_inst__en;
  assign ctrl_flow__complete_inst__msg = writeback__complete_inst__msg;
  assign data_flow__bypass_W__en[0] = writeback__bypass__en[0];
  assign data_flow__bypass_W__msg[0] = writeback__bypass__msg[0];
  assign data_flow__bypass_W__en[1] = writeback__bypass__en[1];
  assign data_flow__bypass_W__msg[1] = writeback__bypass__msg[1];
  assign data_flow__bypass_W__en[2] = writeback__bypass__en[2];
  assign data_flow__bypass_W__msg[2] = writeback__bypass__msg[2];
  assign data_flow__bypass_W__en[3] = writeback__bypass__en[3];
  assign data_flow__bypass_W__msg[3] = writeback__bypass__msg[3];
  assign ctrl_flow__get_head__en = commit__get_head__en;
  assign commit__get_head__rdy = ctrl_flow__get_head__rdy;
  assign commit__get_head__ret = ctrl_flow__get_head__ret;
  assign ctrl_flow__commit_head__en = commit__commit_head__en;
  assign commit__commit_head__rdy = ctrl_flow__commit_head__rdy;
  assign data_flow__free_reg__en = commit__free_reg__en;
  assign data_flow__free_reg__msg = commit__free_reg__msg;
  assign commit__free_reg__rdy = data_flow__free_reg__rdy;
  assign csr_flow__commit_csr__en = commit__commit_csr__en;
  assign csr_flow__commit_csr__msg = commit__commit_csr__msg;
  assign commit__commit_csr__suc = csr_flow__commit_csr__suc;
  assign commit_inst = commit__committed;
  assign commit_pc = commit__committed_pc;
  assign data_flow__checkpoint__en = ctrl_flow__checkpoint__en;
  assign data_flow__checkpoint__msg = ctrl_flow__checkpoint__msg;
  assign ctrl_flow__checkpoint__ret = data_flow__checkpoint__ret;
  assign data_flow__rollback__en = ctrl_flow__rollback__en;
  assign data_flow__rollback__msg = ctrl_flow__rollback__msg;
  assign csr_flow__mngr2proc__en = mngr2proc__en;
  assign csr_flow__mngr2proc__msg = mngr2proc__msg;
  assign mngr2proc__rdy = csr_flow__mngr2proc__rdy;
  assign proc2mngr__en = csr_flow__proc2mngr__en;
  assign proc2mngr__msg = csr_flow__proc2mngr__msg;
  assign csr_flow__proc2mngr__rdy = proc2mngr__rdy;
  assign stats_en = csr_flow__stats_en;
  assign csr_flow__go_bit = go_bit;
  assign csr_flow__committed = commit__committed;
  assign dmem__req__en = mem_flow__dmem__req__en;
  assign dmem__req__msg = mem_flow__dmem__req__msg;
  assign mem_flow__dmem__req__rdy = dmem__req__rdy;
  assign mem_flow__dmem__resp__en = dmem__resp__en;
  assign mem_flow__dmem__resp__msg = dmem__resp__msg;
  assign dmem__resp__rdy = mem_flow__dmem__resp__rdy;
  assign mem_flow__clear_br__en = ctrl_flow__clear_back_end__en;
  assign mem_flow__clear_br__msg = ctrl_flow__clear_back_end__msg;
  assign mem_flow__execute_mem__en = mem_pipe__execute_mem__en;
  assign mem_flow__execute_mem__msg = mem_pipe__execute_mem__msg;
  assign mem_pipe__execute_mem__suc = mem_flow__execute_mem__suc;
  assign mem_pipe__complete_mem__en = mem_flow__complete_mem__en;
  assign mem_pipe__complete_mem__msg = mem_flow__complete_mem__msg;
  assign mem_flow__complete_mem__rdy = mem_pipe__complete_mem__rdy;

endmodule


// PyMTL Component TileManager Definition
// Full name: TileManager__numcores_1__TileCtrlMsg_TileCtrlMsg_1__coreid_1__data_32
// At /work/global/mw828/cifer/cifer-chip/brg_tile/tmu/TileManager.py

module TileManager__d4f13492c2055a3b
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] done_ifc__en  ,
  output logic [31:0] done_ifc__msg  ,
  input logic [0:0] from_proc__en  ,
  input TileCtrlMsg_1__coreid_1__data_32 from_proc__msg  ,
  output logic [0:0] from_proc__rdy  ,
  input logic [0:0] go_ifc__en  ,
  input logic [0:0] go_ifc__msg  ,
  output logic [0:0] test_sink__en  ,
  output TileCtrlMsg_1__coreid_1__data_32 test_sink__msg  ,
  input logic [0:0] test_sink__rdy  ,
  input logic [0:0] test_src__en  ,
  input TileCtrlMsg_1__coreid_1__data_32 test_src__msg  ,
  output logic [0:0] test_src__rdy  ,
  output logic [0:0] to_proc__en  ,
  output TileCtrlMsg_1__coreid_1__data_32 to_proc__msg  ,
  input logic [0:0] to_proc__rdy  
);
  localparam logic [0:0] __const__numcores_at_up_state  = 1'd1;
  localparam logic [0:0] __const__numcores_at_up_comb  = 1'd1;
  logic [0:0] count_reg;
  logic [2:0] state_reg;

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/tmu/TileManager.py:129
  // @update
  // def up_comb():
  // 
  //   # default
  //   s.to_proc.en    @= 0
  //   s.to_proc.msg   @= TileCtrlMsg()
  // 
  //   s.done_ifc.en   @= 0
  //   s.done_ifc.msg  @= 0
  // 
  //   s.test_src.rdy  @= 0
  //   s.test_sink.en  @= 0
  //   s.test_sink.msg @= TileCtrlMsg()
  // 
  //   s.from_proc.rdy @= 0
  // 
  //   # send wakeup msg to all cores
  //   if    ( s.state_reg == s.STATE_INIT ) & \
  //         ( s.count_reg < numcores )      & \
  //         ( s.to_proc.rdy == 1 ):
  // 
  //     s.to_proc.en          @= 1
  //     s.to_proc.msg.coreid  @= s.count_reg
  //     s.to_proc.msg.data    @= 0
  // 
  //   # send done msg to core 0
  //   elif  ( s.state_reg == s.STATE_DONE ) & \
  //         ( s.to_proc.rdy == 1 ):
  // 
  //     s.to_proc.en          @= 1
  //     s.to_proc.msg.coreid  @= 0
  //     s.to_proc.msg.data    @= 0
  // 
  //   # STATE_CHECK
  //   elif  s.state_reg == s.STATE_CHECK:
  // 
  //     # always ready to receive check signal from proc
  //     s.from_proc.rdy @= 1
  // 
  //     # receive exit status from proc
  //     if s.from_proc.en == 1:
  //       s.done_ifc.en   @= 1
  //       s.done_ifc.msg  @= s.from_proc.msg.data
  // 
  //   # debug mode: simply pass through messages
  //   elif  s.state_reg == s.STATE_DEBUG:
  // 
  //     s.to_proc.en    @= s.test_src.en
  //     s.test_src.rdy  @= s.to_proc.rdy
  //     s.to_proc.msg   @= s.test_src.msg
  // 
  //     s.test_sink.en  @= s.from_proc.en
  //     s.from_proc.rdy @= s.test_sink.rdy
  //     s.test_sink.msg @= s.from_proc.msg
  // 
  //   # in CHECK state, from_proc is always ready
  //   elif  s.state_reg == s.STATE_WORK:
  //     s.from_proc.rdy @= 1
  
  always_comb begin : up_comb
    to_proc__en = 1'd0;
    to_proc__msg = { 1'd0, 32'd0 };
    done_ifc__en = 1'd0;
    done_ifc__msg = 32'd0;
    test_src__rdy = 1'd0;
    test_sink__en = 1'd0;
    test_sink__msg = { 1'd0, 32'd0 };
    from_proc__rdy = 1'd0;
    if ( ( ( state_reg == 3'd2 ) & ( count_reg < 1'( __const__numcores_at_up_comb ) ) ) & ( to_proc__rdy == 1'd1 ) ) begin
      to_proc__en = 1'd1;
      to_proc__msg.coreid = count_reg;
      to_proc__msg.data = 32'd0;
    end
    else if ( ( state_reg == 3'd4 ) & ( to_proc__rdy == 1'd1 ) ) begin
      to_proc__en = 1'd1;
      to_proc__msg.coreid = 1'd0;
      to_proc__msg.data = 32'd0;
    end
    else if ( state_reg == 3'd5 ) begin
      from_proc__rdy = 1'd1;
      if ( from_proc__en == 1'd1 ) begin
        done_ifc__en = 1'd1;
        done_ifc__msg = from_proc__msg.data;
      end
    end
    else if ( state_reg == 3'd6 ) begin
      to_proc__en = test_src__en;
      test_src__rdy = to_proc__rdy;
      to_proc__msg = test_src__msg;
      test_sink__en = from_proc__en;
      from_proc__rdy = test_sink__rdy;
      test_sink__msg = from_proc__msg;
    end
    else if ( state_reg == 3'd3 ) begin
      from_proc__rdy = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/tmu/TileManager.py:61
  // @update_ff
  // def up_state():
  // 
  //   # reset
  //   if    s.reset:
  //     s.state_reg <<= s.STATE_RESET
  //     s.count_reg <<= 0
  // 
  //   # RESET -> IDLE
  //   #   out of reset
  //   elif  s.state_reg == s.STATE_RESET:
  //     s.state_reg <<= s.STATE_IDLE
  // 
  //   # IDLE -> INIT
  //   #   received start signal & in normal mode (s.go_ifc.msg == 0)
  //   elif  ( s.state_reg == s.STATE_IDLE ) & \
  //         s.go_ifc.en                     & \
  //         ( s.go_ifc.msg == 0 ):
  //     s.state_reg <<= s.STATE_INIT
  // 
  //   # IDLE -> DEBUG
  //   elif  ( s.state_reg == s.STATE_IDLE ) & \
  //         s.go_ifc.en                     & \
  //         ( s.go_ifc.msg == 1 ):
  //     s.state_reg <<= s.STATE_DEBUG
  // 
  //   # INIT -> INIT
  //   #   sent wakeup signal to one proc
  //   elif  ( s.state_reg == s.STATE_INIT ) & \
  //         ( s.count_reg < numcores )      & \
  //         ( s.to_proc.en == 1 ):
  //     s.state_reg <<= s.STATE_INIT
  //     s.count_reg <<= s.count_reg + 1
  // 
  //   # INIT -> WORK
  //   #   all cores have been waken up/init-ed
  //   elif  ( s.state_reg == s.STATE_INIT ) & \
  //         ( s.count_reg == numcores ):
  //     s.state_reg <<= s.STATE_WORK
  //     s.count_reg <<= 0
  // 
  //   # WORK -> WORK
  //   #   received done signal from proc
  //   elif  ( s.state_reg == s.STATE_WORK ) & \
  //         ( s.count_reg < numcores )      & \
  //         ( s.from_proc.en == 1 ):
  //     s.state_reg <<= s.STATE_WORK
  //     s.count_reg <<= s.count_reg + 1
  // 
  //   # WORK -> DONE
  //   #   all cores have finished working
  //   elif  ( s.state_reg == s.STATE_WORK ) & \
  //         ( s.count_reg == numcores ):
  //     s.state_reg <<= s.STATE_DONE
  //     s.count_reg <<= 0
  // 
  //   # DONE -> CHECK
  //   #   TMU sent core 0 done signal so that it can start checking status
  //   elif  ( s.state_reg == s.STATE_DONE ) & \
  //         ( s.to_proc.en == 1 ):
  //     s.state_reg <<= s.STATE_CHECK
  // 
  //   # CHECK -> IDLE
  //   #   TMU received a status code from core 0
  //   elif  ( s.state_reg == s.STATE_CHECK ) & \
  //         ( s.from_proc.en == 1 ):
  //     s.state_reg <<= s.STATE_IDLE
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      state_reg <= 3'd0;
      count_reg <= 1'd0;
    end
    else if ( state_reg == 3'd0 ) begin
      state_reg <= 3'd1;
    end
    else if ( ( ( state_reg == 3'd1 ) & go_ifc__en ) & ( go_ifc__msg == 1'd0 ) ) begin
      state_reg <= 3'd2;
    end
    else if ( ( ( state_reg == 3'd1 ) & go_ifc__en ) & ( go_ifc__msg == 1'd1 ) ) begin
      state_reg <= 3'd6;
    end
    else if ( ( ( state_reg == 3'd2 ) & ( count_reg < 1'( __const__numcores_at_up_state ) ) ) & ( to_proc__en == 1'd1 ) ) begin
      state_reg <= 3'd2;
      count_reg <= count_reg + 1'd1;
    end
    else if ( ( state_reg == 3'd2 ) & ( count_reg == 1'( __const__numcores_at_up_state ) ) ) begin
      state_reg <= 3'd3;
      count_reg <= 1'd0;
    end
    else if ( ( ( state_reg == 3'd3 ) & ( count_reg < 1'( __const__numcores_at_up_state ) ) ) & ( from_proc__en == 1'd1 ) ) begin
      state_reg <= 3'd3;
      count_reg <= count_reg + 1'd1;
    end
    else if ( ( state_reg == 3'd3 ) & ( count_reg == 1'( __const__numcores_at_up_state ) ) ) begin
      state_reg <= 3'd4;
      count_reg <= 1'd0;
    end
    else if ( ( state_reg == 3'd4 ) & ( to_proc__en == 1'd1 ) ) begin
      state_reg <= 3'd5;
    end
    else if ( ( state_reg == 3'd5 ) & ( from_proc__en == 1'd1 ) ) begin
      state_reg <= 3'd1;
    end
  end

endmodule


// PyMTL Component HBResp2MshrEntry Definition
// Full name: HBResp2MshrEntry__hb_params_<brg_tile.hb_transducer.hb_params.HBParams object at 0x7fe4bc8f4690>
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/mshr_entry_encoders.py

module HBResp2MshrEntry__1c65c0aa7c4c765d
(
  input  logic [0:0] clk ,
  output TransducerMshrMsg__e1bbe4e01acd977d out ,
  input  logic [0:0] reset ,
  input  logic [31:0] returned_data_r 
);

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/mshr_entry_encoders.py:87
  // @update
  // def up_encode_type():
  //   s.out.cacheid    @= 0   # not used
  //   s.out.addr       @= 0   # not used
  //   s.out.write_mask @= 0   # not used
  //   s.out.threadid   @= 0
  //   s.out.type_      @= 0   # ignored
  //   s.out.data       @= zext( s.returned_data_r, 128 )
  
  always_comb begin : up_encode_type
    out.cacheid = 8'd0;
    out.addr = 32'd0;
    out.write_mask = 4'd0;
    out.threadid = 1'd0;
    out.type_ = 4'd0;
    out.data = { { 96 { 1'b0 } }, returned_data_r };
  end

endmodule


// PyMTL Component TransducerMshr Definition
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py

module TransducerMshr_noparam
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] alloc__en  ,
  input TransducerMshrMsg__e1bbe4e01acd977d alloc__msg  ,
  output logic [0:0] alloc__rdy  ,
  input logic [0:0] dealloc__en  ,
  output logic [0:0] dealloc__rdy  ,
  output TransducerMshrMsg__e1bbe4e01acd977d dealloc__ret  ,
  input logic [0:0] issue__en  ,
  output logic [0:0] issue__rdy  ,
  output TransducerMshrMsg__e1bbe4e01acd977d issue__ret  ,
  input logic [0:0] update___en  ,
  input TransducerMshrMsg__e1bbe4e01acd977d update___msg  ,
  output logic [0:0] update___rdy  
);
  localparam logic [3:0] __const__MemMsgType_READ  = 4'd0;
  localparam logic [3:0] __const__MemMsgType_AMO  = 4'd3;
  localparam logic [3:0] __const__MemMsgType_WRITE  = 4'd1;
  EntryType__26f404bb414089c7 entry;
  logic [31:0] entry_r_base_addr;
  logic [7:0] entry_r_cacheid;
  logic [127:0] entry_r_data;
  logic [127:0] entry_r_data_next;
  logic [0:0] entry_r_issued;
  logic [3:0] entry_r_pending;
  logic [0:0] entry_r_threadid;
  logic [3:0] entry_r_type;
  logic [0:0] entry_r_valid;
  logic [0:0] next_empty;
  logic [3:0] pending_next;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:102
  // s.alloc.rdy   //= lambda: ~s.entry_r_valid # | s.next_empty
  
  always_comb begin : _lambda__s_trans_mshr_alloc_rdy
    alloc__rdy = ~entry_r_valid;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:103
  // s.dealloc.rdy //= lambda: s.entry_r_valid & ~reduce_or( s.entry_r_pending )
  
  always_comb begin : _lambda__s_trans_mshr_dealloc_rdy
    dealloc__rdy = entry_r_valid & ( ~( | entry_r_pending ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:104
  // s.issue.rdy   //= lambda: s.entry_r_valid & ~s.entry_r_issued & reduce_or( s.entry_r_pending )
  
  always_comb begin : _lambda__s_trans_mshr_issue_rdy
    issue__rdy = ( entry_r_valid & ( ~entry_r_issued ) ) & ( | entry_r_pending );
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:105
  // s.update_.rdy //= lambda: s.entry_r_valid # & s.entry_r_issued
  
  always_comb begin : _lambda__s_trans_mshr_update__rdy
    update___rdy = entry_r_valid;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:204
  // @update
  // def up_dealloc_ret():
  //   s.dealloc.ret.threadid   @= s.entry_r_threadid
  //   s.dealloc.ret.cacheid    @= s.entry_r_cacheid
  //   s.dealloc.ret.type_      @= s.entry_r_type
  //   s.dealloc.ret.write_mask @= 0
  //   s.dealloc.ret.addr       @= s.entry_r_base_addr # Might not be used
  //   s.dealloc.ret.data       @= s.entry_r_data
  
  always_comb begin : up_dealloc_ret
    dealloc__ret.threadid = entry_r_threadid;
    dealloc__ret.cacheid = entry_r_cacheid;
    dealloc__ret.type_ = entry_r_type;
    dealloc__ret.write_mask = 4'd0;
    dealloc__ret.addr = entry_r_base_addr;
    dealloc__ret.data = entry_r_data;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:120
  // @update
  // def up_entry_r_data():
  //   s.entry_r_data_next @= s.entry_r_data
  //   if (s.update_.en & ( s.entry_r_type == MemMsgType_READ )):
  //     if   s.entry_r_pending[0]:
  //       s.entry_r_data_next[0:32]   @= s.update_.msg.data[0:32]
  //     elif s.entry_r_pending[1]:
  //       s.entry_r_data_next[32:64]  @= s.update_.msg.data[0:32]
  //     elif s.entry_r_pending[2]:
  //       s.entry_r_data_next[64:96]  @= s.update_.msg.data[0:32]
  //     else:
  //       s.entry_r_data_next[96:128] @= s.update_.msg.data[0:32]
  
  always_comb begin : up_entry_r_data
    entry_r_data_next = entry_r_data;
    if ( update___en & ( entry_r_type == 4'( __const__MemMsgType_READ ) ) ) begin
      if ( entry_r_pending[2'd0] ) begin
        entry_r_data_next[7'd31:7'd0] = update___msg.data[7'd31:7'd0];
      end
      else if ( entry_r_pending[2'd1] ) begin
        entry_r_data_next[7'd63:7'd32] = update___msg.data[7'd31:7'd0];
      end
      else if ( entry_r_pending[2'd2] ) begin
        entry_r_data_next[7'd95:7'd64] = update___msg.data[7'd31:7'd0];
      end
      else
        entry_r_data_next[7'd127:7'd96] = update___msg.data[7'd31:7'd0];
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:213
  // @update
  // def up_issue_ret():
  //   s.issue.ret.threadid @= s.entry_r_threadid
  //   s.issue.ret.cacheid  @= s.entry_r_cacheid
  //   s.issue.ret.type_    @= s.entry_r_type
  // 
  //   if s.entry_r_type == MemMsgType_READ:
  //     s.issue.ret.write_mask @= 0
  //   else:
  //     s.issue.ret.write_mask @= 1
  // 
  //   if   s.entry_r_pending[0]:
  //     s.issue.ret.addr @= s.entry_r_base_addr
  //     s.issue.ret.data @= zext( s.entry_r_data[0:32], 128 )
  // 
  //   elif s.entry_r_pending[1]:
  //     s.issue.ret.addr @= s.entry_r_base_addr + b32(4)
  //     s.issue.ret.data @= zext( s.entry_r_data[32:64], 128 )
  // 
  //   elif s.entry_r_pending[2]:
  //     s.issue.ret.addr @= s.entry_r_base_addr + b32(8)
  //     s.issue.ret.data @= zext( s.entry_r_data[64:96], 128 )
  // 
  //   else:
  //     s.issue.ret.addr @= s.entry_r_base_addr + b32(12)
  //     s.issue.ret.data @= zext( s.entry_r_data[96:128], 128 )
  
  always_comb begin : up_issue_ret
    issue__ret.threadid = entry_r_threadid;
    issue__ret.cacheid = entry_r_cacheid;
    issue__ret.type_ = entry_r_type;
    if ( entry_r_type == 4'( __const__MemMsgType_READ ) ) begin
      issue__ret.write_mask = 4'd0;
    end
    else
      issue__ret.write_mask = 4'd1;
    if ( entry_r_pending[2'd0] ) begin
      issue__ret.addr = entry_r_base_addr;
      issue__ret.data = { { 96 { 1'b0 } }, entry_r_data[7'd31:7'd0] };
    end
    else if ( entry_r_pending[2'd1] ) begin
      issue__ret.addr = entry_r_base_addr + 32'd4;
      issue__ret.data = { { 96 { 1'b0 } }, entry_r_data[7'd63:7'd32] };
    end
    else if ( entry_r_pending[2'd2] ) begin
      issue__ret.addr = entry_r_base_addr + 32'd8;
      issue__ret.data = { { 96 { 1'b0 } }, entry_r_data[7'd95:7'd64] };
    end
    else begin
      issue__ret.addr = entry_r_base_addr + 32'd12;
      issue__ret.data = { { 96 { 1'b0 } }, entry_r_data[7'd127:7'd96] };
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:107
  // @update
  // def up_pending_next():
  //   if s.entry_r_pending[0]:
  //     s.pending_next @= concat( s.entry_r_pending[1:4], b1(0) )
  //   elif s.entry_r_pending[1]:
  //     s.pending_next @= concat( s.entry_r_pending[2:4], b2(0) )
  //   elif s.entry_r_pending[2]:
  //     s.pending_next @= concat( s.entry_r_pending[3],   b3(0) )
  //   else:
  //     s.pending_next @= 0
  
  always_comb begin : up_pending_next
    if ( entry_r_pending[2'd0] ) begin
      pending_next = { entry_r_pending[2'd3:2'd1], 1'd0 };
    end
    else if ( entry_r_pending[2'd1] ) begin
      pending_next = { entry_r_pending[2'd3:2'd2], 2'd0 };
    end
    else if ( entry_r_pending[2'd2] ) begin
      pending_next = { entry_r_pending[2'd3], 3'd0 };
    end
    else
      pending_next = 4'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:133
  // @update_ff
  // def up_data_reg():
  // 
  //   if s.alloc.en:
  //     s.entry_r_type      <<= s.alloc.msg.type_
  //     s.entry_r_cacheid   <<= s.alloc.msg.cacheid
  //     s.entry_r_threadid  <<= s.alloc.msg.threadid
  //     s.entry_r_base_addr <<= s.alloc.msg.addr
  //     s.entry_r_data      <<= s.alloc.msg.data
  // 
  //   elif s.update_.en & ( s.entry_r_type == MemMsgType_READ ):
  //     s.entry_r_data <<= s.entry_r_data_next
  // 
  //   elif s.update_.en & ( s.entry_r_type >= MemMsgType_AMO ):
  //     if s.update_.msg.type_ == MemMsgType_AMO:
  //       # For AMO, we need to select the data based on the offset within a
  //       # 4-byte word
  //       if   s.entry_r_base_addr[2:4] == b2(0b00):
  //         s.entry_r_data <<= zext( s.update_.msg.data[0:32], 128 )
  //       elif s.entry_r_base_addr[2:4] == b2(0b01):
  //         s.entry_r_data <<= zext( s.update_.msg.data[32:64], 128 )
  //       elif s.entry_r_base_addr[2:4] == b2(0b10):
  //         s.entry_r_data <<= zext( s.update_.msg.data[64:96], 128 )
  //       elif s.entry_r_base_addr[2:4] == b2(0b11):
  //         s.entry_r_data <<= zext( s.update_.msg.data[96:128], 128 )
  //       else:
  //         s.entry_r_data <<= s.update_.msg.data # shoud never happen
  
  always_ff @(posedge clk) begin : up_data_reg
    if ( alloc__en ) begin
      entry_r_type <= alloc__msg.type_;
      entry_r_cacheid <= alloc__msg.cacheid;
      entry_r_threadid <= alloc__msg.threadid;
      entry_r_base_addr <= alloc__msg.addr;
      entry_r_data <= alloc__msg.data;
    end
    else if ( update___en & ( entry_r_type == 4'( __const__MemMsgType_READ ) ) ) begin
      entry_r_data <= entry_r_data_next;
    end
    else if ( update___en & ( entry_r_type >= 4'( __const__MemMsgType_AMO ) ) ) begin
      if ( update___msg.type_ == 4'( __const__MemMsgType_AMO ) ) begin
        if ( entry_r_base_addr[5'd3:5'd2] == 2'd0 ) begin
          entry_r_data <= { { 96 { 1'b0 } }, update___msg.data[7'd31:7'd0] };
        end
        else if ( entry_r_base_addr[5'd3:5'd2] == 2'd1 ) begin
          entry_r_data <= { { 96 { 1'b0 } }, update___msg.data[7'd63:7'd32] };
        end
        else if ( entry_r_base_addr[5'd3:5'd2] == 2'd2 ) begin
          entry_r_data <= { { 96 { 1'b0 } }, update___msg.data[7'd95:7'd64] };
        end
        else if ( entry_r_base_addr[5'd3:5'd2] == 2'd3 ) begin
          entry_r_data <= { { 96 { 1'b0 } }, update___msg.data[7'd127:7'd96] };
        end
        else
          entry_r_data <= update___msg.data;
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/TransducerMshr.py:165
  // @update_ff
  // def up_state():
  // 
  //   # Reset
  // 
  //   if s.reset:
  //     s.entry_r_valid   <<= 0
  //     s.entry_r_issued  <<= 0
  //     s.entry_r_pending <<= 0
  // 
  //   # Alloc
  // 
  //   elif s.alloc.en:
  //     s.entry_r_valid  <<= 1
  //     s.entry_r_issued <<= 0
  // 
  //     if s.alloc.msg.type_ == MemMsgType_WRITE:
  //       s.entry_r_pending <<= s.alloc.msg.write_mask
  //     else:
  //       s.entry_r_pending <<= Bits4( 0b1111 ) # always read four-word cache line
  // 
  //   # Issue
  // 
  //   elif s.issue.en:
  //     s.entry_r_issued <<= 1
  // 
  //   # Update
  // 
  //   elif s.update_.en:
  //     s.entry_r_pending <<= s.pending_next
  //     s.entry_r_issued  <<= s.issue.en
  // 
  //   elif s.dealloc.en:
  //     s.entry_r_valid   <<= 0
  //     s.entry_r_issued  <<= 0
  //     s.entry_r_pending <<= 0
  
  always_ff @(posedge clk) begin : up_state
    if ( reset ) begin
      entry_r_valid <= 1'd0;
      entry_r_issued <= 1'd0;
      entry_r_pending <= 4'd0;
    end
    else if ( alloc__en ) begin
      entry_r_valid <= 1'd1;
      entry_r_issued <= 1'd0;
      if ( alloc__msg.type_ == 4'( __const__MemMsgType_WRITE ) ) begin
        entry_r_pending <= alloc__msg.write_mask;
      end
      else
        entry_r_pending <= 4'd15;
    end
    else if ( issue__en ) begin
      entry_r_issued <= 1'd1;
    end
    else if ( update___en ) begin
      entry_r_pending <= pending_next;
      entry_r_issued <= issue__en;
    end
    else if ( dealloc__en ) begin
      entry_r_valid <= 1'd0;
      entry_r_issued <= 1'd0;
      entry_r_pending <= 4'd0;
    end
  end

  assign entry.valid = entry_r_valid;
  assign entry.issued = entry_r_issued;
  assign entry.pending = entry_r_pending;
  assign entry.type_ = entry_r_type;
  assign entry.threadid = entry_r_threadid;
  assign entry.cacheid = entry_r_cacheid;
  assign entry.base_addr = entry_r_base_addr;
  assign entry.data = entry_r_data;

endmodule


// PyMTL Component Eva2Npa Definition
// Full name: Eva2Npa__data_width_32__addr_width_28__x_cord_width_2__y_cord_width_3__num_tiles_x_4__num_tiles_y_5__vcache_block_size_in_words_8__vcache_size_8192__vcache_sets_128
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/Eva2Npa.py

module Eva2Npa__4e5b9d642d2a57ca
(
  input  logic [0:0] clk ,
  output logic [27:0] epa_o ,
  input  logic [31:0] eva_i ,
  input  logic [0:0] reset ,
  input  logic [1:0] tgo_x_i ,
  input  logic [2:0] tgo_y_i ,
  output logic [1:0] x_cord_o ,
  output logic [2:0] y_cord_o 
);
  localparam logic [1:0] __const__vcache_word_offset_width_at__lambda__s_trans_mshr2hb_eva2npa_hash_bank_input  = 2'd3;
  localparam logic [4:0] __const__hash_bank_input_width_at__lambda__s_trans_mshr2hb_eva2npa_hash_bank_input  = 5'd26;
  localparam logic [1:0] __const__lg_banks_at_hash_function  = 2'd3;
  localparam logic [4:0] __const__hash_bank_index_width_at_hash_function  = 5'd23;
  localparam logic [1:0] __const__x_cord_width_at_comb_logic  = 2'd2;
  localparam logic [2:0] __const__num_tiles_y_at_comb_logic  = 3'd5;
  localparam logic [1:0] __const__vcache_word_offset_width_at_comb_logic  = 2'd3;
  logic [22:0] hash_bank_index_lo;
  logic [25:0] hash_bank_input;
  logic [2:0] hash_bank_lo;
  logic [0:0] tmp_wire;

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/Eva2Npa.py:51
  // s.hash_bank_input //= lambda: s.eva_i[2+vcache_word_offset_width:2+vcache_word_offset_width+hash_bank_input_width]
  
  always_comb begin : _lambda__s_trans_mshr2hb_eva2npa_hash_bank_input
    hash_bank_input = eva_i[5'd30:5'd2 + 5'( __const__vcache_word_offset_width_at__lambda__s_trans_mshr2hb_eva2npa_hash_bank_input )];
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/Eva2Npa.py:60
  // @update
  // def comb_logic():
  //   s.y_cord_o @= 0
  //   if (s.hash_bank_lo[x_cord_width] == Bits1(1)):
  //     s.y_cord_o @= num_tiles_y + 1
  //   s.x_cord_o @= s.hash_bank_lo[0:x_cord_width]
  //   s.tmp_wire @= 0
  //   s.epa_o @= concat( Bits1(0),
  //                      s.tmp_wire,
  //                      s.hash_bank_index_lo,
  //                      s.eva_i[2:2+vcache_word_offset_width]
  //                    )
  
  always_comb begin : comb_logic
    y_cord_o = 3'd0;
    if ( hash_bank_lo[2'( __const__x_cord_width_at_comb_logic )] == 1'd1 ) begin
      y_cord_o = 3'( __const__num_tiles_y_at_comb_logic ) + 3'd1;
    end
    x_cord_o = hash_bank_lo[2'd1:2'd0];
    tmp_wire = 1'd0;
    epa_o = { 1'd0, tmp_wire, hash_bank_index_lo, eva_i[3'd4:5'd2] };
  end

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/Eva2Npa.py:53
  // @update
  // def hash_function():
  //   s.hash_bank_lo       @= s.hash_bank_input[0:lg_banks]
  //   s.hash_bank_index_lo @= s.hash_bank_input[lg_banks:lg_banks+hash_bank_index_width]
  
  always_comb begin : hash_function
    hash_bank_lo = hash_bank_input[5'd2:5'd0];
    hash_bank_index_lo = hash_bank_input[5'd25:5'( __const__lg_banks_at_hash_function )];
  end

endmodule


// PyMTL Component MshrEntry2HBReq Definition
// Full name: MshrEntry2HBReq__num_tiles_x_4__num_tiles_y_5__vcache_block_size_in_words_8__vcache_size_8192__vcache_sets_128__hb_params_<brg_tile.hb_transducer.hb_params.HBParams object at 0x7fe4bc8f4690>
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/mshr_entry_encoders.py

module MshrEntry2HBReq__7636178515c4b01b
(
  input  logic [0:0] clk ,
  input  TransducerMshrMsg__e1bbe4e01acd977d in_ ,
  input  logic [1:0] my_x ,
  input  logic [2:0] my_y ,
  output HBEndpointPacket__29ee445108156f7d out ,
  input  logic [0:0] reset 
);
  localparam logic [3:0] __const__MemMsgType_WRITE  = 4'd1;
  localparam logic [3:0] __const__MemMsgType_READ  = 4'd0;
  localparam logic [3:0] __const__MemMsgType_AMO_ADD  = 4'd3;
  localparam logic [3:0] __const__MemMsgType_SC  = 4'd13;
  localparam logic [3:0] __const__MemMsgType_AMO_AND  = 4'd4;
  localparam logic [3:0] __const__MemMsgType_AMO_OR  = 4'd5;
  localparam logic [3:0] __const__MemMsgType_AMO_SWAP  = 4'd6;
  localparam logic [3:0] __const__MemMsgType_AMO_MIN  = 4'd7;
  localparam logic [3:0] __const__MemMsgType_AMO_MINU  = 4'd8;
  localparam logic [3:0] __const__MemMsgType_AMO_MAX  = 4'd9;
  localparam logic [3:0] __const__MemMsgType_AMO_MAXU  = 4'd10;
  localparam logic [3:0] __const__MemMsgType_AMO_XOR  = 4'd11;
  //-------------------------------------------------------------
  // Component eva2npa
  //-------------------------------------------------------------

  logic [0:0] eva2npa__clk;
  logic [27:0] eva2npa__epa_o;
  logic [31:0] eva2npa__eva_i;
  logic [0:0] eva2npa__reset;
  logic [1:0] eva2npa__tgo_x_i;
  logic [2:0] eva2npa__tgo_y_i;
  logic [1:0] eva2npa__x_cord_o;
  logic [2:0] eva2npa__y_cord_o;

  Eva2Npa__4e5b9d642d2a57ca eva2npa
  (
    .clk( eva2npa__clk ),
    .epa_o( eva2npa__epa_o ),
    .eva_i( eva2npa__eva_i ),
    .reset( eva2npa__reset ),
    .tgo_x_i( eva2npa__tgo_x_i ),
    .tgo_y_i( eva2npa__tgo_y_i ),
    .x_cord_o( eva2npa__x_cord_o ),
    .y_cord_o( eva2npa__y_cord_o )
  );

  //-------------------------------------------------------------
  // End of component eva2npa
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/mshr_entry_encoders.py:123
  // @update
  // def up_encoder():
  //   s.out.addr       @= s.eva2npa.epa_o
  //   s.out.op         @= 0
  //   s.out.op_ex      @= 0
  //   s.out.x_cord     @= s.eva2npa.x_cord_o
  //   s.out.y_cord     @= s.eva2npa.y_cord_o
  //   s.out.src_x_cord @= s.my_x
  //   s.out.src_y_cord @= s.my_y
  //   s.out.reg_id     @= 0
  //   s.out.payload    @= 0
  // 
  //   if   s.in_.type_ == MemMsgType_WRITE:
  //     s.out.op      @= hb_params.packet_op.e_remote_store
  //     s.out.payload @= s.in_.data[0:hb_params_data.data_width]
  //   elif s.in_.type_ == MemMsgType_READ:
  //     s.out.op      @= hb_params.packet_op.e_remote_load
  //   elif ( s.in_.type_ >= MemMsgType_AMO_ADD ) & \
  //        ( s.in_.type_ <= MemMsgType_SC ):
  //     s.out.op      @= hb_params.packet_op.e_remote_amo
  // 
  //     if   s.in_.type_ == MemMsgType_AMO_ADD:  s.out.op_ex @= hb_params.amo_type.e_amo_add
  //     elif s.in_.type_ == MemMsgType_AMO_AND:  s.out.op_ex @= hb_params.amo_type.e_amo_and
  //     elif s.in_.type_ == MemMsgType_AMO_OR:   s.out.op_ex @= hb_params.amo_type.e_amo_or
  //     elif s.in_.type_ == MemMsgType_AMO_SWAP: s.out.op_ex @= hb_params.amo_type.e_amo_swap
  //     elif s.in_.type_ == MemMsgType_AMO_MIN:  s.out.op_ex @= hb_params.amo_type.e_amo_min
  //     elif s.in_.type_ == MemMsgType_AMO_MINU: s.out.op_ex @= hb_params.amo_type.e_amo_minu
  //     elif s.in_.type_ == MemMsgType_AMO_MAX:  s.out.op_ex @= hb_params.amo_type.e_amo_max
  //     elif s.in_.type_ == MemMsgType_AMO_MAXU: s.out.op_ex @= hb_params.amo_type.e_amo_maxu
  //     elif s.in_.type_ == MemMsgType_AMO_XOR:  s.out.op_ex @= hb_params.amo_type.e_amo_xor
  
  always_comb begin : up_encoder
    out.addr = eva2npa__epa_o;
    out.op = 2'd0;
    out.op_ex = 4'd0;
    out.x_cord = eva2npa__x_cord_o;
    out.y_cord = eva2npa__y_cord_o;
    out.src_x_cord = my_x;
    out.src_y_cord = my_y;
    out.reg_id = 5'd0;
    out.payload = 32'd0;
    if ( in_.type_ == 4'( __const__MemMsgType_WRITE ) ) begin
      out.op = 2'd1;
      out.payload = in_.data[7'd31:7'd0];
    end
    else if ( in_.type_ == 4'( __const__MemMsgType_READ ) ) begin
      out.op = 2'd0;
    end
    else if ( ( in_.type_ >= 4'( __const__MemMsgType_AMO_ADD ) ) & ( in_.type_ <= 4'( __const__MemMsgType_SC ) ) ) begin
      out.op = 2'd2;
      if ( in_.type_ == 4'( __const__MemMsgType_AMO_ADD ) ) begin
        out.op_ex = 4'd1;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_AND ) ) begin
        out.op_ex = 4'd3;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_OR ) ) begin
        out.op_ex = 4'd4;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_SWAP ) ) begin
        out.op_ex = 4'd0;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_MIN ) ) begin
        out.op_ex = 4'd5;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_MINU ) ) begin
        out.op_ex = 4'd7;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_MAX ) ) begin
        out.op_ex = 4'd6;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_MAXU ) ) begin
        out.op_ex = 4'd8;
      end
      else if ( in_.type_ == 4'( __const__MemMsgType_AMO_XOR ) ) begin
        out.op_ex = 4'd2;
      end
    end
  end

  assign eva2npa__clk = clk;
  assign eva2npa__reset = reset;
  assign eva2npa__eva_i = in_.addr;

endmodule


// PyMTL Component MshrEntry2MemResp Definition
// Full name: MshrEntry2MemResp__MemRespType_MemRespMsg_8_128_m1__c72937e2b7853c90
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/mshr_entry_encoders.py

module MshrEntry2MemResp__e64c643bebbca125
(
  input  logic [0:0] clk ,
  input  TransducerMshrMsg__e1bbe4e01acd977d in_ ,
  output MemRespMsg_8_128_m1__c72937e2b7853c90 out ,
  input  logic [0:0] reset 
);

  assign out.type_ = in_.type_;
  assign out.data = in_.data;
  assign out.opaque = in_.cacheid;
  assign out.len = 4'd0;

endmodule


// PyMTL Component MemReq2MshrEntry Definition
// Full name: MemReq2MshrEntry__MemReqType_MemReqMsg_8_32_128_m1__35a1cc23a1d2d863
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/mshr_entry_encoders.py

module MemReq2MshrEntry__167d6b06a2f46c32
(
  input  logic [0:0] clk ,
  input  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 in_ ,
  output TransducerMshrMsg__e1bbe4e01acd977d out ,
  input  logic [0:0] reset 
);

  assign out.threadid = 1'd0;
  assign out.cacheid = in_.opaque;
  assign out.type_ = in_.type_;
  assign out.write_mask = in_.wr_mask;
  assign out.addr = in_.addr;
  assign out.data = in_.data;

endmodule


// PyMTL Component HBTransducer Definition
// Full name: HBTransducer__MemReqType_MemReqMsg_8_32_128_m1__35a1cc23a1d2d863__MemRespType_MemRespMsg_8_128_m1__c72937e2b7853c90__num_tiles_x_4__num_tiles_y_5__vcache_block_size_in_words_8__vcache_size_8192__vcache_sets_128__hb_params_<brg_tile.hb_transducer.hb_params.HBParams object at 0x7fe4bc8f4690>
// At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/HBTransducer.py

module HBTransducer__789323c469943ea8
(
  input  logic [0:0] clk ,
  input  logic [27:0] in_addr ,
  input  logic [31:0] in_data ,
  input  logic [6:0] in_load_info ,
  input  logic [3:0] in_mask ,
  input  logic [1:0] in_src_x_cord ,
  input  logic [2:0] in_src_y_cord ,
  input  logic [0:0] in_v ,
  input  logic [0:0] in_we ,
  output logic [0:0] in_yumi ,
  input  logic [1:0] my_x ,
  input  logic [2:0] my_y ,
  input  logic [7:0] out_credit ,
  output HBEndpointPacket__29ee445108156f7d out_packet ,
  input  logic [0:0] out_ready ,
  output logic [0:0] out_v ,
  input  logic [0:0] reset ,
  input  logic [31:0] returned_data_r ,
  input  logic [0:0] returned_fifo_full ,
  input  logic [1:0] returned_pkt_type_r ,
  input  logic [4:0] returned_reg_id_r ,
  input  logic [0:0] returned_v_r ,
  output logic [0:0] returned_yumi ,
  output logic [31:0] returning_data ,
  output logic [0:0] returning_v ,
  input logic [0:0] mem_minion_ifc__req__en ,
  input MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 mem_minion_ifc__req__msg ,
  output logic [0:0] mem_minion_ifc__req__rdy ,
  output logic [0:0] mem_minion_ifc__resp__en ,
  output MemRespMsg_8_128_m1__c72937e2b7853c90 mem_minion_ifc__resp__msg ,
  input logic [0:0] mem_minion_ifc__resp__rdy 
);
  //-------------------------------------------------------------
  // Component hb2mshr
  //-------------------------------------------------------------

  logic [0:0] hb2mshr__clk;
  TransducerMshrMsg__e1bbe4e01acd977d hb2mshr__out;
  logic [0:0] hb2mshr__reset;
  logic [31:0] hb2mshr__returned_data_r;

  HBResp2MshrEntry__1c65c0aa7c4c765d hb2mshr
  (
    .clk( hb2mshr__clk ),
    .out( hb2mshr__out ),
    .reset( hb2mshr__reset ),
    .returned_data_r( hb2mshr__returned_data_r )
  );

  //-------------------------------------------------------------
  // End of component hb2mshr
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mshr
  //-------------------------------------------------------------

  logic [0:0] mshr__clk;
  logic [0:0] mshr__reset;
  logic [0:0] mshr__alloc__en;
  TransducerMshrMsg__e1bbe4e01acd977d mshr__alloc__msg;
  logic [0:0] mshr__alloc__rdy;
  logic [0:0] mshr__dealloc__en;
  logic [0:0] mshr__dealloc__rdy;
  TransducerMshrMsg__e1bbe4e01acd977d mshr__dealloc__ret;
  logic [0:0] mshr__issue__en;
  logic [0:0] mshr__issue__rdy;
  TransducerMshrMsg__e1bbe4e01acd977d mshr__issue__ret;
  logic [0:0] mshr__update___en;
  TransducerMshrMsg__e1bbe4e01acd977d mshr__update___msg;
  logic [0:0] mshr__update___rdy;

  TransducerMshr_noparam mshr
  (
    .clk( mshr__clk ),
    .reset( mshr__reset ),
    .alloc__en( mshr__alloc__en ),
    .alloc__msg( mshr__alloc__msg ),
    .alloc__rdy( mshr__alloc__rdy ),
    .dealloc__en( mshr__dealloc__en ),
    .dealloc__rdy( mshr__dealloc__rdy ),
    .dealloc__ret( mshr__dealloc__ret ),
    .issue__en( mshr__issue__en ),
    .issue__rdy( mshr__issue__rdy ),
    .issue__ret( mshr__issue__ret ),
    .update___en( mshr__update___en ),
    .update___msg( mshr__update___msg ),
    .update___rdy( mshr__update___rdy )
  );

  //-------------------------------------------------------------
  // End of component mshr
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mshr2hb
  //-------------------------------------------------------------

  logic [0:0] mshr2hb__clk;
  TransducerMshrMsg__e1bbe4e01acd977d mshr2hb__in_;
  logic [1:0] mshr2hb__my_x;
  logic [2:0] mshr2hb__my_y;
  HBEndpointPacket__29ee445108156f7d mshr2hb__out;
  logic [0:0] mshr2hb__reset;

  MshrEntry2HBReq__7636178515c4b01b mshr2hb
  (
    .clk( mshr2hb__clk ),
    .in_( mshr2hb__in_ ),
    .my_x( mshr2hb__my_x ),
    .my_y( mshr2hb__my_y ),
    .out( mshr2hb__out ),
    .reset( mshr2hb__reset )
  );

  //-------------------------------------------------------------
  // End of component mshr2hb
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mshr2resp
  //-------------------------------------------------------------

  logic [0:0] mshr2resp__clk;
  TransducerMshrMsg__e1bbe4e01acd977d mshr2resp__in_;
  MemRespMsg_8_128_m1__c72937e2b7853c90 mshr2resp__out;
  logic [0:0] mshr2resp__reset;

  MshrEntry2MemResp__e64c643bebbca125 mshr2resp
  (
    .clk( mshr2resp__clk ),
    .in_( mshr2resp__in_ ),
    .out( mshr2resp__out ),
    .reset( mshr2resp__reset )
  );

  //-------------------------------------------------------------
  // End of component mshr2resp
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req2mshr
  //-------------------------------------------------------------

  logic [0:0] req2mshr__clk;
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 req2mshr__in_;
  TransducerMshrMsg__e1bbe4e01acd977d req2mshr__out;
  logic [0:0] req2mshr__reset;

  MemReq2MshrEntry__167d6b06a2f46c32 req2mshr
  (
    .clk( req2mshr__clk ),
    .in_( req2mshr__in_ ),
    .out( req2mshr__out ),
    .reset( req2mshr__reset )
  );

  //-------------------------------------------------------------
  // End of component req2mshr
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/HBTransducer.py:94
  // s.mem_minion_ifc.resp.en  //= lambda: s.mshr.dealloc.rdy & s.mem_minion_ifc.resp.rdy
  
  always_comb begin : _lambda__s_trans_mem_minion_ifc_resp_en
    mem_minion_ifc__resp__en = mshr__dealloc__rdy & mem_minion_ifc__resp__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/HBTransducer.py:96
  // s.mshr.dealloc.en         //= lambda: s.mshr.dealloc.rdy & s.mem_minion_ifc.resp.rdy
  
  always_comb begin : _lambda__s_trans_mshr_dealloc_en
    mshr__dealloc__en = mshr__dealloc__rdy & mem_minion_ifc__resp__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/hb_transducer/HBTransducer.py:107
  // s.mshr.issue.en //= lambda: s.mshr.issue.rdy & s.out_ready
  
  always_comb begin : _lambda__s_trans_mshr_issue_en
    mshr__issue__en = mshr__issue__rdy & out_ready;
  end

  assign mshr__clk = clk;
  assign mshr__reset = reset;
  assign req2mshr__clk = clk;
  assign req2mshr__reset = reset;
  assign req2mshr__in_ = mem_minion_ifc__req__msg;
  assign mshr__alloc__en = mem_minion_ifc__req__en;
  assign mem_minion_ifc__req__rdy = mshr__alloc__rdy;
  assign mshr__alloc__msg = req2mshr__out;
  assign mshr2resp__clk = clk;
  assign mshr2resp__reset = reset;
  assign mshr2resp__in_ = mshr__dealloc__ret;
  assign mem_minion_ifc__resp__msg = mshr2resp__out;
  assign mshr2hb__clk = clk;
  assign mshr2hb__reset = reset;
  assign mshr2hb__in_ = mshr__issue__ret;
  assign mshr2hb__my_x = my_x;
  assign mshr2hb__my_y = my_y;
  assign out_v = mshr__issue__rdy;
  assign out_packet = mshr2hb__out;
  assign hb2mshr__clk = clk;
  assign hb2mshr__reset = reset;
  assign hb2mshr__returned_data_r = returned_data_r;
  assign mshr__update___en = returned_v_r;
  assign mshr__update___msg = hb2mshr__out;
  assign returned_yumi = returned_v_r;
  assign in_yumi = 1'd0;
  assign returning_v = 1'd0;
  assign returning_data = 32'd0;

endmodule


// PyMTL Component HBTile Definition
// Full name: HBTile__reset_pc_2147483648__num_tiles_x_4__num_tiles_y_5__vcache_block_size_in_words_8__vcache_size_8192__vcache_sets_128__hb_params_<brg_tile.hb_transducer.hb_params.HBParams object at 0x7fe4bc8f4690>
// At /work/global/mw828/cifer/cifer-chip/brg_tile/HBTile.py

module BrgHBTile
(
  input  logic [0:0] clk ,
  output logic [0:0] commit_inst ,
  output logic [31:0] commit_pc ,
  input  logic [27:0] in_addr ,
  input  logic [31:0] in_data ,
  input  logic [6:0] in_load_info ,
  input  logic [3:0] in_mask ,
  input  logic [1:0] in_src_x_cord ,
  input  logic [2:0] in_src_y_cord ,
  input  logic [0:0] in_v ,
  input  logic [0:0] in_we ,
  output logic [0:0] in_yumi ,
  input  logic [1:0] my_x ,
  input  logic [2:0] my_y ,
  input  logic [31:0] ntiles ,
  input  logic [7:0] out_credit ,
  output HBEndpointPacket__29ee445108156f7d out_packet ,
  input  logic [0:0] out_ready ,
  output logic [0:0] out_v ,
  input  logic [0:0] reset ,
  input  logic [31:0] returned_data_r ,
  input  logic [0:0] returned_fifo_full ,
  input  logic [1:0] returned_pkt_type_r ,
  input  logic [4:0] returned_reg_id_r ,
  input  logic [0:0] returned_v_r ,
  output logic [0:0] returned_yumi ,
  output logic [31:0] returning_data ,
  output logic [0:0] returning_v ,
  input  logic [31:0] tileid ,
  output logic [0:0] done_ifc__en  ,
  output logic [31:0] done_ifc__msg  ,
  input logic [0:0] go_ifc__en  ,
  input logic [0:0] go_ifc__msg  ,
  output logic [0:0] test_sink__en  ,
  output TileCtrlMsg_1__coreid_1__data_32 test_sink__msg  ,
  input logic [0:0] test_sink__rdy  ,
  input logic [0:0] test_src__en  ,
  input TileCtrlMsg_1__coreid_1__data_32 test_src__msg  ,
  output logic [0:0] test_src__rdy  
);
  //-------------------------------------------------------------
  // Component dcaches[0:0]
  //-------------------------------------------------------------

  logic [0:0] dcaches__clk [0:0];
  logic [0:0] dcaches__reset [0:0];
  logic [0:0] dcaches__mem_master_ifc__req__en [0:0];
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 dcaches__mem_master_ifc__req__msg [0:0];
  logic [0:0] dcaches__mem_master_ifc__req__rdy [0:0];
  logic [0:0] dcaches__mem_master_ifc__resp__en [0:0];
  MemRespMsg_8_128_m1__c72937e2b7853c90 dcaches__mem_master_ifc__resp__msg [0:0];
  logic [0:0] dcaches__mem_master_ifc__resp__rdy [0:0];
  logic [0:0] dcaches__mem_minion_ifc__req__en [0:0];
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 dcaches__mem_minion_ifc__req__msg [0:0];
  logic [0:0] dcaches__mem_minion_ifc__req__rdy [0:0];
  logic [0:0] dcaches__mem_minion_ifc__resp__en [0:0];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 dcaches__mem_minion_ifc__resp__msg [0:0];
  logic [0:0] dcaches__mem_minion_ifc__resp__rdy [0:0];

  BlockingCacheRTL__97559d5d0b1f6da0 dcaches__0
  (
    .clk( dcaches__clk[0] ),
    .reset( dcaches__reset[0] ),
    .mem_master_ifc__req__en( dcaches__mem_master_ifc__req__en[0] ),
    .mem_master_ifc__req__msg( dcaches__mem_master_ifc__req__msg[0] ),
    .mem_master_ifc__req__rdy( dcaches__mem_master_ifc__req__rdy[0] ),
    .mem_master_ifc__resp__en( dcaches__mem_master_ifc__resp__en[0] ),
    .mem_master_ifc__resp__msg( dcaches__mem_master_ifc__resp__msg[0] ),
    .mem_master_ifc__resp__rdy( dcaches__mem_master_ifc__resp__rdy[0] ),
    .mem_minion_ifc__req__en( dcaches__mem_minion_ifc__req__en[0] ),
    .mem_minion_ifc__req__msg( dcaches__mem_minion_ifc__req__msg[0] ),
    .mem_minion_ifc__req__rdy( dcaches__mem_minion_ifc__req__rdy[0] ),
    .mem_minion_ifc__resp__en( dcaches__mem_minion_ifc__resp__en[0] ),
    .mem_minion_ifc__resp__msg( dcaches__mem_minion_ifc__resp__msg[0] ),
    .mem_minion_ifc__resp__rdy( dcaches__mem_minion_ifc__resp__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component dcaches[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component fpus[0:0]
  //-------------------------------------------------------------

  logic [0:0] fpus__clk [0:0];
  logic [0:0] fpus__reset [0:0];
  logic [0:0] fpus__req__en [0:0];
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 fpus__req__msg [0:0];
  logic [0:0] fpus__req__rdy [0:0];
  logic [0:0] fpus__resp__en [0:0];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 fpus__resp__msg [0:0];
  logic [0:0] fpus__resp__rdy [0:0];

  FloatingPointUnit__57be055cf8afa8d8 fpus__0
  (
    .clk( fpus__clk[0] ),
    .reset( fpus__reset[0] ),
    .req__en( fpus__req__en[0] ),
    .req__msg( fpus__req__msg[0] ),
    .req__rdy( fpus__req__rdy[0] ),
    .resp__en( fpus__resp__en[0] ),
    .resp__msg( fpus__resp__msg[0] ),
    .resp__rdy( fpus__resp__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component fpus[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component icaches[0:0]
  //-------------------------------------------------------------

  logic [0:0] icaches__clk [0:0];
  logic [0:0] icaches__reset [0:0];
  logic [0:0] icaches__mem_master_ifc__req__en [0:0];
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 icaches__mem_master_ifc__req__msg [0:0];
  logic [0:0] icaches__mem_master_ifc__req__rdy [0:0];
  logic [0:0] icaches__mem_master_ifc__resp__en [0:0];
  MemRespMsg_8_128_m1__c72937e2b7853c90 icaches__mem_master_ifc__resp__msg [0:0];
  logic [0:0] icaches__mem_master_ifc__resp__rdy [0:0];
  logic [0:0] icaches__mem_minion_ifc__req__en [0:0];
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 icaches__mem_minion_ifc__req__msg [0:0];
  logic [0:0] icaches__mem_minion_ifc__req__rdy [0:0];
  logic [0:0] icaches__mem_minion_ifc__resp__en [0:0];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 icaches__mem_minion_ifc__resp__msg [0:0];
  logic [0:0] icaches__mem_minion_ifc__resp__rdy [0:0];

  BlockingCacheRTL__97559d5d0b1f6da0 icaches__0
  (
    .clk( icaches__clk[0] ),
    .reset( icaches__reset[0] ),
    .mem_master_ifc__req__en( icaches__mem_master_ifc__req__en[0] ),
    .mem_master_ifc__req__msg( icaches__mem_master_ifc__req__msg[0] ),
    .mem_master_ifc__req__rdy( icaches__mem_master_ifc__req__rdy[0] ),
    .mem_master_ifc__resp__en( icaches__mem_master_ifc__resp__en[0] ),
    .mem_master_ifc__resp__msg( icaches__mem_master_ifc__resp__msg[0] ),
    .mem_master_ifc__resp__rdy( icaches__mem_master_ifc__resp__rdy[0] ),
    .mem_minion_ifc__req__en( icaches__mem_minion_ifc__req__en[0] ),
    .mem_minion_ifc__req__msg( icaches__mem_minion_ifc__req__msg[0] ),
    .mem_minion_ifc__req__rdy( icaches__mem_minion_ifc__req__rdy[0] ),
    .mem_minion_ifc__resp__en( icaches__mem_minion_ifc__resp__en[0] ),
    .mem_minion_ifc__resp__msg( icaches__mem_minion_ifc__resp__msg[0] ),
    .mem_minion_ifc__resp__rdy( icaches__mem_minion_ifc__resp__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component icaches[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component intra_tile_net
  //-------------------------------------------------------------

  logic [0:0] intra_tile_net__clk;
  logic [0:0] intra_tile_net__reset;
  logic [0:0] intra_tile_net__from_mngr__en;
  TileCtrlMsg_1__coreid_1__data_32 intra_tile_net__from_mngr__msg;
  logic [0:0] intra_tile_net__from_mngr__rdy;
  logic [0:0] intra_tile_net__from_proc__en [0:0];
  logic [31:0] intra_tile_net__from_proc__msg [0:0];
  logic [0:0] intra_tile_net__from_proc__rdy [0:0];
  logic [0:0] intra_tile_net__to_mngr__en;
  TileCtrlMsg_1__coreid_1__data_32 intra_tile_net__to_mngr__msg;
  logic [0:0] intra_tile_net__to_mngr__rdy;
  logic [0:0] intra_tile_net__to_proc__en [0:0];
  logic [31:0] intra_tile_net__to_proc__msg [0:0];
  logic [0:0] intra_tile_net__to_proc__rdy [0:0];

  IntraTileCtrlNet__2a28ef76eb7cf049 intra_tile_net
  (
    .clk( intra_tile_net__clk ),
    .reset( intra_tile_net__reset ),
    .from_mngr__en( intra_tile_net__from_mngr__en ),
    .from_mngr__msg( intra_tile_net__from_mngr__msg ),
    .from_mngr__rdy( intra_tile_net__from_mngr__rdy ),
    .from_proc__en( intra_tile_net__from_proc__en ),
    .from_proc__msg( intra_tile_net__from_proc__msg ),
    .from_proc__rdy( intra_tile_net__from_proc__rdy ),
    .to_mngr__en( intra_tile_net__to_mngr__en ),
    .to_mngr__msg( intra_tile_net__to_mngr__msg ),
    .to_mngr__rdy( intra_tile_net__to_mngr__rdy ),
    .to_proc__en( intra_tile_net__to_proc__en ),
    .to_proc__msg( intra_tile_net__to_proc__msg ),
    .to_proc__rdy( intra_tile_net__to_proc__rdy )
  );

  //-------------------------------------------------------------
  // End of component intra_tile_net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mdus[0:0]
  //-------------------------------------------------------------

  logic [0:0] mdus__clk [0:0];
  logic [0:0] mdus__reset [0:0];
  logic [0:0] mdus__req__en [0:0];
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 mdus__req__msg [0:0];
  logic [0:0] mdus__req__rdy [0:0];
  logic [0:0] mdus__resp__en [0:0];
  MduRespMsg_8_32__opaque_8__res_32 mdus__resp__msg [0:0];
  logic [0:0] mdus__resp__rdy [0:0];

  IntMulDivUnit__c5b256859b3294d6 mdus__0
  (
    .clk( mdus__clk[0] ),
    .reset( mdus__reset[0] ),
    .req__en( mdus__req__en[0] ),
    .req__msg( mdus__req__msg[0] ),
    .req__rdy( mdus__req__rdy[0] ),
    .resp__en( mdus__resp__en[0] ),
    .resp__msg( mdus__resp__msg[0] ),
    .resp__rdy( mdus__resp__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component mdus[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component mem_net
  //-------------------------------------------------------------

  logic [0:0] mem_net__clk;
  logic [0:0] mem_net__reset;
  logic [0:0] mem_net__cache_ifc__req__en [0:1];
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 mem_net__cache_ifc__req__msg [0:1];
  logic [0:0] mem_net__cache_ifc__req__rdy [0:1];
  logic [0:0] mem_net__cache_ifc__resp__en [0:1];
  MemRespMsg_8_128_m1__c72937e2b7853c90 mem_net__cache_ifc__resp__msg [0:1];
  logic [0:0] mem_net__cache_ifc__resp__rdy [0:1];
  logic [0:0] mem_net__mem_ifc__req__en;
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 mem_net__mem_ifc__req__msg;
  logic [0:0] mem_net__mem_ifc__req__rdy;
  logic [0:0] mem_net__mem_ifc__resp__en;
  MemRespMsg_8_128_m1__c72937e2b7853c90 mem_net__mem_ifc__resp__msg;
  logic [0:0] mem_net__mem_ifc__resp__rdy;

  MasterMinionXbar__ncaches_2 mem_net
  (
    .clk( mem_net__clk ),
    .reset( mem_net__reset ),
    .cache_ifc__req__en( mem_net__cache_ifc__req__en ),
    .cache_ifc__req__msg( mem_net__cache_ifc__req__msg ),
    .cache_ifc__req__rdy( mem_net__cache_ifc__req__rdy ),
    .cache_ifc__resp__en( mem_net__cache_ifc__resp__en ),
    .cache_ifc__resp__msg( mem_net__cache_ifc__resp__msg ),
    .cache_ifc__resp__rdy( mem_net__cache_ifc__resp__rdy ),
    .mem_ifc__req__en( mem_net__mem_ifc__req__en ),
    .mem_ifc__req__msg( mem_net__mem_ifc__req__msg ),
    .mem_ifc__req__rdy( mem_net__mem_ifc__req__rdy ),
    .mem_ifc__resp__en( mem_net__mem_ifc__resp__en ),
    .mem_ifc__resp__msg( mem_net__mem_ifc__resp__msg ),
    .mem_ifc__resp__rdy( mem_net__mem_ifc__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component mem_net
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component procs[0:0]
  //-------------------------------------------------------------

  logic [0:0] procs__clk [0:0];
  logic [0:0] procs__commit_inst [0:0];
  logic [31:0] procs__commit_pc [0:0];
  logic [0:0] procs__go_bit [0:0];
  logic [31:0] procs__ntiles [0:0];
  logic [0:0] procs__reset [0:0];
  logic [31:0] procs__reset_pc [0:0];
  logic [0:0] procs__stats_en [0:0];
  logic [31:0] procs__tile_x [0:0];
  logic [31:0] procs__tile_y [0:0];
  logic [31:0] procs__tileid [0:0];
  logic [0:0] procs__dmem__req__en [0:0];
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 procs__dmem__req__msg [0:0];
  logic [0:0] procs__dmem__req__rdy [0:0];
  logic [0:0] procs__dmem__resp__en [0:0];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 procs__dmem__resp__msg [0:0];
  logic [0:0] procs__dmem__resp__rdy [0:0];
  logic [0:0] procs__fpu__req__en [0:0];
  FpuReqMsg_8_32__type__4__opaque_8__op_a_32__op_b_32__frnd_3 procs__fpu__req__msg [0:0];
  logic [0:0] procs__fpu__req__rdy [0:0];
  logic [0:0] procs__fpu__resp__en [0:0];
  FpuRespMsg_8_32__opaque_8__result_32__fexc_5 procs__fpu__resp__msg [0:0];
  logic [0:0] procs__fpu__resp__rdy [0:0];
  logic [0:0] procs__imem__req__en [0:0];
  MemReqMsg__type__4__opaque_8__addr_32__len_2__data_32 procs__imem__req__msg [0:0];
  logic [0:0] procs__imem__req__rdy [0:0];
  logic [0:0] procs__imem__resp__en [0:0];
  MemRespMsg__type__4__opaque_8__test_2__len_2__data_32 procs__imem__resp__msg [0:0];
  logic [0:0] procs__imem__resp__rdy [0:0];
  logic [0:0] procs__mdu__req__en [0:0];
  MduReqMsg_8_32__type__3__opaque_8__op_a_32__op_b_32 procs__mdu__req__msg [0:0];
  logic [0:0] procs__mdu__req__rdy [0:0];
  logic [0:0] procs__mdu__resp__en [0:0];
  MduRespMsg_8_32__opaque_8__res_32 procs__mdu__resp__msg [0:0];
  logic [0:0] procs__mdu__resp__rdy [0:0];
  logic [0:0] procs__mngr2proc__en [0:0];
  logic [31:0] procs__mngr2proc__msg [0:0];
  logic [0:0] procs__mngr2proc__rdy [0:0];
  logic [0:0] procs__proc2mngr__en [0:0];
  logic [31:0] procs__proc2mngr__msg [0:0];
  logic [0:0] procs__proc2mngr__rdy [0:0];

  ProcI2OL_Pipeline__numcores_1__coreid_0 procs__0
  (
    .clk( procs__clk[0] ),
    .commit_inst( procs__commit_inst[0] ),
    .commit_pc( procs__commit_pc[0] ),
    .go_bit( procs__go_bit[0] ),
    .ntiles( procs__ntiles[0] ),
    .reset( procs__reset[0] ),
    .reset_pc( procs__reset_pc[0] ),
    .stats_en( procs__stats_en[0] ),
    .tile_x( procs__tile_x[0] ),
    .tile_y( procs__tile_y[0] ),
    .tileid( procs__tileid[0] ),
    .dmem__req__en( procs__dmem__req__en[0] ),
    .dmem__req__msg( procs__dmem__req__msg[0] ),
    .dmem__req__rdy( procs__dmem__req__rdy[0] ),
    .dmem__resp__en( procs__dmem__resp__en[0] ),
    .dmem__resp__msg( procs__dmem__resp__msg[0] ),
    .dmem__resp__rdy( procs__dmem__resp__rdy[0] ),
    .fpu__req__en( procs__fpu__req__en[0] ),
    .fpu__req__msg( procs__fpu__req__msg[0] ),
    .fpu__req__rdy( procs__fpu__req__rdy[0] ),
    .fpu__resp__en( procs__fpu__resp__en[0] ),
    .fpu__resp__msg( procs__fpu__resp__msg[0] ),
    .fpu__resp__rdy( procs__fpu__resp__rdy[0] ),
    .imem__req__en( procs__imem__req__en[0] ),
    .imem__req__msg( procs__imem__req__msg[0] ),
    .imem__req__rdy( procs__imem__req__rdy[0] ),
    .imem__resp__en( procs__imem__resp__en[0] ),
    .imem__resp__msg( procs__imem__resp__msg[0] ),
    .imem__resp__rdy( procs__imem__resp__rdy[0] ),
    .mdu__req__en( procs__mdu__req__en[0] ),
    .mdu__req__msg( procs__mdu__req__msg[0] ),
    .mdu__req__rdy( procs__mdu__req__rdy[0] ),
    .mdu__resp__en( procs__mdu__resp__en[0] ),
    .mdu__resp__msg( procs__mdu__resp__msg[0] ),
    .mdu__resp__rdy( procs__mdu__resp__rdy[0] ),
    .mngr2proc__en( procs__mngr2proc__en[0] ),
    .mngr2proc__msg( procs__mngr2proc__msg[0] ),
    .mngr2proc__rdy( procs__mngr2proc__rdy[0] ),
    .proc2mngr__en( procs__proc2mngr__en[0] ),
    .proc2mngr__msg( procs__proc2mngr__msg[0] ),
    .proc2mngr__rdy( procs__proc2mngr__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component procs[0:0]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile_manager
  //-------------------------------------------------------------

  logic [0:0] tile_manager__clk;
  logic [0:0] tile_manager__reset;
  logic [0:0] tile_manager__done_ifc__en;
  logic [31:0] tile_manager__done_ifc__msg;
  logic [0:0] tile_manager__from_proc__en;
  TileCtrlMsg_1__coreid_1__data_32 tile_manager__from_proc__msg;
  logic [0:0] tile_manager__from_proc__rdy;
  logic [0:0] tile_manager__go_ifc__en;
  logic [0:0] tile_manager__go_ifc__msg;
  logic [0:0] tile_manager__test_sink__en;
  TileCtrlMsg_1__coreid_1__data_32 tile_manager__test_sink__msg;
  logic [0:0] tile_manager__test_sink__rdy;
  logic [0:0] tile_manager__test_src__en;
  TileCtrlMsg_1__coreid_1__data_32 tile_manager__test_src__msg;
  logic [0:0] tile_manager__test_src__rdy;
  logic [0:0] tile_manager__to_proc__en;
  TileCtrlMsg_1__coreid_1__data_32 tile_manager__to_proc__msg;
  logic [0:0] tile_manager__to_proc__rdy;

  TileManager__d4f13492c2055a3b tile_manager
  (
    .clk( tile_manager__clk ),
    .reset( tile_manager__reset ),
    .done_ifc__en( tile_manager__done_ifc__en ),
    .done_ifc__msg( tile_manager__done_ifc__msg ),
    .from_proc__en( tile_manager__from_proc__en ),
    .from_proc__msg( tile_manager__from_proc__msg ),
    .from_proc__rdy( tile_manager__from_proc__rdy ),
    .go_ifc__en( tile_manager__go_ifc__en ),
    .go_ifc__msg( tile_manager__go_ifc__msg ),
    .test_sink__en( tile_manager__test_sink__en ),
    .test_sink__msg( tile_manager__test_sink__msg ),
    .test_sink__rdy( tile_manager__test_sink__rdy ),
    .test_src__en( tile_manager__test_src__en ),
    .test_src__msg( tile_manager__test_src__msg ),
    .test_src__rdy( tile_manager__test_src__rdy ),
    .to_proc__en( tile_manager__to_proc__en ),
    .to_proc__msg( tile_manager__to_proc__msg ),
    .to_proc__rdy( tile_manager__to_proc__rdy )
  );

  //-------------------------------------------------------------
  // End of component tile_manager
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component trans
  //-------------------------------------------------------------

  logic [0:0] trans__clk;
  logic [27:0] trans__in_addr;
  logic [31:0] trans__in_data;
  logic [6:0] trans__in_load_info;
  logic [3:0] trans__in_mask;
  logic [1:0] trans__in_src_x_cord;
  logic [2:0] trans__in_src_y_cord;
  logic [0:0] trans__in_v;
  logic [0:0] trans__in_we;
  logic [0:0] trans__in_yumi;
  logic [1:0] trans__my_x;
  logic [2:0] trans__my_y;
  logic [7:0] trans__out_credit;
  HBEndpointPacket__29ee445108156f7d trans__out_packet;
  logic [0:0] trans__out_ready;
  logic [0:0] trans__out_v;
  logic [0:0] trans__reset;
  logic [31:0] trans__returned_data_r;
  logic [0:0] trans__returned_fifo_full;
  logic [1:0] trans__returned_pkt_type_r;
  logic [4:0] trans__returned_reg_id_r;
  logic [0:0] trans__returned_v_r;
  logic [0:0] trans__returned_yumi;
  logic [31:0] trans__returning_data;
  logic [0:0] trans__returning_v;
  logic [0:0] trans__mem_minion_ifc__req__en;
  MemReqMsg_8_32_128_m1__35a1cc23a1d2d863 trans__mem_minion_ifc__req__msg;
  logic [0:0] trans__mem_minion_ifc__req__rdy;
  logic [0:0] trans__mem_minion_ifc__resp__en;
  MemRespMsg_8_128_m1__c72937e2b7853c90 trans__mem_minion_ifc__resp__msg;
  logic [0:0] trans__mem_minion_ifc__resp__rdy;

  HBTransducer__789323c469943ea8 trans
  (
    .clk( trans__clk ),
    .in_addr( trans__in_addr ),
    .in_data( trans__in_data ),
    .in_load_info( trans__in_load_info ),
    .in_mask( trans__in_mask ),
    .in_src_x_cord( trans__in_src_x_cord ),
    .in_src_y_cord( trans__in_src_y_cord ),
    .in_v( trans__in_v ),
    .in_we( trans__in_we ),
    .in_yumi( trans__in_yumi ),
    .my_x( trans__my_x ),
    .my_y( trans__my_y ),
    .out_credit( trans__out_credit ),
    .out_packet( trans__out_packet ),
    .out_ready( trans__out_ready ),
    .out_v( trans__out_v ),
    .reset( trans__reset ),
    .returned_data_r( trans__returned_data_r ),
    .returned_fifo_full( trans__returned_fifo_full ),
    .returned_pkt_type_r( trans__returned_pkt_type_r ),
    .returned_reg_id_r( trans__returned_reg_id_r ),
    .returned_v_r( trans__returned_v_r ),
    .returned_yumi( trans__returned_yumi ),
    .returning_data( trans__returning_data ),
    .returning_v( trans__returning_v ),
    .mem_minion_ifc__req__en( trans__mem_minion_ifc__req__en ),
    .mem_minion_ifc__req__msg( trans__mem_minion_ifc__req__msg ),
    .mem_minion_ifc__req__rdy( trans__mem_minion_ifc__req__rdy ),
    .mem_minion_ifc__resp__en( trans__mem_minion_ifc__resp__en ),
    .mem_minion_ifc__resp__msg( trans__mem_minion_ifc__resp__msg ),
    .mem_minion_ifc__resp__rdy( trans__mem_minion_ifc__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component trans
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/HBTile.py:180
  // s.procs[ i ].tile_x //= lambda: zext(s.my_x, 32)
  
  always_comb begin : _lambda__s_procs_0__tile_x
    procs__tile_x[1'd0] = { { 30 { 1'b0 } }, my_x };
  end

  // PyMTL Lambda Block Source
  // At /work/global/mw828/cifer/cifer-chip/brg_tile/HBTile.py:181
  // s.procs[ i ].tile_y //= lambda: zext(s.my_y, 32)
  
  always_comb begin : _lambda__s_procs_0__tile_y
    procs__tile_y[1'd0] = { { 29 { 1'b0 } }, my_y };
  end

  assign tile_manager__clk = clk;
  assign tile_manager__reset = reset;
  assign intra_tile_net__clk = clk;
  assign intra_tile_net__reset = reset;
  assign procs__clk[0] = clk;
  assign procs__reset[0] = reset;
  assign dcaches__clk[0] = clk;
  assign dcaches__reset[0] = reset;
  assign mdus__clk[0] = clk;
  assign mdus__reset[0] = reset;
  assign fpus__clk[0] = clk;
  assign fpus__reset[0] = reset;
  assign icaches__clk[0] = clk;
  assign icaches__reset[0] = reset;
  assign mem_net__clk = clk;
  assign mem_net__reset = reset;
  assign trans__clk = clk;
  assign trans__reset = reset;
  assign tile_manager__go_ifc__en = go_ifc__en;
  assign tile_manager__go_ifc__msg = go_ifc__msg;
  assign done_ifc__en = tile_manager__done_ifc__en;
  assign done_ifc__msg = tile_manager__done_ifc__msg;
  assign tile_manager__test_src__en = test_src__en;
  assign tile_manager__test_src__msg = test_src__msg;
  assign test_src__rdy = tile_manager__test_src__rdy;
  assign test_sink__en = tile_manager__test_sink__en;
  assign test_sink__msg = tile_manager__test_sink__msg;
  assign tile_manager__test_sink__rdy = test_sink__rdy;
  assign intra_tile_net__from_mngr__en = tile_manager__to_proc__en;
  assign intra_tile_net__from_mngr__msg = tile_manager__to_proc__msg;
  assign tile_manager__to_proc__rdy = intra_tile_net__from_mngr__rdy;
  assign tile_manager__from_proc__en = intra_tile_net__to_mngr__en;
  assign tile_manager__from_proc__msg = intra_tile_net__to_mngr__msg;
  assign intra_tile_net__to_mngr__rdy = tile_manager__from_proc__rdy;
  assign procs__ntiles[0] = ntiles;
  assign procs__tileid[0] = tileid;
  assign procs__reset_pc[0] = 32'd2147483648;
  assign procs__go_bit[0] = 1'd1;
  assign intra_tile_net__from_proc__en[0] = procs__proc2mngr__en[0];
  assign intra_tile_net__from_proc__msg[0] = procs__proc2mngr__msg[0];
  assign procs__proc2mngr__rdy[0] = intra_tile_net__from_proc__rdy[0];
  assign procs__mngr2proc__en[0] = intra_tile_net__to_proc__en[0];
  assign procs__mngr2proc__msg[0] = intra_tile_net__to_proc__msg[0];
  assign intra_tile_net__to_proc__rdy[0] = procs__mngr2proc__rdy[0];
  assign trans__mem_minion_ifc__req__en = mem_net__mem_ifc__req__en;
  assign trans__mem_minion_ifc__req__msg = mem_net__mem_ifc__req__msg;
  assign mem_net__mem_ifc__req__rdy = trans__mem_minion_ifc__req__rdy;
  assign mem_net__mem_ifc__resp__en = trans__mem_minion_ifc__resp__en;
  assign mem_net__mem_ifc__resp__msg = trans__mem_minion_ifc__resp__msg;
  assign trans__mem_minion_ifc__resp__rdy = mem_net__mem_ifc__resp__rdy;
  assign trans__my_x = my_x;
  assign trans__my_y = my_y;
  assign trans__in_v = in_v;
  assign trans__in_data = in_data;
  assign trans__in_mask = in_mask;
  assign trans__in_addr = in_addr;
  assign trans__in_we = in_we;
  assign trans__in_load_info = in_load_info;
  assign trans__in_src_x_cord = in_src_x_cord;
  assign trans__in_src_y_cord = in_src_y_cord;
  assign in_yumi = trans__in_yumi;
  assign returning_data = trans__returning_data;
  assign returning_v = trans__returning_v;
  assign out_v = trans__out_v;
  assign out_packet = trans__out_packet;
  assign trans__out_ready = out_ready;
  assign trans__out_credit = out_credit;
  assign trans__returned_data_r = returned_data_r;
  assign trans__returned_reg_id_r = returned_reg_id_r;
  assign trans__returned_v_r = returned_v_r;
  assign trans__returned_pkt_type_r = returned_pkt_type_r;
  assign returned_yumi = trans__returned_yumi;
  assign trans__returned_fifo_full = returned_fifo_full;
  assign commit_inst = procs__commit_inst[0];
  assign commit_pc = procs__commit_pc[0];
  assign dcaches__mem_minion_ifc__req__en[0] = procs__dmem__req__en[0];
  assign dcaches__mem_minion_ifc__req__msg[0] = procs__dmem__req__msg[0];
  assign procs__dmem__req__rdy[0] = dcaches__mem_minion_ifc__req__rdy[0];
  assign procs__dmem__resp__en[0] = dcaches__mem_minion_ifc__resp__en[0];
  assign procs__dmem__resp__msg[0] = dcaches__mem_minion_ifc__resp__msg[0];
  assign dcaches__mem_minion_ifc__resp__rdy[0] = procs__dmem__resp__rdy[0];
  assign mem_net__cache_ifc__req__en[0] = icaches__mem_master_ifc__req__en[0];
  assign mem_net__cache_ifc__req__msg[0] = icaches__mem_master_ifc__req__msg[0];
  assign icaches__mem_master_ifc__req__rdy[0] = mem_net__cache_ifc__req__rdy[0];
  assign icaches__mem_master_ifc__resp__en[0] = mem_net__cache_ifc__resp__en[0];
  assign icaches__mem_master_ifc__resp__msg[0] = mem_net__cache_ifc__resp__msg[0];
  assign mem_net__cache_ifc__resp__rdy[0] = icaches__mem_master_ifc__resp__rdy[0];
  assign mem_net__cache_ifc__req__en[1] = dcaches__mem_master_ifc__req__en[0];
  assign mem_net__cache_ifc__req__msg[1] = dcaches__mem_master_ifc__req__msg[0];
  assign dcaches__mem_master_ifc__req__rdy[0] = mem_net__cache_ifc__req__rdy[1];
  assign dcaches__mem_master_ifc__resp__en[0] = mem_net__cache_ifc__resp__en[1];
  assign dcaches__mem_master_ifc__resp__msg[0] = mem_net__cache_ifc__resp__msg[1];
  assign mem_net__cache_ifc__resp__rdy[1] = dcaches__mem_master_ifc__resp__rdy[0];
  assign icaches__mem_minion_ifc__req__en[0] = procs__imem__req__en[0];
  assign icaches__mem_minion_ifc__req__msg[0] = procs__imem__req__msg[0];
  assign procs__imem__req__rdy[0] = icaches__mem_minion_ifc__req__rdy[0];
  assign procs__imem__resp__en[0] = icaches__mem_minion_ifc__resp__en[0];
  assign procs__imem__resp__msg[0] = icaches__mem_minion_ifc__resp__msg[0];
  assign icaches__mem_minion_ifc__resp__rdy[0] = procs__imem__resp__rdy[0];
  assign fpus__req__en[0] = procs__fpu__req__en[0];
  assign fpus__req__msg[0] = procs__fpu__req__msg[0];
  assign procs__fpu__req__rdy[0] = fpus__req__rdy[0];
  assign procs__fpu__resp__en[0] = fpus__resp__en[0];
  assign procs__fpu__resp__msg[0] = fpus__resp__msg[0];
  assign fpus__resp__rdy[0] = procs__fpu__resp__rdy[0];
  assign mdus__req__en[0] = procs__mdu__req__en[0];
  assign mdus__req__msg[0] = procs__mdu__req__msg[0];
  assign procs__mdu__req__rdy[0] = mdus__req__rdy[0];
  assign procs__mdu__resp__en[0] = mdus__resp__en[0];
  assign procs__mdu__resp__msg[0] = mdus__resp__msg[0];
  assign mdus__resp__rdy[0] = procs__mdu__resp__rdy[0];

endmodule
//========================================================================
// SRAM wrappers
//========================================================================
// Author: Shady Agwa
// Date: May 2020

module SramGenericPRTL
 #(parameter num_bits=128 , parameter num_words=256)
(
  input logic [($clog2(num_words))-1:0] A1 ,
  input logic [0:0] CE1 ,
  input logic [0:0] CSB1 ,
  input logic [num_bits-1:0] I1 ,
  output logic [num_bits-1:0] O1 ,
  input logic [0:0] OEB1 ,
  input logic [num_bits-1:0] WBM1 ,
  input logic [0:0] WEB1 ,
  input logic [0:0] clk ,
  input logic [0:0] reset
);

  wire  cen;
  wire rdwen;
  wire [$clog2(num_words)-1:0] a;
  wire [num_bits-1:0] d;
  wire [num_bits-1:0] bw;
  logic [num_bits-1:0] q;

  localparam logic [31:0] __const__nbytes_at_write_logic  = (num_bits/8);
  localparam logic [31:0] __const__num_words_at_write_logic  = num_words;
  localparam logic [31:0] __const__num_bits_at_write_logic  = num_bits;
  localparam logic [31:0] __const__num_words_at_update_sram  = num_words;

  assign a = A1;
  assign d = I1;
  assign rdwen = WEB1; // READ Active High & Write Active Low
  assign cen = CSB1;  // CSB1 Active Low
  assign bw = WBM1;  // WBM1 Active High

if ((num_bits==128) && (num_words==256)) begin
    gf14_sram_256x128 brg_sram_256x128 (.clk(clk), .cen(cen), .rdwen(rdwen), .a(a), .d(d), .bw(bw), .q(q));
  end
  else if((num_bits==26) && (num_words==128)) begin
    gf14_sram_128x26 brg_sram_128x26 (.clk(clk), .cen(cen), .rdwen(rdwen), .a(a), .d(d), .bw(bw), .q(q));
  end
  else begin
  // Do not find a hard SRAM, then use the behavioral model
  logic [num_bits-1:0] dout_next;
  logic [num_bits-1:0] ram [0:num_words-1];
  logic [num_bits-1:0] ram_next [0:num_words-1];

    always_comb begin : read_logic
      if ( ( !CSB1 ) && WEB1 ) begin
        dout_next = ram[A1];
      end
      else
        dout_next = 0;
    end

    always_comb begin : write_logic
      for ( int i = 0; i < __const__num_words_at_write_logic; i += 1 )
        ram_next[i] = ram[i];
      for ( int i = 0; i < __const__num_bits_at_write_logic; i += 1 )
        if ( ( !CSB1 ) && ( !WEB1 ) && WBM1[i] ) begin // Bit Mask
          ram_next[A1][i] = I1[i];
        end
    end
    always_ff @(posedge clk) begin : update_sram
      q <= dout_next;
      if ( ( !CSB1 ) && ( !WEB1 ) ) begin
        for ( int i = 0; i < __const__num_words_at_update_sram; i += 1 )
          ram[i] <= ram_next[i];
      end
    end

  end

// Enable the output
 always_comb begin : comb_logic
    if ( !OEB1 ) begin
      O1 = q;
    end
    else
      O1 = 0;
  end

endmodule

module gf14_sram_256x128
   (
    input  clk,
    input  cen,
    input  rdwen,
    input  [7:0] a,
    input  [127:0] d,
    input  [127:0] bw,
    output [127:0] q
    );

   sram_256x128 R1PB
     (
      .CLK         (clk),
      .CEN         (cen),
      .RDWEN       (rdwen),
      .A           (a),
      .D           (d),
      .BW          (bw),
      .T_LOGIC     (1'b0),
      .T_Q_RST     (1'b0),
      .MA_SAWL     (1'b0),
      .MA_WL       (1'b0),
      .MA_VD1      (1'b0),
      .MA_VD0      (1'b0),
      .MA_WRT      (1'b0),
      .Q           (q),
      .OBSV_CTL    ()
     );

endmodule

module gf14_sram_128x26
   (
    input  clk,
    input  cen,
    input  rdwen,
    input  [6:0] a,
    input  [25:0] d,
    input  [25:0] bw,
    output [25:0] q
    );


   sram_128x26 R1PB
     (
      .CLK         (clk),
      .CEN         (cen),
      .RDWEN       (rdwen),
      .A           (a),
      .D           (d),
      .BW          (bw),
      .T_LOGIC     (1'b0),
      .T_Q_RST     (1'b0),
      .MA_SAWL     (1'b0),
      .MA_WL       (1'b0),
      .MA_VD1      (1'b0),
      .MA_VD0      (1'b0),
      .MA_WRT      (1'b0),
      .Q           (q),
      .OBSV_CTL    ()
     );

endmodule

//------------------------------------------------------------------------
// Behavior models
//------------------------------------------------------------------------
// Behavior models for gf14_sram_256x128 and gf14_sram_128x26. Should be
// replaced with real SRAM cells in ASIC flows

// synopsys translate_off

module sram_128x26
(
   input logic CLK,
   input logic CEN,
   input logic RDWEN,
   input logic [6:0] A,
   input logic [25:0] D,
   input logic [25:0] BW,
   input logic T_LOGIC,
   input logic T_Q_RST,
   output logic [25:0] Q,
   output logic [1:0] OBSV_CTL,
   input logic MA_SAWL,
   input logic MA_WL,
   input logic MA_VD1,
   input logic MA_VD0,
   input logic MA_WRT

);

  logic [25:0] dout_next;
  logic [25:0] ram [0:127];
  logic [25:0] ram_next [0:127];

  always_comb begin : read_logic
    if ( ( !CEN ) && RDWEN ) begin
      dout_next = ram[A];
    end
    else
      dout_next = 0;
  end

  always_comb begin : write_logic
    for ( int i = 0; i < 128; i += 1 )
      ram_next[i] = ram[i];
    for ( int i = 0; i < 26; i += 1 )
      if ( ( !CEN ) && ( !RDWEN ) && BW[i] ) begin // Bit Mask
        ram_next[A][i] = D[i];
      end
  end

  always_ff @(posedge CLK) begin : update_sram
    Q <= dout_next;
    if ( ( !CEN ) && ( !RDWEN ) ) begin
      for ( int i = 0; i < 128; i += 1 )
        ram[i] <= ram_next[i];
    end
  end

endmodule

module sram_256x128
(
   input logic CLK,
   input logic CEN,
   input logic RDWEN,
   input logic [7:0] A,
   input logic [127:0] D,
   input logic [127:0] BW,
   input logic T_LOGIC,
   input logic T_Q_RST,
   output logic [127:0] Q,
   output logic [1:0] OBSV_CTL,
   input logic MA_SAWL,
   input logic MA_WL,
   input logic MA_VD1,
   input logic MA_VD0,
   input logic MA_WRT
);

  logic [127:0] dout_next;
  logic [127:0] ram [0:255];
  logic [127:0] ram_next [0:255];

  always_comb begin : read_logic
    if ( ( !CEN ) && RDWEN) begin
      dout_next = ram[A];
    end
    else
      dout_next = 0;
  end

  always_comb begin : write_logic
    for ( int i = 0; i < 256; i += 1 )
      ram_next[i] = ram[i];
    for ( int i = 0; i < 128; i += 1 )
      if ( ( !CEN ) && ( !RDWEN ) && BW[i] ) begin // Bit Mask
        ram_next[A][i] = D[i];
      end
  end

  always_ff @(posedge CLK) begin : update_sram
    Q <= dout_next;
    if ( ( !CEN ) && ( !RDWEN ) ) begin
      for ( int i = 0; i < 256; i += 1 )
        ram[i] <= ram_next[i];
    end
  end

endmodule

// synopsys translate_on
