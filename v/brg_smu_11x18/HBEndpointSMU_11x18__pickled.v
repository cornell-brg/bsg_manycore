//-------------------------------------------------------------------------
// HBEndpointSMU_11x18.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct XcelReqMsg__type__1__addr_4__data_32 Definition
typedef struct packed {
  logic [0:0] type_;
  logic [3:0] addr;
  logic [31:0] data;
} XcelReqMsg__type__1__addr_4__data_32;

// PyMTL BitStruct XcelRespMsg__type__1__data_32 Definition
typedef struct packed {
  logic [0:0] type_;
  logic [31:0] data;
} XcelRespMsg__type__1__data_32;

// PyMTL BitStruct SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 Definition
typedef struct packed {
  logic [0:0] wen;
  logic [4:0] reg_id;
  logic [5:0] opaque;
  logic [31:0] addr;
  logic [31:0] data;
} SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32;

// PyMTL BitStruct SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 Definition
typedef struct packed {
  logic [0:0] wen;
  logic [4:0] reg_id;
  logic [5:0] opaque;
  logic [31:0] data;
} SMURespMsg__wen_1__reg_id_5__opaque_6__data_32;

// PyMTL BitStruct HBEndpointPacket__890e8baa82bc2d18 Definition
typedef struct packed {
  logic [27:0] addr;
  logic [1:0] op;
  logic [3:0] op_ex;
  logic [4:0] reg_id;
  logic [31:0] payload;
  logic [3:0] src_y_cord;
  logic [4:0] src_x_cord;
  logic [3:0] y_cord;
  logic [4:0] x_cord;
} HBEndpointPacket__890e8baa82bc2d18;

// PyMTL Component HBEndpointSMURXAdapter Definition
// Full name: HBEndpointSMURXAdapter__hb_params_<hammerblade.params.HBParams object at 0x7fe4a6e6c4d0>
// At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py

module HBEndpointSMURXAdapter__a2fcce5840d3ec14
(
  input  logic [0:0] clk ,
  output logic [4:0] dst_x_cord ,
  output logic [3:0] dst_y_cord ,
  input  logic [4:0] my_x ,
  input  logic [3:0] my_y ,
  input  logic [27:0] req_addr ,
  input  logic [31:0] req_data ,
  input  logic [6:0] req_load_info ,
  input  logic [3:0] req_mask ,
  input  logic [4:0] req_src_x_cord ,
  input  logic [3:0] req_src_y_cord ,
  input  logic [0:0] req_val ,
  input  logic [0:0] req_we ,
  output logic [0:0] req_yumi ,
  input  logic [0:0] reset ,
  output logic [31:0] resp_data ,
  output logic [0:0] resp_val ,
  output logic [0:0] cfg_master__req__en ,
  output XcelReqMsg__type__1__addr_4__data_32 cfg_master__req__msg ,
  input logic [0:0] cfg_master__req__rdy ,
  input logic [0:0] cfg_master__resp__en ,
  input XcelRespMsg__type__1__data_32 cfg_master__resp__msg ,
  output logic [0:0] cfg_master__resp__rdy 
);
  localparam logic [2:0] __const__cfg_addr_width_at_check_RX_xcel_addr  = 3'd4;
  localparam logic [3:0] __const__DST_CORD  = 4'd10;
  logic [0:0] is_DRAM_enable_addr;
  logic [0:0] is_socket_CSR_addr;
  logic [0:0] is_xcel_addr;
  logic [0:0] needs_fake_resp_r;

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:95
  // @update
  // def RX_yumi_req():
  //   s.req_yumi @= (s.is_xcel_addr & s.req_val & s.cfg_master.req.rdy) | \
  //                 (~s.is_xcel_addr & s.req_val)
  
  always_comb begin : RX_yumi_req
    req_yumi = ( ( is_xcel_addr & req_val ) & cfg_master__req__rdy ) | ( ( ~is_xcel_addr ) & req_val );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:100
  // s.cfg_master.req.en //= lambda: s.req_yumi & s.is_xcel_addr
  
  always_comb begin : _lambda__s_dut_rx_cfg_master_req_en
    cfg_master__req__en = req_yumi & is_xcel_addr;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:120
  // s.resp_data //= lambda: 0 if s.needs_fake_resp_r else s.cfg_master.resp.msg.data
  
  always_comb begin : _lambda__s_dut_rx_resp_data
    resp_data = needs_fake_resp_r ? 32'd0 : cfg_master__resp__msg.data;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:118
  // s.resp_val //= lambda: s.cfg_master.resp.en | s.needs_fake_resp_r
  
  always_comb begin : _lambda__s_dut_rx_resp_val
    resp_val = cfg_master__resp__en | needs_fake_resp_r;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:67
  // @update
  // def check_RX_CSR_addr():
  //   s.is_socket_CSR_addr @= s.req_addr[hp.epa_word_addr_width-1] & \
  //                         ( s.req_addr[hp.epa_word_addr_width:hp.addr_width] == 0 )
  
  always_comb begin : check_RX_CSR_addr
    is_socket_CSR_addr = req_addr[5'd16 - 5'd1] & ( req_addr[5'd27:5'd16] == 12'd0 );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:73
  // @update
  // def check_RX_DRAM_enable_addr():
  //   s.is_DRAM_enable_addr @= s.is_socket_CSR_addr & \
  //                          ( s.req_addr[0:hp.epa_word_addr_width-1] == 4 )
  
  always_comb begin : check_RX_DRAM_enable_addr
    is_DRAM_enable_addr = is_socket_CSR_addr & ( req_addr[4'd14:5'd0] == 15'd4 );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:78
  // @update
  // def check_RX_xcel_addr():
  //   s.is_xcel_addr @= s.req_addr[cfg_addr_width:hp.addr_width] == 0
  
  always_comb begin : check_RX_xcel_addr
    is_xcel_addr = req_addr[5'd27:5'( __const__cfg_addr_width_at_check_RX_xcel_addr )] == 24'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:111
  // @update_ff
  // def RX_register_needs_fake_resp():
  //   s.needs_fake_resp_r <<= s.req_yumi & ((s.is_xcel_addr & s.req_we) | ~s.is_xcel_addr)
  
  always_ff @(posedge clk) begin : RX_register_needs_fake_resp
    needs_fake_resp_r <= req_yumi & ( ( is_xcel_addr & req_we ) | ( ~is_xcel_addr ) );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMURXAdapter.py:82
  // @update_ff
  // def smu_rx_cord_r():
  //   if s.reset:
  //     s.dst_y_cord <<= 0
  //     s.dst_x_cord <<= 0
  //   else:
  //     if (s.req_addr == DST_CORD) & s.req_we:
  //       s.dst_y_cord <<= s.req_data[16:16+hp.y_cord_width]
  //       s.dst_x_cord <<= s.req_data[0 :hp.x_cord_width]
  
  always_ff @(posedge clk) begin : smu_rx_cord_r
    if ( reset ) begin
      dst_y_cord <= 4'd0;
      dst_x_cord <= 5'd0;
    end
    else if ( ( req_addr == 28'( __const__DST_CORD ) ) & req_we ) begin
      dst_y_cord <= req_data[5'd19:5'd16];
      dst_x_cord <= req_data[5'd4:5'd0];
    end
  end

  assign cfg_master__req__msg.type_ = req_we;
  assign cfg_master__req__msg.addr = req_addr[3:0];
  assign cfg_master__req__msg.data = req_data;
  assign cfg_master__resp__rdy = 1'd1;

endmodule


// PyMTL Component StreamingMemUnitCtrl Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py

module StreamingMemUnitCtrl__num_elems_32
(
  output logic [0:0] cfg_go ,
  input  logic [0:0] cfg_req_en ,
  output logic [0:0] cfg_req_rdy ,
  output logic [0:0] cfg_resp_en ,
  input  logic [0:0] cfg_resp_rdy ,
  input  logic [0:0] clk ,
  output logic [0:0] is_ack_state ,
  input  logic [0:0] is_cfg_msg_go ,
  input  logic [0:0] is_padding ,
  input  logic [0:0] local_req_all_sent ,
  input  logic [0:0] local_req_all_sent_n ,
  output logic [0:0] local_req_en ,
  input  logic [0:0] local_req_rdy ,
  input  logic [0:0] local_resp_en ,
  output logic [0:0] local_resp_rdy ,
  output logic [0:0] local_sent ,
  output logic [0:0] pad_resp_en ,
  input  logic [0:0] pad_resp_rdy ,
  input  logic [0:0] remote_req_all_sent ,
  output logic [0:0] remote_req_en ,
  input  logic [0:0] remote_req_rdy ,
  output logic [0:0] remote_sent ,
  output logic [0:0] reorder_q_deq_en ,
  input  logic [0:0] reorder_q_deq_rdy ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__WORK_at_smu_ctrl_fsm_comb_signals  = 1'd1;
  localparam logic [1:0] __const__ACK_at_smu_ctrl_fsm_comb_signals  = 2'd2;
  localparam logic [0:0] __const__IDLE_at_smu_ctrl_fsm  = 1'd0;
  localparam logic [0:0] __const__IDLE_at_smu_ctrl_next_state  = 1'd0;
  localparam logic [0:0] __const__WORK_at_smu_ctrl_next_state  = 1'd1;
  localparam logic [1:0] __const__ACK_at_smu_ctrl_next_state  = 2'd2;
  localparam logic [5:0] __const__num_elems_at_smu_ctrl_credit_counter  = 6'd32;
  localparam logic [1:0] __const__ACK_at__lambda__s_dut_smu_ctrl_is_ack_state  = 2'd2;
  localparam logic [0:0] __const__IDLE_at__lambda__s_dut_smu_ctrl_cfg_req_rdy  = 1'd0;
  localparam logic [0:0] __const__WORK_at__lambda__s_dut_smu_ctrl_remote_req_en  = 1'd1;
  localparam logic [0:0] __const__WORK_at__lambda__s_dut_smu_ctrl_pad_resp_en  = 1'd1;
  localparam logic [0:0] __const__WORK_at__lambda__s_dut_smu_ctrl_local_req_en  = 1'd1;
  localparam logic [1:0] __const__ACK_at__lambda__s_dut_smu_ctrl_local_req_en  = 2'd2;
  logic [5:0] credit_n;
  logic [5:0] credit_r;
  logic [0:0] pad_ifc_sent;
  logic [0:0] remote_ifc_sent;
  logic [0:0] smu_ack_sent;
  logic [0:0] smu_go;
  logic [0:0] smu_work_done;
  logic [1:0] state;
  logic [1:0] state_next;

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:225
  // s.cfg_go //= lambda: s.cfg_req_en & s.cfg_req_rdy
  
  always_comb begin : _lambda__s_dut_smu_ctrl_cfg_go
    cfg_go = cfg_req_en & cfg_req_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:231
  // s.cfg_req_rdy //= lambda: s.state == IDLE
  
  always_comb begin : _lambda__s_dut_smu_ctrl_cfg_req_rdy
    cfg_req_rdy = state == 2'( __const__IDLE_at__lambda__s_dut_smu_ctrl_cfg_req_rdy );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:226
  // s.is_ack_state //= lambda: s.state == ACK
  
  always_comb begin : _lambda__s_dut_smu_ctrl_is_ack_state
    is_ack_state = state == 2'( __const__ACK_at__lambda__s_dut_smu_ctrl_is_ack_state );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:242
  // s.local_req_en //= lambda: s.local_req_rdy & \
  //                            (((s.state == WORK) & ~s.local_req_all_sent & s.reorder_q_deq_en) | \
  //                             (s.state == ACK))
  
  always_comb begin : _lambda__s_dut_smu_ctrl_local_req_en
    local_req_en = local_req_rdy & ( ( ( ( state == 2'( __const__WORK_at__lambda__s_dut_smu_ctrl_local_req_en ) ) & ( ~local_req_all_sent ) ) & reorder_q_deq_en ) | ( state == 2'( __const__ACK_at__lambda__s_dut_smu_ctrl_local_req_en ) ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:229
  // s.local_sent //= lambda: s.local_req_en & s.local_req_rdy
  
  always_comb begin : _lambda__s_dut_smu_ctrl_local_sent
    local_sent = local_req_en & local_req_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:219
  // s.pad_ifc_sent    //= lambda: s.pad_resp_en & s.pad_resp_rdy
  
  always_comb begin : _lambda__s_dut_smu_ctrl_pad_ifc_sent
    pad_ifc_sent = pad_resp_en & pad_resp_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:238
  // s.pad_resp_en //= lambda: s.pad_resp_rdy & (s.state == WORK) & \
  //                           s.is_padding & \
  //                           (s.credit_r != 0) & ~s.remote_req_all_sent
  
  always_comb begin : _lambda__s_dut_smu_ctrl_pad_resp_en
    pad_resp_en = ( ( ( pad_resp_rdy & ( state == 2'( __const__WORK_at__lambda__s_dut_smu_ctrl_pad_resp_en ) ) ) & is_padding ) & ( credit_r != 6'd0 ) ) & ( ~remote_req_all_sent );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:218
  // s.remote_ifc_sent //= lambda: s.remote_req_en & s.remote_req_rdy
  
  always_comb begin : _lambda__s_dut_smu_ctrl_remote_ifc_sent
    remote_ifc_sent = remote_req_en & remote_req_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:234
  // s.remote_req_en //= lambda: s.remote_req_rdy & (s.state == WORK) & \
  //                             ~s.is_padding & \
  //                             (s.credit_r != 0) & ~s.remote_req_all_sent
  
  always_comb begin : _lambda__s_dut_smu_ctrl_remote_req_en
    remote_req_en = ( ( ( remote_req_rdy & ( state == 2'( __const__WORK_at__lambda__s_dut_smu_ctrl_remote_req_en ) ) ) & ( ~is_padding ) ) & ( credit_r != 6'd0 ) ) & ( ~remote_req_all_sent );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:228
  // s.remote_sent //= lambda: s.remote_ifc_sent | s.pad_ifc_sent
  
  always_comb begin : _lambda__s_dut_smu_ctrl_remote_sent
    remote_sent = remote_ifc_sent | pad_ifc_sent;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:246
  // s.reorder_q_deq_en //= lambda: s.reorder_q_deq_rdy & s.local_req_rdy
  
  always_comb begin : _lambda__s_dut_smu_ctrl_reorder_q_deq_en
    reorder_q_deq_en = reorder_q_deq_rdy & local_req_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:210
  // @update
  // def smu_ctrl_credit_n():
  //   s.credit_n @= s.credit_r
  //   if s.remote_sent & ~s.reorder_q_deq_en:
  //     s.credit_n @= s.credit_r - 1
  //   if ~s.remote_sent & s.reorder_q_deq_en:
  //     s.credit_n @= s.credit_r + 1
  
  always_comb begin : smu_ctrl_credit_n
    credit_n = credit_r;
    if ( remote_sent & ( ~reorder_q_deq_en ) ) begin
      credit_n = credit_r - 6'd1;
    end
    if ( ( ~remote_sent ) & reorder_q_deq_en ) begin
      credit_n = credit_r + 6'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:167
  // @update
  // def smu_ctrl_fsm_comb_signals():
  //   s.smu_go        @= s.cfg_req_en & s.cfg_req_rdy & s.is_cfg_msg_go
  //   s.smu_work_done @= (s.state == WORK) & s.local_req_all_sent_n
  //   s.smu_ack_sent  @= (s.state == ACK) & s.local_req_en & s.local_req_rdy
  
  always_comb begin : smu_ctrl_fsm_comb_signals
    smu_go = ( cfg_req_en & cfg_req_rdy ) & is_cfg_msg_go;
    smu_work_done = ( state == 2'( __const__WORK_at_smu_ctrl_fsm_comb_signals ) ) & local_req_all_sent_n;
    smu_ack_sent = ( ( state == 2'( __const__ACK_at_smu_ctrl_fsm_comb_signals ) ) & local_req_en ) & local_req_rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:180
  // @update
  // def smu_ctrl_next_state():
  //   s.state_next @= s.state
  //   if s.state == IDLE:
  //     if s.smu_go:
  //       s.state_next @= WORK
  //   elif s.state == WORK:
  //     if s.smu_work_done:
  //       s.state_next @= ACK
  //   elif s.state == ACK:
  //     if s.smu_ack_sent:
  //       s.state_next @= IDLE
  
  always_comb begin : smu_ctrl_next_state
    state_next = state;
    if ( state == 2'( __const__IDLE_at_smu_ctrl_next_state ) ) begin
      if ( smu_go ) begin
        state_next = 2'( __const__WORK_at_smu_ctrl_next_state );
      end
    end
    else if ( state == 2'( __const__WORK_at_smu_ctrl_next_state ) ) begin
      if ( smu_work_done ) begin
        state_next = 2'( __const__ACK_at_smu_ctrl_next_state );
      end
    end
    else if ( state == 2'( __const__ACK_at_smu_ctrl_next_state ) ) begin
      if ( smu_ack_sent ) begin
        state_next = 2'( __const__IDLE_at_smu_ctrl_next_state );
      end
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:203
  // @update_ff
  // def smu_ctrl_credit_counter():
  //   if s.reset:
  //     s.credit_r <<= num_elems
  //   else:
  //     s.credit_r <<= s.credit_n
  
  always_ff @(posedge clk) begin : smu_ctrl_credit_counter
    if ( reset ) begin
      credit_r <= 6'( __const__num_elems_at_smu_ctrl_credit_counter );
    end
    else
      credit_r <= credit_n;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:173
  // @update_ff
  // def smu_ctrl_fsm():
  //   if s.reset:
  //     s.state <<= IDLE
  //   else:
  //     s.state <<= s.state_next
  
  always_ff @(posedge clk) begin : smu_ctrl_fsm
    if ( reset ) begin
      state <= 2'( __const__IDLE_at_smu_ctrl_fsm );
    end
    else
      state <= state_next;
  end

  assign cfg_resp_en = 1'd0;
  assign local_resp_rdy = 1'd1;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits2__reset_value_1
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [1:0] in_ ,
  output logic [1:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd1;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 2'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RoundRobinArbiterEn Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py

module RoundRobinArbiterEn__nreqs_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  output logic [1:0] grants ,
  input  logic [1:0] reqs ,
  input  logic [0:0] reset 
);
  localparam logic [1:0] __const__nreqs_at_comb_reqs_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_reqs_int  = 3'd4;
  localparam logic [1:0] __const__nreqs_at_comb_grants  = 2'd2;
  localparam logic [1:0] __const__nreqs_at_comb_priority_int  = 2'd2;
  localparam logic [2:0] __const__nreqsX2_at_comb_priority_int  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_kills  = 3'd4;
  localparam logic [2:0] __const__nreqsX2_at_comb_grants_int  = 3'd4;
  logic [3:0] grants_int;
  logic [4:0] kills;
  logic [0:0] priority_en;
  logic [3:0] priority_int;
  logic [3:0] reqs_int;
  //-------------------------------------------------------------
  // Component priority_reg
  //-------------------------------------------------------------

  logic [0:0] priority_reg__clk;
  logic [0:0] priority_reg__en;
  logic [1:0] priority_reg__in_;
  logic [1:0] priority_reg__out;
  logic [0:0] priority_reg__reset;

  RegEnRst__Type_Bits2__reset_value_1 priority_reg
  (
    .clk( priority_reg__clk ),
    .en( priority_reg__en ),
    .in_( priority_reg__in_ ),
    .out( priority_reg__out ),
    .reset( priority_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component priority_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:118
  // @update
  // def comb_grants():
  //   for i in range( nreqs ):
  //     s.grants[i] @= s.grants_int[i] | s.grants_int[nreqs+i]
  
  always_comb begin : comb_grants
    for ( int unsigned i = 1'd0; i < 2'( __const__nreqs_at_comb_grants ); i += 1'd1 )
      grants[1'(i)] = grants_int[2'(i)] | grants_int[2'( __const__nreqs_at_comb_grants ) + 2'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:141
  // @update
  // def comb_grants_int():
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.grants_int[i] @= s.reqs_int[i]
  //     else:
  //       s.grants_int[i] @= ~s.kills[i] & s.reqs_int[i]
  
  always_comb begin : comb_grants_int
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_grants_int ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        grants_int[2'(i)] = reqs_int[2'(i)];
      end
      else
        grants_int[2'(i)] = ( ~kills[3'(i)] ) & reqs_int[2'(i)];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:132
  // @update
  // def comb_kills():
  //   s.kills[0] @= 1
  //   for i in range( nreqsX2 ):
  //     if s.priority_int[i]:
  //       s.kills[i+1] @= s.reqs_int[i]
  //     else:
  //       s.kills[i+1] @= s.kills[i] | ( ~s.kills[i] & s.reqs_int[i] )
  
  always_comb begin : comb_kills
    kills[3'd0] = 1'd1;
    for ( int unsigned i = 1'd0; i < 3'( __const__nreqsX2_at_comb_kills ); i += 1'd1 )
      if ( priority_int[2'(i)] ) begin
        kills[3'(i) + 3'd1] = reqs_int[2'(i)];
      end
      else
        kills[3'(i) + 3'd1] = kills[3'(i)] | ( ( ~kills[3'(i)] ) & reqs_int[2'(i)] );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:123
  // @update
  // def comb_priority_en():
  //   s.priority_en @= ( s.grants != 0 ) & s.en
  
  always_comb begin : comb_priority_en
    priority_en = ( grants != 2'd0 ) & en;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:127
  // @update
  // def comb_priority_int():
  //   s.priority_int[    0:nreqs  ] @= s.priority_reg.out
  //   s.priority_int[nreqs:nreqsX2] @= 0
  
  always_comb begin : comb_priority_int
    priority_int[2'd1:2'd0] = priority_reg__out;
    priority_int[2'd3:2'( __const__nreqs_at_comb_priority_int )] = 2'd0;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/arbiters.py:113
  // @update
  // def comb_reqs_int():
  //   s.reqs_int [    0:nreqs  ] @= s.reqs
  //   s.reqs_int [nreqs:nreqsX2] @= s.reqs
  
  always_comb begin : comb_reqs_int
    reqs_int[2'd1:2'd0] = reqs;
    reqs_int[2'd3:2'( __const__nreqs_at_comb_reqs_int )] = reqs;
  end

  assign priority_reg__clk = clk;
  assign priority_reg__reset = reset;
  assign priority_reg__en = priority_en;
  assign priority_reg__in_[1:1] = grants[0:0];
  assign priority_reg__in_[0:0] = grants[1:1];

endmodule


// PyMTL Component NormalQueueRTLCtrl Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTLCtrl__num_entries_2
(
  input  logic [0:0] clk ,
  input  logic [0:0] deq_rdy ,
  output logic [0:0] deq_val ,
  output logic [0:0] enq_rdy ,
  input  logic [0:0] enq_val ,
  output logic [1:0] num_free_entries ,
  output logic [0:0] raddr ,
  input  logic [0:0] reset ,
  output logic [0:0] waddr ,
  output logic [0:0] wen 
);
  logic [0:0] deq_ptr;
  logic [0:0] deq_ptr_inc;
  logic [0:0] deq_ptr_next;
  logic [0:0] do_deq;
  logic [0:0] do_enq;
  logic [0:0] empty;
  logic [0:0] enq_ptr;
  logic [0:0] enq_ptr_inc;
  logic [0:0] enq_ptr_next;
  logic [0:0] full;
  logic [0:0] full_next_cycle;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py:221
  // @update
  // def comb():
  // 
  //   # only enqueue/dequeue if valid and ready
  // 
  //   s.do_enq @= s.enq_rdy & s.enq_val
  //   s.do_deq @= s.deq_rdy & s.deq_val
  // 
  //   # write enable
  // 
  //   s.wen @= s.do_enq
  // 
  //   # enq ptr incrementer
  // 
  //   if s.enq_ptr == s.last_idx: s.enq_ptr_inc @= 0
  //   else:                       s.enq_ptr_inc @= s.enq_ptr + 1
  // 
  //   # deq ptr incrementer
  // 
  //   if s.deq_ptr == s.last_idx: s.deq_ptr_inc @= 0
  //   else:                       s.deq_ptr_inc @= s.deq_ptr + 1
  // 
  //   # set the next ptr value
  // 
  //   if s.do_enq: s.enq_ptr_next @= s.enq_ptr_inc
  //   else:        s.enq_ptr_next @= s.enq_ptr
  // 
  //   if s.do_deq: s.deq_ptr_next @= s.deq_ptr_inc
  //   else:        s.deq_ptr_next @= s.deq_ptr
  // 
  //   # number of free entries calculation
  // 
  //   if   s.reset:
  //     s.num_free_entries @= s.num_entries
  //   elif s.full:
  //     s.num_free_entries @= 0
  //   elif s.empty:
  //     s.num_free_entries @= s.num_entries
  //   elif s.enq_ptr > s.deq_ptr:
  //     s.num_free_entries @= s.num_entries - zext( s.enq_ptr - s.deq_ptr, SizeType)
  //   elif s.deq_ptr > s.enq_ptr:
  //     s.num_free_entries @= zext( s.deq_ptr - s.enq_ptr, SizeType )
  // 
  //   s.full_next_cycle @= s.do_enq & ~s.do_deq & (s.enq_ptr_next == s.deq_ptr)
  
  always_comb begin : comb
    do_enq = enq_rdy & enq_val;
    do_deq = deq_rdy & deq_val;
    wen = do_enq;
    if ( enq_ptr == 1'd1 ) begin
      enq_ptr_inc = 1'd0;
    end
    else
      enq_ptr_inc = enq_ptr + 1'd1;
    if ( deq_ptr == 1'd1 ) begin
      deq_ptr_inc = 1'd0;
    end
    else
      deq_ptr_inc = deq_ptr + 1'd1;
    if ( do_enq ) begin
      enq_ptr_next = enq_ptr_inc;
    end
    else
      enq_ptr_next = enq_ptr;
    if ( do_deq ) begin
      deq_ptr_next = deq_ptr_inc;
    end
    else
      deq_ptr_next = deq_ptr;
    if ( reset ) begin
      num_free_entries = 2'd2;
    end
    else if ( full ) begin
      num_free_entries = 2'd0;
    end
    else if ( empty ) begin
      num_free_entries = 2'd2;
    end
    else if ( enq_ptr > deq_ptr ) begin
      num_free_entries = 2'd2 - { { 1 { 1'b0 } }, enq_ptr - deq_ptr };
    end
    else if ( deq_ptr > enq_ptr ) begin
      num_free_entries = { { 1 { 1'b0 } }, deq_ptr - enq_ptr };
    end
    full_next_cycle = ( do_enq & ( ~do_deq ) ) & ( enq_ptr_next == deq_ptr );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py:266
  // @update
  // def up_ctrl_signals():
  // 
  //   # set output signals
  // 
  //   s.empty   @= ~s.full & (s.enq_ptr == s.deq_ptr)
  // 
  //   s.enq_rdy @= ~s.full
  //   s.deq_val @= ~s.empty
  // 
  //   # set control signals
  // 
  //   s.waddr   @= s.enq_ptr
  //   s.raddr   @= s.deq_ptr
  
  always_comb begin : up_ctrl_signals
    empty = ( ~full ) & ( enq_ptr == deq_ptr );
    enq_rdy = ~full;
    deq_val = ~empty;
    waddr = enq_ptr;
    raddr = deq_ptr;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py:281
  // @update_ff
  // def seq():
  // 
  //   if s.reset:
  //     s.deq_ptr <<= AddrType( 0 )
  //     s.enq_ptr <<= AddrType( 0 )
  //   else:
  //     s.deq_ptr <<= s.deq_ptr_next
  //     s.enq_ptr <<= s.enq_ptr_next
  // 
  //   if   s.reset:             s.full <<= Bits1(0)
  //   elif s.full_next_cycle:   s.full <<= Bits1(1)
  //   elif (s.do_deq & s.full): s.full <<= Bits1(0)
  //   else:                     s.full <<= s.full
  
  always_ff @(posedge clk) begin : seq
    if ( reset ) begin
      deq_ptr <= 1'd0;
      enq_ptr <= 1'd0;
    end
    else begin
      deq_ptr <= deq_ptr_next;
      enq_ptr <= enq_ptr_next;
    end
    if ( reset ) begin
      full <= 1'd0;
    end
    else if ( full_next_cycle ) begin
      full <= 1'd1;
    end
    else if ( do_deq & full ) begin
      full <= 1'd0;
    end
    else
      full <= full;
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__c31e5c5b35a4ad4f
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueRTLDpath Definition
// Full name: NormalQueueRTLDpath__num_entries_2__Type_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTLDpath__f3f5a597077c4de8
(
  input  logic [0:0] clk ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 deq_bits ,
  input  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 enq_bits ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__c31e5c5b35a4ad4f queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_bits = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_bits;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__num_entries_2__Type_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTL__f3f5a597077c4de8
(
  input  logic [0:0] clk ,
  output logic [1:0] num_free_entries ,
  input  logic [0:0] reset ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 deq__msg  ,
  input logic [0:0] deq__rdy  ,
  output logic [0:0] deq__val  ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 enq__msg  ,
  output logic [0:0] enq__rdy  ,
  input logic [0:0] enq__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__deq_val;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__enq_val;
  logic [1:0] ctrl__num_free_entries;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueRTLCtrl__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .deq_rdy( ctrl__deq_rdy ),
    .deq_val( ctrl__deq_val ),
    .enq_rdy( ctrl__enq_rdy ),
    .enq_val( ctrl__enq_val ),
    .num_free_entries( ctrl__num_free_entries ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__deq_bits;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__enq_bits;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueRTLDpath__f3f5a597077c4de8 dpath
  (
    .clk( dpath__clk ),
    .deq_bits( dpath__deq_bits ),
    .enq_bits( dpath__enq_bits ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__enq_val = enq__val;
  assign enq__rdy = ctrl__enq_rdy;
  assign deq__val = ctrl__deq_val;
  assign ctrl__deq_rdy = deq__rdy;
  assign num_free_entries = ctrl__num_free_entries;
  assign dpath__enq_bits = enq__msg;
  assign deq__msg = dpath__deq_bits;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;

endmodule


// PyMTL Component Encoder Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/encoders.py

module Encoder__in_nbits_2__out_nbits_1
(
  input  logic [0:0] clk ,
  input  logic [1:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/encoders.py:28
  // @update
  // def encode():
  //   s.out @= 0
  //   for i in range( s.in_nbits ):
  //     if s.in_[i]:
  //       s.out @= i
  
  always_comb begin : encode
    out = 1'd0;
    for ( int unsigned i = 1'd0; i < 2'd2; i += 1'd1 )
      if ( in_[1'(i)] ) begin
        out = 1'(i);
      end
  end

endmodule


// PyMTL Component SendIfcRTLArbiter Definition
// Full name: SendIfcRTLArbiter__MsgType_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32__ninputs_2
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py

module SendIfcRTLArbiter__e45dd7c056417f94
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:1] ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 recv__msg [0:1] ,
  output logic [0:0] recv__rdy [0:1] ,
  output logic [0:0] send__en  ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [0:0] __const__i_at__lambda__s_dut_smu_dpath_arb_buffer_0__deq_rdy  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dut_smu_dpath_arb_buffer_1__deq_rdy  = 1'd1;
  logic [0:0] grant_idx;
  //-------------------------------------------------------------
  // Component arb
  //-------------------------------------------------------------

  logic [0:0] arb__clk;
  logic [0:0] arb__en;
  logic [1:0] arb__grants;
  logic [1:0] arb__reqs;
  logic [0:0] arb__reset;

  RoundRobinArbiterEn__nreqs_2 arb
  (
    .clk( arb__clk ),
    .en( arb__en ),
    .grants( arb__grants ),
    .reqs( arb__reqs ),
    .reset( arb__reset )
  );

  //-------------------------------------------------------------
  // End of component arb
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component buffer[0:1]
  //-------------------------------------------------------------

  logic [0:0] buffer__clk [0:1];
  logic [1:0] buffer__num_free_entries [0:1];
  logic [0:0] buffer__reset [0:1];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 buffer__deq__msg [0:1];
  logic [0:0] buffer__deq__rdy [0:1];
  logic [0:0] buffer__deq__val [0:1];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 buffer__enq__msg [0:1];
  logic [0:0] buffer__enq__rdy [0:1];
  logic [0:0] buffer__enq__val [0:1];

  NormalQueueRTL__f3f5a597077c4de8 buffer__0
  (
    .clk( buffer__clk[0] ),
    .num_free_entries( buffer__num_free_entries[0] ),
    .reset( buffer__reset[0] ),
    .deq__msg( buffer__deq__msg[0] ),
    .deq__rdy( buffer__deq__rdy[0] ),
    .deq__val( buffer__deq__val[0] ),
    .enq__msg( buffer__enq__msg[0] ),
    .enq__rdy( buffer__enq__rdy[0] ),
    .enq__val( buffer__enq__val[0] )
  );

  NormalQueueRTL__f3f5a597077c4de8 buffer__1
  (
    .clk( buffer__clk[1] ),
    .num_free_entries( buffer__num_free_entries[1] ),
    .reset( buffer__reset[1] ),
    .deq__msg( buffer__deq__msg[1] ),
    .deq__rdy( buffer__deq__rdy[1] ),
    .deq__val( buffer__deq__val[1] ),
    .enq__msg( buffer__enq__msg[1] ),
    .enq__rdy( buffer__enq__rdy[1] ),
    .enq__val( buffer__enq__val[1] )
  );

  //-------------------------------------------------------------
  // End of component buffer[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [1:0] encoder__in_;
  logic [0:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_2__out_nbits_1 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py:43
  // s.buffer[i].deq.rdy //= lambda: s.arb.grants[i] & s.send.rdy
  
  always_comb begin : _lambda__s_dut_smu_dpath_arb_buffer_0__deq_rdy
    buffer__deq__rdy[1'd0] = arb__grants[1'( __const__i_at__lambda__s_dut_smu_dpath_arb_buffer_0__deq_rdy )] & send__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py:43
  // s.buffer[i].deq.rdy //= lambda: s.arb.grants[i] & s.send.rdy
  
  always_comb begin : _lambda__s_dut_smu_dpath_arb_buffer_1__deq_rdy
    buffer__deq__rdy[1'd1] = arb__grants[1'( __const__i_at__lambda__s_dut_smu_dpath_arb_buffer_1__deq_rdy )] & send__rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py:55
  // @update
  // def send_ifc_arb_out():
  //   s.send.en @= (s.arb.grants != 0) & s.send.rdy
  //   s.send.msg @= s.buffer[s.grant_idx].deq.msg
  
  always_comb begin : send_ifc_arb_out
    send__en = ( arb__grants != 2'd0 ) & send__rdy;
    send__msg = buffer__deq__msg[grant_idx];
  end

  assign buffer__clk[0] = clk;
  assign buffer__reset[0] = reset;
  assign buffer__clk[1] = clk;
  assign buffer__reset[1] = reset;
  assign buffer__enq__val[0] = recv__en[0];
  assign recv__rdy[0] = buffer__enq__rdy[0];
  assign buffer__enq__msg[0] = recv__msg[0];
  assign buffer__enq__val[1] = recv__en[1];
  assign recv__rdy[1] = buffer__enq__rdy[1];
  assign buffer__enq__msg[1] = recv__msg[1];
  assign arb__clk = clk;
  assign arb__reset = reset;
  assign arb__en = send__rdy;
  assign arb__reqs[0:0] = buffer__deq__val[0];
  assign arb__reqs[1:1] = buffer__deq__val[1];
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arb__grants;
  assign grant_idx = encoder__out;

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits32__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [31:0] in_ ,
  output logic [31:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 32'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits1__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [0:0] in_ ,
  output logic [0:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 1'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component RegEnRst Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py

module RegEnRst__Type_Bits4__reset_value_0
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [3:0] in_ ,
  output logic [3:0] out ,
  input  logic [0:0] reset 
);
  localparam logic [0:0] __const__reset_value_at_up_regenrst  = 1'd0;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/registers.py:55
  // @update_ff
  // def up_regenrst():
  //   if s.reset: s.out <<= reset_value
  //   elif s.en:  s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regenrst
    if ( reset ) begin
      out <= 4'( __const__reset_value_at_up_regenrst );
    end
    else if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component ReorderQueueCtrl Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py

module ReorderQueueCtrl__num_elems_32
(
  input  logic [0:0] clk ,
  input  logic [0:0] deq_en ,
  output logic [4:0] deq_ptr ,
  output logic [0:0] deq_rdy ,
  input  logic [0:0] enq_en ,
  output logic [0:0] enq_go ,
  input  logic [4:0] enq_ptr ,
  output logic [0:0] enq_rdy ,
  input  logic [0:0] reset 
);
  logic [31:0] buf_invalid_r;
  logic [31:0] buf_valid_n;
  logic [31:0] buf_valid_r;

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:75
  // s.buf_invalid_r //= lambda: ~s.buf_valid_r
  
  always_comb begin : _lambda__s_dut_smu_dpath_reorder_q_ctrl_buf_invalid_r
    buf_invalid_r = ~buf_valid_r;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:78
  // s.deq_rdy //= lambda: s.buf_valid_r[s.deq_ptr]
  
  always_comb begin : _lambda__s_dut_smu_dpath_reorder_q_ctrl_deq_rdy
    deq_rdy = buf_valid_r[deq_ptr];
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:79
  // s.enq_go  //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_dut_smu_dpath_reorder_q_ctrl_enq_go
    enq_go = enq_en & enq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:77
  // s.enq_rdy //= lambda: reduce_or( s.buf_invalid_r )
  
  always_comb begin : _lambda__s_dut_smu_dpath_reorder_q_ctrl_enq_rdy
    enq_rdy = ( | buf_invalid_r );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:64
  // @update
  // def reorder_q_buf_valid_n():
  //   s.buf_valid_n @= s.buf_valid_r
  //   if s.deq_en & s.deq_rdy:
  //     s.buf_valid_n[s.deq_ptr] @= 0
  //   if s.enq_en & s.enq_rdy:
  //     s.buf_valid_n[s.enq_ptr] @= 1
  
  always_comb begin : reorder_q_buf_valid_n
    buf_valid_n = buf_valid_r;
    if ( deq_en & deq_rdy ) begin
      buf_valid_n[deq_ptr] = 1'd0;
    end
    if ( enq_en & enq_rdy ) begin
      buf_valid_n[enq_ptr] = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:57
  // @update_ff
  // def reorder_q_buf_valid_r():
  //   if s.reset:
  //     s.buf_valid_r <<= 0
  //   else:
  //     s.buf_valid_r <<= s.buf_valid_n
  
  always_ff @(posedge clk) begin : reorder_q_buf_valid_r
    if ( reset ) begin
      buf_valid_r <= 32'd0;
    end
    else
      buf_valid_r <= buf_valid_n;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:44
  // @update_ff
  // def reorder_q_deq_ptr_r():
  //   if s.reset:
  //     s.deq_ptr <<= 0
  //   else:
  //     if s.deq_rdy & s.deq_en:
  //       s.deq_ptr <<= s.deq_ptr + 1
  
  always_ff @(posedge clk) begin : reorder_q_deq_ptr_r
    if ( reset ) begin
      deq_ptr <= 5'd0;
    end
    else if ( deq_rdy & deq_en ) begin
      deq_ptr <= deq_ptr + 5'd1;
    end
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32__nregs_32__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__ed0999d91ed51853
(
  input  logic [0:0] clk ,
  input  logic [4:0] raddr [0:0],
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [4:0] waddr [0:0],
  input  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 regs [0:31];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component ReorderQueueDpath Definition
// Full name: ReorderQueueDpath__MsgType_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32__num_elems_32__field_reg_id
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py

module ReorderQueueDpath__9ce2b7c8b464735d
(
  input  logic [0:0] clk ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 deq_msg ,
  input  logic [4:0] deq_ptr ,
  input  logic [0:0] enq_go ,
  input  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 enq_msg ,
  output logic [4:0] enq_ptr ,
  input  logic [0:0] reset 
);
  localparam logic [2:0] __const__ptr_width_at_reorder_q_dpath_reg_id  = 3'd5;
  //-------------------------------------------------------------
  // Component buffer
  //-------------------------------------------------------------

  logic [0:0] buffer__clk;
  logic [4:0] buffer__raddr [0:0];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 buffer__rdata [0:0];
  logic [0:0] buffer__reset;
  logic [4:0] buffer__waddr [0:0];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 buffer__wdata [0:0];
  logic [0:0] buffer__wen [0:0];

  RegisterFile__ed0999d91ed51853 buffer
  (
    .clk( buffer__clk ),
    .raddr( buffer__raddr ),
    .rdata( buffer__rdata ),
    .reset( buffer__reset ),
    .waddr( buffer__waddr ),
    .wdata( buffer__wdata ),
    .wen( buffer__wen )
  );

  //-------------------------------------------------------------
  // End of component buffer
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py:118
  // @update
  // def reorder_q_dpath_reg_id():
  //   s.enq_ptr @= s.enq_msg.reg_id[0:ptr_width]
  
  always_comb begin : reorder_q_dpath_reg_id
    enq_ptr = enq_msg.reg_id[3'd4:3'd0];
  end

  assign buffer__clk = clk;
  assign buffer__reset = reset;
  assign buffer__raddr[0] = deq_ptr;
  assign deq_msg = buffer__rdata[0];
  assign buffer__wen[0] = enq_go;
  assign buffer__waddr[0] = enq_ptr;
  assign buffer__wdata[0] = enq_msg;

endmodule


// PyMTL Component ReorderQueue Definition
// Full name: ReorderQueue__MsgType_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32__num_elems_32__field_reg_id
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/ReorderQueue.py

module ReorderQueue__9ce2b7c8b464735d
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] deq__en  ,
  output logic [0:0] deq__rdy  ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 deq__ret  ,
  input logic [0:0] enq__en  ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 enq__msg  ,
  output logic [0:0] enq__rdy  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_en;
  logic [4:0] ctrl__deq_ptr;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__enq_en;
  logic [0:0] ctrl__enq_go;
  logic [4:0] ctrl__enq_ptr;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__reset;

  ReorderQueueCtrl__num_elems_32 ctrl
  (
    .clk( ctrl__clk ),
    .deq_en( ctrl__deq_en ),
    .deq_ptr( ctrl__deq_ptr ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_go( ctrl__enq_go ),
    .enq_ptr( ctrl__enq_ptr ),
    .enq_rdy( ctrl__enq_rdy ),
    .reset( ctrl__reset )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__deq_msg;
  logic [4:0] dpath__deq_ptr;
  logic [0:0] dpath__enq_go;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__enq_msg;
  logic [4:0] dpath__enq_ptr;
  logic [0:0] dpath__reset;

  ReorderQueueDpath__9ce2b7c8b464735d dpath
  (
    .clk( dpath__clk ),
    .deq_msg( dpath__deq_msg ),
    .deq_ptr( dpath__deq_ptr ),
    .enq_go( dpath__enq_go ),
    .enq_msg( dpath__enq_msg ),
    .enq_ptr( dpath__enq_ptr ),
    .reset( dpath__reset )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign dpath__enq_msg = enq__msg;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign deq__ret = dpath__deq_msg;
  assign dpath__enq_go = ctrl__enq_go;
  assign dpath__deq_ptr = ctrl__deq_ptr;
  assign ctrl__enq_ptr = dpath__enq_ptr;

endmodule


// PyMTL Component StreamingMemUnitDpath Definition
// Full name: StreamingMemUnitDpath__DataType_Bits32__AddrType_Bits32__StrideType_Bits32__CountType_Bits32__OpaqueType_Bits5__num_elems_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py

module StreamingMemUnitDpath__3c34b51d9f2758ac
(
  input  logic [0:0] cfg_go ,
  input  XcelReqMsg__type__1__addr_4__data_32 cfg_req_msg ,
  output XcelRespMsg__type__1__data_32 cfg_resp_msg ,
  input  logic [0:0] clk ,
  input  logic [0:0] is_ack_state ,
  output logic [0:0] is_cfg_msg_go ,
  output logic [0:0] is_padding ,
  output logic [0:0] local_req_all_sent ,
  output logic [0:0] local_req_all_sent_n ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 local_req_msg ,
  input  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 local_resp_msg ,
  input  logic [0:0] local_sent ,
  input  logic [0:0] pad_resp_en ,
  output logic [0:0] pad_resp_rdy ,
  output logic [0:0] remote_req_all_sent ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 remote_req_msg ,
  input  logic [0:0] remote_sent ,
  input  logic [0:0] reorder_q_deq_en ,
  output logic [0:0] reorder_q_deq_rdy ,
  input  logic [0:0] reset ,
  input logic [0:0] remote_resp__en  ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 remote_resp__msg  ,
  output logic [0:0] remote_resp__rdy  
);
  localparam logic [0:0] __const__GO  = 1'd0;
  localparam logic [0:0] __const__STATUS  = 1'd1;
  localparam logic [1:0] __const__PADDING  = 2'd2;
  localparam logic [1:0] __const__SRC_BASE_ADDR  = 2'd3;
  localparam logic [2:0] __const__SRC_X_STRIDE  = 3'd4;
  localparam logic [2:0] __const__SRC_X_COUNT  = 3'd5;
  localparam logic [2:0] __const__SRC_Y_STRIDE  = 3'd6;
  localparam logic [2:0] __const__SRC_Y_COUNT  = 3'd7;
  localparam logic [3:0] __const__DST_BASE_ADDR  = 4'd8;
  localparam logic [3:0] __const__DST_ACK_ADDR  = 4'd9;
  localparam logic [5:0] __const__addr_width_at_smu_dpath_register_in_ports  = 6'd32;
  localparam logic [5:0] __const__stride_width_at_smu_dpath_register_in_ports  = 6'd32;
  localparam logic [5:0] __const__count_width_at_smu_dpath_register_in_ports  = 6'd32;
  localparam logic [5:0] __const__count_width_at_smu_dpath_xy_count_r  = 6'd32;
  localparam logic [5:0] __const__addr_width_at_smu_dpath_xy_count_r  = 6'd32;
  localparam logic [0:0] __const__W  = 1'd0;
  localparam logic [0:0] __const__E  = 1'd1;
  localparam logic [1:0] __const__N  = 2'd2;
  localparam logic [1:0] __const__S  = 2'd3;
  logic [3:0] cfg_read_addr_r;
  logic [31:0] local_addr_n;
  logic [31:0] local_addr_r;
  logic [31:0] local_x_count_n;
  logic [31:0] local_x_count_r;
  logic [31:0] local_y_count_n;
  logic [31:0] local_y_count_r;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 pad_resp_msg;
  logic [31:0] register_read_n;
  logic [31:0] register_read_r;
  logic [31:0] remote_addr;
  logic [4:0] remote_opaque_n;
  logic [4:0] remote_opaque_r;
  logic [0:0] remote_req_all_sent_n;
  logic [31:0] remote_row_addr_n;
  logic [31:0] remote_row_addr_offset_n;
  logic [31:0] remote_row_addr_offset_r;
  logic [31:0] remote_row_addr_r;
  logic [31:0] remote_x_count_n;
  logic [31:0] remote_x_count_r;
  logic [31:0] remote_y_count_n;
  logic [31:0] remote_y_count_r;
  //-------------------------------------------------------------
  // Component arb
  //-------------------------------------------------------------

  logic [0:0] arb__clk;
  logic [0:0] arb__reset;
  logic [0:0] arb__recv__en [0:1];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 arb__recv__msg [0:1];
  logic [0:0] arb__recv__rdy [0:1];
  logic [0:0] arb__send__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 arb__send__msg;
  logic [0:0] arb__send__rdy;

  SendIfcRTLArbiter__e45dd7c056417f94 arb
  (
    .clk( arb__clk ),
    .reset( arb__reset ),
    .recv__en( arb__recv__en ),
    .recv__msg( arb__recv__msg ),
    .recv__rdy( arb__recv__rdy ),
    .send__en( arb__send__en ),
    .send__msg( arb__send__msg ),
    .send__rdy( arb__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component arb
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dst_ack_addr_r
  //-------------------------------------------------------------

  logic [0:0] dst_ack_addr_r__clk;
  logic [0:0] dst_ack_addr_r__en;
  logic [31:0] dst_ack_addr_r__in_;
  logic [31:0] dst_ack_addr_r__out;
  logic [0:0] dst_ack_addr_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 dst_ack_addr_r
  (
    .clk( dst_ack_addr_r__clk ),
    .en( dst_ack_addr_r__en ),
    .in_( dst_ack_addr_r__in_ ),
    .out( dst_ack_addr_r__out ),
    .reset( dst_ack_addr_r__reset )
  );

  //-------------------------------------------------------------
  // End of component dst_ack_addr_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dst_base_addr_r
  //-------------------------------------------------------------

  logic [0:0] dst_base_addr_r__clk;
  logic [0:0] dst_base_addr_r__en;
  logic [31:0] dst_base_addr_r__in_;
  logic [31:0] dst_base_addr_r__out;
  logic [0:0] dst_base_addr_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 dst_base_addr_r
  (
    .clk( dst_base_addr_r__clk ),
    .en( dst_base_addr_r__en ),
    .in_( dst_base_addr_r__in_ ),
    .out( dst_base_addr_r__out ),
    .reset( dst_base_addr_r__reset )
  );

  //-------------------------------------------------------------
  // End of component dst_base_addr_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component go_r
  //-------------------------------------------------------------

  logic [0:0] go_r__clk;
  logic [0:0] go_r__en;
  logic [0:0] go_r__in_;
  logic [0:0] go_r__out;
  logic [0:0] go_r__reset;

  RegEnRst__Type_Bits1__reset_value_0 go_r
  (
    .clk( go_r__clk ),
    .en( go_r__en ),
    .in_( go_r__in_ ),
    .out( go_r__out ),
    .reset( go_r__reset )
  );

  //-------------------------------------------------------------
  // End of component go_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component padding_r
  //-------------------------------------------------------------

  logic [0:0] padding_r__clk;
  logic [0:0] padding_r__en;
  logic [3:0] padding_r__in_;
  logic [3:0] padding_r__out;
  logic [0:0] padding_r__reset;

  RegEnRst__Type_Bits4__reset_value_0 padding_r
  (
    .clk( padding_r__clk ),
    .en( padding_r__en ),
    .in_( padding_r__in_ ),
    .out( padding_r__out ),
    .reset( padding_r__reset )
  );

  //-------------------------------------------------------------
  // End of component padding_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reorder_q
  //-------------------------------------------------------------

  logic [0:0] reorder_q__clk;
  logic [0:0] reorder_q__reset;
  logic [0:0] reorder_q__deq__en;
  logic [0:0] reorder_q__deq__rdy;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 reorder_q__deq__ret;
  logic [0:0] reorder_q__enq__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 reorder_q__enq__msg;
  logic [0:0] reorder_q__enq__rdy;

  ReorderQueue__9ce2b7c8b464735d reorder_q
  (
    .clk( reorder_q__clk ),
    .reset( reorder_q__reset ),
    .deq__en( reorder_q__deq__en ),
    .deq__rdy( reorder_q__deq__rdy ),
    .deq__ret( reorder_q__deq__ret ),
    .enq__en( reorder_q__enq__en ),
    .enq__msg( reorder_q__enq__msg ),
    .enq__rdy( reorder_q__enq__rdy )
  );

  //-------------------------------------------------------------
  // End of component reorder_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component src_base_addr_r
  //-------------------------------------------------------------

  logic [0:0] src_base_addr_r__clk;
  logic [0:0] src_base_addr_r__en;
  logic [31:0] src_base_addr_r__in_;
  logic [31:0] src_base_addr_r__out;
  logic [0:0] src_base_addr_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 src_base_addr_r
  (
    .clk( src_base_addr_r__clk ),
    .en( src_base_addr_r__en ),
    .in_( src_base_addr_r__in_ ),
    .out( src_base_addr_r__out ),
    .reset( src_base_addr_r__reset )
  );

  //-------------------------------------------------------------
  // End of component src_base_addr_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component src_x_count_r
  //-------------------------------------------------------------

  logic [0:0] src_x_count_r__clk;
  logic [0:0] src_x_count_r__en;
  logic [31:0] src_x_count_r__in_;
  logic [31:0] src_x_count_r__out;
  logic [0:0] src_x_count_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 src_x_count_r
  (
    .clk( src_x_count_r__clk ),
    .en( src_x_count_r__en ),
    .in_( src_x_count_r__in_ ),
    .out( src_x_count_r__out ),
    .reset( src_x_count_r__reset )
  );

  //-------------------------------------------------------------
  // End of component src_x_count_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component src_x_stride_r
  //-------------------------------------------------------------

  logic [0:0] src_x_stride_r__clk;
  logic [0:0] src_x_stride_r__en;
  logic [31:0] src_x_stride_r__in_;
  logic [31:0] src_x_stride_r__out;
  logic [0:0] src_x_stride_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 src_x_stride_r
  (
    .clk( src_x_stride_r__clk ),
    .en( src_x_stride_r__en ),
    .in_( src_x_stride_r__in_ ),
    .out( src_x_stride_r__out ),
    .reset( src_x_stride_r__reset )
  );

  //-------------------------------------------------------------
  // End of component src_x_stride_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component src_y_count_r
  //-------------------------------------------------------------

  logic [0:0] src_y_count_r__clk;
  logic [0:0] src_y_count_r__en;
  logic [31:0] src_y_count_r__in_;
  logic [31:0] src_y_count_r__out;
  logic [0:0] src_y_count_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 src_y_count_r
  (
    .clk( src_y_count_r__clk ),
    .en( src_y_count_r__en ),
    .in_( src_y_count_r__in_ ),
    .out( src_y_count_r__out ),
    .reset( src_y_count_r__reset )
  );

  //-------------------------------------------------------------
  // End of component src_y_count_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component src_y_stride_r
  //-------------------------------------------------------------

  logic [0:0] src_y_stride_r__clk;
  logic [0:0] src_y_stride_r__en;
  logic [31:0] src_y_stride_r__in_;
  logic [31:0] src_y_stride_r__out;
  logic [0:0] src_y_stride_r__reset;

  RegEnRst__Type_Bits32__reset_value_0 src_y_stride_r
  (
    .clk( src_y_stride_r__clk ),
    .en( src_y_stride_r__en ),
    .in_( src_y_stride_r__in_ ),
    .out( src_y_stride_r__out ),
    .reset( src_y_stride_r__reset )
  );

  //-------------------------------------------------------------
  // End of component src_y_stride_r
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component status_r
  //-------------------------------------------------------------

  logic [0:0] status_r__clk;
  logic [0:0] status_r__en;
  logic [0:0] status_r__in_;
  logic [0:0] status_r__out;
  logic [0:0] status_r__reset;

  RegEnRst__Type_Bits1__reset_value_0 status_r
  (
    .clk( status_r__clk ),
    .en( status_r__en ),
    .in_( status_r__in_ ),
    .out( status_r__out ),
    .reset( status_r__reset )
  );

  //-------------------------------------------------------------
  // End of component status_r
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:595
  // s.is_cfg_msg_go //= lambda: s.cfg_req_msg.addr == GO
  
  always_comb begin : _lambda__s_dut_smu_dpath_is_cfg_msg_go
    is_cfg_msg_go = cfg_req_msg.addr == 4'( __const__GO );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:568
  // @update
  // def smu_dpath_all_sent_n():
  //   s.remote_req_all_sent_n @= s.remote_req_all_sent
  //   s.local_req_all_sent_n @= s.local_req_all_sent
  // 
  //   if s.cfg_go & (s.cfg_req_msg.addr == GO):
  //     s.remote_req_all_sent_n @= 0
  //     s.local_req_all_sent_n  @= 0
  //   else:
  //     s.remote_req_all_sent_n @= s.remote_req_all_sent | \
  //                                ( s.remote_sent & \
  //                                ( s.remote_x_count_r == 1 ) & \
  //                                ( s.remote_y_count_r == 1 ) )
  //     s.local_req_all_sent_n  @= s.local_req_all_sent | \
  //                                ( s.local_sent & \
  //                                ( s.local_x_count_r == 1 ) & \
  //                                ( s.local_y_count_r == 1 ) )
  
  always_comb begin : smu_dpath_all_sent_n
    remote_req_all_sent_n = remote_req_all_sent;
    local_req_all_sent_n = local_req_all_sent;
    if ( cfg_go & ( cfg_req_msg.addr == 4'( __const__GO ) ) ) begin
      remote_req_all_sent_n = 1'd0;
      local_req_all_sent_n = 1'd0;
    end
    else begin
      remote_req_all_sent_n = remote_req_all_sent | ( ( remote_sent & ( remote_x_count_r == 32'd1 ) ) & ( remote_y_count_r == 32'd1 ) );
      local_req_all_sent_n = local_req_all_sent | ( ( local_sent & ( local_x_count_r == 32'd1 ) ) & ( local_y_count_r == 32'd1 ) );
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:501
  // @update
  // def smu_dpath_is_padding():
  //   s.is_padding @= 0
  //   if s.padding_r.out[W] & (s.remote_x_count_r == s.src_x_count_r.out):
  //     s.is_padding @= 1
  //   if s.padding_r.out[E] & (s.remote_x_count_r == 1):
  //     s.is_padding @= 1
  //   if s.padding_r.out[N] & (s.remote_y_count_r == s.src_y_count_r.out):
  //     s.is_padding @= 1
  //   if s.padding_r.out[S] & (s.remote_y_count_r == 1):
  //     s.is_padding @= 1
  
  always_comb begin : smu_dpath_is_padding
    is_padding = 1'd0;
    if ( padding_r__out[2'( __const__W )] & ( remote_x_count_r == src_x_count_r__out ) ) begin
      is_padding = 1'd1;
    end
    if ( padding_r__out[2'( __const__E )] & ( remote_x_count_r == 32'd1 ) ) begin
      is_padding = 1'd1;
    end
    if ( padding_r__out[2'( __const__N )] & ( remote_y_count_r == src_y_count_r__out ) ) begin
      is_padding = 1'd1;
    end
    if ( padding_r__out[2'( __const__S )] & ( remote_y_count_r == 32'd1 ) ) begin
      is_padding = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:539
  // @update
  // def smu_dpath_msg():
  //   s.cfg_resp_msg.type_ @= 0
  //   s.cfg_resp_msg.data  @= 0
  // 
  //   s.pad_resp_msg.wen    @= 0
  //   s.pad_resp_msg.reg_id @= s.remote_opaque_r
  //   s.pad_resp_msg.opaque @= 0
  //   s.pad_resp_msg.data   @= 0
  // 
  //   s.remote_req_msg.wen    @= 0
  //   s.remote_req_msg.reg_id @= s.remote_opaque_r
  //   s.remote_req_msg.opaque @= 0
  //   s.remote_req_msg.data   @= 0
  //   s.remote_req_msg.addr   @= s.remote_addr
  // 
  //   # TODO: currently only supports matrix-gather mode
  //   s.local_req_msg.wen    @= 1
  //   s.local_req_msg.reg_id @= 0 # no reg_id for remote_store
  //   s.local_req_msg.opaque @= 0
  //   s.local_req_msg.data   @= s.reorder_q.deq.ret.data if ~s.is_ack_state else 1
  //   s.local_req_msg.addr   @= s.local_addr_r if ~s.is_ack_state else s.dst_ack_addr_r.out
  
  always_comb begin : smu_dpath_msg
    cfg_resp_msg.type_ = 1'd0;
    cfg_resp_msg.data = 32'd0;
    pad_resp_msg.wen = 1'd0;
    pad_resp_msg.reg_id = remote_opaque_r;
    pad_resp_msg.opaque = 6'd0;
    pad_resp_msg.data = 32'd0;
    remote_req_msg.wen = 1'd0;
    remote_req_msg.reg_id = remote_opaque_r;
    remote_req_msg.opaque = 6'd0;
    remote_req_msg.data = 32'd0;
    remote_req_msg.addr = remote_addr;
    local_req_msg.wen = 1'd1;
    local_req_msg.reg_id = 5'd0;
    local_req_msg.opaque = 6'd0;
    local_req_msg.data = ( ~is_ack_state ) ? reorder_q__deq__ret.data : 32'd1;
    local_req_msg.addr = ( ~is_ack_state ) ? local_addr_r : dst_ack_addr_r__out;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:368
  // @update
  // def smu_dpath_register_in_ports():
  //   s.go_r.in_              @= s.cfg_req_msg.data[0:1]
  //   s.status_r.in_          @= s.cfg_req_msg.data[0:1]
  //   s.padding_r.in_         @= s.cfg_req_msg.data[0:4]
  //   s.src_base_addr_r.in_   @= s.cfg_req_msg.data[0:addr_width]
  //   s.src_x_stride_r.in_    @= s.cfg_req_msg.data[0:stride_width]
  //   s.src_x_count_r.in_     @= s.cfg_req_msg.data[0:count_width]
  //   s.src_y_stride_r.in_    @= s.cfg_req_msg.data[0:stride_width]
  //   s.src_y_count_r.in_     @= s.cfg_req_msg.data[0:count_width]
  //   s.dst_base_addr_r.in_   @= s.cfg_req_msg.data[0:addr_width]
  //   s.dst_ack_addr_r.in_    @= s.cfg_req_msg.data[0:addr_width]
  // 
  //   s.go_r.en              @= s.cfg_go & (s.cfg_req_msg.addr == GO)
  //   s.status_r.en          @= s.cfg_go & (s.cfg_req_msg.addr == STATUS)
  //   s.padding_r.en         @= s.cfg_go & (s.cfg_req_msg.addr == PADDING)
  //   s.src_base_addr_r.en   @= s.cfg_go & (s.cfg_req_msg.addr == SRC_BASE_ADDR)
  //   s.src_x_stride_r.en    @= s.cfg_go & (s.cfg_req_msg.addr == SRC_X_STRIDE)
  //   s.src_x_count_r.en     @= s.cfg_go & (s.cfg_req_msg.addr == SRC_X_COUNT)
  //   s.src_y_stride_r.en    @= s.cfg_go & (s.cfg_req_msg.addr == SRC_Y_STRIDE)
  //   s.src_y_count_r.en     @= s.cfg_go & (s.cfg_req_msg.addr == SRC_Y_COUNT)
  //   s.dst_base_addr_r.en   @= s.cfg_go & (s.cfg_req_msg.addr == DST_BASE_ADDR)
  //   s.dst_ack_addr_r.en    @= s.cfg_go & (s.cfg_req_msg.addr == DST_ACK_ADDR)
  
  always_comb begin : smu_dpath_register_in_ports
    go_r__in_ = cfg_req_msg.data[5'd0:5'd0];
    status_r__in_ = cfg_req_msg.data[5'd0:5'd0];
    padding_r__in_ = cfg_req_msg.data[5'd3:5'd0];
    src_base_addr_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    src_x_stride_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    src_x_count_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    src_y_stride_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    src_y_count_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    dst_base_addr_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    dst_ack_addr_r__in_ = cfg_req_msg.data[5'd31:5'd0];
    go_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__GO ) );
    status_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__STATUS ) );
    padding_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__PADDING ) );
    src_base_addr_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_BASE_ADDR ) );
    src_x_stride_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_X_STRIDE ) );
    src_x_count_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_X_COUNT ) );
    src_y_stride_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_Y_STRIDE ) );
    src_y_count_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_Y_COUNT ) );
    dst_base_addr_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__DST_BASE_ADDR ) );
    dst_ack_addr_r__en = cfg_go & ( cfg_req_msg.addr == 4'( __const__DST_ACK_ADDR ) );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:344
  // @update
  // def smu_dpath_register_read_n():
  //   s.register_read_n @= 0
  //   if s.cfg_read_addr_r == GO:
  //     s.register_read_n @= zext( s.go_r.out, data_width )
  //   elif s.cfg_read_addr_r == STATUS:
  //     s.register_read_n @= zext( s.status_r.out, data_width )
  //   elif s.cfg_read_addr_r == PADDING:
  //     s.register_read_n @= zext( s.padding_r.out, data_width )
  //   elif s.cfg_read_addr_r == SRC_BASE_ADDR:
  //     s.register_read_n @= zext( s.src_base_addr_r.out, data_width )
  //   elif s.cfg_read_addr_r == SRC_X_STRIDE:
  //     s.register_read_n @= zext( s.src_x_stride_r.out, data_width )
  //   elif s.cfg_read_addr_r == SRC_X_COUNT:
  //     s.register_read_n @= zext( s.src_x_count_r.out, data_width )
  //   elif s.cfg_read_addr_r == SRC_Y_STRIDE:
  //     s.register_read_n @= zext( s.src_y_stride_r.out, data_width )
  //   elif s.cfg_read_addr_r == SRC_Y_COUNT:
  //     s.register_read_n @= zext( s.src_y_count_r.out, data_width )
  //   elif s.cfg_read_addr_r == DST_BASE_ADDR:
  //     s.register_read_n @= zext( s.dst_base_addr_r.out, data_width )
  //   elif s.cfg_read_addr_r == DST_ACK_ADDR:
  //     s.register_read_n @= zext( s.dst_ack_addr_r.out, data_width )
  
  always_comb begin : smu_dpath_register_read_n
    register_read_n = 32'd0;
    if ( cfg_read_addr_r == 4'( __const__GO ) ) begin
      register_read_n = { { 31 { 1'b0 } }, go_r__out };
    end
    else if ( cfg_read_addr_r == 4'( __const__STATUS ) ) begin
      register_read_n = { { 31 { 1'b0 } }, status_r__out };
    end
    else if ( cfg_read_addr_r == 4'( __const__PADDING ) ) begin
      register_read_n = { { 28 { 1'b0 } }, padding_r__out };
    end
    else if ( cfg_read_addr_r == 4'( __const__SRC_BASE_ADDR ) ) begin
      register_read_n = src_base_addr_r__out;
    end
    else if ( cfg_read_addr_r == 4'( __const__SRC_X_STRIDE ) ) begin
      register_read_n = src_x_stride_r__out;
    end
    else if ( cfg_read_addr_r == 4'( __const__SRC_X_COUNT ) ) begin
      register_read_n = src_x_count_r__out;
    end
    else if ( cfg_read_addr_r == 4'( __const__SRC_Y_STRIDE ) ) begin
      register_read_n = src_y_stride_r__out;
    end
    else if ( cfg_read_addr_r == 4'( __const__SRC_Y_COUNT ) ) begin
      register_read_n = src_y_count_r__out;
    end
    else if ( cfg_read_addr_r == 4'( __const__DST_BASE_ADDR ) ) begin
      register_read_n = dst_base_addr_r__out;
    end
    else if ( cfg_read_addr_r == 4'( __const__DST_ACK_ADDR ) ) begin
      register_read_n = dst_ack_addr_r__out;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:462
  // @update
  // def smu_dpath_xy_count_n():
  //   s.remote_x_count_n         @= s.remote_x_count_r
  //   s.remote_y_count_n         @= s.remote_y_count_r
  //   s.local_x_count_n          @= s.local_x_count_r
  //   s.local_y_count_n          @= s.local_y_count_r
  //   s.remote_row_addr_n        @= s.remote_row_addr_r
  //   s.remote_row_addr_offset_n @= s.remote_row_addr_offset_r
  //   s.remote_addr              @= s.remote_row_addr_r + s.remote_row_addr_offset_r
  //   s.local_addr_n             @= s.local_addr_r
  //   s.remote_opaque_n          @= s.remote_opaque_r
  // 
  //   if s.remote_sent & (s.remote_x_count_r == 1) & (s.remote_y_count_r > 1):
  //     s.remote_x_count_n         @= s.src_x_count_r.out
  //     s.remote_y_count_n         @= s.remote_y_count_r-1
  //     s.remote_row_addr_n        @= s.remote_row_addr_n + zext( s.src_y_stride_r.out, addr_width )
  //     s.remote_row_addr_offset_n @= 0
  //   elif s.remote_sent & (s.remote_x_count_r > 1):
  //     s.remote_x_count_n         @= s.remote_x_count_r-1
  //     s.remote_row_addr_offset_n @= s.remote_row_addr_offset_r + zext( s.src_x_stride_r.out, addr_width )
  // 
  //   if s.local_sent & (s.local_x_count_r == 1) & (s.local_y_count_r > 1):
  //     s.local_x_count_n @= s.src_x_count_r.out
  //     s.local_y_count_n @= s.local_y_count_r-1
  //   elif s.local_sent & (s.local_x_count_r > 1):
  //     s.local_x_count_n @= s.local_x_count_r-1
  // 
  //   if s.local_sent:
  //     s.local_addr_n @= s.local_addr_n + 4
  // 
  //   if s.remote_sent:
  //     s.remote_opaque_n @= s.remote_opaque_r + 1
  
  always_comb begin : smu_dpath_xy_count_n
    remote_x_count_n = remote_x_count_r;
    remote_y_count_n = remote_y_count_r;
    local_x_count_n = local_x_count_r;
    local_y_count_n = local_y_count_r;
    remote_row_addr_n = remote_row_addr_r;
    remote_row_addr_offset_n = remote_row_addr_offset_r;
    remote_addr = remote_row_addr_r + remote_row_addr_offset_r;
    local_addr_n = local_addr_r;
    remote_opaque_n = remote_opaque_r;
    if ( ( remote_sent & ( remote_x_count_r == 32'd1 ) ) & ( remote_y_count_r > 32'd1 ) ) begin
      remote_x_count_n = src_x_count_r__out;
      remote_y_count_n = remote_y_count_r - 32'd1;
      remote_row_addr_n = remote_row_addr_n + src_y_stride_r__out;
      remote_row_addr_offset_n = 32'd0;
    end
    else if ( remote_sent & ( remote_x_count_r > 32'd1 ) ) begin
      remote_x_count_n = remote_x_count_r - 32'd1;
      remote_row_addr_offset_n = remote_row_addr_offset_r + src_x_stride_r__out;
    end
    if ( ( local_sent & ( local_x_count_r == 32'd1 ) ) & ( local_y_count_r > 32'd1 ) ) begin
      local_x_count_n = src_x_count_r__out;
      local_y_count_n = local_y_count_r - 32'd1;
    end
    else if ( local_sent & ( local_x_count_r > 32'd1 ) ) begin
      local_x_count_n = local_x_count_r - 32'd1;
    end
    if ( local_sent ) begin
      local_addr_n = local_addr_n + 32'd4;
    end
    if ( remote_sent ) begin
      remote_opaque_n = remote_opaque_r + 5'd1;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:586
  // @update_ff
  // def smu_dpath_all_sent_r():
  //   if s.reset:
  //     s.remote_req_all_sent <<= 0
  //     s.local_req_all_sent <<= 0
  //   else:
  //     s.remote_req_all_sent <<= s.remote_req_all_sent_n
  //     s.local_req_all_sent  <<= s.local_req_all_sent_n
  
  always_ff @(posedge clk) begin : smu_dpath_all_sent_r
    if ( reset ) begin
      remote_req_all_sent <= 1'd0;
      local_req_all_sent <= 1'd0;
    end
    else begin
      remote_req_all_sent <= remote_req_all_sent_n;
      local_req_all_sent <= local_req_all_sent_n;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:335
  // @update_ff
  // def smu_dpath_registers():
  //   if s.reset:
  //     s.register_read_r <<= 0
  //     s.cfg_read_addr_r <<= 0
  //   else:
  //     s.register_read_r <<= s.register_read_n
  //     s.cfg_read_addr_r <<= s.cfg_req_msg.addr
  
  always_ff @(posedge clk) begin : smu_dpath_registers
    if ( reset ) begin
      register_read_r <= 32'd0;
      cfg_read_addr_r <= 4'd0;
    end
    else begin
      register_read_r <= register_read_n;
      cfg_read_addr_r <= cfg_req_msg.addr;
    end
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py:419
  // @update_ff
  // def smu_dpath_xy_count_r():
  //   if s.reset:
  //     s.remote_x_count_r <<= 0
  //     s.remote_y_count_r <<= 0
  //     s.local_x_count_r  <<= 0
  //     s.local_y_count_r  <<= 0
  //     s.remote_row_addr_r <<= 0
  //     s.remote_row_addr_offset_r <<= 0
  //     s.local_addr_r <<= 0
  //     s.remote_opaque_r <<= 0
  //   else:
  //     if s.cfg_go & (s.cfg_req_msg.addr == SRC_X_COUNT):
  //       s.remote_x_count_r <<= s.cfg_req_msg.data[0:count_width]
  //       s.local_x_count_r  <<= s.cfg_req_msg.data[0:count_width]
  //     else:
  //       s.remote_x_count_r <<= s.remote_x_count_n
  //       s.local_x_count_r  <<= s.local_x_count_n
  // 
  //     if s.cfg_go & (s.cfg_req_msg.addr == SRC_Y_COUNT):
  //       s.remote_y_count_r <<= s.cfg_req_msg.data[0:count_width]
  //       s.local_y_count_r  <<= s.cfg_req_msg.data[0:count_width]
  //     else:
  //       s.remote_y_count_r <<= s.remote_y_count_n
  //       s.local_y_count_r  <<= s.local_y_count_n
  // 
  //     if s.cfg_go & (s.cfg_req_msg.addr == SRC_BASE_ADDR):
  //       s.remote_row_addr_r <<= s.cfg_req_msg.data[0:addr_width]
  //       s.remote_row_addr_offset_r <<= 0
  //     else:
  //       s.remote_row_addr_r <<= s.remote_row_addr_n
  //       s.remote_row_addr_offset_r <<= s.remote_row_addr_offset_n
  // 
  //     if s.cfg_go & (s.cfg_req_msg.addr == DST_BASE_ADDR):
  //       s.local_addr_r <<= s.cfg_req_msg.data[0:addr_width]
  //     else:
  //       s.local_addr_r <<= s.local_addr_n
  // 
  //     if s.cfg_go & (s.cfg_req_msg.addr == GO):
  //       s.remote_opaque_r <<= 0
  //     else:
  //       s.remote_opaque_r <<= s.remote_opaque_n
  
  always_ff @(posedge clk) begin : smu_dpath_xy_count_r
    if ( reset ) begin
      remote_x_count_r <= 32'd0;
      remote_y_count_r <= 32'd0;
      local_x_count_r <= 32'd0;
      local_y_count_r <= 32'd0;
      remote_row_addr_r <= 32'd0;
      remote_row_addr_offset_r <= 32'd0;
      local_addr_r <= 32'd0;
      remote_opaque_r <= 5'd0;
    end
    else begin
      if ( cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_X_COUNT ) ) ) begin
        remote_x_count_r <= cfg_req_msg.data[5'd31:5'd0];
        local_x_count_r <= cfg_req_msg.data[5'd31:5'd0];
      end
      else begin
        remote_x_count_r <= remote_x_count_n;
        local_x_count_r <= local_x_count_n;
      end
      if ( cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_Y_COUNT ) ) ) begin
        remote_y_count_r <= cfg_req_msg.data[5'd31:5'd0];
        local_y_count_r <= cfg_req_msg.data[5'd31:5'd0];
      end
      else begin
        remote_y_count_r <= remote_y_count_n;
        local_y_count_r <= local_y_count_n;
      end
      if ( cfg_go & ( cfg_req_msg.addr == 4'( __const__SRC_BASE_ADDR ) ) ) begin
        remote_row_addr_r <= cfg_req_msg.data[5'd31:5'd0];
        remote_row_addr_offset_r <= 32'd0;
      end
      else begin
        remote_row_addr_r <= remote_row_addr_n;
        remote_row_addr_offset_r <= remote_row_addr_offset_n;
      end
      if ( cfg_go & ( cfg_req_msg.addr == 4'( __const__DST_BASE_ADDR ) ) ) begin
        local_addr_r <= cfg_req_msg.data[5'd31:5'd0];
      end
      else
        local_addr_r <= local_addr_n;
      if ( cfg_go & ( cfg_req_msg.addr == 4'( __const__GO ) ) ) begin
        remote_opaque_r <= 5'd0;
      end
      else
        remote_opaque_r <= remote_opaque_n;
    end
  end

  assign go_r__clk = clk;
  assign go_r__reset = reset;
  assign status_r__clk = clk;
  assign status_r__reset = reset;
  assign padding_r__clk = clk;
  assign padding_r__reset = reset;
  assign src_base_addr_r__clk = clk;
  assign src_base_addr_r__reset = reset;
  assign src_x_stride_r__clk = clk;
  assign src_x_stride_r__reset = reset;
  assign src_x_count_r__clk = clk;
  assign src_x_count_r__reset = reset;
  assign src_y_stride_r__clk = clk;
  assign src_y_stride_r__reset = reset;
  assign src_y_count_r__clk = clk;
  assign src_y_count_r__reset = reset;
  assign dst_base_addr_r__clk = clk;
  assign dst_base_addr_r__reset = reset;
  assign dst_ack_addr_r__clk = clk;
  assign dst_ack_addr_r__reset = reset;
  assign arb__clk = clk;
  assign arb__reset = reset;
  assign arb__recv__en[0] = remote_resp__en;
  assign arb__recv__msg[0] = remote_resp__msg;
  assign remote_resp__rdy = arb__recv__rdy[0];
  assign arb__recv__en[1] = pad_resp_en;
  assign pad_resp_rdy = arb__recv__rdy[1];
  assign arb__recv__msg[1] = pad_resp_msg;
  assign reorder_q__clk = clk;
  assign reorder_q__reset = reset;
  assign reorder_q__enq__en = arb__send__en;
  assign reorder_q__enq__msg = arb__send__msg;
  assign arb__send__rdy = reorder_q__enq__rdy;
  assign reorder_q__deq__en = reorder_q_deq_en;
  assign reorder_q_deq_rdy = reorder_q__deq__rdy;

endmodule


// PyMTL Component StreamingMemUnit Definition
// Full name: StreamingMemUnit__DataType_Bits32__AddrType_Bits32__StrideType_Bits32__CountType_Bits32__OpaqueType_Bits5__num_elems_32__mode_matrix-gather
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/mem/StreamingMemUnit.py

module StreamingMemUnit__9fe0efbd6f5ff91e
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] cfg__req__en ,
  input XcelReqMsg__type__1__addr_4__data_32 cfg__req__msg ,
  output logic [0:0] cfg__req__rdy ,
  output logic [0:0] cfg__resp__en ,
  output XcelRespMsg__type__1__data_32 cfg__resp__msg ,
  input logic [0:0] cfg__resp__rdy ,
  output logic [0:0] loc__req__en ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 loc__req__msg ,
  input logic [0:0] loc__req__rdy ,
  input logic [0:0] loc__resp__en ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 loc__resp__msg ,
  output logic [0:0] loc__resp__rdy ,
  output logic [0:0] rmt__req__en ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 rmt__req__msg ,
  input logic [0:0] rmt__req__rdy ,
  input logic [0:0] rmt__resp__en ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 rmt__resp__msg ,
  output logic [0:0] rmt__resp__rdy 
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__cfg_go;
  logic [0:0] ctrl__cfg_req_en;
  logic [0:0] ctrl__cfg_req_rdy;
  logic [0:0] ctrl__cfg_resp_en;
  logic [0:0] ctrl__cfg_resp_rdy;
  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__is_ack_state;
  logic [0:0] ctrl__is_cfg_msg_go;
  logic [0:0] ctrl__is_padding;
  logic [0:0] ctrl__local_req_all_sent;
  logic [0:0] ctrl__local_req_all_sent_n;
  logic [0:0] ctrl__local_req_en;
  logic [0:0] ctrl__local_req_rdy;
  logic [0:0] ctrl__local_resp_en;
  logic [0:0] ctrl__local_resp_rdy;
  logic [0:0] ctrl__local_sent;
  logic [0:0] ctrl__pad_resp_en;
  logic [0:0] ctrl__pad_resp_rdy;
  logic [0:0] ctrl__remote_req_all_sent;
  logic [0:0] ctrl__remote_req_en;
  logic [0:0] ctrl__remote_req_rdy;
  logic [0:0] ctrl__remote_sent;
  logic [0:0] ctrl__reorder_q_deq_en;
  logic [0:0] ctrl__reorder_q_deq_rdy;
  logic [0:0] ctrl__reset;

  StreamingMemUnitCtrl__num_elems_32 ctrl
  (
    .cfg_go( ctrl__cfg_go ),
    .cfg_req_en( ctrl__cfg_req_en ),
    .cfg_req_rdy( ctrl__cfg_req_rdy ),
    .cfg_resp_en( ctrl__cfg_resp_en ),
    .cfg_resp_rdy( ctrl__cfg_resp_rdy ),
    .clk( ctrl__clk ),
    .is_ack_state( ctrl__is_ack_state ),
    .is_cfg_msg_go( ctrl__is_cfg_msg_go ),
    .is_padding( ctrl__is_padding ),
    .local_req_all_sent( ctrl__local_req_all_sent ),
    .local_req_all_sent_n( ctrl__local_req_all_sent_n ),
    .local_req_en( ctrl__local_req_en ),
    .local_req_rdy( ctrl__local_req_rdy ),
    .local_resp_en( ctrl__local_resp_en ),
    .local_resp_rdy( ctrl__local_resp_rdy ),
    .local_sent( ctrl__local_sent ),
    .pad_resp_en( ctrl__pad_resp_en ),
    .pad_resp_rdy( ctrl__pad_resp_rdy ),
    .remote_req_all_sent( ctrl__remote_req_all_sent ),
    .remote_req_en( ctrl__remote_req_en ),
    .remote_req_rdy( ctrl__remote_req_rdy ),
    .remote_sent( ctrl__remote_sent ),
    .reorder_q_deq_en( ctrl__reorder_q_deq_en ),
    .reorder_q_deq_rdy( ctrl__reorder_q_deq_rdy ),
    .reset( ctrl__reset )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__cfg_go;
  XcelReqMsg__type__1__addr_4__data_32 dpath__cfg_req_msg;
  XcelRespMsg__type__1__data_32 dpath__cfg_resp_msg;
  logic [0:0] dpath__clk;
  logic [0:0] dpath__is_ack_state;
  logic [0:0] dpath__is_cfg_msg_go;
  logic [0:0] dpath__is_padding;
  logic [0:0] dpath__local_req_all_sent;
  logic [0:0] dpath__local_req_all_sent_n;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 dpath__local_req_msg;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__local_resp_msg;
  logic [0:0] dpath__local_sent;
  logic [0:0] dpath__pad_resp_en;
  logic [0:0] dpath__pad_resp_rdy;
  logic [0:0] dpath__remote_req_all_sent;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 dpath__remote_req_msg;
  logic [0:0] dpath__remote_sent;
  logic [0:0] dpath__reorder_q_deq_en;
  logic [0:0] dpath__reorder_q_deq_rdy;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__remote_resp__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__remote_resp__msg;
  logic [0:0] dpath__remote_resp__rdy;

  StreamingMemUnitDpath__3c34b51d9f2758ac dpath
  (
    .cfg_go( dpath__cfg_go ),
    .cfg_req_msg( dpath__cfg_req_msg ),
    .cfg_resp_msg( dpath__cfg_resp_msg ),
    .clk( dpath__clk ),
    .is_ack_state( dpath__is_ack_state ),
    .is_cfg_msg_go( dpath__is_cfg_msg_go ),
    .is_padding( dpath__is_padding ),
    .local_req_all_sent( dpath__local_req_all_sent ),
    .local_req_all_sent_n( dpath__local_req_all_sent_n ),
    .local_req_msg( dpath__local_req_msg ),
    .local_resp_msg( dpath__local_resp_msg ),
    .local_sent( dpath__local_sent ),
    .pad_resp_en( dpath__pad_resp_en ),
    .pad_resp_rdy( dpath__pad_resp_rdy ),
    .remote_req_all_sent( dpath__remote_req_all_sent ),
    .remote_req_msg( dpath__remote_req_msg ),
    .remote_sent( dpath__remote_sent ),
    .reorder_q_deq_en( dpath__reorder_q_deq_en ),
    .reorder_q_deq_rdy( dpath__reorder_q_deq_rdy ),
    .reset( dpath__reset ),
    .remote_resp__en( dpath__remote_resp__en ),
    .remote_resp__msg( dpath__remote_resp__msg ),
    .remote_resp__rdy( dpath__remote_resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__cfg_req_en = cfg__req__en;
  assign cfg__req__rdy = ctrl__cfg_req_rdy;
  assign dpath__cfg_req_msg = cfg__req__msg;
  assign cfg__resp__en = ctrl__cfg_resp_en;
  assign ctrl__cfg_resp_rdy = cfg__resp__rdy;
  assign cfg__resp__msg = dpath__cfg_resp_msg;
  assign rmt__req__en = ctrl__remote_req_en;
  assign ctrl__remote_req_rdy = rmt__req__rdy;
  assign rmt__req__msg = dpath__remote_req_msg;
  assign dpath__remote_resp__en = rmt__resp__en;
  assign dpath__remote_resp__msg = rmt__resp__msg;
  assign rmt__resp__rdy = dpath__remote_resp__rdy;
  assign loc__req__en = ctrl__local_req_en;
  assign ctrl__local_req_rdy = loc__req__rdy;
  assign loc__req__msg = dpath__local_req_msg;
  assign ctrl__local_resp_en = loc__resp__en;
  assign loc__resp__rdy = ctrl__local_resp_rdy;
  assign dpath__local_resp_msg = loc__resp__msg;
  assign ctrl__is_cfg_msg_go = dpath__is_cfg_msg_go;
  assign ctrl__remote_req_all_sent = dpath__remote_req_all_sent;
  assign ctrl__local_req_all_sent = dpath__local_req_all_sent;
  assign ctrl__local_req_all_sent_n = dpath__local_req_all_sent_n;
  assign dpath__cfg_go = ctrl__cfg_go;
  assign dpath__is_ack_state = ctrl__is_ack_state;
  assign dpath__remote_sent = ctrl__remote_sent;
  assign dpath__local_sent = ctrl__local_sent;
  assign ctrl__is_padding = dpath__is_padding;
  assign dpath__reorder_q_deq_en = ctrl__reorder_q_deq_en;
  assign ctrl__reorder_q_deq_rdy = dpath__reorder_q_deq_rdy;
  assign dpath__pad_resp_en = ctrl__pad_resp_en;
  assign ctrl__pad_resp_rdy = dpath__pad_resp_rdy;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py

module RegisterFile__e4d8616be700cb38
(
  input  logic [0:0] clk ,
  input  logic [0:0] raddr [0:0],
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 rdata [0:0],
  input  logic [0:0] reset ,
  input  logic [0:0] waddr [0:0],
  input  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 wdata [0:0],
  input  logic [0:0] wen [0:0]
);
  localparam logic [0:0] __const__rd_ports_at_up_rf_read  = 1'd1;
  localparam logic [0:0] __const__wr_ports_at_up_rf_write  = 1'd1;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 regs [0:1];

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:20
  // @update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] @= s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int unsigned i = 1'd0; i < 1'( __const__rd_ports_at_up_rf_read ); i += 1'd1 )
      rdata[1'(i)] = regs[raddr[1'(i)]];
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/basic_rtl/register_files.py:32
  // @update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int unsigned i = 1'd0; i < 1'( __const__wr_ports_at_up_rf_write ); i += 1'd1 )
      if ( wen[1'(i)] ) begin
        regs[waddr[1'(i)]] <= wdata[1'(i)];
      end
  end

endmodule


// PyMTL Component NormalQueueRTLDpath Definition
// Full name: NormalQueueRTLDpath__num_entries_2__Type_SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTLDpath__1c25502195bcabf5
(
  input  logic [0:0] clk ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 deq_bits ,
  input  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 enq_bits ,
  input  logic [0:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [0:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [0:0] queue__raddr [0:0];
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [0:0] queue__waddr [0:0];
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__e4d8616be700cb38 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_bits = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_bits;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__num_entries_2__Type_SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTL__1c25502195bcabf5
(
  input  logic [0:0] clk ,
  output logic [1:0] num_free_entries ,
  input  logic [0:0] reset ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 deq__msg  ,
  input logic [0:0] deq__rdy  ,
  output logic [0:0] deq__val  ,
  input SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 enq__msg  ,
  output logic [0:0] enq__rdy  ,
  input logic [0:0] enq__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__deq_val;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__enq_val;
  logic [1:0] ctrl__num_free_entries;
  logic [0:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [0:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueRTLCtrl__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .deq_rdy( ctrl__deq_rdy ),
    .deq_val( ctrl__deq_val ),
    .enq_rdy( ctrl__enq_rdy ),
    .enq_val( ctrl__enq_val ),
    .num_free_entries( ctrl__num_free_entries ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 dpath__deq_bits;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 dpath__enq_bits;
  logic [0:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [0:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueRTLDpath__1c25502195bcabf5 dpath
  (
    .clk( dpath__clk ),
    .deq_bits( dpath__deq_bits ),
    .enq_bits( dpath__enq_bits ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__enq_val = enq__val;
  assign enq__rdy = ctrl__enq_rdy;
  assign deq__val = ctrl__deq_val;
  assign ctrl__deq_rdy = deq__rdy;
  assign num_free_entries = ctrl__num_free_entries;
  assign dpath__enq_bits = enq__msg;
  assign deq__msg = dpath__deq_bits;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;

endmodule


// PyMTL Component SendIfcRTLArbiter Definition
// Full name: SendIfcRTLArbiter__MsgType_SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32__ninputs_2
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py

module SendIfcRTLArbiter__c3d841a71d618a81
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  input logic [0:0] recv__en [0:1] ,
  input SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 recv__msg [0:1] ,
  output logic [0:0] recv__rdy [0:1] ,
  output logic [0:0] send__en  ,
  output SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 send__msg  ,
  input logic [0:0] send__rdy  
);
  localparam logic [0:0] __const__i_at__lambda__s_dut_tx_arb_buffer_0__deq_rdy  = 1'd0;
  localparam logic [0:0] __const__i_at__lambda__s_dut_tx_arb_buffer_1__deq_rdy  = 1'd1;
  logic [0:0] grant_idx;
  //-------------------------------------------------------------
  // Component arb
  //-------------------------------------------------------------

  logic [0:0] arb__clk;
  logic [0:0] arb__en;
  logic [1:0] arb__grants;
  logic [1:0] arb__reqs;
  logic [0:0] arb__reset;

  RoundRobinArbiterEn__nreqs_2 arb
  (
    .clk( arb__clk ),
    .en( arb__en ),
    .grants( arb__grants ),
    .reqs( arb__reqs ),
    .reset( arb__reset )
  );

  //-------------------------------------------------------------
  // End of component arb
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component buffer[0:1]
  //-------------------------------------------------------------

  logic [0:0] buffer__clk [0:1];
  logic [1:0] buffer__num_free_entries [0:1];
  logic [0:0] buffer__reset [0:1];
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 buffer__deq__msg [0:1];
  logic [0:0] buffer__deq__rdy [0:1];
  logic [0:0] buffer__deq__val [0:1];
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 buffer__enq__msg [0:1];
  logic [0:0] buffer__enq__rdy [0:1];
  logic [0:0] buffer__enq__val [0:1];

  NormalQueueRTL__1c25502195bcabf5 buffer__0
  (
    .clk( buffer__clk[0] ),
    .num_free_entries( buffer__num_free_entries[0] ),
    .reset( buffer__reset[0] ),
    .deq__msg( buffer__deq__msg[0] ),
    .deq__rdy( buffer__deq__rdy[0] ),
    .deq__val( buffer__deq__val[0] ),
    .enq__msg( buffer__enq__msg[0] ),
    .enq__rdy( buffer__enq__rdy[0] ),
    .enq__val( buffer__enq__val[0] )
  );

  NormalQueueRTL__1c25502195bcabf5 buffer__1
  (
    .clk( buffer__clk[1] ),
    .num_free_entries( buffer__num_free_entries[1] ),
    .reset( buffer__reset[1] ),
    .deq__msg( buffer__deq__msg[1] ),
    .deq__rdy( buffer__deq__rdy[1] ),
    .deq__val( buffer__deq__val[1] ),
    .enq__msg( buffer__enq__msg[1] ),
    .enq__rdy( buffer__enq__rdy[1] ),
    .enq__val( buffer__enq__val[1] )
  );

  //-------------------------------------------------------------
  // End of component buffer[0:1]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component encoder
  //-------------------------------------------------------------

  logic [0:0] encoder__clk;
  logic [1:0] encoder__in_;
  logic [0:0] encoder__out;
  logic [0:0] encoder__reset;

  Encoder__in_nbits_2__out_nbits_1 encoder
  (
    .clk( encoder__clk ),
    .in_( encoder__in_ ),
    .out( encoder__out ),
    .reset( encoder__reset )
  );

  //-------------------------------------------------------------
  // End of component encoder
  //-------------------------------------------------------------

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py:43
  // s.buffer[i].deq.rdy //= lambda: s.arb.grants[i] & s.send.rdy
  
  always_comb begin : _lambda__s_dut_tx_arb_buffer_0__deq_rdy
    buffer__deq__rdy[1'd0] = arb__grants[1'( __const__i_at__lambda__s_dut_tx_arb_buffer_0__deq_rdy )] & send__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py:43
  // s.buffer[i].deq.rdy //= lambda: s.arb.grants[i] & s.send.rdy
  
  always_comb begin : _lambda__s_dut_tx_arb_buffer_1__deq_rdy
    buffer__deq__rdy[1'd1] = arb__grants[1'( __const__i_at__lambda__s_dut_tx_arb_buffer_1__deq_rdy )] & send__rdy;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/SendIfcRTLArbiter.py:55
  // @update
  // def send_ifc_arb_out():
  //   s.send.en @= (s.arb.grants != 0) & s.send.rdy
  //   s.send.msg @= s.buffer[s.grant_idx].deq.msg
  
  always_comb begin : send_ifc_arb_out
    send__en = ( arb__grants != 2'd0 ) & send__rdy;
    send__msg = buffer__deq__msg[grant_idx];
  end

  assign buffer__clk[0] = clk;
  assign buffer__reset[0] = reset;
  assign buffer__clk[1] = clk;
  assign buffer__reset[1] = reset;
  assign buffer__enq__val[0] = recv__en[0];
  assign recv__rdy[0] = buffer__enq__rdy[0];
  assign buffer__enq__msg[0] = recv__msg[0];
  assign buffer__enq__val[1] = recv__en[1];
  assign recv__rdy[1] = buffer__enq__rdy[1];
  assign buffer__enq__msg[1] = recv__msg[1];
  assign arb__clk = clk;
  assign arb__reset = reset;
  assign arb__en = send__rdy;
  assign arb__reqs[0:0] = buffer__deq__val[0];
  assign arb__reqs[1:1] = buffer__deq__val[1];
  assign encoder__clk = clk;
  assign encoder__reset = reset;
  assign encoder__in_ = arb__grants;
  assign grant_idx = encoder__out;

endmodule


// PyMTL Component NormalQueueRTLCtrl Definition
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTLCtrl__num_entries_32
(
  input  logic [0:0] clk ,
  input  logic [0:0] deq_rdy ,
  output logic [0:0] deq_val ,
  output logic [0:0] enq_rdy ,
  input  logic [0:0] enq_val ,
  output logic [5:0] num_free_entries ,
  output logic [4:0] raddr ,
  input  logic [0:0] reset ,
  output logic [4:0] waddr ,
  output logic [0:0] wen 
);
  logic [4:0] deq_ptr;
  logic [4:0] deq_ptr_inc;
  logic [4:0] deq_ptr_next;
  logic [0:0] do_deq;
  logic [0:0] do_enq;
  logic [0:0] empty;
  logic [4:0] enq_ptr;
  logic [4:0] enq_ptr_inc;
  logic [4:0] enq_ptr_next;
  logic [0:0] full;
  logic [0:0] full_next_cycle;

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py:221
  // @update
  // def comb():
  // 
  //   # only enqueue/dequeue if valid and ready
  // 
  //   s.do_enq @= s.enq_rdy & s.enq_val
  //   s.do_deq @= s.deq_rdy & s.deq_val
  // 
  //   # write enable
  // 
  //   s.wen @= s.do_enq
  // 
  //   # enq ptr incrementer
  // 
  //   if s.enq_ptr == s.last_idx: s.enq_ptr_inc @= 0
  //   else:                       s.enq_ptr_inc @= s.enq_ptr + 1
  // 
  //   # deq ptr incrementer
  // 
  //   if s.deq_ptr == s.last_idx: s.deq_ptr_inc @= 0
  //   else:                       s.deq_ptr_inc @= s.deq_ptr + 1
  // 
  //   # set the next ptr value
  // 
  //   if s.do_enq: s.enq_ptr_next @= s.enq_ptr_inc
  //   else:        s.enq_ptr_next @= s.enq_ptr
  // 
  //   if s.do_deq: s.deq_ptr_next @= s.deq_ptr_inc
  //   else:        s.deq_ptr_next @= s.deq_ptr
  // 
  //   # number of free entries calculation
  // 
  //   if   s.reset:
  //     s.num_free_entries @= s.num_entries
  //   elif s.full:
  //     s.num_free_entries @= 0
  //   elif s.empty:
  //     s.num_free_entries @= s.num_entries
  //   elif s.enq_ptr > s.deq_ptr:
  //     s.num_free_entries @= s.num_entries - zext( s.enq_ptr - s.deq_ptr, SizeType)
  //   elif s.deq_ptr > s.enq_ptr:
  //     s.num_free_entries @= zext( s.deq_ptr - s.enq_ptr, SizeType )
  // 
  //   s.full_next_cycle @= s.do_enq & ~s.do_deq & (s.enq_ptr_next == s.deq_ptr)
  
  always_comb begin : comb
    do_enq = enq_rdy & enq_val;
    do_deq = deq_rdy & deq_val;
    wen = do_enq;
    if ( enq_ptr == 5'd31 ) begin
      enq_ptr_inc = 5'd0;
    end
    else
      enq_ptr_inc = enq_ptr + 5'd1;
    if ( deq_ptr == 5'd31 ) begin
      deq_ptr_inc = 5'd0;
    end
    else
      deq_ptr_inc = deq_ptr + 5'd1;
    if ( do_enq ) begin
      enq_ptr_next = enq_ptr_inc;
    end
    else
      enq_ptr_next = enq_ptr;
    if ( do_deq ) begin
      deq_ptr_next = deq_ptr_inc;
    end
    else
      deq_ptr_next = deq_ptr;
    if ( reset ) begin
      num_free_entries = 6'd32;
    end
    else if ( full ) begin
      num_free_entries = 6'd0;
    end
    else if ( empty ) begin
      num_free_entries = 6'd32;
    end
    else if ( enq_ptr > deq_ptr ) begin
      num_free_entries = 6'd32 - { { 1 { 1'b0 } }, enq_ptr - deq_ptr };
    end
    else if ( deq_ptr > enq_ptr ) begin
      num_free_entries = { { 1 { 1'b0 } }, deq_ptr - enq_ptr };
    end
    full_next_cycle = ( do_enq & ( ~do_deq ) ) & ( enq_ptr_next == deq_ptr );
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py:266
  // @update
  // def up_ctrl_signals():
  // 
  //   # set output signals
  // 
  //   s.empty   @= ~s.full & (s.enq_ptr == s.deq_ptr)
  // 
  //   s.enq_rdy @= ~s.full
  //   s.deq_val @= ~s.empty
  // 
  //   # set control signals
  // 
  //   s.waddr   @= s.enq_ptr
  //   s.raddr   @= s.deq_ptr
  
  always_comb begin : up_ctrl_signals
    empty = ( ~full ) & ( enq_ptr == deq_ptr );
    enq_rdy = ~full;
    deq_val = ~empty;
    waddr = enq_ptr;
    raddr = deq_ptr;
  end

  // PyMTL Update Block Source
  // At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py:281
  // @update_ff
  // def seq():
  // 
  //   if s.reset:
  //     s.deq_ptr <<= AddrType( 0 )
  //     s.enq_ptr <<= AddrType( 0 )
  //   else:
  //     s.deq_ptr <<= s.deq_ptr_next
  //     s.enq_ptr <<= s.enq_ptr_next
  // 
  //   if   s.reset:             s.full <<= Bits1(0)
  //   elif s.full_next_cycle:   s.full <<= Bits1(1)
  //   elif (s.do_deq & s.full): s.full <<= Bits1(0)
  //   else:                     s.full <<= s.full
  
  always_ff @(posedge clk) begin : seq
    if ( reset ) begin
      deq_ptr <= 5'd0;
      enq_ptr <= 5'd0;
    end
    else begin
      deq_ptr <= deq_ptr_next;
      enq_ptr <= enq_ptr_next;
    end
    if ( reset ) begin
      full <= 1'd0;
    end
    else if ( full_next_cycle ) begin
      full <= 1'd1;
    end
    else if ( do_deq & full ) begin
      full <= 1'd0;
    end
    else
      full <= full;
  end

endmodule


// PyMTL Component NormalQueueRTLDpath Definition
// Full name: NormalQueueRTLDpath__num_entries_32__Type_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTLDpath__ad89d4fad53825fa
(
  input  logic [0:0] clk ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 deq_bits ,
  input  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 enq_bits ,
  input  logic [4:0] raddr ,
  input  logic [0:0] reset ,
  input  logic [4:0] waddr ,
  input  logic [0:0] wen 
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk;
  logic [4:0] queue__raddr [0:0];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 queue__rdata [0:0];
  logic [0:0] queue__reset;
  logic [4:0] queue__waddr [0:0];
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 queue__wdata [0:0];
  logic [0:0] queue__wen [0:0];

  RegisterFile__ed0999d91ed51853 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_bits = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_bits;

endmodule


// PyMTL Component NormalQueueRTL Definition
// Full name: NormalQueueRTL__num_entries_32__Type_SMURespMsg__wen_1__reg_id_5__opaque_6__data_32
// At /work/global/pp482/clean/pymtl3/pymtl3/stdlib/queues/valrdy_queues.py

module NormalQueueRTL__ad89d4fad53825fa
(
  input  logic [0:0] clk ,
  output logic [5:0] num_free_entries ,
  input  logic [0:0] reset ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 deq__msg  ,
  input logic [0:0] deq__rdy  ,
  output logic [0:0] deq__val  ,
  input SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 enq__msg  ,
  output logic [0:0] enq__rdy  ,
  input logic [0:0] enq__val  
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk;
  logic [0:0] ctrl__deq_rdy;
  logic [0:0] ctrl__deq_val;
  logic [0:0] ctrl__enq_rdy;
  logic [0:0] ctrl__enq_val;
  logic [5:0] ctrl__num_free_entries;
  logic [4:0] ctrl__raddr;
  logic [0:0] ctrl__reset;
  logic [4:0] ctrl__waddr;
  logic [0:0] ctrl__wen;

  NormalQueueRTLCtrl__num_entries_32 ctrl
  (
    .clk( ctrl__clk ),
    .deq_rdy( ctrl__deq_rdy ),
    .deq_val( ctrl__deq_val ),
    .enq_rdy( ctrl__enq_rdy ),
    .enq_val( ctrl__enq_val ),
    .num_free_entries( ctrl__num_free_entries ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__deq_bits;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 dpath__enq_bits;
  logic [4:0] dpath__raddr;
  logic [0:0] dpath__reset;
  logic [4:0] dpath__waddr;
  logic [0:0] dpath__wen;

  NormalQueueRTLDpath__ad89d4fad53825fa dpath
  (
    .clk( dpath__clk ),
    .deq_bits( dpath__deq_bits ),
    .enq_bits( dpath__enq_bits ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign ctrl__enq_val = enq__val;
  assign enq__rdy = ctrl__enq_rdy;
  assign deq__val = ctrl__deq_val;
  assign ctrl__deq_rdy = deq__rdy;
  assign num_free_entries = ctrl__num_free_entries;
  assign dpath__enq_bits = enq__msg;
  assign deq__msg = dpath__deq_bits;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;

endmodule


// PyMTL Component HBEndpointSMUTXAdapter Definition
// Full name: HBEndpointSMUTXAdapter__hb_params_<hammerblade.params.HBParams object at 0x7fe4a6e6c4d0>
// At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py

module HBEndpointSMUTXAdapter__a2fcce5840d3ec14
(
  input  logic [0:0] clk ,
  input  logic [4:0] dst_x_cord ,
  input  logic [3:0] dst_y_cord ,
  input  logic [4:0] my_x ,
  input  logic [3:0] my_y ,
  input  logic [5:0] req_credits ,
  output logic [88:0] req_pkt ,
  output logic [31:0] req_pkt_eva ,
  input  logic [0:0] req_rdy ,
  output logic [0:0] req_val ,
  input  logic [0:0] reset ,
  input  logic [31:0] resp_data ,
  input  logic [0:0] resp_fifo_full ,
  input  logic [1:0] resp_pkt_type ,
  input  logic [4:0] resp_reg_id ,
  input  logic [0:0] resp_val ,
  output logic [0:0] resp_yumi ,
  input logic [0:0] loc__req__en ,
  input SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 loc__req__msg ,
  output logic [0:0] loc__req__rdy ,
  output logic [0:0] loc__resp__en ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 loc__resp__msg ,
  input logic [0:0] loc__resp__rdy ,
  input logic [0:0] rmt__req__en ,
  input SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 rmt__req__msg ,
  output logic [0:0] rmt__req__rdy ,
  output logic [0:0] rmt__resp__en ,
  output SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 rmt__resp__msg ,
  input logic [0:0] rmt__resp__rdy 
);
  logic [0:0] is_local_store_resp;
  logic [0:0] is_remote_load_req;
  logic [0:0] is_remote_load_resp;
  HBEndpointPacket__890e8baa82bc2d18 req_packet;
  //-------------------------------------------------------------
  // Component arb
  //-------------------------------------------------------------

  logic [0:0] arb__clk;
  logic [0:0] arb__reset;
  logic [0:0] arb__recv__en [0:1];
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 arb__recv__msg [0:1];
  logic [0:0] arb__recv__rdy [0:1];
  logic [0:0] arb__send__en;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 arb__send__msg;
  logic [0:0] arb__send__rdy;

  SendIfcRTLArbiter__c3d841a71d618a81 arb
  (
    .clk( arb__clk ),
    .reset( arb__reset ),
    .recv__en( arb__recv__en ),
    .recv__msg( arb__recv__msg ),
    .recv__rdy( arb__recv__rdy ),
    .send__en( arb__send__en ),
    .send__msg( arb__send__msg ),
    .send__rdy( arb__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component arb
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component req_q
  //-------------------------------------------------------------

  logic [0:0] req_q__clk;
  logic [1:0] req_q__num_free_entries;
  logic [0:0] req_q__reset;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 req_q__deq__msg;
  logic [0:0] req_q__deq__rdy;
  logic [0:0] req_q__deq__val;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 req_q__enq__msg;
  logic [0:0] req_q__enq__rdy;
  logic [0:0] req_q__enq__val;

  NormalQueueRTL__1c25502195bcabf5 req_q
  (
    .clk( req_q__clk ),
    .num_free_entries( req_q__num_free_entries ),
    .reset( req_q__reset ),
    .deq__msg( req_q__deq__msg ),
    .deq__rdy( req_q__deq__rdy ),
    .deq__val( req_q__deq__val ),
    .enq__msg( req_q__enq__msg ),
    .enq__rdy( req_q__enq__rdy ),
    .enq__val( req_q__enq__val )
  );

  //-------------------------------------------------------------
  // End of component req_q
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component resp_q
  //-------------------------------------------------------------

  logic [0:0] resp_q__clk;
  logic [5:0] resp_q__num_free_entries;
  logic [0:0] resp_q__reset;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 resp_q__deq__msg;
  logic [0:0] resp_q__deq__rdy;
  logic [0:0] resp_q__deq__val;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 resp_q__enq__msg;
  logic [0:0] resp_q__enq__rdy;
  logic [0:0] resp_q__enq__val;

  NormalQueueRTL__ad89d4fad53825fa resp_q
  (
    .clk( resp_q__clk ),
    .num_free_entries( resp_q__num_free_entries ),
    .reset( resp_q__reset ),
    .deq__msg( resp_q__deq__msg ),
    .deq__rdy( resp_q__deq__rdy ),
    .deq__val( resp_q__deq__val ),
    .enq__msg( resp_q__enq__msg ),
    .enq__rdy( resp_q__enq__rdy ),
    .enq__val( resp_q__enq__val )
  );

  //-------------------------------------------------------------
  // End of component resp_q
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:138
  // @update
  // def HB_endpoint_smu_tx_req_resp_msg():
  //   # Request packet
  //   s.req_packet.op         @= hp.packet_op_enum.e_remote_load \
  //                              if s.is_remote_load_req else \
  //                              hp.packet_op_enum.e_remote_store
  //   s.req_packet.op_ex      @= 0xF # store mask
  //   s.req_packet.reg_id     @= s.req_q.deq.msg.reg_id
  //   s.req_packet.payload    @= hp.empty_load_info if s.is_remote_load_req else \
  //                              s.req_q.deq.msg.data
  //   s.req_packet.src_y_cord @= s.my_y
  //   s.req_packet.src_x_cord @= s.my_x
  // 
  //   # Request destination NPA address
  //   # We need the bsg_manycore_eva_to_npa module to decode the address.
  //   # However I don't want to bring in a new placeholder because that
  //   # will bring in numerous *_pkg.v and header files, which would lead
  //   # to redefinitions during VCS sim.
  //   s.req_packet.addr   @= 0
  //   s.req_packet.y_cord @= s.dst_y_cord
  //   s.req_packet.x_cord @= s.dst_x_cord
  // 
  //   # For now I expose the EVA through s.req_pkt_eva, and we need to
  //   # do address translation when we compose SMU, TX, and RX with the
  //   # endpoint.
  //   s.req_pkt_eva @= s.req_q.deq.msg.addr
  // 
  //   # Remote response packet -> remote master resp
  //   s.rmt.resp.msg.wen    @= s.resp_q.deq.msg.wen
  //   s.rmt.resp.msg.reg_id @= s.resp_q.deq.msg.reg_id
  //   s.rmt.resp.msg.opaque @= s.resp_q.deq.msg.opaque
  //   s.rmt.resp.msg.data   @= s.resp_q.deq.msg.data
  // 
  //   # Local response packet -> local master resp
  //   s.loc.resp.msg.wen    @= s.resp_q.deq.msg.wen
  //   s.loc.resp.msg.reg_id @= s.resp_q.deq.msg.reg_id
  //   s.loc.resp.msg.opaque @= s.resp_q.deq.msg.opaque
  //   s.loc.resp.msg.data   @= s.resp_q.deq.msg.data
  
  always_comb begin : HB_endpoint_smu_tx_req_resp_msg
    req_packet.op = is_remote_load_req ? 2'd0 : 2'd1;
    req_packet.op_ex = 4'd15;
    req_packet.reg_id = req_q__deq__msg.reg_id;
    req_packet.payload = is_remote_load_req ? 32'd16 : req_q__deq__msg.data;
    req_packet.src_y_cord = my_y;
    req_packet.src_x_cord = my_x;
    req_packet.addr = 28'd0;
    req_packet.y_cord = dst_y_cord;
    req_packet.x_cord = dst_x_cord;
    req_pkt_eva = req_q__deq__msg.addr;
    rmt__resp__msg.wen = resp_q__deq__msg.wen;
    rmt__resp__msg.reg_id = resp_q__deq__msg.reg_id;
    rmt__resp__msg.opaque = resp_q__deq__msg.opaque;
    rmt__resp__msg.data = resp_q__deq__msg.data;
    loc__resp__msg.wen = resp_q__deq__msg.wen;
    loc__resp__msg.reg_id = resp_q__deq__msg.reg_id;
    loc__resp__msg.opaque = resp_q__deq__msg.opaque;
    loc__resp__msg.data = resp_q__deq__msg.data;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:135
  // s.is_local_store_resp //= lambda: s.resp_pkt_type == \
  //                                   hp.return_packet_type_enum.e_return_credit
  
  always_comb begin : _lambda__s_dut_tx_is_local_store_resp
    is_local_store_resp = resp_pkt_type == 2'd0;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:130
  // s.is_remote_load_req  //= lambda: s.req_q.deq.msg.wen == 0
  
  always_comb begin : _lambda__s_dut_tx_is_remote_load_req
    is_remote_load_req = req_q__deq__msg.wen == 1'd0;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:132
  // s.is_remote_load_resp //= lambda: s.resp_pkt_type == \
  //                                   hp.return_packet_type_enum.e_return_int_wb
  
  always_comb begin : _lambda__s_dut_tx_is_remote_load_resp
    is_remote_load_resp = resp_pkt_type == 2'd1;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:115
  // s.loc.resp.en //= lambda: s.resp_q.deq.val & s.loc.resp.rdy & (s.resp_q.deq.msg.wen == 1)
  
  always_comb begin : _lambda__s_dut_tx_loc_resp_en
    loc__resp__en = ( resp_q__deq__val & loc__resp__rdy ) & ( resp_q__deq__msg.wen == 1'd1 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:112
  // s.req_q.deq.rdy //= lambda: s.req_rdy & (s.req_credits != 0)
  
  always_comb begin : _lambda__s_dut_tx_req_q_deq_rdy
    req_q__deq__rdy = req_rdy & ( req_credits != 6'd0 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:111
  // s.req_val //= lambda: s.req_q.deq.val & (s.req_credits != 0)
  
  always_comb begin : _lambda__s_dut_tx_req_val
    req_val = req_q__deq__val & ( req_credits != 6'd0 );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:117
  // s.resp_q.deq.rdy //= lambda: (s.rmt.resp.rdy & (s.resp_q.deq.msg.wen == 0)) | \
  //                              (s.loc.resp.rdy & (s.resp_q.deq.msg.wen == 1))
  
  always_comb begin : _lambda__s_dut_tx_resp_q_deq_rdy
    resp_q__deq__rdy = ( rmt__resp__rdy & ( resp_q__deq__msg.wen == 1'd0 ) ) | ( loc__resp__rdy & ( resp_q__deq__msg.wen == 1'd1 ) );
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:104
  // s.resp_q.enq.msg.wen    //= lambda: 0 if s.is_remote_load_resp else 1
  
  always_comb begin : _lambda__s_dut_tx_resp_q_enq_msg_wen
    resp_q__enq__msg.wen = is_remote_load_resp ? 1'd0 : 1'd1;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:103
  // s.resp_yumi //= lambda: s.resp_val & s.resp_q.enq.rdy
  
  always_comb begin : _lambda__s_dut_tx_resp_yumi
    resp_yumi = resp_val & resp_q__enq__rdy;
  end

  // PyMTL Lambda Block Source
  // At /work/global/pp482/cgra/src/smu/HBEndpointSMUTXAdapter.py:114
  // s.rmt.resp.en //= lambda: s.resp_q.deq.val & s.rmt.resp.rdy & (s.resp_q.deq.msg.wen == 0)
  
  always_comb begin : _lambda__s_dut_tx_rmt_resp_en
    rmt__resp__en = ( resp_q__deq__val & rmt__resp__rdy ) & ( resp_q__deq__msg.wen == 1'd0 );
  end

  assign arb__clk = clk;
  assign arb__reset = reset;
  assign arb__recv__en[0] = rmt__req__en;
  assign arb__recv__msg[0] = rmt__req__msg;
  assign rmt__req__rdy = arb__recv__rdy[0];
  assign arb__recv__en[1] = loc__req__en;
  assign arb__recv__msg[1] = loc__req__msg;
  assign loc__req__rdy = arb__recv__rdy[1];
  assign req_q__clk = clk;
  assign req_q__reset = reset;
  assign resp_q__clk = clk;
  assign resp_q__reset = reset;
  assign req_q__enq__val = arb__send__en;
  assign arb__send__rdy = req_q__enq__rdy;
  assign req_q__enq__msg = arb__send__msg;
  assign resp_q__enq__val = resp_yumi;
  assign resp_q__enq__msg.reg_id = resp_reg_id;
  assign resp_q__enq__msg.opaque = 6'd0;
  assign resp_q__enq__msg.data = resp_data;
  assign req_pkt[4:0] = req_packet.x_cord;
  assign req_pkt[8:5] = req_packet.y_cord;
  assign req_pkt[13:9] = req_packet.src_x_cord;
  assign req_pkt[17:14] = req_packet.src_y_cord;
  assign req_pkt[49:18] = req_packet.payload;
  assign req_pkt[54:50] = req_packet.reg_id;
  assign req_pkt[58:55] = req_packet.op_ex;
  assign req_pkt[60:59] = req_packet.op;
  assign req_pkt[88:61] = req_packet.addr;

endmodule


// PyMTL Component HBEndpointSMU Definition
// Full name: HBEndpointSMU__hb_params_<hammerblade.params.HBParams object at 0x7fe4a6e6c4d0>
// At /work/global/pp482/cgra/src/smu/HBEndpointSMU.py

module HBEndpointSMU_11x18
(
  input  logic [0:0] clk ,
  input  logic [27:0] in_addr_i ,
  input  logic [31:0] in_data_i ,
  input  logic [6:0] in_load_info_i ,
  input  logic [3:0] in_mask_i ,
  input  logic [4:0] in_src_x_cord_i ,
  input  logic [3:0] in_src_y_cord_i ,
  input  logic [0:0] in_v_i ,
  input  logic [0:0] in_we_i ,
  output logic [0:0] in_yumi_o ,
  input  logic [4:0] my_x_i ,
  input  logic [3:0] my_y_i ,
  input  logic [0:0] out_credit_or_ready_i ,
  input  logic [5:0] out_credits_i ,
  output logic [88:0] out_packet_o ,
  output logic [31:0] out_pkt_eva_o ,
  output logic [0:0] out_v_o ,
  input  logic [0:0] reset ,
  input  logic [31:0] returned_data_r_i ,
  input  logic [0:0] returned_fifo_full_i ,
  input  logic [1:0] returned_pkt_type_r_i ,
  input  logic [4:0] returned_reg_id_r_i ,
  input  logic [0:0] returned_v_r_i ,
  output logic [0:0] returned_yumi_o ,
  output logic [31:0] returning_data_o ,
  output logic [0:0] returning_v_o 
);
  //-------------------------------------------------------------
  // Component rx
  //-------------------------------------------------------------

  logic [0:0] rx__clk;
  logic [4:0] rx__dst_x_cord;
  logic [3:0] rx__dst_y_cord;
  logic [4:0] rx__my_x;
  logic [3:0] rx__my_y;
  logic [27:0] rx__req_addr;
  logic [31:0] rx__req_data;
  logic [6:0] rx__req_load_info;
  logic [3:0] rx__req_mask;
  logic [4:0] rx__req_src_x_cord;
  logic [3:0] rx__req_src_y_cord;
  logic [0:0] rx__req_val;
  logic [0:0] rx__req_we;
  logic [0:0] rx__req_yumi;
  logic [0:0] rx__reset;
  logic [31:0] rx__resp_data;
  logic [0:0] rx__resp_val;
  logic [0:0] rx__cfg_master__req__en;
  XcelReqMsg__type__1__addr_4__data_32 rx__cfg_master__req__msg;
  logic [0:0] rx__cfg_master__req__rdy;
  logic [0:0] rx__cfg_master__resp__en;
  XcelRespMsg__type__1__data_32 rx__cfg_master__resp__msg;
  logic [0:0] rx__cfg_master__resp__rdy;

  HBEndpointSMURXAdapter__a2fcce5840d3ec14 rx
  (
    .clk( rx__clk ),
    .dst_x_cord( rx__dst_x_cord ),
    .dst_y_cord( rx__dst_y_cord ),
    .my_x( rx__my_x ),
    .my_y( rx__my_y ),
    .req_addr( rx__req_addr ),
    .req_data( rx__req_data ),
    .req_load_info( rx__req_load_info ),
    .req_mask( rx__req_mask ),
    .req_src_x_cord( rx__req_src_x_cord ),
    .req_src_y_cord( rx__req_src_y_cord ),
    .req_val( rx__req_val ),
    .req_we( rx__req_we ),
    .req_yumi( rx__req_yumi ),
    .reset( rx__reset ),
    .resp_data( rx__resp_data ),
    .resp_val( rx__resp_val ),
    .cfg_master__req__en( rx__cfg_master__req__en ),
    .cfg_master__req__msg( rx__cfg_master__req__msg ),
    .cfg_master__req__rdy( rx__cfg_master__req__rdy ),
    .cfg_master__resp__en( rx__cfg_master__resp__en ),
    .cfg_master__resp__msg( rx__cfg_master__resp__msg ),
    .cfg_master__resp__rdy( rx__cfg_master__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component rx
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component smu
  //-------------------------------------------------------------

  logic [0:0] smu__clk;
  logic [0:0] smu__reset;
  logic [0:0] smu__cfg__req__en;
  XcelReqMsg__type__1__addr_4__data_32 smu__cfg__req__msg;
  logic [0:0] smu__cfg__req__rdy;
  logic [0:0] smu__cfg__resp__en;
  XcelRespMsg__type__1__data_32 smu__cfg__resp__msg;
  logic [0:0] smu__cfg__resp__rdy;
  logic [0:0] smu__loc__req__en;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 smu__loc__req__msg;
  logic [0:0] smu__loc__req__rdy;
  logic [0:0] smu__loc__resp__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 smu__loc__resp__msg;
  logic [0:0] smu__loc__resp__rdy;
  logic [0:0] smu__rmt__req__en;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 smu__rmt__req__msg;
  logic [0:0] smu__rmt__req__rdy;
  logic [0:0] smu__rmt__resp__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 smu__rmt__resp__msg;
  logic [0:0] smu__rmt__resp__rdy;

  StreamingMemUnit__9fe0efbd6f5ff91e smu
  (
    .clk( smu__clk ),
    .reset( smu__reset ),
    .cfg__req__en( smu__cfg__req__en ),
    .cfg__req__msg( smu__cfg__req__msg ),
    .cfg__req__rdy( smu__cfg__req__rdy ),
    .cfg__resp__en( smu__cfg__resp__en ),
    .cfg__resp__msg( smu__cfg__resp__msg ),
    .cfg__resp__rdy( smu__cfg__resp__rdy ),
    .loc__req__en( smu__loc__req__en ),
    .loc__req__msg( smu__loc__req__msg ),
    .loc__req__rdy( smu__loc__req__rdy ),
    .loc__resp__en( smu__loc__resp__en ),
    .loc__resp__msg( smu__loc__resp__msg ),
    .loc__resp__rdy( smu__loc__resp__rdy ),
    .rmt__req__en( smu__rmt__req__en ),
    .rmt__req__msg( smu__rmt__req__msg ),
    .rmt__req__rdy( smu__rmt__req__rdy ),
    .rmt__resp__en( smu__rmt__resp__en ),
    .rmt__resp__msg( smu__rmt__resp__msg ),
    .rmt__resp__rdy( smu__rmt__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component smu
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tx
  //-------------------------------------------------------------

  logic [0:0] tx__clk;
  logic [4:0] tx__dst_x_cord;
  logic [3:0] tx__dst_y_cord;
  logic [4:0] tx__my_x;
  logic [3:0] tx__my_y;
  logic [5:0] tx__req_credits;
  logic [88:0] tx__req_pkt;
  logic [31:0] tx__req_pkt_eva;
  logic [0:0] tx__req_rdy;
  logic [0:0] tx__req_val;
  logic [0:0] tx__reset;
  logic [31:0] tx__resp_data;
  logic [0:0] tx__resp_fifo_full;
  logic [1:0] tx__resp_pkt_type;
  logic [4:0] tx__resp_reg_id;
  logic [0:0] tx__resp_val;
  logic [0:0] tx__resp_yumi;
  logic [0:0] tx__loc__req__en;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 tx__loc__req__msg;
  logic [0:0] tx__loc__req__rdy;
  logic [0:0] tx__loc__resp__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 tx__loc__resp__msg;
  logic [0:0] tx__loc__resp__rdy;
  logic [0:0] tx__rmt__req__en;
  SMUReqMsg__wen_1__reg_id_5__opaque_6__addr_32__data_32 tx__rmt__req__msg;
  logic [0:0] tx__rmt__req__rdy;
  logic [0:0] tx__rmt__resp__en;
  SMURespMsg__wen_1__reg_id_5__opaque_6__data_32 tx__rmt__resp__msg;
  logic [0:0] tx__rmt__resp__rdy;

  HBEndpointSMUTXAdapter__a2fcce5840d3ec14 tx
  (
    .clk( tx__clk ),
    .dst_x_cord( tx__dst_x_cord ),
    .dst_y_cord( tx__dst_y_cord ),
    .my_x( tx__my_x ),
    .my_y( tx__my_y ),
    .req_credits( tx__req_credits ),
    .req_pkt( tx__req_pkt ),
    .req_pkt_eva( tx__req_pkt_eva ),
    .req_rdy( tx__req_rdy ),
    .req_val( tx__req_val ),
    .reset( tx__reset ),
    .resp_data( tx__resp_data ),
    .resp_fifo_full( tx__resp_fifo_full ),
    .resp_pkt_type( tx__resp_pkt_type ),
    .resp_reg_id( tx__resp_reg_id ),
    .resp_val( tx__resp_val ),
    .resp_yumi( tx__resp_yumi ),
    .loc__req__en( tx__loc__req__en ),
    .loc__req__msg( tx__loc__req__msg ),
    .loc__req__rdy( tx__loc__req__rdy ),
    .loc__resp__en( tx__loc__resp__en ),
    .loc__resp__msg( tx__loc__resp__msg ),
    .loc__resp__rdy( tx__loc__resp__rdy ),
    .rmt__req__en( tx__rmt__req__en ),
    .rmt__req__msg( tx__rmt__req__msg ),
    .rmt__req__rdy( tx__rmt__req__rdy ),
    .rmt__resp__en( tx__rmt__resp__en ),
    .rmt__resp__msg( tx__rmt__resp__msg ),
    .rmt__resp__rdy( tx__rmt__resp__rdy )
  );

  //-------------------------------------------------------------
  // End of component tx
  //-------------------------------------------------------------

  assign tx__clk = clk;
  assign tx__reset = reset;
  assign rx__clk = clk;
  assign rx__reset = reset;
  assign smu__clk = clk;
  assign smu__reset = reset;
  assign rx__my_x = my_x_i;
  assign rx__my_y = my_y_i;
  assign rx__req_val = in_v_i;
  assign rx__req_data = in_data_i;
  assign rx__req_mask = in_mask_i;
  assign rx__req_addr = in_addr_i;
  assign rx__req_we = in_we_i;
  assign rx__req_load_info = in_load_info_i;
  assign rx__req_src_x_cord = in_src_x_cord_i;
  assign rx__req_src_y_cord = in_src_y_cord_i;
  assign in_yumi_o = rx__req_yumi;
  assign returning_v_o = rx__resp_val;
  assign returning_data_o = rx__resp_data;
  assign smu__cfg__req__en = rx__cfg_master__req__en;
  assign smu__cfg__req__msg = rx__cfg_master__req__msg;
  assign rx__cfg_master__req__rdy = smu__cfg__req__rdy;
  assign rx__cfg_master__resp__en = smu__cfg__resp__en;
  assign rx__cfg_master__resp__msg = smu__cfg__resp__msg;
  assign smu__cfg__resp__rdy = rx__cfg_master__resp__rdy;
  assign tx__my_x = my_x_i;
  assign tx__my_y = my_y_i;
  assign out_v_o = tx__req_val;
  assign out_packet_o = tx__req_pkt;
  assign tx__req_rdy = out_credit_or_ready_i;
  assign tx__req_credits = out_credits_i;
  assign out_pkt_eva_o = tx__req_pkt_eva;
  assign tx__resp_data = returned_data_r_i;
  assign tx__resp_reg_id = returned_reg_id_r_i;
  assign tx__resp_val = returned_v_r_i;
  assign tx__resp_pkt_type = returned_pkt_type_r_i;
  assign returned_yumi_o = tx__resp_yumi;
  assign tx__resp_fifo_full = returned_fifo_full_i;
  assign tx__dst_y_cord = rx__dst_y_cord;
  assign tx__dst_x_cord = rx__dst_x_cord;
  assign tx__rmt__req__en = smu__rmt__req__en;
  assign tx__rmt__req__msg = smu__rmt__req__msg;
  assign smu__rmt__req__rdy = tx__rmt__req__rdy;
  assign smu__rmt__resp__en = tx__rmt__resp__en;
  assign smu__rmt__resp__msg = tx__rmt__resp__msg;
  assign tx__rmt__resp__rdy = smu__rmt__resp__rdy;
  assign tx__loc__req__en = smu__loc__req__en;
  assign tx__loc__req__msg = smu__loc__req__msg;
  assign smu__loc__req__rdy = tx__loc__req__rdy;
  assign smu__loc__resp__en = tx__loc__resp__en;
  assign smu__loc__resp__msg = tx__loc__resp__msg;
  assign tx__loc__resp__rdy = smu__loc__resp__rdy;

endmodule
